#!/usr/bin/perl

my $VERSION = '2013-09-29';

######################################################################
#
#     publish.pl
#
#     Don Johnson
#     drj826@acm.org
#     http://drj826.net/
#
#     $Id: publish.pl 16454 2013-09-29 11:19:57Z don.johnson $
#
#--------------------------------------------------------------------#
#                                                                    #
#     Copyright (c) 2002-2007, Don Johnson (drj826@acm.org)          #
#     Copyright (c) 2007, Futures, Inc                               #
#     Copyright (c) 2008-2011, Don Johnson (drj826@acm.org)          #
#                                                                    #
#     Distributed under the terms of the Gnu General Public License  #
#     (version 2, 1991)                                              #
#                                                                    #
#     This software is distributed in the hope that it will be       #
#     useful, but WITHOUT ANY WARRANTY; without even the implied     #
#     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR        #
#     PURPOSE.  See the GNU License for more details.                #
#                                                                    #
#     MODIFICATIONS AND ENHANCEMENTS TO THIS SOFTWARE OR WORKS       #
#     DERIVED FROM THIS SOFTWARE MUST BE MADE FREELY AVAILABLE       #
#     UNDER THESE SAME TERMS.                                        #
#                                                                    #
#--------------------------------------------------------------------#
# DESCRIPTION
#
#     This script takes a document written in plain ASCII text and
#     renders it to any number of final renditions: LaTeX (used to
#     produce PDF), HTML, XML, or CSV.
#
#---------------------------------------------------------------------
# USAGE
#
#     publish.pl                            # display GUI
#     publish.pl mybook.txt                 # publish mybook.txt
#
#     see later section "COMMAND LINE OPTIONS"
#
#---------------------------------------------------------------------
# BUGS TO FIX, FEATURES TO IMPLEMENT
#
#     - Throw an error if a document contains multiple preamble data
#       elements when multiples are not allowed according to the
#       %structure data structure.
#
#     - Combine the escape functions to make it safe to render several
#       renditions at the same time.
#
#     - Migrate to use of Regexp::Common for regular expressions.
#       This will result in more readable, more maintainable usage of
#       regular expressions.  See "Perl Best Practices" page 263.
#
#     - Complete the implementation of the ``conditional block''
#       feature.
#
#     - Implement a POC (point of contact) environment that allows
#       authors to include structured POC information in documents.
#
#     - Update the following subroutines to accept a combination of
#       values including a label followed by a comma and a note:
#
#       [ ] html_author_for           [ ] latex_author_for
#       [ ] html_owner_for            [ ] latex_owner_for
#       [ ] html_assignees_for        [ ] latex_assignees_for
#       [ ] html_stakeholders_for     [ ] latex_stakeholders_for
#       [ ] html_previous_for         [ ] latex_previous_for
#       [ ] html_next_for             [ ] latex_next_for
#       [ ] html_validator_for        [ ] latex_validator_for
#       [x] html_directed_by          [x] latex_directed_by
#       [ ] html_derived_from         [ ] latex_derived_from
#       [ ] html_derived              [ ] latex_derived
#       [ ] html_instance_of          [ ] latex_instance_of
#       [ ] html_class_of             [ ] latex_class_of
#       [x] html_solutions_for        [x] latex_solutions_for
#       [ ] html_allocations_for      [x] latex_allocations_for
#       [ ] html_assignments_for      [x] latex_assignments_for
#       [ ] html_tests_for            [ ] latex_tests_for
#       [ ] html_tasks_for            [ ] latex_tasks_for
#       [ ] html_results_for          [ ] latex_results_for
#       [ ] html_roles_for            [ ] latex_roles_for
#       [ ] html_associates_of        [ ] latex_associates_of
#       [ ] html_requests_for         [ ] latex_requests_for
#       [ ] html_outcomes_for         [ ] latex_outcomes_for
#       [ ] html_depends_on           [ ] latex_depends_on
#       [ ] html_required_by          [ ] latex_required_by
#       [ ] html_problems_for         [ ] latex_problems_for
#       [ ] html_product_of           [ ] latex_product_of
#
#---------------------------------------------------------------------
# DESIGNED FOR...
#
#    This publishing script has been designed to be suitable for
#    document publishing within the following problem domains:
#
#    - computer security assessment reporting
#      - automatic penetration tests
#      - automatic vulnerability assessments
#      - automatic log audit reporting
#
#    - software project documentation
#      - project plans
#      - build notes
#      - configuration control documentation
#      - configuration management audits
#
#    - requirements documents
#      - problems
#      - solutions
#      - allocations
#      - assignments
#      - tests
#      - results
#      - roles
#      - tasks
#
#    - quality assurance audits
#      - requirements verification audits
#
#    - training course development
#      - exercises
#      - demonstrations
#      - slides
#
#---------------------------------------------------------------------
# REQUIRED SOFTWARE
#
#    The following (freely available) software packages are required
#    to publish documents using this script:
#
#    1. Perl
#
#       http://www.activestate.com/
#
#    2. LaTeX
#
#       http://www.miktex.org/
#       http://www.tug.org/teTeX/
#
#    3. Image Magick
#
#       http://www.imagemagick.org/
#
#    4. PDF Viewer
#
#       http://www.adobe.com/
#
#    5. Web Browser
#
#       http://www.mozilla.org/
#
#    6. Subversion
#
#       http://subversion.tigris.org/
#
#---------------------------------------------------------------------
# STRUCTURED MANUSCRIPT LANGUAGE
#
#    The structured manuscript language is a carefully designed,
#    extremely minimal descriptive markup language, or, structured
#    text language.  It was designed for simplicity of editing with a
#    plain text editor.
#
#    Structured manuscript language files are like the source code for
#    documents, and the publish script is like a compiler that
#    'builds' (renders) the documents in a variety of renditions (PDF,
#    HTML, XML, RTV, CSV...) with a variety of formatting options.
#
#    Although the structured manuscript language is a markup language
#    (like SGML, XML, or HTML), the actual markup has been reduced to
#    a bare minimum to improve the readability of the text and
#    simplicity of editing.  For this reason, the language is not as
#    flexible as XML.  In return for the loss of flexibility, you gain
#    ease of use.  Normal people don't like to edit raw XML in a text
#    editor because it's too complicated, and it's too easy to
#    introduce errors.  My hope is that normal people (well,
#    programmers anyway) are willing to edit structured text documents
#    using a simple text editor.
#
#    One benefit is reuseability.  Not only can you publish the
#    structured text documents in a variety of forms, but you can also
#    modularize the content and reuse bits and pieces in different
#    documents.  Using the 'include' mechanism, the actual text can be
#    stored in one file but reused in many documents.
#
#    Descriptive markup can be used to describe format, structure, and
#    content:
#
#    - Elements of **format** (or style) describe how text is to be
#      presented like: bold, italics, font-family, and font-size.
#
#    - Elements of **structure** are the building blocks of a document
#      like: titles, paragraphs, sections, lists, list items, tables,
#      figures, and attachments.
#
#    - Elements of **content** describe the meaning of the text like:
#      exercises, demonstrations, problems, and solutions.
#
#    We can enumerate the features of the structured text language in
#    terms of format, structure, and content.
#
#---------------------------------------------------------------------
# FORMAT FEATURES
#
#    - document font size
#    - bold
#    - italics
#    - typewriter-type
#    - underline
#    - table cell background color
#    - table cell content justification
#    - figure width
#    - copyright symbol
#    - trademark symbol
#    - registered trademark symbol
#    - keystroke
#    - "take note!" indicator
#    - smiley and frowny faces
#    - right and left arrows
#    - TeX and LaTeX logos
#    - horizontal rules
#    - fill in the blanks
#    - literal strings
#    - pagebreak
#    - clearpage
#
#---------------------------------------------------------------------
# STRUCTURE FEATURES
#
#    - document type (article, report, book)
#    - preamble for document meta-data
#      - author (multivalued)
#      - classification
#      - classified_by
#      - classif_reason
#      - copyright
#      - full_copyright
#      - date
#      - declassify_on
#      - define (for conditional content)
#      - doctype (book, article, report)
#      - editor (multivalued)
#      - fontsize
#      - handling_caveat (multivalued)
#      - organization
#      - revision
#      - title
#    - include mechanism (include text from other files)
#    - titles
#    - paragraphs
#    - sections (unlimited hierarchy)
#    - headers and footers
#    - unordered lists (can be nested)
#    - ordered lists (can be nested)
#    - tables (cannot be nested)
#      - table captions
#    - baretables (not numbered or listed in list of tables)
#    - figures (w/ captions)
#    - attachments (w/ titles)
#    - images
#    - preformatted text blocks (simple or fancy)
#    - footnotes
#    - labels and references
#    - external hyperlinks
#    - bibliographic sources and citations
#    - procedural sequences (steps)
#    - sidebar (w/ titles)
#    - glossary entries
#    - acronyms
#    - changelog
#    - index (w/ categorical entries)
#    - listings (w/ captions)
#      - optional line number
#      - optional language syntax highlighting (for code listings)
#
#---------------------------------------------------------------------
# CONTENT FEATURES
#
#    - comments (block and inline, not presented in rendition)
#    - exercises (w/ titles, durations)
#    - slides (w/ titles, durations)
#    - quotations (w/ titles, sources)
#    - demos (w/ titles, durations)
#    - keypoints (w/ titles)
#    - to-do items (w/ status indicators: normal, urgent, work
#      started, cancelled, completed, question, deadline, OPR)
#    - notes (w/ author)
#    - problems (w/ title, type, parent, priority, status,
#      stakeholder, owner, author, validator, solutions, test,
#      description)
#    - solutions (w/ title, status, parent, type, version, cost,
#      problems, tests, description)
#    - allocations (w/ label, solution, problem)
#    - assignments (w/ label, solution, problem)
#    - tests (w/ title, type, parent, problems, scripts, tester)
#    - tasks (w/ title, type, parent, product, priority, status)
#    - results (w/ title, type, status)
#    - roles (w/ title, type, status)
#    - outcomes (of audits, tests, analysis...)
#    - reviews (of problems, solutions, tasks, test, results, roles...)
#
#---------------------------------------------------------------------
# INLINE COMMENTS
#
#    You can include an inline comment like this:
#
#        [# This is my inline comment]
#
#    A special form of an inline comment will cause this program to
#    automatically update the version number of externally included
#    files like this:
#
#        [#v:Solutions/ci-000001.txt:22].
#
#    The 'v' stands for version and the format of the inline comment
#    is:
#
#        [#v:<path/to/filename>:<version>]
#
#    The program automatically parses the included file to find the
#    current version number and then updates the file version for each
#    of these "version" inline comments.  This is similar to the way
#    versioning systems like RCS, SCCS, CVS, and SVN automatically
#    update specially formatted tags containing versioning
#    information.
#
#    You may perform the same function directly in the include
#    statement like this:
#
#        include:$r1260$: path/to/file.txt
#
#---------------------------------------------------------------------
# COMMENT LINES
#
#    You can 'comment out' lines of text by beginning each with '#'.
#    For example:
#
#      # This paragraph is 'commented out' because each line begins
#      # with a '#'.  Depending on the rendition (i.e. HTML, XML) this
#      # paragraph will appear inside comment markup in the rendition.
#
#---------------------------------------------------------------------
# COMMENT BLOCKS
#
#    You can 'comment out' blocks of text with '###comment' (three or
#    more hashes '###' starting at the beginning of a line and ending
#    with the word 'comment') at the beginning and end of the block.
#    For example:
#
#      ########################################################comment
#
#      This paragraph is 'commented out' because it is between comment
#      block markers.  Depending on the rendition (i.e. HTML, XML)
#      this paragraph will appear inside comment markup in the
#      rendition.
#
#      ########################################################comment
#
#---------------------------------------------------------------------
# CONDITIONAL BLOCKS
#
#    Sometimes I have a document I want to use for multiple purposes
#    with slight differences for each.  The conditional text mechanism
#    is like the IFDEF in C.
#
#    You can make blocks of text conditional with '???name1,name2' at
#    the beginning and end of the block (three or more question
#    marks'???'  starting at the beginning of a line and ending with a
#    comma separated list of names of conditionals) will start and
#    stop the conditional block.  For example:
#
#      define: rh9,knoppix
#
#      ????????????????????????????????????????????????????????????rh9
#
#      This paragraph goes into the RedHat 9 version of the document,
#      but not into other variations.  The '..define' statement above
#      tells the publish script to include this text.
#
#      ????????????????????????????????????????????????????????????rh9
#
#    Conditional names are defined using 'define: name' at the
#    beginning of the line anywhere in the document (but normally near
#    the top where they are easily changed).
#
#    NOTE: perhaps I should restrict 'define:' statements to the
#    document pre-amble?
#
#---------------------------------------------------------------------
# ENVIRONMENTS
#
#    Environments are blocks of text representing elements of
#    **structure** like tables, figures, attachments, listings,
#    sidebars, bibliographic sources, and preformatted environments.
#    Environemnts begin and end like '---table'. They include:
#
#    - figure
#    - attachment
#    - listing
#    - preformatted
#    - sidebar
#    - source
#    - table
#
#    Environments **cannot** contain other environments.
#
#---------------------------------------------------------------------
# REGIONS
#
#    Regions are blocks of text representing elements of **content**
#    like exercises, slides, demonstrations, etc.  Regions begin and
#    end like '>>>exercise' and '<<<exercise'. Regions include:
#
#    - demo
#    - exercise
#    - keypoints
#    - problem
#    - quotation
#    - slide
#    - solution
#    - test
#    - task
#    - result
#    - role
#
#    Regions can contain environments (e.g. you can put a table inside
#    an exercise) but environments cannot contain regions (e.g. you
#    can't put an exercise inside a table).
#
#    Regions **cannot** contain other regions.
#
#    In the future, users will be able to define their own regions
#    simply by adding a new region in the source text.  This will give
#    users the ability to create their own semantics on the fly.
#    Furthermore, I plan to enable users to add custom data elements
#    in their own regions (just by using them they spring into
#    existence).  A data element that corresponds to a region name
#    will automatically create a semantic relationship.
#
#---------------------------------------------------------------------
# PREAMBLE DATA ELEMENTS
#
#    There are several data elements that can appear in what is
#    considered the document "preamble," the beginning of the document
#    before the first paragraph or section heading:
#
#    - title
#    - subtitle
#
#    - author
#    - editor
#    - translator
#
#    - publisher
#    - publisher_location
#    - publisher_logo
#    - publisher_address
#
#    - edition
#
#    - biographical_note
#    - copyright
#    - publication_year
#
#    - date
#    - isbn
#    - issn
#    - cip_data
#
#    - permissions
#    - grants
#
#    - paper_durability
#
#    - dedication
#    - epigraph
#    - epigraph_source
#
#    - define
#    - doctype
#    - fontsize
#    - organization
#    - revision
#
#    - classification
#    - classified_by
#    - classif_reason
#    - declassify_on
#    - handling_caveat
#
#---------------------------------------------------------------------
# UNIVERSAL DATA ELEMENTS
#
#    There are also a few data elements that can appear anywhere in
#    the text, not confined to environments, regions, or the preamble
#    (although it would be bad form to put any of these in a
#    preamble):
#
#    - file
#    - footnote
#    - generate
#    - script
#    - image
#    - include
#    - glossary
#    - acronym
#    - index
#    - label
#    - target
#    - step
#
#---------------------------------------------------------------------
# PROGRAM DESCRIPTION
#
#    This program converts structured text files to HTML and LaTeX
#    (for high quality typeset PDF generation).  It puts the results
#    in a directory named after the text file processed.
#
#    This is very simlar to Aurelio Marinho Jargas' txt2tags program
#    written in python (http://txt2tags.sourceforge.net/).
#
#    See the file "how-to-use-publish.txt" for complete structured
#    text rules (that file also serves as an example of those rules).
#
#---------------------------------------------------------------------
# OUTPUT
#
#    The publish program creates a directory containing all of the
#    output it creates.  If you've got a structured text file called
#    "my-notes.txt" this script will create the following directory
#    structure as output:
#
#        my-notes
#          |
#          +-- makepdf.bat
#          +-- makepdf.sh
#          +
#          +-- my-notes.html
#          +-- my-notes.exercises.html
#          +-- my-notes.figures.html
#          +-- my-notes.attachments.html
#          +-- my-notes.footnotes.html
#          +-- my-notes.listings.html
#          +-- my-notes.slides.html
#          +-- my-notes.sidebars.html
#          +-- my-notes.quotations.html
#          +-- my-notes.problems.html
#          +-- my-notes.solutions.html
#          +-- my-notes.allocations.html
#          +-- my-notes.assignments.html
#          +-- my-notes.tests.html
#          +-- my-notes.tasks.html
#          +-- my-notes.result.html
#          +-- my-notes.tables.html
#          +-- my-notes.toc.html
#          +-- my-notes.revisions.html
#          +-- my-notes.todo.html
#          +
#          +-- my-notes.tex
#          +
#          +-- files
#          |     |
#          |     +-- included-file-1.txt
#          |     +-- included-file-2.txt
#          |     +-- included-file-3.txt
#          |
#          +-- images
#          |     |
#          |     +-- image_1.png
#          |     +-- image_2.png
#          |     +-- image_3.png
#          |
#          +-- images-scaled
#          |     |
#          |     +-- image_1.png
#          |
#          +-- images-thumbnails
#          |     |
#          |     +-- image_1.png
#          |     +-- image_2.png
#          |     +-- image_3.png
#
#---------------------------------------------------------------------
# PROCESSING MODEL (or, HOW IT WORKS...)
#
#    Publishing (implemented by the "publish" function) occurs in
#    three passes through the original text file(s).  The second pass
#    is repeated as necessary to resolve references, run scripts, and
#    create automatically generated content:
#
#
#    +----------------+    +----------------+    +----------------+
#    | PASS 1:        |    | PASS 2:        |    | PASS 3:        |
#    |                |    |                |    |                |
#    | Resolve        |--->| Resolve        |--->| Publish        |
#    | included       |    | refs/labels,   |    | renditions     |
#    | content        |    | get/gen data   |    |                |
#    +----------------+    +----------------+    +----------------+
#                             ^           |
#                             |           |
#                             +-----------+
#                          repeat as necessary
#
#---------------------------------------------------------------------
# RENDITIONS
#
#    The publish script is capable of creating the following
#    renditions:
#
#    - HTML
#    - PDF
#    - XML
#    - CSV
#    - Plain Text
#
#---------------------------------------------------------------------
# HTML RENDITION
#
#    The HTML rendition is assembled into the %html datastructure
#    whose individual elements are joined at the end of the script.
#
#---------------------------------------------------------------------
# PDF RENDITION
#
#    The PDF rendition (via LaTeX) is assembled into the following
#    arrays whose individual elements are joined at the end of the
#    script:
#
#        - @latex_head        begin latex
#        - @latex_nav         navigation elements (toc, lot, lof...)
#        - @latex_title       begin latex
#        - @latex_cvsinfo     revision information
#        - @latex             body of LaTeX rendition
#        - @latex_glossary    glossary entries
#        - @latex_changelog   changelog
#        - @latex_acronym     acronym list entries
#        - @latex_foot        end LaTeX
#
#---------------------------------------------------------------------
# XML RENDITION
#
#    The XML rendition is assembled into the following array then
#    joined at the end of the script:
#
#        - @xml               XML content
#        - @xml_head          XML header information
#        - @xml_foot          XML footer information
#        - @xml_stylesheet    XML stylesheet (CSS)
#        - @xml_dtd           XML document type definition
#
#---------------------------------------------------------------------
# CSV RENDITION
#
#    CSV rendering occurs between pass 2 and 3.
#
#---------------------------------------------------------------------
# PLAIN TEXT RENDITION
#
#    There is also a temporary text file written to the output
#    directory.  The text for this is accumulated in:
#
#        - @text              text content
#
#    The purpose of this text only version is debugging.  If you
#    specify --nocleanup, you will be able to inspect this file after
#    publishing is complete to make sure things worked as expected
#    (included file resolution, generated content, scripts, etc.).  If
#    you wanted to, you could make changes to this text-only version,
#    and publish it.
#
#---------------------------------------------------------------------
# COMMAND LINE OPTIONS
#
#    Here is a list of command line options used to control the way
#    the program works when run from the command line:
#
#    -h, --help            display help information
#    -g, --gui             display the GUI
#    -r, --render=pdf      output renditions (pdf,html,xml,csv)
#    -d, --directory=dir   output directory
#    -o, --output=file     output filename
#    -v, --verbose         print messages
#    -c, --config          configuration file
#    -V, --version         print program version and exit
#
#    --pdf_style=default   PDF style to use
#    --html_style=default  HTML style to use
#    --xml_style=default   XML style to use
#
#    --pdflatex            location of pdflatex program
#    --pdflatex_args       pdflatex arguments
#    --bibtex              location of bibtex program
#    --makeindex           location of makeindex program
#    --makeglossaries      location of makeglossaries program
#    --svn                 location of svn program
#    --convert             location of convert program
#
#    --titlepage           render title page
#    --notitlepage         don't render title page
#
#    --toc                 render a table of contents
#    --notoc               don't render a table of contents
#    --toc_level=N         maximum TOC level (deepness)
#
#    --revisions           render a table of revisions
#    --updates             render a table of recent updates
#
#    --secnums             include section numbers
#    --nosecnums           don't include section numbers
#    --secnum_level=N      maximum section number level (depth)
#
#    --lof                 render a list of figures
#    --nolof               don't render a list of figures
#
#    --loa                 render a list of attachments
#    --noloa               don't render a list of attachments
#
#    --lot                 render a list of tables
#    --nolot               don't render a list of tables
#
#    --lolists             render a list of listings
#    --nololists           don't render a list of listings
#
#    --attachments         render attachment icons
#    --noattachments       don't render attachment icons
#
#    --epigraphs           render epigraphs
#    --noepigraphs         don't render epigraphs
#
#    --audio               render audio clip icons
#    --noaudio             don't render audio clip icons
#
#    --video               render video clip icons
#    --novideo             don't render video clip icons
#
#    --demos               render demos
#    --nodemos             don't render demos
#    --lodemos             render a list of demos
#    --nolodemos           don't render a list of demos
#
#    --exercises           render exercises
#    --noexercises         don't render exercises
#    --loexercises         render list of exercises
#    --noloexercises       don't render list of exercises
#
#    --keypoints           render keypoints lists
#    --nokeypoints         don't render keypoints lists
#
#    --slides              render slides
#    --noslides            don't render slides
#    --loslides            render a list of slides
#    --noloslides          don't render a list of slides
#
#    --lofootnotes         render a list of footnotes
#    --nolofootnotes       don't render a list of footnotes
#
#    --todo                render todo items
#    --notodo              don't render todo items
#    --lotodo              render a list of todo items
#    --nolotodo            don't render a list of todo items
#
#    --problems            render problems
#    --noproblems          don't render problems
#    --loproblems          render list of problems
#    --noloproblems        don't render a list of problems
#
#    --solutions           render solutions
#    --nosolutions         don't render solutions
#    --losolutions         render list of solutions
#    --nolosolutions       don't render a list of solutions
#
#    --allocations         render allocations
#    --noallocations       don't render allocations
#    --loallocations       render list of allocations
#    --noloallocations     don't render a list of allocations
#
#    --assignments         render assignments
#    --noassignments       don't render assignments
#    --loassignments       render list of assignments
#    --noloassignments     don't render a list of assignments
#
#    --tests               render tests
#    --notests             don't render tests
#    --lotests             render list of tests
#    --nolotests           don't render a list of tests
#
#    --tasks               render tasks
#    --notasks             don't render tasks
#    --lotasks             render list of tasks
#    --nolotasks           don't render a list of tasks
#
#    --results             render results
#    --noresults           don't render results
#    --loresults           render list of results
#    --noloresults         don't render a list of results
#
#    --roles               render roles
#    --noroles             don't render roles
#    --loroles             render list of roles
#    --noloroles           don't render a list of roles
#
#    --sources             render bibliographic sources
#    --nosource            don't render bibliographic sources
#    --losources           render a list of sources
#    --nolosources         don't render a list of sources
#
#    --generate            render requested generated content
#    --nogenerate          don't render requested generated content
#
#    --scripts             run scripts, insert output
#    --noscripts           don't run scripts
#
#    --glossary            render glossary
#    --noglossary          don't render glossary
#
#    --changelog           render changelog
#    --nochangelog         don't render changelog
#
#    --acronym             render acronyms
#    --noacronym           don't render acronyms
#
#    --index               render index
#    --noindex             don't render index
#
#    --pdf_link_color      black, blue, red, ...
#    --pdf_fontsize=10pt   font size for PDF rendition (10,11,12)
#    --pdf_fontfam=times   font family for PDF rendition
#                            - computer_modern
#                            - times
#                            - bookman
#                            - chancery
#                            - charter
#                            - new_century
#                            - palatino
#    --pdf_nonstop         1 or 0, nonstopmode
#
#    --run_pdflatex        run pdflatex to generate PDF file
#
#    --cleanup             remove temporary files
#    --nocleanup           don't remove temporary files
#
#    --launch_browser      launch browser after publishing
#    --nolaunch_browser    don't launch browser arfter publishing
#
#    --launch_pdfview      launch a PDF viewer after publishing
#    --nolaunch_pdfview    don't launch a PDF viewer after publishing
#
#    --use_formal_status      use status values only from results
#    --nouse_formal_status    use all status values
#
#    --use_svn                warn of uncommitted changes
#    --nouse_svn              don't warn or uncommitted changes
#
#    --rev_in_filename     make revision part of the filename
#    --norev_in_filename   don't make revision part of the filename
#
#---------------------------------------------------------------------
# MAPPING OF DOCBOOK FEATURES TO STRUCTURED TEXT FEATURES
#
#    The purpose of this section is to see how well features of the
#    structured text language match up to the docbook DTD.  One of my
#    goals is to publish to docbook XML.  Along the way, I may find I
#    need to enhance the structured text language to support some of
#    the compelling features in docbook.
#
#    This exercise of mapping docbook features to structured text
#    features has given me lots of ideas for features to add to the
#    structured text language.  Structured text will never be as
#    feature rich as docbook, but there are several useful features
#    I'd like to add that wouldn't increase the complexity of
#    structured text too much.
#
# ELEMENTS OF FORMAT
#
#    structured text                      docbook element or attribute
#    ---------------------------------    ----------------------------
#    document font size                   [style sheet]
#    bold
#    italics                              <emphasis>
#    typewriter-type
#    underline
#    superscript                          <superscript>
#    table cell background color
#    table cell content justification
#    figure width
#    copyright symbol                     &copy;
#    trademark symbol                     &trademark;
#    registered trademark symbol          &registered;
#    keystroke                            <keycap>, <keycode>, <keycombo>
#    "take note!" indicator               <important>, <caution>
#    smiley and frowny faces
#    right and left arrows
#    TeX and LaTeX logos
#    horizontal rules
#    fill in the blanks
#    simple preformatted text block       <literallayout>
#    fancy preformatted text block        <literallayout>
#    literal strings
#    pagebreak
#    clearpage
#
# ELEMENTS OF STRUCTURE
#
#    structured text                      docbook element or attribute
#    ---------------------------------    ----------------------------
#    document type
#    document preamble
#    document author                      <author>, <authorgroup>
#    document classification
#    document classified_by
#    document classif_reason
#    document copyright                   <copyright>
#    document date                        <date>, <pubdate>
#    document declassify_on
#    document define
#    document doctype
#    document editor                      <editor>
#    document fontsize
#    document handling_caveat
#    document organization
#    document revision                    <revision>, <edition>
#    document title                       <title>
#    include mechanism
#    paragraph                            <para>
#    section
#    itemized list                        <itemizedlist>
#    itemized list item                   <listitem>
#    ordered list                         <orderedlist>
#    ordered list item                    <listitem>
#    definition list
#    definition list item
#    table                                <table>
#    table caption                        <caption>
#    table row
#    table header cell
#    table cell
#    baretable                            <informaltable>
#    figures                              <figure>
#    figure caption                       <caption>
#    figure width                         width=
#    attachments
#    attachment caption
#    image                                <imageobject>, <graphic>
#    listing                              <programlisting>
#    listing caption                      <title>
#    listing numbering                    linenumbering=
#    footnote reference                   <footnoteref>
#    footnote content                     <footnote>
#    label                                <anchor>, xreflabel=, label=
#    reference                            <reference>
#    link                                 <link>
#    external hyperlinks                  <link>
#    email hyperlinks                     <email>
#    bibliographic source                 <biblioentry>
#    bibliographic citation               <biblioref>
#    bibliography                         <bibliolist>
#    procedural sequence                  <procedure>
#    step                                 <step>
#    substep                              <substep>
#    sidebar                              <sidebar>
#    glossary entry
#    acronym
#    index entry
#
# ELEMENTS OF CONTENT
#
#    structured text                      docbook element or attribute
#    ---------------------------------    ----------------------------
#    comment line                         <!-- ... -->
#    comment block                        <!-- ... -->
#    exercise
#    slide
#    quotation                            <blockquote>
#    quotation title                      <title>
#    quote source                         <attribution>
#    demo                                 <example>
#    keypoints                            <highlights>
#    to-do item                           <task>
#    note                                 <note>, <remark>
#    problem                              <question>
#    solution                             <answer>
#    test
#    task
#    result
#    role
#
#---------------------------------------------------------------------
# HOW DOES IMAGE PUBLISHING WORK?
#
#    When a document contains an image (often within a figure) the
#    publishing script must perform a number of functions:
#
#    - put a copy of the image into the output directory's "images"
#      sub-directory.
#
#    - If the image is used within a slide or demo, the publish script
#      needs to make a thumbnail of the image.
#
#    - If the image is bigger than XxY and you're rendering HTML, then
#      a scaled down version of the image needs to be created for
#      display on the page.
#
#    WHAT HAPPENS IN EACH PASS?
#
#    - pass 2 counts the total number of images
#
#    - pass 2 calls "publish_image" to publish each image
#
#    - between pass 2 and 3, subdirectories named () are created in
#      the output directory
#
#    - pass 3 calls "process_image" to process each image
#
#---------------------------------------------------------------------
# HOW DOES GENERATED CONTENT WORK?
#
#    The structured text language enables the user to insert several
#    types of "generated content":
#
#    - problem domain listing (table representing problem domain
#      hierarchy)
#
#    - solution domain listing (table representing solution domain
#      hierarchy)
#
#    - priority problem listing (table of unsolved problems in
#      priority order)
#
#    - priority solution listing (table of solutions requiring
#      attention in priority order)
#
#    To insert these into the the document, the user adds:
#
#      generate: problem-domain-listing
#      generate: solution-domain-listing
#      generate: priority-problem-listing
#      generate: priority-solution-listing
#
#    During pass 2, the script does two things: (1) makes a list of
#    "generate:" requests, and (2) performs the actual content
#    generation.  It does not do both on the same pass for any given
#    request.  In other words, the script performs pass 2 once to
#    discover "generate:" requests, and then performs pass 2 again to
#    generate the requested content.
#
#    At the end of pass 2, if there are any requests in the request
#    list, pass 2 is repeated, and the content is generated.
#
#    Since generating content can insert new tables and figures, this
#    disrupts the internal table and figure numbering.  Therefore,
#    pass 2 must be run one more time to straighten out the table and
#    figure numbering.
#
#    I want this design to be flexible enough to support recursion if
#    it is needed later on.  In other words, I want the ability for
#    generated content to generate other generated content, and for
#    the script to re-run pass 2 as many times as needed to resolve
#    all generated content requests.  Something tells me this could
#    turn out to be a powerful mechanism some day.
#
#    One application I can think of is to have the publishing system
#    run a script that results in generated content.  For instance,
#    perhaps I have a script that runs nmap, and inserts the results
#    of the scan into the document.  Hmmm... fully automated security
#    auditing and report generation!
#
#      script: run_nmap -sS 192.168.0.1-254
#
#    But what if the nmap script decides that other scripts need to be
#    run?  The publisher should continue to do "pass 2" until all
#    generated content requests are fulfilled.
#
#    Let's play with some scenarios.
#
# SCENARIO 1
#
#    The document contains a single 'generate:' directive:
#
#      generate: problem-domain-listing
#
#    1. During the first pass 2, all problem domain listing content
#    will be gathered in the %data data structure.  Note that we MUST
#    NOT generate the problem domain listing on the first runnin of
#    pass 2 because there may be problem domain data AFTER the
#    generate directive.  We must wait until the second pass to ensure
#    all data is collected.
#
#    2. During the second pass 2, the line with 'generate: ...' is
#    replaced with the generated content, but this messes up the table
#    counting.
#
#    3. During the third pass 2, all the table numbering is
#    straightened out and we're ready to go on to pass 3.
#
# SCENARIO 2
#
#    What if the generated content in the previous scenario contained
#    a 'generate:' directive?  We would have to detect this condition
#    and repeat pass 2 ANOTHER time to generate the content requested
#    by the initial generated content. (Is this complicated enought
#    yet?)
#
#    1. First pass 2: data collected.
#
#    2. Second pass 2: generated content is created and inserted (and
#    it contains another 'generate:' directive.  After this second
#    pass, the system checks for unresolved 'generate:' directives and
#    finds one.
#
#    3. Third pass 2: The second bit of generated content is generated
#    and inserted, and the system once again checks for unresolved
#    'generate:' directives.  It finds none this time.
#
#    4. Forth pass 2: This is the last pass to make sure all numbering
#    is correct before going on to pass 3.
#
#---------------------------------------------------------------------
# TESTS
#
#    The structured text format enables you to design tests.  A test
#    is a set of true/false questions.  Answers to the questions are
#    evaluated to determine a test score (0 - 5 or N/A).  This test
#    mechanism is designed to meet or facilitate the following
#    requirements:
#
#    - Automatically generate paper surveys (tests) from one or more
#    test documents.
#
#    - Automatically generate web-based surveys from one or more test
#    documents.
#
#    - The web survey mechanism should store answers to questions in a
#    structured text format that can be automatically processed to
#    generate a scorecard.
#
#    - Include impact information in the tests and questions to enable
#    the automatic generation of a final report that includes
#    recommended actions.
#
#    - The web-survey should ask the minimum number of questions
#    necessary to produce the scorecard, final report, and list of
#    recommendations.  If the answers to the first two of twenty
#    questions of a test garauntee the score will be a zero, there is
#    no point in asking the other eighteen questions.  Actually, the
#    questions for the next grade should be asked to give improvement
#    recommendations.
#
#    - There is no such thing as a level 0 question.
#
#    >>>test
#
#    <<<test
#
#---------------------------------------------------------------------
# RESULTS
#
#    Results formally record the outcome of tests (aka audits).  They
#    are often used as a container for outcomes.  Outcomes (which can
#    appear anywhere in a document, not just within a result) formally
#    declare the value of the 'status' element of problems, solutions,
#    allocations, assignments, tests, and tasks.
#
#    There are two ways to document the status of problems, solutions,
#    allocations, assignments, tests, and tasks: (1) informally by
#    including a 'status' element within problems, solutions, test,
#    and tasks, or (2) formally documented outcomes.
#
#    A typical 'result' region might look like this (notice there are
#    multiple status elements):
#
#    #------------------------------------------------------------
#
#    >>>result
#
#    title:: 2009-06-01 Requirements Management Audit
#
#    label:: re-000001
#
#    description:: The purpose of this audit was to verify compliance
#    with requirements management requirements.
#
#    <<<result
#
#    outcome::2009-06-01:rq-000111:green: The organization uses a
#    Requirements Management System that features strict version
#    control of all requirements artifacts.
#
#    outcome::2009-06-01:rq-000222:green: The organization has defined
#    and documented its requirements management policies in the
#    document, ``ACME Requirements Management Policy'' dated
#    2008-07-01.
#
#    outcome::2009-06-01:rq-000333:green: The organization has met the
#    requirement to review and update requirements management policies
#    annually.  The last review/update occurred on 2008-12-25 and is
#    documented in the document, ``ACME Requirements Management
#    Policy.''
#
#    #------------------------------------------------------------
#
#    Each formally declared outcome includes: (1) The date the outcome
#    was verified, (2) the label of the verified item, (3) the status
#    of the verified item.
#
#    Only 'leaf' nodes of the requirements structure need be
#    audited. The status of 'container' nodes will be derived from the
#    status of contained 'leaf' nodes.  Since requirements are
#    structured in a whole-part hierarchy, the algorithm for rolling
#    up status is simple: (1) a container is green if and only if all
#    children are green, (2) a container is red if and only if all
#    children are red, (3) a container is yellow in all other cases.
#
#    Force the publish script to ONLY use status from results by (1)
#    specifying the '--use_formal_status' command line option, or (2)
#    adding the 'use_formal_status: 1' to the document preamble.  The
#    value of the 'use_formal_status' element is a document attribute
#    (boolean) stored in the %document datastructure.
#
#---------------------------------------------------------------------
# ROLES
#
#    Roles define those responsible for performing tasks.  Roles "own"
#    problems and solutions.
#
#---------------------------------------------------------------------
# REVIEWS
#
#    Reviews can appear anywhere in the document.  A review is a
#    formal mechanism to document information about document content.
#    For instance, you can use reviews to document stakeholder
#    agreement with requirements, solutions, allocations, or
#    assignments.
#
#    review:2009-07-20:rq-000123: We have reviewed this requirement
#    and agree it accurately documents our needs. (Don Johnson, Troy
#    Morgan, Bob Lewis)
#
#---------------------------------------------------------------------
# GLOSSARY ENTRIES
#
#    To indicate the word "Perl" is in the glossary and create a
#    hyperlink to the glossary entry use one of:
#
#      [g:Perl]
#      [gloss:Perl]
#      [glossary:Perl]
#
#    To create the "Perl" glossary entry:
#
#      glossary: Perl = Practical Extraction and Reporting Language.
#
#    Note: in the future I plan to implement a feature that enables
#    authors to refer to a particular glossary entry.  For example:
#
#      [g:insider:Insider]
#      [gloss:insider:Insider]
#      [glossary:insider:Insider]
#
#    would link to the "insider" glossary entry even though the word
#    is capitalized (perhaps used as the first word in a sentence).
#
#---------------------------------------------------------------------
# ACRONYMS
#
#    The LaTeX glossary package also handles acronyms.  To handle
#    acronyms using the LaTeX glossary package, define an acronym like
#    this in the SML text:
#
#      acronym: TLA = three letter acronym
#
#    To use a defined acronym in the SML text, choose one of the
#    following:
#
#      [ac:TLA]   first use renders   => three letter acronym (TLA)
#      [ac:TLA]   subsequent use      => TLA
#      [acs:TLA]  "short" form        => TLA
#      [acl:TLA]  "long" form         => three letter acronym
#
#    Define an acronym (latex):
#
#      \newacronym{<acronym>}[<short name>]{<full name>}
#      \acro{tla}[TLA]{three letter acronym}
#
#    Use an acronym in the text:
#
#      \ac{TLA}     => three letter acronym (TLA) [first use]
#      \ac{TLA}     => TLA                        [subsequent uses]
#      \acs{TLA}    => TLA
#      \acl{TLA}    => three letter acronym
#
#---------------------------------------------------------------------
# INDEX ENTRIES
#
#    To create an inline index entry for "Perl" choose one of:
#
#      [i:Perl]
#      [index:Perl]
#
#    To create an inline index AND glossary reference at the same time:
#
#      [ig:Perl] (not yet implemented)
#
#    Or, put the following on a line by itself:
#
#      index: Perl
#
#    Or, indicate a block of text about Perl:
#
#      index:begin: Perl
#
#      Blah, blah, blah, blah, blah.
#
#      index:end: Perl
#
#---------------------------------------------------------------------
# TABLES
#
#    The structured text syntax has a pretty good system for
#    describing tables.  Improvements are possible (like the ability
#    to do row and column spanning, the ability to spcify borders,
#    etc) but it meets my needs for now.
#
#    It has been a challenge finding the right way to typeset tables
#    in LaTeX.  Here are some pros and cons of various table
#    description mechanisms in LaTeX:
#
#.....................................................................
# tabbing
#
#    PROS:
#
#      - simple
#      - can span pages
#
#    CONS:
#
#      - can be typeset only as a separate paragraph
#      - must explicitly specify the position of each tab stop
#      - cannot be nested
#      - lines in a tabbing environment are never broken
#
#.....................................................................
# tabular
#
#    PROS:
#
#      - can be placed anywhere in the text
#      - can be placed inside mathematics
#      - can automatically determine the width of columns
#      - can be nested
#
#    CONS:
#
#      - can't span pages
#
#.....................................................................
# array
#
#    The array environment is the same as the tabular environment only
#    in math mode.
#
#    PROS:
#
#    CONS:
#
#      - can't span pages
#
#.....................................................................
# tabular*
#
#    PROS:
#
#      - allows you to sepcify the overall width of the table
#
#    CONS:
#
#      - can't span pages
#
#.....................................................................
# tabularx
#
#    PROS:
#
#      - automatic calculation of column widths
#
#    CONS:
#
#      - all columns same width unless special preamble is used
#      - can't span pages
#
#.....................................................................
# tabulary
#
#    PROS:
#
#      - column widths calculated based on the content of the cells
#
#    CONS:
#
#      - can't span pages
#
#.....................................................................
# supertabular and supertabular*
#
#    PROS:
#
#      - can span pages
#      - widths of columns can be different on different pages
#
#    CONS:
#
#.....................................................................
# mpsupertabular and mpsupertabular* (minipage supertabular)
#
#    PROS:
#
#      - footnotes appear on same page instead of end of the table
#
#    CONS:
#
#.....................................................................
# longtable
#
#    PROS:
#
#      - can span pages
#      - widths of columns are the same on every page
#
#    CONS:
#
#      - does not support multicolumn mode
#
#---------------------------------------------------------------------
# HEADERS AND FOOTERS
#
#     You have a choice between two types of headers and footers: (1)
#     security markings headers/footers, and (2) specified
#     headers/footers.  Don't use both at the same time or the program
#     will scold you.
#
#     Choose to use security markings by specifying document
#     classification and handling caveats in the document preamble.
#     The same headers and footers will be used for the entire
#     document because the security markings apply to the overall
#     document.
#
#     Choose to use specified headers/footers by specifying the
#     header/footer information anywhere in the document.  If you want
#     the same headers/footers throughout the entire document, specify
#     header/footer information in the preamble.
#
#       - header_left
#       - header_left_even
#       - header_left_odd
#
#       - header_center
#       - header_center_even
#       - header_center_odd
#
#       - header_right
#       - header_right_even
#       - header_right_odd
#
#       - footer_left
#       - footer_left_even
#       - footer_left_odd
#
#       - footer_center
#       - footer_center_even
#       - footer_center_odd
#
#       - footer_right
#       - footer_right_even
#       - footer_right_odd
#
#     Headers and Footers are surprisingly complex because:
#
#       - Both the header and footer are divided into left, center,
#         and right blocks.  These blocks must have elastic widths so
#         that blocks with little content are narrow and that empty
#         blocks have no width.
#
#       - Headers and footers in the PDF rendition may be different on
#         odd and even pages (recto and verso).
#
#       - Each block may contain multiple content elements (e.g. the
#         center footer block might contain both the page number and a
#         brief disclaimer statement).
#
#       - Each content element may be independently formatted for
#         size, weight, slant, and justification.
#
#       - Header and footer content can change anywhere in the
#         document.
#
#       - Users require the ability to insert the values of several
#       special variables into header and footer content: [thepage],
#       [pagecount], [thesection], [version], [revision], [copyright],
#       etc.
#
#---------------------------------------------------------------------
# ERROR CHECKING
#
#     Should ALL error checking really be done in pass three or is
#     some error checking appropriate in pass two?  It seems that some
#     of these errors, like duplicate labels and unknown data elements
#     would best be detected in pass 2.  However, since pass two is
#     performed multiple times, I would incur a performance hit from
#     doing the error checking over and over again.
#
#     Pass three should detect the following errors:
#
# preamble errors (100xxx):
#
#     100001: unknown preamble data element
#     100002: define element can't contain spaces
#     100003: unknown doctype
#     100004: unknown fontsize
#     100005: multiples not allowed
#
# include errors (101xxx):
#
#     101001: included file not found (checked in pass 1)
#
# conditional block errors (102xxx):
#
#     102001: spaces in conditional block markers
#
# attachment errors (103xxx):
#
#     103001: attached file not found
#     103002: appearance must be 'true' or 'false'
#     103003: unknown attachment icon color
#     103004: can't understand attachment date
#     103005: unknown icon
#     103006: unknown mime type
#
# section errors (104xxx):
#
#     104001: bad section label (contains spaces)
#     104002: multiples not allowed
#     104003: section heading crosses line boundary [bug]
#
# glossary errors (105xxx):
#
#     105001: no glossary entry corresponding to term
#     105002: glossary term crosses line boundary [bug]
#     105003: urls not allowed in glossary entries [bug]
#     105004: citations not allowed in glossary entries [bug]
#     105005: glossary term contains special formatting characters [bug]
#
# acronym errors (139xxx):
#
#     139001: no defined acronym corresponding to term
#     139002: acronym term crosses line boundary [bug]
#     139003: urls not allowed in acronym entries [bug]
#     139004: citations not allowed in acronym entries [bug]
#     139005: acronym term contains special formatting characters [bug]
#
# inline element errors (106xxx):
#
#     106001: paragraph ends while bolding text (missing end markup)
#     106002: paragraph ends while tt'ing text (missing end markup)
#     106003: paragraph ends while italicizing text (missing end markup)
#     106004: paragraph ends while underlining text (missing end markup)
#     106005: nested bold text
#     106006: nested tt text
#     106007: nested italicized text
#     106008: nested underlined text
#
#   literal string errors (107xxx):
#
#     107001: literal string declaration crosses line boundary [bug]
#     107002: multiple literal strings on same line [bug]
#
#   footnote errors (108xxx):
#
#     108001: count of footnote markers doesn't match footnote count
#
#   cross reference errors (109xxx):
#
#     109001: broken reference, no corresponding label
#     109002: broken title reference, no corresponding label
#     109003: broken description reference, no corresponding label
#     109004: malformed reference (contains spaces)
#     109005: malformed title reference (contains spaces)
#     109006: reference crosses line boundary
#     109007: title reference crosses line boundary
#
#   source errors (110xxx):
#
#     110001: unknown source type
#     110002: missing information
#
#   citation errors (111xxx):
#
#     111001: broken citation, no corresponding label
#     111002: malformed citation (contains spaces)
#     111003: citation crosses line boundary
#
#   label errors (112xxx):
#
#     112001: malformed label, contains spaces
#     112002: same label used multiple times
#
#   todo errors (113xxx):
#
#     113001: malformed todo indicator, contains illegal character
#
#   index errors (114xxx):
#
#     11401: inline index entry crosses line boundary
#
#   path errors (115xxx):
#
#     115001: missing end bracket
#     115002: path ends with backslash [bug]
#
#   environment errors (116xxx):
#
#     116001: unknown environment marker
#
#   region errors (117xxx):
#
#     117001: unknown region marker
#
#   data element errors (118xxx):
#
#     118001: data element not defined for this region
#     118002: data element not defined for this environment
#     118003: data element not defined for the preamble
#     118004: unknown or illegal value for data element
#
#   comment errors (119xxx):
#
#     119001 end of document found inside comment block
#
#   table errors (120xxx):
#
#     120001: unknown cell attribute
#     120002: unknown header attribute
#     120003: some, but not all, column widths declared
#     120004: column width not an integer between 0 and 100
#     120005: wrong number of columns
#     120006: unknown column background color
#     120007: can't understand width
#     120008: unknown font size
#
#   figure errors (121xxx):
#
#     121001: invalid width
#     121002: image file not found
#
#   listing errors (122xxx):
#
#     122001: invalid 'numbers' value (must be none, right, or left)
#     122002: unknown language
#     122003: listing file not found
#     122004: firstline not in listing
#     122005: firstline not a number
#     122006: lastline not in listing
#     122007: lastline not a number
#     122008: showspaces must be 'true' or 'false'
#     122009: showtabs must be 'true' or 'false'
#     122010: showstringspaces must be 'true' or 'false'
#     122011: unknown fontsize
#     122012: stepnumber must be an integer
#     122013: float must be 'true' or 'false'
#
#   audio errors (123xxx):
#
#     123001: can't understand duration
#     123002: audio file not found
#
#   video errors (124xxx):
#
#     124001: can't understand duration
#     124002: video file not found
#
#   image errors (125xxx):
#
#     125001: image file not found
#
#   file errors (126xxx):
#
#     126001: file not found
#
#   security marking errors (127xxx):
#
#     127001: missing portion markings
#
#   generate errors (128xxx):
#
#     128001: unknown generate request
#     128002: request label doesn't exist
#
#   script errors (129xxx):
#
#     129001: script not found
#     129002: script not executable
#     129003: permission to run script denied
#
#   assertion errors (130xxx):
#
#     130001: subject label not found
#     130002: predicate label not found
#     130003: object label not found
#
#   misc errors (131xxx):
#
#     131001: wide line, greater that 100 characters
#
#   region errors (applies to any region) (132xxx):
#
#     132001: associated label not found
#
#   problem errors (133xxx):
#
#     133001: parent not found
#     133002: unknown priority (must be a number from 0 to 10)
#     133003: unknown status (must be red, yellow, green, grey)
#     133004: solution not found
#     133005: test not found
#
#   solution errors (134xxx):
#
#     134001: parent not found
#     134002: unknown priority (must be a number from 0 to 10)
#     134003: unknown status (must be red, yellow, green, grey)
#     134004: problem not found
#     134005: test not found
#     134006: depends_on not found
#     134007: required_by not found
#     134008: instance_of not found
#     134009: class_of not found
#
#   task errors (135xxx):
#
#     135001: parent not found
#     135002: problem not found
#     135003: solution not found
#
#   test problems (136xxx):
#
#     136001: parent not found
#     136002: problem not found
#     136003: solution not found
#     136004: script file not found
#
#   result problems (137xxx):
#
#     137001: parent not found
#     137002: problem not found
#     137003: solution not found
#     137004: script file not found
#
#   role problems (138xxx):
#
#     138001: parent not found
#     138002: problem not found
#     138003: solution not found
#     138004: script file not found
#
######################################################################

#---------------------------------------------------------------------
# USE STRICT?
#
#     !!! BUG HERE !!!
#
#     Find a way to use strict.
#
#     Normally I "use Strict;" in all perl scripts I write.  However,
#     I can't use strict in this one because of the way I use
#     filehandles in the resolve_includes subroutine.  Therefore,
#     leave the following line commented out:
#
# use strict;

use Carp;
use English          qw( -no_match_vars );
use Cwd              qw(getcwd abs_path);
use Getopt::Long     qw(:config no_ignore_case);
use Config::General;
use Date::Pcalc      qw(:all);
use File::Copy;
use File::Glob       qw(:globally);
use File::Basename;
use Digest::SHA qw(sha1);
use Tk;
use Tk::Dialog;
use Tk::DialogBox;
use Tk::Menubutton;
use Tk::Text;
use Tk::Scrollbar;
use Tk::NoteBook;
use Tk::LabFrame;
use Tk::Optionmenu;
use Image::Size;
use Text::Wrap;
use Regexp::Common;
use Benchmark;

# use IPC::Capture;
# use IPC::Cmd qw(run);
# use IPC::Run3;

# use Tie::Hash::NamedCapture;

#---------------------------------------------------------------------
# CONSTANTS
#
my $EMPTY_STRING = q{};

#---------------------------------------------------------------------
# LONGTABLE OR SUPERTABULAR?
#
#    I'm in the process of converting over from using LaTeX longtables
#    to using supertabular environments for the typesetting of
#    non-floating tables in the PDF rendition.  During the conversion,
#    I'm using the following variables to indicate which method I want
#    to use.
#
my $using_longtable    = 1;
my $using_supertabular = 0;

#---------------------------------------------------------------------
# DEFAULT RENDITION
#
#    This is the default rendition that will be published if you're
#    not using the GUI and no rendition(s) are specified on the
#    command line.
#
my $DEFAULT_RENDITION = 'html';

#---------------------------------------------------------------------
# RECENT
#
#    This is the number of days to consider 'recent' for the purpose
#    of determining recently updated items.
#
my $RECENT = 10;

#---------------------------------------------------------------------
# MAXIMUM ALLOWED SECTION DEPTH
#
#    Define the maximum depth of the section structure.  Sections that
#    exceed this depth will be converted to $MAX_SEC_DEPTH sections.
#
my $MAX_SEC_DEPTH = 6;

#---------------------------------------------------------------------
# MAXIMUM ALLOWED LABEL HIERARCHY DEPTH
#
#    Among other things, labels represent entities that can exist in
#    parent-child (whole/part) hierarchies such as problems,
#    solutions, tests, and tasks.  This value represents the maximum
#    allowable depth of one of these hierarchies.
#
my $MAX_LABEL_HIERARCHY_DEPTH = 100;

#---------------------------------------------------------------------
# MAXIMUM PASS TWO ITERATIONS
#
#    Pass two is repeated over and over again until all generated
#    content and script requests are satisfied.  Since generated
#    content can request MORE generated content and script output can
#    request the running of OTHER scripts, it is possible to create
#    infinite loops.
#
#    To prevent the program from going into an infinite loop, we
#    define a maximum number of times pass two can run.
#
my $MAX_PASS_TWO_ITERATIONS = 10;
my $pass_two_count          = 0;

#---------------------------------------------------------------------
# COLUMN CHARACTER CAP
#
#    For the purpose of determining table column widths, this program
#    counts the number of characters in the largest table cell of each
#    column of a table. It may be useful to ignore characters above a
#    certain number.  That's what this constant is for.
#
#    This idea of 'capping' the column character count serves to
#    moderate overly large and small column widths.
#
#    For instance.  Imagine a 2-column table containing mostly
#    narrative information (paragraphs) in which the largest cell in
#    column 1 contains 100 characters and the largest cell in column 2
#    contains 900 characters.
#
#    Taken as a straight ratio, column 1 would be 10% (100 of 1000)
#    and column 2 would be 90% (900 of 1000).
#
#    PROBLEM: 10% is too narrow for a column containing narrative
#    text.
#
#    Capping at 200 characters, however, results in column 1 being 33%
#    (100 of 300) and column 2 being 66% (200 of 300).  This is more
#    reasonable.
#
#    Make the value of $COLUMN_CHAR_CAP smaller to increase the
#    moderating effect and larger to reduce the moderating effect.
#
my $COLUMN_CHAR_CAP = 150;

#---------------------------------------------------------------------
# LOG ARRAYS
#
my @LOG_FILE          = ();
my @LOG_WARNINGS_FILE = ();
my @LOG_ERRORS_FILE   = ();
my @LOG_CHANGES_FILE  = ();

#---------------------------------------------------------------------
# LOG FILES
#
my $LOG_FILE          = 'publish.log.txt';
my $LOG_WARNINGS_FILE = 'publish.warnings.txt';
my $LOG_ERRORS_FILE   = 'publish.errors.txt';
my $LOG_CHANGES_FILE  = 'publish.changes.txt';

#---------------------------------------------------------------------
# IMAGE FILES
#
#    These images are used in the HTML presentation of the document.
#
my $paperclip_icon       = 'paperclip.png';
my $folder_open_icon     = 'folder_green_open.png';
my $folder_icon          = 'folder_green.png';
my $page_icon            = 'page.png';

my $status_green_icon    = 'status_green.png';
my $status_red_icon      = 'status_red.png';
my $status_yellow_icon   = 'status_yellow.png';
my $status_grey_icon     = 'status_grey.png';

my $priority_green_icon  = 'priority_green.png';
my $priority_red_icon    = 'priority_red.png';
my $priority_orange_icon = 'priority_orange.png';
my $priority_yellow_icon = 'priority_yellow.png';
my $priority_grey_icon   = 'priority_grey.png';

#---------------------------------------------------------------------
# List of icons used in HTML rendition
#
my @icons =
  ($paperclip_icon,$folder_open_icon,$folder_icon,$page_icon,
   $status_green_icon,$status_red_icon,$status_yellow_icon,
   $status_grey_icon,$priority_green_icon,$priority_red_icon,
   $priority_orange_icon,$priority_yellow_icon,$priority_grey_icon
  );

#---------------------------------------------------------------------
# List of image directories
#
my @image_directories = ('images','images-scaled','images-thumbnails');

#---------------------------------------------------------------------
# CONFIGURATION OPTIONS
#
#    There are 3 ways to define configuration options.  In order of
#    precedence: (1) command line options, (2) config file options,
#    (3) default options.

#---------------------------------------------------------------------
# DEFAULT OPTIONS
#
my @opt_render = ();
my $renditions = '';
my %option = (

    gui              => 1,             # use the GUI
    help             => 0,             # don't display help info
    directory        => $EMPTY_STRING, # same as input file basename
    output           => $EMPTY_STRING, # same as input file basename
    verbose          => 0,             # show verbose messages
    config           => '',            # configuration file
    version          => 0,             # don't show program version
    debugging        => 0,             # don't show debugging info
    draft            => 0,             # not draft copy
    hide_ids         => 0,             # don't hide data IDs (labels)
    front_list_heads => 1,             # headings in frontmatter lists

    # stylesheet options
    #
    pdf_style      => 'default',       # default PDF stylesheet
    html_style     => 'default',       # default HTML stylesheet
    xml_style      => 'default',       # default XML stylesheet

    # ignorable content types
    #
    attachment     => 1,
    epigraph       => 1,
    audio          => 1,
    video          => 1,
    demo           => 1,
    exercise       => 1,
    keypoints      => 1,
    problem        => 1,
    slide          => 1,
    solution       => 1,
    allocation     => 1,
    assignment     => 1,
    test           => 1,
    task           => 1,
    result         => 1,
    role           => 1,

    # optional features
    #
    titlepage      => 1,                 # include titlepage
    toc            => 1,                 # if sections present
    toc_level      => 4,                 # 4 levels of sections in TOC
    revisions      => 1,                 # if revisions present
    updates        => 1,                 # if recent updates present
    secnums        => 1,                 # include section numbers
    secnum_level   => $EMPTY_STRING,     # all section depths numbered
    generate       => 1,                 # insert generated content
    insert         => 1,                 # insert inserted content
    scripts        => 0,                 # run scripts
    glossary       => 1,                 # if glossary entries present
    changelog      => 1,                 # if SVN changelog present
    acronym        => 0,                 # if acronym definitions present
    index          => 1,                 # if index entries present
    lof            => 1,                 # if figures present
    loa            => 1,                 # if attachments present
    lot            => 1,                 # if tables present
    lolistings     => 1,                 # if listings present
    loslides       => 1,                 # if slides present
    loexercises    => 1,                 # if exercises present
    lodemos        => 1,                 # if demos present
    footnotes      => 1,                 # if footnotes present
    lofootnotes    => 1,                 # if footnotes present
    losidebars     => 1,                 # if sidebars present
    loquotations   => 1,                 # if sidebars present
    todo           => 1,                 # if todo items present
    lotodo         => 1,                 # if todo items present
    loproblems     => 0,                 # if problems present
    losolutions    => 0,                 # if solutions present
    loallocations  => 0,                 # if allocations present
    loassignments  => 0,                 # if assignments present
    lotests        => 0,                 # if tests present
    lotasks        => 0,                 # if tasks present
    loresults      => 0,                 # if results present
    loroles        => 1,                 # if roles present
    sources        => 1,                 # if sources present
    losources      => 1,                 # if sources present

    # PDF options
    #
    pdf_fontsize   => '10pt',            # default PDF font size
    pdf_fontfam    => 'times',           # default PDF font family
    pdf_link_color => 'blue',            # default PDF link color
    pdf_nonstop    => '1',               # default nonstopmode

    # clean up temporary files
    #
    cleanup_files  => 1,                 # remove temporary files

    # launch external programs
    #
    run_pdflatex   => 1,                 # run pdflatex program
    launch_browser => 1,                 # launch web browser
    launch_pdfview => 1,                 # launch PDF viewer

    # use status values only from results elements
    #
    use_formal_status => 0,              # use results status values

    # use svn to warn of uncommitted changes, update inline revision
    # numbers
    #
    use_svn => 1,                        # warn of uncommitted changes

    # make revision part of the PDF document filename
    #
    rev_in_filename => 1,                # put rev in filename

    # executable programs used by publish
    #
    pdflatex       => 'pdflatex',
    pdflatex_args  => '--main-memory=90000000 --extra-mem-bot=90000000',
    bibtex         => 'bibtex',
    makeindex      => 'makeindex',
    makeglossaries => 'makeglossaries',
    svn            => 'svn',
    convert        => 'convert',
);

#---------------------------------------------------------------------
# CONFIG FILE OPTIONS
#
#    Override default options with those defined in the configuration
#    file.
#
my $config_file = $option{'config'} || "publish.conf";
my $conf        = '';
my %conf        = ();
if ( -f $config_file ) {
  $conf = new Config::General("$config_file");
  %conf = $conf->getall;
}

# reconcile configuration options
#
$option{'pdflatex'}       = $conf{'pdflatex'}       if $conf{'pdflatex'};
$option{'pdflatex_args'}  = $conf{'pdflatex_args'}  if $conf{'pdflatex_args'};
$option{'bibtex'}         = $conf{'bibtex'}         if $conf{'bibtex'};
$option{'makeindex'}      = $conf{'makeindex'}      if $conf{'makeindex'};
$option{'makeglossaries'} = $conf{'makeglossaries'} if $conf{'makeglossaries'};
$option{'svn'}            = $conf{'svn'}            if $conf{'svn'};
$option{'convert'}        = $conf{'convert'}        if $conf{'convert'};

#---------------------------------------------------------------------
# COMMAND LINE OPTIONS
#
#    Override default and configuration file options with those passed
#    on the command line.
#
GetOptions (

    'gui|g!'            => \$option{'gui'},
    'help|h!'           => \$option{'help'},
    'render|r=s'        => \@opt_render,
    'directory|d=s'     => \$option{'directory'},
    'output|o=s'        => \$option{'output'},
    'verbose|v!'        => \$option{'verbose'},
    'config|c=s'        => \$option{'config'},
    'Version|V!'        => \$option{'version'},
    'debugging|D!'      => \$option{'debugging'},
    'draft!'            => \$option{'draft'},
    'hide_ids!'         => \$option{'hide_ids'},
    'front_list_heads!' => \$option{'front_list_heads'},

    # stylesheet options
    #
    'pdf_style=s'      => \$option{'pdf_style'},
    'html_style=s'     => \$option{'html_style'},
    'xml_style=s'      => \$option{'xml_style'},

    # ignorable content types
    #
    'attachments!'     => \$option{'attachment'},
    'epigraphs!'       => \$option{'epigraph'},
    'audio!'           => \$option{'audio'},
    'video!'           => \$option{'video'},
    'demos!'           => \$option{'demo'},
    'exercises!'       => \$option{'exercise'},
    'keypoints!'       => \$option{'keypoints'},
    'problems!'        => \$option{'problem'},
    'slides!'          => \$option{'slide'},
    'solutions!'       => \$option{'solution'},
    'allocations!'     => \$option{'allocation'},
    'assignments!'     => \$option{'assignment'},
    'tests!'           => \$option{'test'},
    'tasks!'           => \$option{'task'},
    'results!'         => \$option{'result'},
    'roles!'           => \$option{'role'},
    'todos!'           => \$option{'todo'},

    # optional features
    #
    'titlepage!'       => \$option{'titlepage'},
    'toc!'             => \$option{'toc'},
    'toc_level=i'      => \$option{'toc_level'},
    'revisions!'       => \$option{'revisions'},
    'updates!'         => \$option{'updates'},
    'secnums!'         => \$option{'secnums'},
    'secnum_level=i'   => \$option{'secnum_level'},
    'generate!'        => \$option{'generate'},
    'scripts!'         => \$option{'scripts'},
    'glossary!'        => \$option{'glossary'},
    'changelog!'       => \$option{'changelog'},
    'acronym!'         => \$option{'acronym'},
    'index!'           => \$option{'index'},
    'lof!'             => \$option{'lof'},
    'lot!'             => \$option{'lot'},
    'lolists!'         => \$option{'lolistings'},
    'loslides!'        => \$option{'loslides'},
    'loexercises!'     => \$option{'loexercises'},
    'lodemos!'         => \$option{'lodemos'},
    'footnotes!'       => \$option{'footnotes'},
    'lofootnotes!'     => \$option{'lofootnotes'},
    'losidebars'       => \$option{'losidebars'},
    'loquotations'     => \$option{'loquotations'},
    'todo!'            => \$option{'todo'},
    'lotodo!'          => \$option{'lotodo'},
    'loproblems!'      => \$option{'loproblems'},
    'losolutions!'     => \$option{'losolutions'},
    'loallocations!'   => \$option{'loallocations'},
    'loassignments!'   => \$option{'loassignments'},
    'lotests!'         => \$option{'lotests'},
    'lotasks!'         => \$option{'lotasks'},
    'loresults!'       => \$option{'loresults'},
    'loroles!'         => \$option{'loroles'},
    'sources!'         => \$option{'sources'},
    'losources!'       => \$option{'losources'},

    # PDF options
    #
    'pdf_fontsize=i'   => \$option{'pdf_fontsize'},
    'pdf_fontfam=s'    => \$option{'pdf_fontfam'},
    'pdf_link_color=s' => \$option{'pdf_link_color'},
    'pdf_nonstop!'     => \$option{'pdf_nonstop'},

    # clean up temporary files
    #
    'cleanup!'         => \$option{'cleanup_files'},

    # launch external programs
    #
    'run_pdflatex!'    => \$option{'run_pdflatex'},
    'launch_browser!'  => \$option{'launch_browser'},
    'launch_pdfview!'  => \$option{'launch_pdfview'},

    # only use status from results elements
    #
    'use_formal_status!' => \$option{'use_formal_status'},

    # only use status from results elements
    #
    'use_svn!'         => \$option{'use_svn'},

    # make revision part of the PDF filename
    #
    'rev_in_filename!' => \$option{'rev_in_filename'},

    # make revision part of the PDF document filename
    #
    rev_in_filename    => 1,

    # executable programs used by publish
    #
    'pdflatex=s'       => \$option{'pdflatex'},
    'pdflatex_args=s'  => \$option{'pdflatex_args'},
    'bibtex=s'         => \$option{'bibtex'},
    'makeindex=s'      => \$option{'makeindex'},
    'makeglossaries=s' => \$option{'makeglossaries'},
    'svn=s'            => \$option{'svn'},
    'convert=s'        => \$option{'convert'},
);

#---------------------------------------------------------------------
# TYPES OF GENERATED CONTENT
#
#    The 'generate' feature of this program is able to generate
#    content based on other content.  For example, it can generate a
#    prioritized list of problems based on a derived urgency (computed
#    based on priority and status) of all problems in the document.
#
#    Some types of generated content are context sensitive and others
#    are not.  The hash knows.
#
#    Here is a list of the types of generated content the program
#    knows how to create:
#
my %generated_content_types =
  (
   'problem-domain-listing'        => "not context sensitive",
   'solution-domain-listing'       => "not context sensitive",
   'prioritized-problem-listing'   => "not context sensitive",
   'prioritized-solution-listing'  => "not context sensitive",
   'associated-problem-listing'    => "context sensitive",
   'associated-solution-listing'   => "context sensitive",
  );

#---------------------------------------------------------------------
# TYPES OF INSERTED CONTENT
#
#    The 'insert' feature of this program is able to insert reusable
#    content.  For example, it can insert the narrative portion of a
#    problem or solution.
#
#    Here is a list of the types of inserted content the program
#    knows how to handle:
#
my %inserted_content_types =
  (
   'narrative'  => 1,   # item narratives
   'definition' => 1,   # glossary definitions
  );

#---------------------------------------------------------------------
# FONT SIZES
#
#    Use standard LaTeX font size descriptors.
#
my @font_sizes =
  (
   'tiny', 'scriptsize', 'footnotesize', 'small', 'normalsize',
   'large', 'Large', 'LARGE', 'huge', 'Huge',
  );

#---------------------------------------------------------------------
# FONT WEIGHTS
#
#    Use standard LaTeX font weight (series) descriptors.
#
my @font_weights =
  (
   'medium', 'bold', 'bold_extended', 'semi_bold', 'condensed',
  );

#---------------------------------------------------------------------
# FONT SHAPES
#
#    Use standard LaTeX font shape descriptors.
#
my @font_shapes = ('normal', 'italic', 'slanted', 'smallcaps');

#---------------------------------------------------------------------
# FONT FAMILIES
#
#    Use standard LaTeX font family descriptors.
#
my @font_families = ('roman', 'serif', 'typewriter');

#---------------------------------------------------------------------
# List of header/footer elements
#
my @header_footer_elements =
  (
   'header_left',
   'header_center',
   'header_right',

   'header_left_odd',
   'header_center_odd',
   'header_right_odd',

   'header_left_even',
   'header_center_even',
   'header_right_even',

   'footer_left',
   'footer_center',
   'footer_right',

   'footer_left_odd',
   'footer_center_odd',
   'footer_right_odd',

   'footer_left_even',
   'footer_center_even',
   'footer_right_even',
  );

#---------------------------------------------------------------------
# DEFAULT MARGIN SIZES
#
#    These are the default margin sizes for PDF output.  Please
#    specify them in inches (i.e. '.75in').  For books, the left
#    margin will be the INNER margin and the right margin will be the
#    OUTER margin.
#
my %margin = (

    left   => '1.0',
    right  => '1.5',
    top    => '0.5',
    bottom => '0.7',

);

#---------------------------------------------------------------------
# GENERATED CONTENT DATA STRUCTURE
#
#    Initialize a hash to hold generated content.  This will hold
#    generated content for both 'generate:' and 'script:' requests.
#    The key will be the requested content
#    (i.e. problem-domain-listing) or the script number (i.e. script1)
#    The values of the hash will be either the generated content or
#    the output of the script.
#
my %generated_content = ();

#---------------------------------------------------------------------
# RENDITONS
#
#    Define variables that define what formats to render.
#
my %rendering = (

    html => 0,
    pdf  => 0,
    xml  => 0,
    csv  => 0,

);

#---------------------------------------------------------------------
# INPUT FILENAME
#
#    Define the name of the main plain text input file.
#
#    !! BUG HERE !!
#
#    This needs to be changed to handle a list of input files instead
#    of just a single input file because I want to be able to pass a
#    list of files to the script.
#
my $text_file = $EMPTY_STRING;

#---------------------------------------------------------------------
# HTML DATASTRUCTURE
#
#    Define arrays to hold HTML output data that will later be written
#    to files.  These are anonymous arrays.  I'll use array
#    references, typically called aref, to refer to them.
#
my %html = (

  'head'     => [], 'foot'      => [], 'nav' => [], 'changelog' => [],
  'title'    => [], 'preamble'  => [], 'toc' => [], 'glossary'  => [],
  'acronym'  => [], 'revisions' => [], 'updates' => [],

  'slide'      => { 'index' => [] }, 'sidebar'  => { 'index' => [] },
  'quotation'  => { 'index' => [] }, 'demo'     => { 'index' => [] },
  'exercise'   => { 'index' => [] }, 'listing'  => { 'index' => [] },
  'todo'       => { 'index' => [] }, 'footnote' => { 'index' => [] },
  'table'      => { 'index' => [] }, 'figure'   => { 'index' => [] },
  'attachment' => { 'index' => [] }, 'source'   => { 'index' => [] },

  'problem'    => {
    'index'       => [], 'tree_big'   => [], 'tree_small' => [],
    'spreadsheet' => [], 'priorities' => [],
  },

  'solution'   => {
    'index'       => [], 'tree_big'   => [], 'tree_small' => [],
    'spreadsheet' => [], 'priorities' => [],
  },

  'task'       => {
    'index'       => [], 'tree_big'   => [], 'tree_small' => [],
    'spreadsheet' => [], 'priorities' => [],
  },

  'test'       => {
    'index'       => [], 'tree_big'   => [], 'tree_small' => [],
    'spreadsheet' => [], 'priorities' => [],
  },

  'result'     => {
    'index'       => [], 'tree_big'   => [], 'tree_small' => [],
    'spreadsheet' => [], 'priorities' => [],
  },

  'role'       => {
    'index'       => [], 'tree_big'   => [], 'tree_small' => [],
    'spreadsheet' => [], 'priorities' => [],
  },

);

#---------------------------------------------------------------------
# CSV DATASTRUCTURE
#
#     Define arrays to hold comma-separated-value (CSV) output data
#     that will later be written to files.
#
my %csv = (
  'problem' => [], 'solution' => [], 'task' => [],
  'test'    => [], 'result'   => [], 'role' => [],
);

#---------------------------------------------------------------------
# LATEX DATA ARRAYS
#
#    Define arrays to hold LaTeX data.  LaTeX is used to typeset the
#    PDF rendition.
#
#    !!! Bug Here !!!
#
#    Rather than individual arrays, this really ought to be a
#    datastructure of array references.
#
my @latex_head        = ();
my @latex_nav         = ();
my @latex_title       = ();
my @latex_cvsinfo     = ();
my @latex             = ();
my @latex_glossary    = ();
my @latex_changelog   = ();
my @latex_acronym     = ();
my @latex_foot        = ();

#---------------------------------------------------------------------
# XML DATA ARRAYS
#
#    Define arrays for accumulating XML data.
#
#    !!! Bug Here !!!
#
#    Rather than individual arrays, this really ought to be a
#    datastructure of array references.
#
my @xml            = ();
my @xml_head       = ();
my @xml_foot       = ();
my @xml_stylesheet = ();
my @xml_dtd        = ();

#---------------------------------------------------------------------
# ORIGINAL DATA ARRAY
#
#    Define array for storing the original raw text.  Under some
#    circumstances, this program may make changes to the original text
#    and write those changes back out to the original file.
#
#    For instance, the author can include an inline "version" comment
#    like this:
#
#        include: myfile.txt [#v:myfile.txt:22]
#
#        include:$r22$: myfile.txt
#
#    This program will automatically update the containing document
#    with the current version (currently 22) of myfile.txt.
#
#    These changes will be made first in the @original data array then
#    written back out to the source document (as long as the source
#    document file is writeable).
#
my @original = ();

#---------------------------------------------------------------------
# TEXT DATA ARRAY
#
#     Define an array for accumulating *and manipulating* output text.
#     The text in this array will be manipulated during processing.
#     For instance, files added to the document using the "include"
#     mechanism will have their text dumped into this array.
#     Therefore, after processing, the text in this "text" array may
#     not mirror the original source document.
#
my @text = ();

#---------------------------------------------------------------------
# RAW TEXT OF THE DOCUMENT
#
#     Explain the difference between the @text and @intext arrays.
#
my @intext  = ();
my @outtext = ();

#---------------------------------------------------------------------
# OUTPUT FILENAMES
#
#    Define scalar variables for output file names
#
#    !!! Bug Here !!!
#
#    Rather than individual scalars, this really ought to be a
#    datastructure.  Perhaps something like:
#
#      $output{$rendition}{$component}
#
my $html_toc_file                     = $EMPTY_STRING;
my $html_revisions_file               = $EMPTY_STRING;
my $html_updates_file                 = $EMPTY_STRING;
my $html_slide_index_file             = $EMPTY_STRING;
my $html_sidebar_index_file           = $EMPTY_STRING;
my $html_quotation_index_file         = $EMPTY_STRING;
my $html_problem_index_file           = $EMPTY_STRING;
my $html_solution_index_file          = $EMPTY_STRING;
my $html_test_index_file              = $EMPTY_STRING;
my $html_task_index_file              = $EMPTY_STRING;
my $html_result_index_file            = $EMPTY_STRING;
my $html_role_index_file              = $EMPTY_STRING;
my $html_priority_index_file          = $EMPTY_STRING;
my $html_problem_tree_big_file        = $EMPTY_STRING;
my $html_solution_tree_big_file       = $EMPTY_STRING;
my $html_test_tree_big_file           = $EMPTY_STRING;
my $html_task_tree_big_file           = $EMPTY_STRING;
my $html_result_tree_big_file         = $EMPTY_STRING;
my $html_role_tree_big_file           = $EMPTY_STRING;
my $html_problem_tree_small_file      = $EMPTY_STRING;
my $html_solution_tree_small_file     = $EMPTY_STRING;
my $html_test_tree_small_file         = $EMPTY_STRING;
my $html_task_tree_small_file         = $EMPTY_STRING;
my $html_result_tree_small_file       = $EMPTY_STRING;
my $html_role_tree_small_file         = $EMPTY_STRING;
my $html_problem_spreadsheet_file     = $EMPTY_STRING;
my $html_solution_spreadsheet_file    = $EMPTY_STRING;
my $html_test_spreadsheet_file        = $EMPTY_STRING;
my $html_task_spreadsheet_file        = $EMPTY_STRING;
my $html_result_spreadsheet_file      = $EMPTY_STRING;
my $html_role_spreadsheet_file        = $EMPTY_STRING;
my $html_allocation_spreadsheet_file  = $EMPTY_STRING;
my $html_assignment_spreadsheet_file  = $EMPTY_STRING;
my $html_problem_priorities_file      = $EMPTY_STRING;
my $html_solution_priorities_file     = $EMPTY_STRING;
my $html_test_priorities_file         = $EMPTY_STRING;
my $html_task_priorities_file         = $EMPTY_STRING;
my $html_result_priorities_file       = $EMPTY_STRING;
my $html_role_priorities_file         = $EMPTY_STRING;
my $html_demo_index_file              = $EMPTY_STRING;
my $html_exercise_index_file          = $EMPTY_STRING;
my $html_listing_index_file           = $EMPTY_STRING;
my $html_todo_index_file              = $EMPTY_STRING;
my $html_footnote_index_file          = $EMPTY_STRING;
my $html_table_index_file             = $EMPTY_STRING;
my $html_figure_index_file            = $EMPTY_STRING;
my $html_attachment_index_file        = $EMPTY_STRING;
my $html_source_index_file            = $EMPTY_STRING;
my $html_glossary_file                = $EMPTY_STRING;
my $html_changelog_file               = $EMPTY_STRING;
my $html_acronym_file                 = $EMPTY_STRING;
my $latex_file                        = $EMPTY_STRING;
my $bibliography_file                 = $EMPTY_STRING;
my $index_file                        = $EMPTY_STRING;
my $xml_doc_file                      = $EMPTY_STRING;
my $xml_stylesheet_file               = $EMPTY_STRING;
my $xml_dtd_file                      = $EMPTY_STRING;
my $text_out_file                     = $EMPTY_STRING;
my $csv_problem_index_file            = $EMPTY_STRING;
my $csv_solution_index_file           = $EMPTY_STRING;
my $csv_test_index_file               = $EMPTY_STRING;
my $csv_task_index_file               = $EMPTY_STRING;
my $csv_result_index_file             = $EMPTY_STRING;
my $csv_role_index_file               = $EMPTY_STRING;
my $csv_allocation_index_file         = $EMPTY_STRING;
my $csv_assignment_index_file         = $EMPTY_STRING;

#---------------------------------------------------------------------
# 'IN' DATASTRUCTURE
#
#    The 'in' data structure is a hash I use to track what type of
#    content I'm 'in' as I'm parsing the text line by line.  Consider,
#    for example, the following 'problem' region:
#
#        >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>problem
#
#        title::      This is my requirement that has a very long
#                     title that actually spans more than one line.
#
#        label::      req-2004-11-19-001
#
#        stakeholder:: Don Johnson
#
#        type::       functional
#
#        priority::   high
#
#        status::     green
#
#        description:: This is the description of the requirement. The
#        description is a single paragraph that summarizes the
#        requirement but doesn't go into a great amount of detail.
#
#        <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<problem
#
#    When I parse the line that begins with '>>>problem' I'll set:
#
#        $in{'problem'}{'region'} = 1;
#
#    When I parse the line that begins with '<<<problem' I'll set:
#
#        $in{'problem'}{'region'} = 0;
#
#    The structured data inside the problem (the title, the label,
#    the stakeholder, type, etc.) can span more than one line.  When I
#    parse the line that begins with 'title:' I'll set:
#
#        $in{'problem'}{'title'} = 1;
#
#    Question: How do I know when I'm no longer in the problem
#    title?  Answer: When I hit another data element, a paragraph, or
#    the end of the problem.
#
#    What data elements are allowed inside each region?  They are
#    defined by the %structure data structure (below).
#
my %in = ();

#-------------------------------------------------------------------
# 'STRUCTURE' DATASTRUCTURE
#
#    This "structure" datastructure lists allowable environments and
#    regions, and the data elements they may contain.  Environments
#    and regions are designed to describe blocks of text with special
#    meaning.
#
#    Regions CAN contain environments, but CANNOT contain other
#    regions (e.g. an exercise CAN contain a table, but a table CANNOT
#    contain an exercise).
#
#    Environments CANNOT contain either regions or other environments
#    (e.g. a table CANNOT contain an exercise and also CANNOT contain
#    another table)
#
#    Here's an example of a 'figure' region containing 'label',
#    'image', 'width', and 'title' data elements:
#
#      ---figure
#      title:      publish icon
#      label:      fig-publish-icon
#      image:      images/publish-icon.png
#      width:      4in
#      ---figure
#
#    The 'structure' data structure is the DEFINITIVE listing of
#    allowable data elements inside environments and regions.  If a
#    data element isn't defined here, it's not allowed.  The script
#    uses this data structure to determine what is allowed and what is
#    not.
#
#    NOTE: A possible exception to this might be user defined
#    regions. I'm toying with the idea of allowing users to define
#    their own regions simply by adding them in a document.  For
#    instance, if I were writing a cookbook, I could enclose recipes
#    in '>>>recipe' regions.  The user defined regions function has
#    NOT been implemented.
#
#    The keys of the 'structure' hash are the names of the
#    environments and regions.  Each environment or region has a
#    'type' (environment or region) and a hash of elements.  Each
#    element can be multivalued or not.  Here are examples of some
#    standard ways to query the structure:
#
#      my @names    = keys %structure;
#      my $type     = $structure{$name}{'type'};
#      my @elements = @{keys %{$structure{$name}{'elements'}}};
#      my $is_multi = $structure{$name}{'elements'}{$element}{'multivalued'};
#
#
#    Several environments support the 'attr' data element.  For
#    instance:
#
#      >>>solution
#      title: My Server
#      label: my-server
#      attr: cpu = i386
#      >>>solution
#
#    The 'attr' data element allows authors to assign key/value pairs
#    to environments.  The key and value are separated by an '='
#    (equals) sign.  This enables authors to basically make up their
#    own attributes.
#
#    Take a configuration management application, for instance.  This
#    enables an author to use Solution environments to define
#    configuration items, and use 'attr' data elements to capture CI
#    attributes.
#
#    The attr data element is multivalued.
#
#    Authors can assign multiple values to the same attribute name.
#
my %structure =
  (

   ###################################################################
   ###################################################################
   ###################################################################
   ###
   ### PREAMBLE Data Elements
   ###
   ###################################################################
   ###################################################################
   ###################################################################
   #
   #     The `preamble' is the beginning of the document.  The
   #     occurance of any one of the following items will END the
   #     preamble:
   #
   #     - the beginning of a region
   #     - the beginning of an environment
   #     - a section heading
   #     - an unordered list item
   #     - an ordered list item
   #     - a todo list item
   #     - a glossary entry
   #     - an acronym definition
   #     - an index entry
   #     - a table
   #     - a quotation
   #     - a paragraph
   #     - a file data element
   #     - an image
   #     - a footnote
   #
   #     !!! Bug Here !!!
   #
   #     The list above will end the preamble for pass three, but I
   #     don't think the list is as complete for pass two.  The items
   #     that end the preamble for pass two should be exactly the same
   #     as the items that end the preamble for pass 3.
   #
   preamble =>
   {
    name                => 'Preamble',
    plural_name         => 'Prambles',
    type                => 'text',
    ignorable           => 'no',
    elements            =>
    {
     title              => { multivalued => 0 },
     subtitle           => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },

     author             => { multivalued => 1 },
     editor             => { multivalued => 1 },
     translator         => { multivalued => 1 },

     publisher          => { multivalued => 0 },
     publisher_location => { multivalued => 0 },
     publisher_logo     => { multivalued => 0 },
     publisher_address  => { multivalued => 0 },

     edition            => { multivalued => 0 },

     biographical_note  => { multivalued => 0 },
     copyright          => { multivalued => 0 },
     full_copyright     => { multivalued => 0 },
     publication_year   => { multivalued => 0 },

     date               => { multivalued => 0 },
     isbn               => { multivalued => 0 },
     issn               => { multivalued => 0 },
     cip_data           => { multivalued => 0 },

     permissions        => { multivalued => 0 },
     grants             => { multivalued => 0 },

     paper_durability   => { multivalued => 0 },

     dedication         => { multivalued => 0 },
     epigraph           => { multivalued => 0 },
     epigraph_source    => { multivalued => 0 },

     define             => { multivalued => 1 },
     doctype            => { multivalued => 0 },
     fontsize           => { multivalued => 0 },
     organization       => { multivalued => 0 },
     revision           => { multivalued => 0 },
     version            => { multivalued => 0 },

     classification     => { multivalued => 0 },
     classified_by      => { multivalued => 0 },
     classif_reason     => { multivalued => 0 },
     declassify_on      => { multivalued => 0 },
     handling_caveat    => { multivalued => 1 },

     priority           => { multivalued => 0 },
     status             => { multivalued => 0 },
     attr               => { multivalued => 1 },

     use_formal_status  => { multivalued => 0 },
     use_svn            => { multivalued => 0 },

     effort_units       => { multivalued => 0 },

     var                => { multivalued => 1 },

     no_titlepage       => { multivalued => 0 },
     no_toc             => { multivalued => 0 },
     no_revisions       => { multivalued => 0 },
     no_updates         => { multivalued => 0 },
     no_secnums         => { multivalued => 0 },
     no_glossary        => { multivalued => 0 },
     no_changelog       => { multivalued => 0 },
     no_loacronyms      => { multivalued => 0 },
     no_index           => { multivalued => 0 },
     no_lofigures       => { multivalued => 0 },
     no_loattachments   => { multivalued => 0 },
     no_lotables        => { multivalued => 0 },
     no_lolistings      => { multivalued => 0 },
     no_loslides        => { multivalued => 0 },
     no_loexercises     => { multivalued => 0 },
     no_lodemos         => { multivalued => 0 },
     no_lofootnotes     => { multivalued => 0 },
     no_losidebars      => { multivalued => 0 },
     no_loquotations    => { multivalued => 0 },
     no_todo            => { multivalued => 0 },
     no_lotodo          => { multivalued => 0 },
     no_loproblems      => { multivalued => 0 },
     no_losolutions     => { multivalued => 0 },
     no_loallocations   => { multivalued => 0 },
     no_loassignments   => { multivalued => 0 },
     no_lotests         => { multivalued => 0 },
     no_lotasks         => { multivalued => 0 },
     no_loresults       => { multivalued => 0 },
     no_loroles         => { multivalued => 0 },
     no_sources         => { multivalued => 0 },
     no_losources       => { multivalued => 0 },

     logo_image_small   => { multivalued => 0 },
     logo_image_left    => { multivalued => 0 },
     logo_image_center  => { multivalued => 0 },
     logo_image_right   => { multivalued => 0 },

     header_left        => { multivalued => 1 },
     header_left_odd    => { multivalued => 1 },
     header_left_even   => { multivalued => 1 },

     header_center      => { multivalued => 1 },
     header_center_odd  => { multivalued => 1 },
     header_center_even => { multivalued => 1 },

     header_right       => { multivalued => 1 },
     header_right_odd   => { multivalued => 1 },
     header_right_even  => { multivalued => 1 },

     footer_left        => { multivalued => 1 },
     footer_left_odd    => { multivalued => 1 },
     footer_left_even   => { multivalued => 1 },

     footer_center      => { multivalued => 1 },
     footer_center_odd  => { multivalued => 1 },
     footer_center_even => { multivalued => 1 },

     footer_right       => { multivalued => 1 },
     footer_right_odd   => { multivalued => 1 },
     footer_right_even  => { multivalued => 1 },

    },
   },


   ###################################################################
   ###################################################################
   ###################################################################
   ###
   ### SECTION Data Elements
   ###
   ###################################################################
   ###################################################################
   ###################################################################
   #
   # These elements describe the section in which they occur.
   #
   section =>
   {
    name                => 'Section',
    plural_name         => 'Sections',
    type                => 'text',
    ignorable           => 'no',
    elements            =>
    {
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     revision           => { multivalued => 0 },
     date               => { multivalued => 0 },
     author             => { multivalued => 1 },
     type               => { multivalued => 0 },
     number             => { multivalued => 0 },
     copyright          => { multivalued => 0 },
     associated         => { multivalued => 1 },
     attr               => { multivalued => 1 },
     narrative          => { multivalued => 0 },
    },
   },

   ###################################################################
   ###################################################################
   ###################################################################
   ###
   ### UNIVERSAL Data Elements
   ###
   ###################################################################
   ###################################################################
   ###################################################################
   #
   # These elements can occur anywhere in the document.  They do not
   # need to be in an environment or region.
   #
   # As a matter of good form, most 'universal' data elements should
   # not occur within the preamble.
   #
   universal =>
   {
    name                => 'Universal',
    plural_name         => 'Universal',
    type                => 'text',
    ignorable           => 'no',
    elements            =>
    {

     # one liners:

     file               => { multivalued => 0 },
     generate           => { multibalued => 0 },
     script             => { multivalued => 0 },
     image              => { multivalued => 0 },
     include            => { multivalued => 0 },

     # text blocks:

     footnote           => { multivalued => 0 },
     glossary           => { multivalued => 0 },
     acronym            => { multivalued => 0 },
     index              => { multivalued => 0 },
     step               => { multivalued => 0 },
     outcome            => { multivalued => 0 },
     review             => { multivalued => 0 },
     var                => { multivalued => 1 },

    },
   },

   ###################################################################
   ###################################################################
   ###################################################################
   ###
   ### ENVIRONMENTS (elements of structure, these cannot contain other
   ###               environments or regions)
   ###
   ###################################################################
   ###################################################################
   ###################################################################

   #------------------------------------------------------------------
   # attachment environment
   #
   #     Attach files to a document like you would attach files to an
   #     email message.
   #
   #     Elements:
   #
   #       title = The subject of the attachment
   #
   #       appearance = true or false: prevent the attachment icon's
   #         appearance from being specified explicitly in the PDF
   #         file.
   #
   #       color = color of the attachment icon in the PDF output
   #
   #       date = timestamp indicating when the attached file was
   #         last modified.
   #
   #       description = one paragraph description of the attachment
   #
   #       icon = Graph, PaperClip, PushPin or Tag
   #
   #       mimetype = MIME type of the attached document
   #
   #       file = file to attach
   #
   #     Example:
   #
   #     ---attachment
   #     title: Pinewood Derby Scoring Program
   #     description: Program for scoring pinewood derby races
   #     label: att-pinewood-derby
   #     file: files/pinewood.exe
   #     ---attachment
   #
   #     NOTE: A ``source'' environment is a special type of
   #     attachment which is also a citable bibliography entry.
   #
   attachment =>
   {
    name                => 'Attachment',
    plural_name         => 'Attachments',
    type                => 'environment',
    ignorable           => 'yes',
    elements            =>
    {
     title              => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     appearance         => { multivalued => 0 },
     color              => { multivalued => 0 },
     date               => { multivalued => 0 },
     icon               => { multivalued => 0 },
     mimetype           => { multivalued => 0 },
     file               => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # revisions environment
   #
   #    A list of revisions, each consisting of (1) a date, (2) a
   #    version, and (3) a description of the changes.
   #
   #    Example:
   #
   #    ---revisions
   #
   #    rev: 0.1 (1539) = 2010-10-19 = Initial draft.  Separated out
   #    the business requirements into their own business requirements
   #    document, and removed all references to this document being a
   #    CONOPS.
   #
   #    rev: 0.2 (1957) = 2011-02-01 = Added this revision summary
   #    table.  Organized each stage description into four parts: (1)
   #    Activities By Role, (2) Work Products, (3) Exit Criteria, (4)
   #    Tailoring Information
   #
   #    ---revisions
   #
   revisions =>
   {
    name                => 'Revisions',
    plural_name         => 'Revisions',
    type                => 'environment',
    ignorable           => 'yes',
    elements            =>
    {
     title              => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     rev                => { multivalued => 1 },
    },
   },

   #------------------------------------------------------------------
   # include environment
   #
   #    A directive to include a file at this location in the document.
   #
   #    Example:
   #
   #    ---include
   #
   #    file: files/include/template.txt
   #
   #    var: item = rq-000291
   #
   #    ---include
   #
   include =>
   {
    name                => 'Include',
    plural_name         => 'Includes',
    type                => 'environment',
    ignorable           => 'yes',
    elements            =>
    {
     title              => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     file               => { multivalued => 0 },
     var                => { multivalued => 1 },
     region             => { multivalued => 0 },
     section            => { multivalued => 0 },
     hide               => { multivalued => 0 },
     raw                => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # epigraph environment
   #
   #    An interesting quotation that goes at the beginning of a major
   #    section.
   #
   #    Example:
   #
   #    ---epigraph
   #
   #    text: Example is the school of mankind, and they will learn at
   #    no other
   #
   #    source: Letters on a Regicide Peace
   #
   #    author: Edmund Burke
   #
   #    ---epigraph
   #
   epigraph =>
   {
    name                => 'Epigraph',
    plural_name         => 'Epigraphs',
    type                => 'environment',
    ignorable           => 'yes',
    elements            =>
    {
     title              => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     text               => { multivalued => 0 },
     source             => { multivalued => 0 },
     author             => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # figure environment
   #
   #     Insert various kinds of figures in a document.  This includes
   #     ASCII art.
   #
   #     Elements:
   #
   #       title -- The title (i.e. caption) for the figure.
   #
   #       label -- unique identifier for this figure.
   #
   #       width -- desired width for the figure (e.g. 6.0in).
   #
   #       image -- file containing image to use in figure.
   #
   #     Example:
   #
   #     ---figure
   #     title: Example Figure
   #     label: fig-example
   #     image: images/example.png
   #     width: 5in
   #     ---figure
   #
   figure =>
   {
    name                => 'Figure',
    plural_name         => 'Figures',
    type                => 'environment',
    ignorable           => 'no',
    elements            =>
    {
     title              => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     width              => { multivalued => 0 },
     border             => { multivalued => 0 },
     image              => { multivalued => 0 },
     orientation        => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # listing environment
   #
   #     Insert various kinds of listings in a document.  This
   #     includes listings of source code.
   #
   #     For the PDF rendition produced using PDFLaTeX, the `listings'
   #     package is used to produce line numberings (if requested) and
   #     language dependent syntax highlighting (if requested).  If
   #     neither numbering or language dependent syntax highlighting
   #     are requested, then a simple `verbatim' environment will be
   #     used to list the contents.
   #
   #     Elements:
   #
   #       numbers -- none, right, or left.
   #
   #       name -- Name of a listing.  Listings that share the same
   #       name share the same counter.  Therefore lines in the second
   #       listing with the same name will have line numbering that
   #       picks up where the first listing left off.
   #
   #       language -- Any language accepted by the LaTeX `listings'
   #       package.
   #
   #       file -- relative path and filename of file containing
   #       listing contents.
   #
   #       firstline -- an integer number on which to start displaying
   #       content from the listing.  If you've got a long file and
   #       only wish to list lines 100 - 200, set firstline to 100.
   #
   #       lastline -- an integer number on which to end displaying
   #       content from the listing.  If you've got a long file and
   #       only wish to list lines 100 - 200, set lastline to 200.
   #
   #       showspaces -- true or false: represent individual spaces in
   #       the listing as little underscore-like characters (only in
   #       PDF)
   #
   #       showtabs -- true or false: represent individual spaces in
   #       the listing as little underscore-like characters (only in
   #       PDF)
   #
   #       showstringspaces -- true or false.  If true, spaces within
   #       strings will be indicated by a little underline-like space
   #       indicator.
   #
   #       fontsize -- from smallest to largest: tiny, scriptsize,
   #       footnotesize, small, normalsize, large, Large, LARGE, huge,
   #       Huge (implemented via the listings package `basicstyle'
   #       directive) I intend to add a default `auto' option which
   #       will automatically calculate the correct fontsize based on
   #       the widest line (number of characters) in the listing.
   #
   #       stepnumber -- number of lines between numbered lines
   #       (i.e. if stepnumber is 10, put a line number every 10
   #       lines).
   #
   #       float -- true or false.  If true, render the listing as a
   #       float. (not yet implemented)
   #
   #     Examples:
   #
   #       ---listing
   #       title:       Example Listing
   #       label:       lis-example
   #       file:        files/example.txt
   #       ---listing
   #
   #       ---listing
   #       title:             Example Listing
   #       label:             lis-example
   #       file:              files/example.txt
   #       language:          Python
   #       numbers:           left
   #       firstline:         100
   #       lastline:          200
   #       showstringspaces:  false
   #       fontsize:          small
   #       ---listing
   #
   listing =>
   {
    name                => 'Listing',
    plural_name         => 'Listings',
    type                => 'environment',
    ignorable           => 'no',
    elements            =>
    {
     title              => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     numbers            => { multivalued => 0 },
     name               => { multivalued => 0 },
     language           => { multivalued => 0 },
     firstline          => { multivalued => 0 },
     lastline           => { multivalued => 0 },
     showspaces         => { multivalued => 0 },
     showtabs           => { multivalued => 0 },
     showstringspaces   => { multivalued => 0 },
     fontsize           => { multivalued => 0 },
     stepnumber         => { multivalued => 0 },
     float              => { multivalued => 0 },
     file               => { multivalued => 0 },
     orientation        => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # preformatted environment
   #
   #     Example:
   #
   #       ---preformatted
   #
   #       This
   #         is
   #           some
   #             preformatted
   #               text...
   #
   #       ---preformatted
   #
   preformatted  =>
   {
    name                => 'Preformatted',
    plural_name         => 'Preformatted',
    type                => 'environment',
    ignorable           => 'no',
    elements            =>
    {
     title              => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     file               => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # sidebar environment
   #
   #   ---sidebar
   #   title: Burrito Threat
   #   label: side-burrito-threat
   #   author: Don Johnson
   #
   #   New Orleans is in danger of being swallowed by a giant burrito
   #   creature from the planet Chipotle.
   #
   #   ---sidebar
   #
   #
   sidebar =>
   {
    name                => 'Sidebar',
    plural_name         => 'Sidebars',
    type                => 'environment',
    ignorable           => 'no',
    elements            =>
    {
     title              => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     author             => { multivalued => 0 },
     file               => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # source environment
   #
   #   A source environment can serve the dual purposes of (1)
   #   establishing a citable bibliography entry, and (2) attaching a
   #   file to the published document.
   #
   #   Example:
   #
   #   ---source
   #
   #   source: misc
   #
   #   label: nist-800-53-r3
   #
   #   title: National Institute of Standards and Technology (NIST) Special
   #   Publication 800-53 Revision 3, Recommended Security Controls for
   #   Federal Information Systems. [FINAL PUBLIC DRAFT]
   #
   #   month: June
   #
   #   year: 2009
   #
   #   file: files/security/800-53-rev3-FPD-clean.pdf
   #
   #   description: The purpose of this publication is to provide guidelines
   #   for selecting and specifying security controls for information systems
   #   supporting the executive agencies of the federal government. This
   #   includes guidelines for meeting the requirements of FIPS 200, Minimum
   #   Security Requirements for Federal Information and Information
   #   Systems. The guidelines apply to all components of an information
   #   system that process, store, or transmit federal information.
   #
   #   # [#v:files/security/800-53-rev3-FPD-clean.pdf:386]
   #
   #   ---source
   #
   source =>
   {
    name                => 'Source',
    plural_name         => 'Sources',
    type                => 'environment',
    ignorable           => 'no',
    elements            =>
    {
     title              => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     address            => { multivalued => 0 },
     annote             => { multivalued => 0 },
     author             => { multivalued => 1 },
     booktitle          => { multivalued => 0 },
     chapter            => { multivalued => 0 },
     crossref           => { multivalued => 0 },
     edition            => { multivalued => 0 },
     editor             => { multivalued => 1 },
     howpublished       => { multivalued => 0 },
     institution        => { multivalued => 0 },
     journal            => { multivalued => 0 },
     key                => { multivalued => 0 },
     month              => { multivalued => 0 },
     note               => { multivalued => 0 },
     number             => { multivalued => 0 },
     organization       => { multivalued => 0 },
     pages              => { multivalued => 0 },
     publisher          => { multivalued => 0 },
     school             => { multivalued => 0 },
     series             => { multivalued => 0 },
     source             => { multivalued => 0 },
     subtitle           => { multivalued => 0 },
     type               => { multivalued => 0 },
     volume             => { multivalued => 0 },
     year               => { multivalued => 0 },

     appearance         => { multivalued => 0 },
     color              => { multivalued => 0 },
     date               => { multivalued => 0 },
     icon               => { multivalued => 0 },
     mimetype           => { multivalued => 0 },
     file               => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # table environment
   #
   #     Example:
   #
   #     ---table
   #
   #     title: A Sample Table
   #     label: tab-sample
   #
   #     :: heading of column 1
   #     :: heading of column 2
   #     ---
   #     : row 1 column 1
   #     : row 1 column 2
   #     ---
   #     : row 2 column 1
   #     : row 2 column 2
   #
   #     ---table
   #
   table =>
   {
    name                => 'Table',
    plural_name         => 'Tables',
    type                => 'environment',
    ignorable           => 'no',
    elements            =>
    {
     title              => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     width              => { multivalued => 0 },
     fontsize           => { multivalued => 0 },
     table              => { multivalued => 0 },
     column             => { multivalued => 0 },
     orientation        => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # audio environment
   #
   audio =>
   {
    name                => 'Audio Clip',
    plural_name         => 'Audio Clips',
    type                => 'environment',
    ignorable           => 'yes',
    elements            =>
    {
     title              => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     author             => { multivalued => 1 },
     duration           => { multivalued => 0 },
     file               => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # video environment
   #
   video =>
   {
    name                => 'Video Clip',
    plural_name         => 'Video Clips',
    type                => 'environment',
    ignorable           => 'yes',
    elements            =>
    {
     title              => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     author             => { multivalued => 0 },
     duration           => { multivalued => 0 },
     file               => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # assertion environment
   #
   assertion =>
   {
    name                => 'Assertion',
    plural_name         => 'Assertions',
    type                => 'environment',
    ignorable           => 'yes',
    elements            =>
    {
     title              => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     author             => { multivalued => 1 },
     revision           => { multivalued => 0 },
     date               => { multivalued => 0 },
     type               => { multivalued => 1 },
     copyright          => { multivalued => 0 },
     subject            => { multivalued => 0 },
     predicate          => { multivalued => 0 },
     object             => { multivalued => 0 },
     attr               => { multivalued => 1 },
     narrative          => { multivalued => 0 },
    },
   },

   ###################################################################
   ###################################################################
   ###################################################################
   ###
   ### REGIONS (elements of content, can contain environments)
   ###
   ###################################################################
   ###################################################################
   ###################################################################

   #------------------------------------------------------------------
   # RESOURCES region
   #
   RESOURCES =>
   {
    name                => 'RESOURCES',
    type                => 'region',
    ignorable           => 'yes',
    elements            =>
    {
    },
   },

   #------------------------------------------------------------------
   # demo region
   #
   demo =>
   {
    name                => 'Demonstration',
    plural_name         => 'Demonstrations',
    type                => 'region',
    ignorable           => 'yes',
    elements            =>
    {
     title              => { multivalued => 0 },
     revision           => { multivalued => 0 },
     date               => { multivalued => 0 },
     author             => { multivalued => 1 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     type               => { multivalued => 1 },
     duration           => { multivalued => 0 },
     copyright          => { multivalued => 0 },
     associated         => { multivalued => 1 },
     attr               => { multivalued => 1 },
     narrative          => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # exercise region
   #
   exercise =>
   {
    name                => 'Exercise',
    plural_name         => 'Exercises',
    type                => 'region',
    ignorable           => 'yes',
    elements            =>
    {
     title              => { multivalued => 0 },
     revision           => { multivalued => 0 },
     date               => { multivalued => 0 },
     author             => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     type               => { multivalued => 1 },
     duration           => { multivalued => 0 },
     copyright          => { multivalued => 0 },
     associated         => { multivalued => 1 },
     attr               => { multivalued => 1 },
     narrative          => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # keypoints region
   #
   keypoints =>
   {
    name                => 'Key Points',
    plural_name         => 'Key Points',
    type                => 'region',
    ignorable           => 'yes',
    elements            =>
    {
     title              => { multivalued => 0 },
     revision           => { multivalued => 0 },
     date               => { multivalued => 0 },
     author             => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     type               => { multivalued => 1 },
     associated         => { multivalued => 1 },
     attr               => { multivalued => 1 },
     narrative          => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # quotation region
   #
   quotation =>
   {
    name                => 'Quotation',
    plural_name         => 'Quotations',
    type                => 'region',
    ignorable           => 'no',
    elements            =>
    {
     title              => { multivalued => 0 },
     revision           => { multivalued => 0 },
     date               => { multivalued => 0 },
     author             => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     type               => { multivalued => 1 },
     source             => { multivalued => 0 },
     associated         => { multivalued => 1 },
     attr               => { multivalued => 1 },
     narrative          => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # problem region
   #
   problem =>
   {
    name                => 'Problem',
    plural_name         => 'Problems',
    type                => 'region',
    ignorable           => 'yes',
    elements            =>
    {
     title              => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     owner              => { multivalued => 0 },
     assignee           => { multivalued => 1 },
     stakeholder        => { multivalued => 1 },
     validator          => { multivalued => 0 },
     type               => { multivalued => 1 },
     next               => { multivalued => 1 },
     previous           => { multivalued => 1 },
     priority           => { multivalued => 0 },
     directs            => { multivalued => 1 },
     directed_by        => { multivalued => 1 },
     uses               => { multivalued => 1 },
     used_by            => { multivalued => 1 },
     extends            => { multivalued => 0 },
     extended_by        => { multivalued => 1 },
     realizes           => { multivalued => 1 },
     realized_by        => { multivalued => 1 },
     derived            => { multivalued => 1 },
     derived_from       => { multivalued => 1 },
     class_of           => { multivalued => 1 },
     instance_of        => { multivalued => 1 },
     solution           => { multivalued => 1 },
     allocation         => { multivalued => 1 },
     assignment         => { multivalued => 1 },
     generalizes        => { multivalued => 1 },
     specializes        => { multivalued => 1 },
     test               => { multivalued => 1 },
     effort             => { multivalued => 1 },
     status             => { multivalued => 0 },
     task               => { multivalued => 1 },
     associated         => { multivalued => 1 },
     request            => { multivalued => 1 },
     attr               => { multivalued => 1 },
     parent             => { multivalued => 0 },
     child              => { multivalued => 1 },
     copyright          => { multivalued => 0 },
     revision           => { multivalued => 0 },
     date               => { multivalued => 0 },
     author             => { multivalued => 0 },
     narrative          => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # slide region
   #
   slide =>
   {
    name                => 'Slide',
    plural_name         => 'Slides',
    type                => 'region',
    ignorable           => 'yes',
    elements            =>
    {
     title              => { multivalued => 0 },
     revision           => { multivalued => 0 },
     date               => { multivalued => 0 },
     author             => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     type               => { multivalued => 1 },
     duration           => { multivalued => 0 },
     copyright          => { multivalued => 0 },
     associated         => { multivalued => 1 },
     attr               => { multivalued => 1 },
     narrative          => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # solution region
   #
   solution =>
   {
    name                => 'Solution',
    plural_name         => 'Solutions',
    type                => 'region',
    ignorable           => 'yes',
    elements            =>
    {
     title              => { multivalued => 0 },
     revision           => { multivalued => 0 },
     date               => { multivalued => 0 },
     author             => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     type               => { multivalued => 1 },
     owner              => { multivalued => 0 },
     assignee           => { multivalued => 1 },
     stakeholder        => { multivalued => 1 },
     next               => { multivalued => 1 },
     previous           => { multivalued => 1 },
     priority           => { multivalued => 0 },
     directed_by        => { multivalued => 1 },
     uses               => { multivalued => 1 },
     used_by            => { multivalued => 1 },
     required_by        => { multivalued => 1 },
     depends_on         => { multivalued => 1 },
     instance_of        => { multivalued => 1 },
     class_of           => { multivalued => 1 },
     realizes           => { multivalued => 1 },
     realized_by        => { multivalued => 1 },
     version            => { multivalued => 0 },
     license            => { multivalued => 0 },
     cost               => { multivalued => 0 },
     pro                => { multivalued => 1 },
     con                => { multivalued => 1 },
     problem            => { multivalued => 1 },
     allocation         => { multivalued => 1 },
     assignment         => { multivalued => 1 },
     generalizes        => { multivalued => 1 },
     specializes        => { multivalued => 1 },
     test               => { multivalued => 1 },
     status             => { multivalued => 0 },
     task               => { multivalued => 1 },
     associated         => { multivalued => 1 },
     request            => { multivalued => 1 },
     attr               => { multivalued => 1 },
     parent             => { multivalued => 0 },
     child              => { multivalued => 1 },
     copyright          => { multivalued => 0 },
     narrative          => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # allocation region
   #
   allocation =>
   {
    name                => 'Allocation',
    plural_name         => 'Allocations',
    type                => 'region',
    ignorable           => 'yes',
    elements            =>
    {
     title              => { multivalued => 0 },
     revision           => { multivalued => 0 },
     date               => { multivalued => 0 },
     author             => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     type               => { multivalued => 1 },
     owner              => { multivalued => 0 },
     assignee           => { multivalued => 1 },
     stakeholder        => { multivalued => 1 },
     directed_by        => { multivalued => 1 },

     priority           => { multivalued => 0 },
     status             => { multivalued => 0 },

     problem            => { multivalued => 0 },
     solution           => { multivalued => 0 },
     test               => { multivalued => 1 },

     release            => { multivalued => 0 },
     rel_component      => { multivalued => 0 },

     associated         => { multivalued => 1 },
     request            => { multivalued => 1 },
     attr               => { multivalued => 1 },
     parent             => { multivalued => 0 },
     child              => { multivalued => 1 },
     narrative          => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # assignment region
   #
   assignment =>
   {
    name                => 'Assignment',
    plural_name         => 'Assignments',
    type                => 'region',
    ignorable           => 'yes',
    elements            =>
    {
     title              => { multivalued => 0 },
     revision           => { multivalued => 0 },
     date               => { multivalued => 0 },
     author             => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     type               => { multivalued => 1 },
     owner              => { multivalued => 0 },
     assignee           => { multivalued => 1 },
     stakeholder        => { multivalued => 1 },
     directed_by        => { multivalued => 1 },

     priority           => { multivalued => 0 },
     status             => { multivalued => 0 },

     problem            => { multivalued => 0 },
     role               => { multivalued => 0 },
     test               => { multivalued => 1 },

     release            => { multivalued => 0 },
     rel_component      => { multivalued => 0 },

     associated         => { multivalued => 1 },
     request            => { multivalued => 1 },
     attr               => { multivalued => 1 },
     parent             => { multivalued => 0 },
     child              => { multivalued => 1 },
     narrative          => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # test region
   #
   #     A test region describes a test.  These tests are specially
   #     designed to have one of the following results: N/A, 0, 1, 2,
   #     3, 4 and 5.
   #
   test =>
   {
    name                => 'Test',
    plural_name         => 'Tests',
    type                => 'region',
    ignorable           => 'yes',
    elements            =>
    {
     title              => { multivalued => 0 },
     revision           => { multivalued => 0 },
     date               => { multivalued => 0 },
     author             => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     type               => { multivalued => 1 },
     priority           => { multivalued => 0 },
     status             => { multivalued => 0 },
     parent             => { multivalued => 0 },
     problem            => { multivalued => 1 },
     solution           => { multivalued => 1 },
     allocation         => { multivalued => 1 },
     assignment         => { multivalued => 1 },
     depends_on         => { multivalued => 1 },
     required_by        => { multivalued => 1 },
     instance_of        => { multivalued => 1 },
     class_of           => { multivalued => 1 },
     directed_by        => { multivalued => 1 },
     request            => { multivalued => 1 },
     script             => { multivalued => 1 },
     tester             => { multivalued => 0 },
     owner              => { multivalued => 0 },
     validator          => { multivalued => 0 },
     copyright          => { multivalued => 0 },
     level              => { multivalued => 1 },
     question           => { multivalued => 1 },
     associated         => { multivalued => 1 },
     attr               => { multivalued => 1 },
     next               => { multivalued => 1 },
     previous           => { multivalued => 1 },
     narrative          => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # task region
   #
   task =>
   {
    name                => 'Task',
    plural_name         => 'Tasks',
    type                => 'region',
    ignorable           => 'yes',
    elements            =>
    {
     title              => { multivalued => 0 },
     revision           => { multivalued => 0 },
     date               => { multivalued => 0 },
     author             => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     type               => { multivalued => 1 },
     parent             => { multivalued => 0 },
     problem            => { multivalued => 1 },
     solution           => { multivalued => 1 },
     test               => { multivalued => 1 },
     depends_on         => { multivalued => 1 },
     required_by        => { multivalued => 1 },
     instance_of        => { multivalued => 1 },
     class_of           => { multivalued => 1 },
     directed_by        => { multivalued => 1 },
     product            => { multivalued => 0 },
     deadline           => { multivalued => 0 },
     priority           => { multivalued => 0 },
     status             => { multivalued => 0 },
     owner              => { multivalued => 0 },
     copyright          => { multivalued => 0 },
     associated         => { multivalued => 1 },
     attr               => { multivalued => 1 },
     next               => { multivalued => 1 },
     previous           => { multivalued => 1 },
     narrative          => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # result region
   #
   #     A result region describes the outcome of a test (including
   #     the answers to each test question).
   #
   result =>
   {
    name                => 'Result',
    plural_name         => 'Results',
    type                => 'region',
    ignorable           => 'yes',
    elements            =>
    {
     title              => { multivalued => 0 },
     revision           => { multivalued => 0 },
     date               => { multivalued => 0 },
     author             => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     type               => { multivalued => 1 },
     parent             => { multivalued => 0 },
     problem            => { multivalued => 1 },
     solution           => { multivalued => 1 },
     allocation         => { multivalued => 1 },
     assignment         => { multivalued => 1 },
     result             => { multivalued => 1 },
     test               => { multivalued => 1 },
     task               => { multivalued => 1 },
     associated         => { multivalued => 1 },
     priority           => { multivalued => 0 },
     status             => { multivalued => 0 },
     attr               => { multivalued => 1 },
     next               => { multivalued => 1 },
     previous           => { multivalued => 1 },
     narrative          => { multivalued => 0 },
    },
   },

   #------------------------------------------------------------------
   # role region
   #
   role =>
   {
    name                => 'Role',
    plural_name         => 'Roles',
    type                => 'region',
    ignorable           => 'yes',
    elements            =>
    {
     title              => { multivalued => 0 },
     revision           => { multivalued => 0 },
     date               => { multivalued => 0 },
     author             => { multivalued => 0 },
     id                 => { multivalued => 0 },
     label              => { multivalued => 0 },
     description        => { multivalued => 0 },
     order              => { multivalued => 0 },
     priority           => { multivalued => 0 },
     status             => { multivalued => 0 },
     parent             => { multivalued => 0 },
     assignment         => { multivalued => 1 },
     problem            => { multivalued => 1 },
     test               => { multivalued => 1 },
     stakeholder        => { multivalued => 1 },
     request            => { multivalued => 1 },
     type               => { multivalued => 1 },
     depends_on         => { multivalued => 1 },
     required_by        => { multivalued => 1 },
     instance_of        => { multivalued => 1 },
     class_of           => { multivalued => 1 },
     directed_by        => { multivalued => 1 },
     associated         => { multivalued => 1 },
     attr               => { multivalued => 1 },
     narrative          => { multivalued => 0 },
    },
   },

  );

#---------------------------------------------------------------------
# 'DEFINE' DATASTRUCTURE
#
#     The purpose of the %define hash is to remember 'define:'
#     strings.  These declare which regions of conditional text should
#     be included in the document.
#
my %define = ();

#---------------------------------------------------------------------
# 'FILES' DATASTRUCTURE
#
#    The purpose of the %files hash is to remember information about
#    files that compose a document (including the actual content of
#    the files themselves).  The main document file can refer to
#    external files in the following ways:
#
#      - INCLUDE: The "include" mechanism allows authors to modularize
#      document content by storing different parts of an SML document
#      in different files then "include" the content of one file
#      inside another.
#
#      - FILE: The "file" mechanism is used to "attach" a file to the
#      document being published.  In the case of HTML, the "attached"
#      file is placed in a "files" subdirectory and can be viewed by
#      clicking a hyperlink in the published document.
#
#    The %files hash stores the actual content of the files and
#    remembers whether the content of each file has been modified by
#    the program:
#
#      $files{'Solutions/ci-000001.txt'}{'content'}  = [];
#      $files{'Solutions/ci-000001.txt'}{'modified'} = 0;
#
#    NOTE: this hash MUST NOT be re-initialized by the init()
#    subroutine.
#
#    The lines of files are read into the %files data structure by the
#    resolve_includes() subroutine which is recursively called to read
#    all file data into memory.
#
my %files = ();

#---------------------------------------------------------------------
# 'SVNINFO' DATASTRUCTURE
#
#    The purpose of the %svninfo hash is to remember subversion (SVN)
#    revision control information about files that make up the
#    document.
#
#    This program is SVN aware.  SVN tracks certain meta-data about
#    files under version control.  The %files hash stores that
#    meta-data for use by the program:
#
#    $svninfo{'Solutions/ci-000001.txt'}{'version'}  = 22;
#    $svninfo{'Solutions/ci-000001.txt'}{'author'}   = 'don.johnson';
#    $svninfo{'Solutions/ci-000001.txt'}{'date'}     = '2008-07-10';
#    $svninfo{'Solutions/ci-000001.txt'}{'modified'} = 1;
#    $svninfo{'Solutions/ci-000001.txt'}{'days_old'} = 26;
#
#    NOTE: The 'modified' value represents whether the file contains
#    uncommitted changes.  DON'T confuse this 'modified' with the
#    %files data structure 'modified' that represents whether the
#    PUBLISH program has modified the file.
#
my %svninfo = ();

my %days_old = ();

#---------------------------------------------------------------------
# 'OUTCOMES' DATASTRUCTURE
#
#     The outcomes datastructure stores the status values (green,
#     yellow, red, or grey) of items (problems, solutions, tests,
#     tasks) determined via formal test or audit.
#
#     $outcomes{'rq-000001'}{'2009-06-01'}{'status'}      = green
#     $outcomes{'rq-000001'}{'2009-06-01'}{'description'} = blah blah...
#     $outcomes{'rq-000001'}{'2009-06-01'}{'source'}      = qr-000001
#
my %outcomes = ();

#---------------------------------------------------------------------
# 'REVIEWS' DATASTRUCTURE
#
#     The reviews datastructure stores review information about
#     document content.  Each "review" is a short paragraph traceable
#     to a label and a date.
#
#     $reviews{'rq-000001'}{'2009-06-01'}{'status'}      = green
#     $reviews{'rq-000001'}{'2009-06-01'}{'description'} = blah blah...
#     $reviews{'rq-000001'}{'2009-06-01'}{'source'}      = qr-000001
#
my %reviews = ();

#---------------------------------------------------------------------
# 'DATA' DATASTRUCTURE
#
#     The 'data' data structure is used to gather all data elements
#     during pass 2.  During pass 2, data elements are gathered into
#     the 'data' datastructure.
#
#     In a document, structured data (i.e. titles, labels,
#     descriptions, etc.) is typically arranged in environments and
#     regions. Special data elements, however, those I consider
#     'universal' can appear anywhere in the document.
#
#     Each environment and region is simply assigned a number as the
#     parser discovers them in the document.  The title of a region
#     would be stored according to region type and number.  For
#     instance:
#
#       $data{$region}{$num}{'title'} = 'My Title';
#
#     The title of the 23rd table in the document would be stored in:
#
#       $data{'table'}{'23'}{'title'}
#
#     The name of the current region is always stored in
#     $current{'name'}, and the number of the current region is
#     always stored in $count{$region}{'total'}.
#
#     All data elements are stored in the 'data' data structure.  For
#     instance, all data for the first problem found in a document
#     might look something like this:
#
#       $data{'problem'}{'1'}{'title'}       = 'My Title';
#       $data{'problem'}{'1'}{'label'}       = 'req-2004-11-21-001';
#       $data{'problem'}{'1'}{'parent'}      = 'req-2004-11-12-001';
#       $data{'problem'}{'1'}{'type'}        = 'functional';
#       $data{'problem'}{'1'}{'priority'}    = 'critical';
#       $data{'problem'}{'1'}{'status'}      = 'yellow';
#       $data{'problem'}{'1'}{'stakeholder'} = 'Don Johnson';
#       $data{'problem'}{'1'}{'owner'}       = 'Don Johnson';
#       $data{'problem'}{'1'}{'author'}      = 'Don Johnson';
#       $data{'problem'}{'1'}{'validator'}   = 'Don Johnson';
#       $data{'problem'}{'1'}{'solution'}    = 'sol-2004-11-21-001';
#       $data{'problem'}{'1'}{'solution'}    = 'sol-2004-11-21-002';
#       $data{'problem'}{'1'}{'solution'}    = 'sol-2004-11-21-003';
#       $data{'problem'}{'1'}{'test'}        = 'test-2004-11-21-001';
#       $data{'problem'}{'1'}{'description'} = 'the description...';
#
my %data = ();

#---------------------------------------------------------------------
# 'CSVDATA' DATASTRUCTURE
#
#    The 'csvdata' data structure is used to gather all data elements
#    from CSV files.  CSV files are structured so that column 1 values
#    are 'keys' and row 1 values are 'names'.  Thus, data can later be
#    looked up using key/name pairs.
#
my $csvdata = {};

#---------------------------------------------------------------------
# 'LOOKUP' DATASTRUCTURE
#
#    After all the data is gathered into the 'data' datastructure in
#    pass 2, it is RE-FACTORED into the 'lookup' datastructure.  This
#    allows all the data to be looked up using labels.
#
#    In the 'lookup' datastructure, data is organized by label instead
#    of by number.  This makes it easier to lookup the data elements
#    during rendering in pass 3.  So, for instance, the 'problem' data
#    shown above in the 'data' datastructure would be stored this way
#    in the 'lookup' datastructure:
#
#    $lookup{'req-2004-11-21-001'}{'title'}       = 'My Title';
#    $lookup{'req-2004-11-21-001'}{'label'}       = 'req-2004-11-21-001';
#    $lookup{'req-2004-11-21-001'}{'parent'}      = 'req-2004-11-12-001';
#    $lookup{'req-2004-11-21-001'}{'type'}        = 'functional';
#    $lookup{'req-2004-11-21-001'}{'priority'}    = 'critical';
#    $lookup{'req-2004-11-21-001'}{'status'}      = 'yellow';
#    $lookup{'req-2004-11-21-001'}{'stakeholder'} = 'Don Johnson';
#    $lookup{'req-2004-11-21-001'}{'owner'}       = 'Don Johnson';
#    $lookup{'req-2004-11-21-001'}{'author'}      = 'Don Johnson';
#    $lookup{'req-2004-11-21-001'}{'validator'}   = 'Don Johnson';
#    $lookup{'req-2004-11-21-001'}{'solution'}    = 'sol-2004-11-21-001';
#    $lookup{'req-2004-11-21-001'}{'solution'}    = 'sol-2004-11-21-002';
#    $lookup{'req-2004-11-21-001'}{'solution'}    = 'sol-2004-11-21-003';
#    $lookup{'req-2004-11-21-001'}{'test'}        = 'test-2004-11-21-001';
#    $lookup{'req-2004-11-21-001'}{'description'} = 'the description...';
#
my %lookup = ();

#---------------------------------------------------------------------
# 'ATTRIBUTE' DATASTRUCTURE
#
#   The attribute datastructure contains all key/value pair
#   information from the 'attr' data elements and makes it searchable
#   by label:
#
#   $attribute{'ci-000078'}{'CPU'}    = ['i386','i686'];
#   $attribute{'ci-000078'}{'memory'} = ['1024 MB'];
#
my %attribute = ();

#---------------------------------------------------------------------
# 'SPECIALS' DATASTRUCTURE
#
#     The 'specials' data structure is used to remember which sections
#     contain any of the following 10 'special' items:
#
#       1. listings
#       2. slides
#       3. exercises
#       4. demonstrations
#       5. problems
#       6. solutions
#       7. tests
#       8. tasks
#       9. results
#      10. roles
#
#     Why do we need to know which sections contain any of these
#     special items?  Because for each of them we create a listing in
#     the frontmatter of the document and I'd like to include section
#     headings in those listings.  To do so I need to know which
#     sections contain which specials.
#
my %specials = ();

#---------------------------------------------------------------------
# 'ITERATOR' DATASTRUCTURE
#
#      The 'iterator' data structure is used to gather data about
#      iterated blocks such as iterated includes like this:
#
#        ...include
#        file: incl/my-template.txt
#        1:var: item = rq-001
#        2:var: item = rq-002
#        3:var: item = rq-003
#        ...include
#
#       $iterator{'include'}{'file'}   = 'incl/my-template.txt';
#       $iterator{'include'}{1}{'var'} = [{item,rq-001}];
#       $iterator{'include'}{2}{'var'} = [{item,rq-002}];
#       $iterator{'include'}{3}{'var'} = [{item,rq-003}];
#
#     After the iterator data is fully gathered, the iterations can be
#     expanded like this:
#
#       ---include
#       file: incl/my-template.txt
#       var: item=rq-001
#       ---include
#
#       ---include
#       file: incl/my-template.txt
#       var: item=rq-002
#       ---include
#
#       ---include
#       file: incl/my-template.txt
#       var: item=rq-003
#       ---include
#
#     The %iterator datastructure gathers information for only one set
#     of iterations at a time, it is not designed to remember data
#     about multiple iterators in the same document.  Therefore, it
#     should be initialized after the iterations are expanded to
#     prepare for the next set of iterations.
#
my %iterator = ();

#---------------------------------------------------------------------
# 'GLOSSARY' DATASTRUCTURE
#
#     The 'glossary' datastructure holds glossary entries.
#
my %glossary = ();

#---------------------------------------------------------------------
# 'CHANGELOG' DATASTRUCTURE
#
#     The 'changelog' datastructure holds changelog entries by
#     revision number.
#
my %changelog = ();

#---------------------------------------------------------------------
# SPECIAL ENVIRONMENTS AND REGIONS
#
#     "Special" environments and regions are those that can be listed
#     in the frontmatter of the published document.
#
my @specials = (
		'listing',
		'slide',
		'exercise',
		'demo',
		'problem',
		'solution',
# 		'allocation',
# 		'assignment',
		'test',
		'task',
		'result',
		'role',
               );

#---------------------------------------------------------------------
# TLAs FOR SPECIALS
#
#     TLA is a three letter acronym that stands for "three letter
#     acronym" :-) -- each "special" region or environment that can
#     have a listing in the frontmatter of the PDF rendition creates
#     that listing using a special file that ends with these
#     three-letter file extensions.
#
my %tla_for = (
               'listing'    => 'lis',
               'slide'      => 'sld',
               'exercise'   => 'exr',
               'demo'       => 'dem',

               'problem'    => 'req',
               'solution'   => 'sol',
               'allocation' => 'alo',
               'assignment' => 'asn',
               'test'       => 'tst',
               'task'       => 'tsk',
               'result'     => 'res',
               'role'       => 'rol',

              );

#---------------------------------------------------------------------
# 'CURRENT' DATASTRUCTURE
#
#    Define variables that indicate the state of parsing.  There are
#    several state variables we need to track as we parse a document.
#    These are maintained in the 'current' datastructure.
#
#    A separate stack is used to track the current label.  This is
#    necessary because the 'current label' changes as the parser moves
#    in and out of environments and regions.  Consider, for instance
#    the following structured text that illustrates a table within an
#    exercise within a section:
#
#      * Example Section
#
#      label: example-section
#
#      This is a simple paragraph inside the 'Example Section'
#      section.  The current label is 'example-section' because we are
#      in that section.  Now we're about to enter an 'exercise'
#      region, however, and the label will change to something
#      different.
#
#      >>>exercise
#
#      title: Example Exercise
#
#      label: example-exercise
#
#      This text is within an exercise region.  The current label is
#      'example-exercise' and will remain the current label until the
#      exercise region ends.  Once the exercise region ends, the
#      current label should revert back to what it was before the
#      exercise started.
#
#      ---table
#
#      title: Table Within Example Exercise
#
#      label: example-table
#
#      :: column 1 heading
#      :: column 2 heading
#      ---
#      : row 1 col 1
#      : row 1 col 2
#      ---
#      : row 2 col 1
#      : row 2 col 2
#
#      ---table
#
#      That was a table inside the exercise.  Inside the table, the
#      current label was 'example-table' -- now the current label has
#      reverted back to 'example-exercise.
#
#      <<<exercise
#
#      Now the exercise has ended and the current label has reverted
#      back to 'example-section.'  A stack is needed to push and pop
#      the value of current label.
#
#    Because they can be nested, stacks are needed to track the
#    current value of:
#
#      - label
#      - file
#      - section type
#      - title
#      - section number
#
my %current = (

    label          => $EMPTY_STRING,
    title          => $EMPTY_STRING,
    sectype        => 'section',
    secnum         => 0,
    file           => $EMPTY_STRING,

    heading        => $EMPTY_STRING,
    top_heading    => $EMPTY_STRING,

    file_stack     => [],
    title_stack    => [],
    label_stack    => [],
    sectype_stack  => [],
    secnum_stack   => [],
    cond_stack     => [],

    line           => $EMPTY_STRING,
    name           => $EMPTY_STRING,
    type           => $EMPTY_STRING,
    topnum         => $EMPTY_STRING,
    number         => $EMPTY_STRING,
    initial_indent => $EMPTY_STRING,

    glossary_term  => $EMPTY_STRING,
    acronym        => $EMPTY_STRING,

    column         => 0,
    depth          => 1,

    ulist_indent   => 0,
    ulist_depth    => 0,
    olist_indent   => 0,
    olist_depth    => 0,

    header_left        => $EMPTY_STRING,
    header_left_even   => $EMPTY_STRING,
    header_left_odd    => $EMPTY_STRING,

    header_center      => $EMPTY_STRING,
    header_center_even => $EMPTY_STRING,
    header_center_odd  => $EMPTY_STRING,

    header_right       => $EMPTY_STRING,
    header_right_even  => $EMPTY_STRING,
    header_right_odd   => $EMPTY_STRING,

    footer_left        => $EMPTY_STRING,
    footer_left_even   => $EMPTY_STRING,
    footer_left_odd    => $EMPTY_STRING,

    footer_center      => $EMPTY_STRING,
    footer_center_even => $EMPTY_STRING,
    footer_center_odd  => $EMPTY_STRING,

    footer_right       => $EMPTY_STRING,
    footer_right_even  => $EMPTY_STRING,
    footer_right_odd   => $EMPTY_STRING,
);

#---------------------------------------------------------------------
# 'STATUS' DATASTRUCTURE
#
#    When the document calls for "formal" status of items, that is,
#    status can only come from result outcomes, then status is either
#    (1) determined by finding the most recent result outcome, or (2)
#    computed by rolling up the status of children items.
#
#    This computation is performed by the "status_of" subroutine.
#    This is an expensive computation.  The purpose of this status
#    datastructure is to remember (memoize) the results of that
#    computation so it only has to be performed a minimum number of
#    times.
#
#    $status{$label}{'status'} = 'green';
#    $status{$label}{'source'} = 'qr-000001';
#    $status{$label}{'date'}   = '2009-06-17';
#
my %status = ();

#---------------------------------------------------------------------
# 'SECTION' DATASTRUCTURE
#
#    The %section datastructure remembers section numbers and the
#    order in which they occur.
#
#    $section{$secnum}{'previous'};  = '2.1.13';
#    $section{$secnum}{'next'};      = '2.1.15';
#    $section{$secnum}{'depth'};     = '3';
#    $section{$secnum}{'type'};      = 'Chapter';
#    $section{$secnum}{'label'};     = 'my-section';
#
my %section = ();

#---------------------------------------------------------------------
# PARSER STATE VARIABLES
#
#    Define counters and various other variables.  Some of these need
#    to go away.  I think I might be able to reduce the number of
#    parser state variables by consolidating them into the 'current'
#    hash.
#
#    The only catch is that some of these may need their own lexical
#    namespace during recursion.  Using a global hash breaks these
#    local lexicals.
#
#    !!! Bug Here !!!
#
#    All variables in this block should probably be re-factored into
#    the %current data-structure since they represent the parser state
#    during passes two and three.
#
my %count                   = (); # count hash
my %ulist_indent_for        = (); # key: depth, value: number of spaces
my %olist_indent_for        = (); # key: depth, value: number of spaces
my %scounter                = (); # Section counter hash
my %dcounter                = (); # Section counter hash (for display)
my $nesting_level           = 0;
my @nesting_stack           = ();
my %seen_title              = ();
my %env_type                = ();
my %env_marker              = ();
my $region_baton            = $EMPTY_STRING;
my %region_marker           = ();
my %begin_region            = ();
my %end_region              = ();
my $textfile                = $EMPTY_STRING;
my @current_line            = 0;
my %current_table           = ();   # information about the current table
my $current_source_key;

#---------------------------------------------------------------------
# 'PREVIOUS' DATASTRUCTURE
#
#     Currently, this is only used to remember the previous section
#     depth.
#
my %previous = (

    depth          => 1,

);

#---------------------------------------------------------------------
# 'DOCUMENT' DATASTRUCTURE
#
#     The 'document' datastructure holds meta-data about the overall
#     document.  It gets populated by pass two parsing.
#
my %document = (

  title              => $EMPTY_STRING,
  subtitle           => $EMPTY_STRING,
  author             => [],
  editor             => [],
  date               => $EMPTY_STRING,
  revision           => $EMPTY_STRING,
  doctype            => $EMPTY_STRING,
  copyright          => $EMPTY_STRING,
  organization       => $EMPTY_STRING,
  modified           => $EMPTY_STRING,

  fontsize           => '10pt',
  define             => [],

  classification     => $EMPTY_STRING,
  handling_caveat    => [],
  classified_by      => $EMPTY_STRING,
  classif_reason     => $EMPTY_STRING,
  declassify_on      => $EMPTY_STRING,

  header_left        => [],
  header_left_odd    => [],
  header_left_even   => [],

  header_center      => [],
  header_center_odd  => [],
  header_center_even => [],

  header_right       => [],
  header_right_odd   => [],
  header_right_even  => [],

  footer_left        => [],
  footer_left_odd    => [],
  footer_left_even   => [],

  footer_center      => [],
  footer_center_odd  => [],
  footer_center_even => [],

  footer_right       => [],
  footer_right_odd   => [],
  footer_right_even  => [],

);

#---------------------------------------------------------------------
# 'LABEL' DATASTRUCTURE
#
my %label = ();

#---------------------------------------------------------------------
# 'VARIABLE' DATASTRUCTURE
#
#     The 'variable' datastructure contains variable name/value pairs
#     defined within documents.
#
#     Variables are defined using this SML syntax:
#
#         var: <name> = <value>
#
#     For instance:
#
#         var: truth-count = 6,725
#
#     Variables are recalled using this SML syntax:
#
#         [var:<name>]
#
#     For instance:
#
#         There are [var:truth-count] truthed matches in the test set.
#
my %variable = ();

#---------------------------------------------------------------------
# Odds and Ends
#
my %to_be_generated       = ();
my %footnote              = ();
my %seen                  = ();
my %current_line          = ();
my %in_preamble           = ();
my %reg_marker            = ();
my %region_type           = ();
my %level_adjustment      = ();
my %include_as_section    = ();
my %hide_marker           = ();
my %raw_marker            = ();
my %slide                 = ();
my %sidebar               = ();
my %results               = ();
my %roles                 = ();

#---------------------------------------------------------------------
# FLAGS
#
#    Define flags to indicate whether or not headings have been
#    included in various listing indexes.
#
#    !!! Bug Here !!!
#
#    The variables defined here should be re-factored into a hash, and
#    perhaps be made part of the %current datastructure.  But, I think
#    they only pertain to pass three.  The %current datastructure
#    pertains to both pass 2 and 3.
#
#    As I re-factor the code to be object-oriented, different objects
#    will likely be responsible for what is now pass 2 and pass 3
#    parsing.  They will each have their own data structures.  Perhaps
#    now is a good time to begin separating the datastructures that
#    will ultimately belong to these two objects.
#
my $heading_in_slide_index        = 0; #
my $heading_in_sidebar_index      = 0; #
my $heading_in_quotation_index    = 0; #
my $heading_in_problem_index      = 0; #
my $heading_in_solution_index     = 0; #
my $heading_in_allocation_index   = 0; #
my $heading_in_assignment_index   = 0; #
my $heading_in_priority_index     = 0; #
my $heading_in_test_index         = 0; #
my $heading_in_task_index         = 0; #
my $heading_in_result_index       = 0; #
my $heading_in_role_index         = 0; #
my $heading_in_demo_index         = 0; #
my $heading_in_exercise_index     = 0; #
my $heading_in_listing_index      = 0; #
my $heading_in_todo_index         = 0; #
my $heading_in_footnote_index     = 0; #
my $heading_in_table_index        = 0; #
my $heading_in_revisions_index    = 0; #
my $heading_in_updates_index      = 0; #
my $heading_in_figure_index       = 0; #
my $heading_in_attachment_index   = 0; #

#---------------------------------------------------------------------
# DEFAULT COLORS AND SIZES
#
#    Define default colors and sizes.  These variables need to be
#    re-factored into some sort of hash.  Also, they should be defined
#    in a stylesheet rather than defined in perl variables and then
#    hard-coded into the HTML output.
#
#    !!! Bug Here !!!
#
#    The variables declared here should be re-factored into a
#    %default hash.
#
my $todo_bgcolor         = '#ffcccc'; # todo item background color
my $todo_regular_color   = '#009900'; # "regular" todo color
my $todo_started_color   = '#004400'; # "started" todo color
my $todo_cancelled_color = '#bbbbbb'; # "cancelled" todo color
my $todo_urgent_color    = '#ff0000'; # "urgent" todo color
my $todo_completed_color = '#000000'; # "completed" todo color
my $todo_question_color  = '#000000'; # "question" todo color

my $footnote_color       = '#000000'; # footnote color

my $num_color            = '#aaaaaa'; # color for slide count

my $preamble_bgcolor     = '#ffffff'; # BG color of preambles
my $preamble_width       = '80%';     # width of preambles
my $preamble_border      = '1px';     # width of preamble border
my $preamble_padding     = '10pt';    # padding around preambles

my $slide_bgcolor        = '#fdfdaa'; # BG color of slides
my $slide_width          = '80%';     # width of slides
my $slide_border         = '1';       # width of slide border
my $slide_padding        = '10';      # padding around slides

my $sidebar_bgcolor      = '#eeeeee'; # BG color of sidebars
my $sidebar_width        = '80%';     # width of sidebars
my $sidebar_border       = '1';       # width of sidebar border
my $sidebar_padding      = '10';      # padding around sidebars

my $quotation_bgcolor    = '#eeeeee'; # BG color of quotations
my $quotation_width      = '80%';     # width of quotations
my $quotation_border     = '1';       # width of quotation border
my $quotation_padding    = '10';      # padding around quotations

my $problem_bgcolor      = '#eeeeee'; # BG color of problems
my $problem_width        = '80%';     # width of problems
my $problem_border       = '1';       # width of problem border
my $problem_padding      = '10';      # padding around problems

my $solution_bgcolor     = '#eeeeee'; # BG color of solutions
my $solution_width       = '80%';     # width of solutions
my $solution_border      = '1';       # width of solution border
my $solution_padding     = '10';      # padding around solutions

my $allocation_bgcolor   = '#eeeeee'; # BG color of allocations
my $allocation_width     = '80%';     # width of allocations
my $allocation_border    = '1';       # width of allocation border
my $allocation_padding   = '10';      # padding around allocations

my $assignment_bgcolor   = '#eeeeee'; # BG color of assignments
my $assignment_width     = '80%';     # width of assignments
my $assignment_border    = '1';       # width of assignment border
my $assignment_padding   = '10';      # padding around assignments

my $test_bgcolor         = '#eeeeee'; # BG color of tests
my $test_width           = '80%';     # width of tests
my $test_border          = '1';       # width of test border
my $test_padding         = '10';      # padding around tests

my $task_bgcolor         = '#eeeeee'; # BG color of tasks
my $task_width           = '80%';     # width of tasks
my $task_border          = '1';       # width of task border
my $task_padding         = '10';      # padding around tasks

my $result_bgcolor       = '#eeeeee'; # BG color of results
my $result_width         = '80%';     # width of results
my $result_border        = '1';       # width of result border
my $result_padding       = '10';      # padding around results

my $role_bgcolor         = '#eeeeee'; # BG color of roles
my $role_width           = '80%';     # width of roles
my $role_border          = '1';       # width of role border
my $role_padding         = '10';      # padding around roles

my $demo_bgcolor         = '#ddddff'; # BG color of demos
my $demo_width           = '80%';     # width of demos
my $demo_border          = '1';       # width of demo border
my $demo_padding         = '10';      # padding around demos

my $exercise_bgcolor     = '#ffffff'; # BG color of exercises
my $exercise_width       = '80%';     # width of exercises
my $exercise_border      = '1';       # width of exercise border
my $exercise_padding     = '10';      # padding around exercises

my $listing_bgcolor      = '#ddffdd'; # BG color of listings
my $listing_width        = '80%';     # width of listings
my $listing_border       = '1';       # width of listing border
my $listing_padding      = '20';      # padding around listings

my $keypoints_bgcolor    = '#eeeeee'; # BG color of keypointss
my $keypoints_width      = '80%';     # width of keypointss
my $keypoints_border     = '1';       # width of keypoints border
my $keypoints_padding    = '20';      # padding around keypointss

my $error_color          = '#ff0000'; # FG color of error text
my $thumbnail_size       = '160';     # size of slide thumbnails
my $scaled_size          = '605';     # width of scaled images
my $max_float_size       = 400;       # more than this? use longtable

#---------------------------------------------------------------------
# HEADER AND FOOTER CONTENT
#
my @header_left          = ();        # header left
my @header_left_even     = ();        # header left even page
my @header_left_odd      = ();        # header left odd page

my @header_center        = ();        # header center
my @header_center_even   = ();        # header center even page
my @header_center_odd    = ();        # header center odd page

my @header_right         = ();        # header right
my @header_right_even    = ();        # header right even page
my @header_right_odd     = ();        # header right odd page

my @footer_left          = ();        # footer left
my @footer_left_even     = ();        # footer left even page
my @footer_left_odd      = ();        # footer left odd page

my @footer_center        = ();        # footer center
my @footer_center_even   = ();        # footer center even page
my @footer_center_odd    = ();        # footer center odd page

my @footer_right         = ();        # footer right
my @footer_right_even    = ();        # footer right even page
my @footer_right_odd     = ();        # footer right odd page

#---------------------------------------------------------------------
# DIRECTORY AND FILE NAMES
#
my $startdir;
my $docdir;
my $icondir;
my $output_dir;
my $output_file;

#---------------------------------------------------------------------
# BACKGROUND COLORS
#
#    Define a set of standard background colors that can be used in
#    table cell backgrounds.
#
my @background_colors =
  (
   'red',      'yellow',     'blue',
   'green',    'orange',     'purple',
   'white',    'litegrey',   'grey',    'darkgrey',
  );

#---------------------------------------------------------------------
# MAIN GUI WIDGETS
#
#    Define GUI widgets that need to be in the main namespace because
#    they're updated by various methods.
#
my $main;
my $messages;
my $nb;
my $pg0;
my $pg1;
my $pg2;
my $pg3;
my $pg4;
my $pg5;
my $b2;
my $fontsize;
my $fontfam;
my $linkcolor;
my $guistatus;

#---------------------------------------------------------------------
# PERSISTENT VARIABLES
#
#    Define variables that SHOULD NOT get reset by the init
#    subroutine.
#
#    !!! Bug Here !!!
#
#    This should be re-written to not include environment or region
#    names.  Hardcoding the environment and region names reduces the
#    flexibility of the code and makes it more difficult to add new
#    environments and regions.
#
$count{ slide     }{ last } = 0; # highest numbered slide
$count{ listing   }{ last } = 0; # highest numbered listing
$count{ exercise  }{ last } = 0; # highest numbered exercise
$count{ demo      }{ last } = 0; # highest numbered demo
$count{ keypoints }{ last } = 0; # highest numbered keypoints

#---------------------------------------------------------------------
# BIBSTRUCTURE DATASTRUCTURE
#
#    Define the bibliography data structure.
#
#    This "bibliography" data structure describes the types of
#    bibliography entries and the fields that are required and
#    optional for each type.  In some cases, one of two fields is
#    required or optional but not both.  In this case, the two fields
#    are expressed as their own (anonymous) list.
#
#    This structure is taken from the bibliography data structure
#    implemented by BiBTeX.
#
#    NOTE: I don't think this datastructure is used for anything at
#    the moment, but it does define the allowable relationships
#    between biliographic data elements, so I think I'll keep it.
#
#    !!! Bug Here !!!
#
#    Use this datastructure to check the validity of source regions.
#    Write a validator subroutine that ensures: (1) the source type is
#    valid, (2) all required fields are provided, (3) all fields
#    supplied in the source region are either required or optional.
#
my %bibstructure = (

   article =>
   {
    required => ['author','title','journal','year'],
    optional => ['volume','number','pages','month','note'],
   },

   book =>
   {
    required => [['author','editor'],'title','publisher','year'],
    optional => [['volume','number'],'series','address','edition',
                 'month','note'],
   },

   booklet =>
   {
    required => ['title'],
    optional => ['author','howpublished','address','month','year',
                 'note'],
   },

   conference =>
   {
    required => ['author','title','booktitle','year'],
    optional => ['editor',['volume','number'],'series','pages',
                 'address','month','organization','publisher',
                 'note'],
   },

   inbook =>
   {
    required => [['author','editor'],'title','chapter','publisher',
                 'year'],
    optional => [['volume','number'],'series','type','address',
                 'edition','month','note'],
   },

   incollection =>
   {
    required => ['author','title','booktitle','publisher','year'],
    optional => ['editor',['volume','number'],'series','type',
                 'chapter','pages','address','edition','month',
                 'note'],
   },

   inproceedings =>
   {
    required => ['author','title','booktitle','year'],
    optional => ['editor',['volume','number'],'series','pages',
                 'address','month','organization','publisher',
                 'note'],
   },

   manual =>
   {
    required => ['title'],
    optional => ['author','organization','address','edition','month',
                 'year','note'],
   },

   mastersthesis =>
   {
    required => ['author','title','school','year'],
    optional => ['type','address','month','note'],
   },

   misc =>
   {
    required => [],
    optional => ['author','title','howpublished','month','year',
                 'note'],
   },

   phdthesis =>
   {
    required => ['author','title','school','year'],
    optional => ['type','address','month','note'],
   },

   proceedings =>
   {
    required => ['title','year'],
    optional => ['editor',['volume','number'],'series','address',
                 'month','organization','publisher','note'],
   },

   techreport =>
   {
    required => ['author','title','institution','year'],
    optional => ['type','number','address','month','note'],
   },

   unpublished =>
   {
    required => ['author','title','note'],
    optional => ['month','year'],
   },

  );

#---------------------------------------------------------------------
# E-MAIL REGULAR EXPRESSION
#
#     Build up a regular expression for matching Internet E-mail
#     addresses.
#
#     !!! BUG HERE !!!
#
#     I plan to replace this with Common::Regexp::Email::Address at
#     some point in the future.
#
my $emailre = '\b[a-zA-Z0-9._]+@[a-zA-Z0-9._]+\.[a-zA-Z0-9._]+\b';

######################################################################
######################################################################
######################################################################
###                                                                ###
###  This is where the script actually starts DOING SOMETHING...   ###
###                                                                ###
######################################################################
######################################################################
######################################################################

#---------------------------------------------------------------------
# Check for the existence of arguments.
#
#     If there were arguments passed on the command line, we don't
#     want to display the GUI.
#
$option{'gui'} = 0 if @ARGV;

#---------------------------------------------------------------------
# Either display the GUI or publish files in a shell
#
#     Either display the GUI or publish the requested files from the
#     command line.  If the 'gui' option is set, display the GUI.
#     Otherwise, foreach file supplied on the command line, publish
#     that file.
#
if ($option{'gui'}) {
  display_gui();
  MainLoop();
}

else {
  foreach my $file (@ARGV) {
    publish($file);
  }
}

######################################################################
######################################################################
######################################################################
###                                                                ###
###                  Subroutine Definitions                        ###
###                                                                ###
######################################################################
######################################################################
######################################################################

sub publish {

  # This subroutine publishes a document.

  #-------------------------------------------------------------------
  # SUBROUTINE OUTLINE
  #
  # 2  1  Remember the start time
  # 2  2  IF debugging option is set
  # 4     1  Set state: DEBUGGING = 1
  # 2  3  ELSE debugging option is not set
  # 4     1  Set state: DEBUGGING = 0
  # 2  4  IF we're using the GUI
  # 4     1  Clear any previous messages in the messages window
  # 4     2  Display page1 (the messages tab)
  # 4     3  Turn the "publish" button red while publishing
  # 4     4  Update the 'main' widget to make all changes take effect
  # 2  5  Get the file passed as an argument
  # 2  6  If the filename is not an empty string
  # 4     1  text_file = file
  # 2  7  IF render option not specified and not using GUI
  # 4     1  Produce the default rendition
  # 2  8  FOREACH rendition specified
  # 4     1  Set the 'rendering' flag for that rendition
  # 2  9  Initialize variables
  # 2 10  Remember directories
  # 2 11  Change to the document directory
  # 2 12  IF OS is Windows
  # 4     1  Substitute forward slashes with backslashes
  # 2 13  Determine output filename and output directory
  # 2 14  IF debugging
  # 4     1  Print debugging information
  # 2 15  IF rendering HTML
  # 4     1  Define HTML output filenames
  # 2 16  IF rendering PDF
  # 4     1  Define PDF output filenames
  # 2 17  IF rendering XML
  # 4     1  Define XML output filenames
  # 2 18  IF rendering CSV
  # 4     1  Define CSV output filenames
  # 2 19  Define plain text output file name
  # 2 20  IF the output directory does not exist
  # 4     1  Create it
  # 2 21  IF rendering HTML
  # 4     1  Print status 'rendering icons...'
  # 4     2  Change directory to the start directory
  # 4     3  FOREACH icon in the list of icons
  # 6        1  Copy the icon to the output directory
  # 4     4  Change back to the document directory
  # 2 22  IF rendering HTML
  # 4     1  Insert heading in each array holding HTML content
  # 2 23  Execute pass one
  # 2 24  IF not using the GUI and not using verbose
  # 4     1  Insert a newline for tidiness
  # 2 25  Set pass_two_count = 0
  # 2 26  WHILE text contains requests
  # 4     1  Increment pass_two_count
  # 4     2  Print status 'beginning pass 2 iteration n'
  # 4     3  IF pass_two_count exceeds maximum allowed
  # 6        1  Print error 'maximum allowed passes exceeded'
  # 6        2  LAST (bail out of the loop)
  # 4     4  Execute pass two
  # 4     5  Create the 'lookup' data structure
  # 4     6  Create the 'attribute' data structure
  # 4     7  Create the 'specials' data structure
  # 4     8  Create 'generated' content
  # 2 27  Increment pass_two_count
  # 2 28  Print status 'beginning pass 2 iteration n'
  # 2 29  Execute pass two
  # 2 30  Create 'lookup' data structure
  # 2 31  Create 'specials' data structure
  # 2 32  Create 'attribute' data structure
  # 2 33  Increment pass_two_count
  # 2 34  Print status 'beginning pass 2 iteration n'
  # 2 35  Execute pass two
  # 2 36  IF debugging
  # 4     1  Print debugging message
  # 2 37  Create 'lookup' data structure
  # 2 38  Create 'specials' data structure
  # 2 39  Create 'attribute' data structure
  # 2 40  Organize document metadata
  # 2 41  Normalize glossary definitions
  # 2 42  Normalize variable values
  # 2 43  Normalize acronym definitions
  # 2 44  IF rendering HTML
  # 4     1  FOREACH type of item
  # 6        1  Render traceability matrix for item type
  # 6        2  Render big tree for item type
  # 6        3  Render small tree for item type
  # 6        4  Render spreadsheet for item type
  # 6        5  Render priorities listing for item type
  # 2 45  IF rendering CSV
  # 4     1  FOREACH type of item
  # 6        1  Render CSV file for item type
  # 2 46  IF document contains images
  # 4     1  IF debugging
  # 6        1  Print debugging message
  # 4     2  FOREACH image directory
  # 6        1  IF image directory doesn't exist
  # 8           1  Print status 'creating image directory'
  # 8           2  Make image directory
  # 2 47  IF document contains files
  # 4     1  IF debugging
  # 6        1  Print debugging message
  # 4     1  IF 'files' directory doesn't exist
  # 6        1  Print status 'creating files directory'
  # 6        2  Make files directory
  # 2 48  IF 'list of sources' is required
  # 4     1  Render bibliography
  # 2 49  IF glossary is required
  # 4     1  Render glossary
  # 2 50  IF change log is required
  # 4     1  Render change log
  # 2 51  IF 'list of acronyms' is required
  # 4     1  Render list of acronyms
  # 2 52  Execute pass three
  # 2 53  Update files
  # 2 54  IF rendering HTML
  # 4     1  Assemble HTML header array
  # 4     2  Assemble HTML navigation array
  # 4     3  Assemble HTML title array
  # 4     4  Assemble HTML footer array
  # 4     5  FOREACH section of the document
  # 6        1  Print status 'writing HTML document section'
  # 6        2  IF not using GUI and not verbose
  # 8           1  Print progress indicator '.'
  # 6        3  Determine output file and section array reference
  # 6        4  Assemble section document
  # 6        5  Write HTML section document file
  # 4     6  IF document contains sections and TOC is required
  # 6        1  Print status 'writing HTML TOC'
  # 6        2  IF not using GUI and not verbose
  # 8           1  Print progress indicator '.'
  # 6        3  Assemble TOC
  # 6        4  Write HTML TOC file
  # 4     7  IF document contains slides and list of slides is required
  # 6        1  Print status 'writing HTML slide index'
  # 6        2  IF not using GUI and not verbose
  # 8           1  Print progress indicator '.'
  # 6        3  Assemble list of slides
  # 6        4  Write HTML 'list of slides' file
  # 4     8  IF document contains sidebars and list of sidebars is required
  # 6        1  Print status 'writing HTML sidebar index'
  # 6        2  IF not using GUI and not verbose
  # 8           1  Print progress indicator '.'
  # 6        3  Assemble list of sidebars
  # 6        4  Write HTML 'list of sidebars' file
  # 4     9  IF document contains quotations and list of quotations is required
  # 6        1  Print status 'writing HTML quotation index'
  # 6        2  IF not using GUI and not verbose
  # 8           1  Print progress indicator '.'
  # 6        3  Assemble list of quotations
  # 6        4  Write HTML 'list of quotations' file
  # 4    10  IF document contains problems and list of problems is required
  # 6        1  Print status 'writing HTML problem index'
  # 6        2  IF not using GUI and not verbose
  # 8           1  Print progress indicator '.'
  # 6        3  Assemble list of problems
  # 6        4  Write HTML 'list of problems' file
  # 4    11  IF document contains solutions and list of solutions is required
  # 6        1  Print status 'writing HTML solution index'
  # 6        2  IF not using GUI and not verbose
  # 8           1  Print progress indicator '.'
  # 6        3  Assemble list of solutions
  # 6        4  Write HTML 'list of solutions' file
  #
  #-------------------------------------------------------------------

  #-------------------------------------------------------------------
  # 1 - Remember the start time
  #
  my $t0 = new Benchmark;

  #-------------------------------------------------------------------
  # 2 - IF debugging option is set
  #
  if ($option{debugging}) {
    $DEBUGGING = 1;
  }

  #-------------------------------------------------------------------
  # 3 - ELSE debugging option is not set
  #
  else {
    $DEBUGGING = 0;
  }

  #-------------------------------------------------------------------
  # 4 - If we're using the GUI...
  #
  if ( $option{'gui'} ) {

    #-----------------------------------------------------------------
    # 4.1 - Clear any previous messages in the messages window
    #
    $messages->configure(-state=>'normal');
    $messages->delete("1.0",'end');
    $messages->configure(-state=>'disabled');

    #-----------------------------------------------------------------
    # 4.2 - Display page1 (the messages tab)
    #
    $nb->raise("page1");

    #-----------------------------------------------------------------
    # 4.3 - Turn the "publish" button red while publishing
    #
    $b2->configure(
        -text             => 'Publishing',
        -background       => 'red',
        -activebackground => 'red',
    );

    #-----------------------------------------------------------------
    # 4.4 - Update the 'main' widget to make all changes take effect
    #
    $main->update();
  }

  #-------------------------------------------------------------------
  # 5 - Get the file passed as an argument
  #
  #     The file to be published was either passed to this subroutine
  #     as an argument, or it was selected through the GUI and is in
  #     the $text_file variable.
  #
  #     !!! Bug Here !!!
  #
  #     Handle the condition when the user runs publish without
  #     specifying a manuscript text file to be published.  i.e. raise
  #     an error.
  #
  my $file = shift;

  #-------------------------------------------------------------------
  # 6 - IF the filename is not an empty string
  #
  if ($file) {
    $text_file = $file;
  }

  #-------------------------------------------------------------------
  # 7 - IF render option not specified AND not using GUI
  #
  #     Make sure renditions to publish are properly specified.
  #     First, if no renditions were specified on the command line
  #     (and we're not using the GUI) then set the chosen rendition to
  #     the default one.
  #
  if (scalar(@opt_render) == 0 and not $option{'gui'}) {
    push @opt_render, $DEFAULT_RENDITION;
  }
  $renditions = join(',',@opt_render);

  #-------------------------------------------------------------------
  # 8 - FOREACH rendition specified
  #
  #     Set the 'rendering' flag for that rendition
  #
  foreach my $rendition (@opt_render) {
    $rendering{ html } = 1 if $rendition =~ /^html$/i;
    $rendering{ pdf  } = 1 if $rendition =~ /^pdf$/i;
    $rendering{ xml  } = 1 if $rendition =~ /^xml$/i;
    $rendering{ csv  } = 1 if $rendition =~ /^csv$/i;
  }

  #-----------------------------------------------------------------
  # 9 - Initialize variables
  #
  #     The init() method gets called each time the user presses the
  #     'publish' button.  It is necessary to re-initialize lots of
  #     variables before each publishing run.
  #
  init();

  #-----------------------------------------------------------------
  # 10 - Remember diretories
  #
  #     Remember the current working directory (cwd) and the directory
  #     containing the toplevel file being published.  Change into the
  #     directory containing the toplevel file being published.
  #
  $startdir = getcwd;
  $docdir   = dirname($text_file);
  $icondir  = dirname($0) . "/images";

  #-----------------------------------------------------------------
  # 11 - Change to the document directory
  #
  chdir($docdir);

  #-----------------------------------------------------------------
  # 12 - IF OS is Windows
  #
  #     Substitute forward slashes with backslashes.
  #
  if ($^O eq 'MSWin32') {
    $startdir =~ s/\//\\/g;
    $docdir   =~ s/\//\\/g;
    $icondir  =~ s/\//\\/g;
  }

  #-----------------------------------------------------------------
  # 13 - Determine output filename and output directory
  #
  #     Get the name of the text file and pop the filename extenstion
  #     (probably .txt) off of it.  The filename (without the .txt)
  #     will be used as the name of the output directory and the basis
  #     for the other output file names.
  #
  #     !!! Bug Here !!!
  #
  #     Consider warning the user if the filename extension is NOT
  #     .txt
  #
  my $base_file = basename($text_file);
  my @part      = split(/\./,$base_file);
  my $extension = pop @part;
  $output_file  = join('.', @part);
  $output_dir   = "$docdir/$output_file";

  #-----------------------------------------------------------------
  # 14 - IF debugging
  #
  #     Print debugging information
  #
  if ($DEBUGGING) {
    printdebug("rendering_html: $rendering{'html'}");
    printdebug("rendering_pdf: $rendering{'pdf'}");
    printdebug("rendering_xml: $rendering{'xml'}");
    printdebug("startdir: $startdir");
    printdebug("docdir: $docdir");
    printdebug("output_file: $output_file");
    printdebug("output_dir: $output_dir");
  }

  #-----------------------------------------------------------------
  # 15 - IF rendering HTML
  #
  #     Define HTML output file names.
  #
  #     !!! Bug Here !!!
  #
  #     This block of code seems kludgey.  Shouldn't all of these
  #     filenames be in a hash or something?  The same goes for the
  #     filenames associated with the other renditions as well.
  #
  #     Consider $outfile{<rendition>}{<description>}
  #
  #     So, individual hash elements might be:
  #
  #       $outfile{'html'}{'document'} = "$output_file.html";
  #       $outfile{'html'}{'toc'}      = "$output_file.toc.html";
  #       $outfile{'html'}{'slides'}   = "$output_file.slides.html";
  #       $outfile{'html'}{'sidebars'} = "$output_file.sidebars.html";
  #       etc...
  #
  if ($rendering{'html'}) {
    $html_toc_file                  = "$output_file.toc.html";
    $html_revisions_file            = "$output_file.revisions.html";
    $html_updates_file              = "$output_file.updates.html";
    $html_slide_index_file          = "$output_file.slide.html";
    $html_sidebar_index_file        = "$output_file.sidebar.html";
    $html_quotation_index_file      = "$output_file.quotation.html";
    $html_problem_index_file        = "$output_file.problem.html";
    $html_solution_index_file       = "$output_file.solution.html";
    $html_allocation_index_file     = "$output_file.allocation.html";
    $html_assignment_index_file     = "$output_file.assignment.html";
    $html_test_index_file           = "$output_file.test.html";
    $html_task_index_file           = "$output_file.task.html";
    $html_result_index_file         = "$output_file.result.html";
    $html_role_index_file           = "$output_file.role.html";
    $html_problem_tree_big_file     = "$output_file.problem-tree-big.html";
    $html_solution_tree_big_file    = "$output_file.solution-tree-big.html";
    $html_allocation_tree_big_file  = "$output_file.allocation-tree-big.html";
    $html_assignment_tree_big_file  = "$output_file.assignment-tree-big.html";
    $html_test_tree_big_file        = "$output_file.test-tree-big.html";
    $html_task_tree_big_file        = "$output_file.task-tree-big.html";
    $html_result_tree_big_file      = "$output_file.result-tree-big.html";
    $html_role_tree_big_file        = "$output_file.role-tree-big.html";
    $html_problem_tree_small_file   = "$output_file.problem-tree-small.html";
    $html_solution_tree_small_file  = "$output_file.solution-tree-small.html";
    $html_allocation_tree_small_file = "$output_file.allocation-tree-small.html";
    $html_assignment_tree_small_file = "$output_file.assignment-tree-small.html";
    $html_test_tree_small_file      = "$output_file.test-tree-small.html";
    $html_task_tree_small_file      = "$output_file.task-tree-small.html";
    $html_result_tree_small_file    = "$output_file.result-tree-small.html";
    $html_role_tree_small_file      = "$output_file.role-tree-small.html";
    $html_problem_spreadsheet_file  = "$output_file.problem-spreadsheet.html";
    $html_solution_spreadsheet_file = "$output_file.solution-spreadsheet.html";
    $html_allocation_spreadsheet_file = "$output_file.allocation-spreadsheet.html";
    $html_assignment_spreadsheet_file = "$output_file.assignment-spreadsheet.html";
    $html_test_spreadsheet_file     = "$output_file.test-spreadsheet.html";
    $html_task_spreadsheet_file     = "$output_file.task-spreadsheet.html";
    $html_result_spreadsheet_file   = "$output_file.result-spreadsheet.html";
    $html_role_spreadsheet_file     = "$output_file.role-spreadsheet.html";
    $html_problem_priorities_file   = "$output_file.problem-priorities.html";
    $html_solution_priorities_file  = "$output_file.solution-priorities.html";
    $html_allocation_priorities_file = "$output_file.allocation-priorities.html";
    $html_assignment_priorities_file = "$output_file.assignment-priorities.html";
    $html_test_priorities_file      = "$output_file.test-priorities.html";
    $html_task_priorities_file      = "$output_file.task-priorities.html";
    $html_result_priorities_file    = "$output_file.result-priorities.html";
    $html_role_priorities_file      = "$output_file.role-priorities.html";
    $html_priority_index_file       = "$output_file.priorities.html";
    $html_demo_index_file           = "$output_file.demo.html";
    $html_exercise_index_file       = "$output_file.exercise.html";
    $html_listing_index_file        = "$output_file.listing.html";
    $html_todo_index_file           = "$output_file.todo.html";
    $html_footnote_index_file       = "$output_file.footnote.html";
    $html_table_index_file          = "$output_file.table.html";
    $html_figure_index_file         = "$output_file.figure.html";
    $html_attachment_index_file     = "$output_file.attachment.html";
    $html_source_index_file         = "$output_file.source.html";
    $html_glossary_file             = "$output_file.glossary.html";
    $html_acronym_file              = "$output_file.acronym.html";
    $html_changelog_file            = "$output_file.changelog.html";
  }

  #-----------------------------------------------------------------
  # 16 - IF rendering PDF
  #
  #     Define PDF output file names.
  #
  if ($rendering{'pdf'}) {
    $latex_file                   = "$output_file.tex";
    $bibliography_file            = "$output_file.bib";
    $index_file                   = "$output_file.idx";
  }

  #-----------------------------------------------------------------
  # 17 - IF rendering XML
  #
  #     Define XML output file names.
  #
  if ($rendering{'xml'}) {
    $xml_doc_file                 = "$output_file.xml";
    $xml_stylesheet_file          = "publish.css";
    $xml_dtd_file                 = "publish.dtd";
  }

  #-----------------------------------------------------------------
  # 18 - IF rendering CSV
  #
  #     Define CSV output file names.
  #
  if ($rendering{'csv'}) {
    $csv_problem_index_file       = "$output_file.problem.csv";
    $csv_solution_index_file      = "$output_file.solution.csv";
    $csv_allocation_index_file    = "$output_file.allocation.csv";
    $csv_assignment_index_file    = "$output_file.assignment.csv";
    $csv_test_index_file          = "$output_file.test.csv";
    $csv_task_index_file          = "$output_file.task.csv";
    $csv_result_index_file        = "$output_file.result.csv";
    $csv_role_index_file          = "$output_file.role.csv";
  }

  #-------------------------------------------------------------------
  # 19 - Define plain text output file name
  #
  $text_out_file                  = "$output_file.txt";

  #-----------------------------------------------------------------
  # 20 - IF the output directory does not exist
  #
  #     Create it.
  #
  #     If the text file is named "my_notes.txt" then the output
  #     directory should be named "my_notes"
  #
  if (not -d $output_dir) {
    printstatus("creating output dir: $output_dir");
    mkdir $output_dir, 0755;
  }

  #-------------------------------------------------------------------
  # 21 - IF Rendering HTML
  #
  #     If rendering HTML, copy image files to the output directory
  #     that are used in the HTML presentation.
  #
  if ($rendering{'html'}) {
    printstatus("copying icons");
    chdir($startdir);
    foreach my $icon (@icons) {
      File::Copy::copy("$icondir/$icon","$output_dir/$icon");
    }
    chdir($docdir);
  }

  #-----------------------------------------------------------------
  # 22 - IF rendering HTML
  #
  #     Insert navigation links for related views.
  #
  if ($rendering{'html'}) {

    my $problem_nav_links = <<"END_OF_TEXT";
<div align="center" style="font-size: 8pt;">
<a href="$html_problem_index_file">Traceability Matrix</a> -
<a href="$html_problem_tree_small_file">Tree View (small)</a> -
<a href="$html_problem_tree_big_file">Tree View (big)</a> -
<a href="$html_problem_spreadsheet_file">Spreadsheet View</a> -
<a href="$html_problem_priorities_file">Priorities View</a>
</div>
END_OF_TEXT

    my $solution_nav_links = <<"END_OF_TEXT";
<div align="center" style="font-size: 8pt;">
<a href="$html_solution_index_file">Traceability Matrix</a>-
<a href="$html_solution_tree_small_file">Tree View (small)</a>-
<a href="$html_solution_tree_big_file">Tree View (big)</a>-
<a href="$html_solution_spreadsheet_file">Spreadsheet View</a>-
<a href="$html_solution_priorities_file">Priorities View</a>
</div>
END_OF_TEXT

    my $allocation_nav_links = <<"END_OF_TEXT";
<div align="center" style="font-size: 8pt;">
<a href="$html_allocation_index_file">Traceability Matrix</a>-
<a href="$html_allocation_tree_small_file">Tree View (small)</a>-
<a href="$html_allocation_tree_big_file">Tree View (big)</a>-
<a href="$html_allocation_spreadsheet_file">Spreadsheet View</a>-
<a href="$html_allocation_priorities_file">Priorities View</a>
</div>
END_OF_TEXT

    my $assignment_nav_links = <<"END_OF_TEXT";
<div align="center" style="font-size: 8pt;">
<a href="$html_assignment_index_file">Traceability Matrix</a>-
<a href="$html_assignment_tree_small_file">Tree View (small)</a>-
<a href="$html_assignment_tree_big_file">Tree View (big)</a>-
<a href="$html_assignment_spreadsheet_file">Spreadsheet View</a>-
<a href="$html_assignment_priorities_file">Priorities View</a>
</div>
END_OF_TEXT

    my $test_nav_links = <<"END_OF_TEXT";
<div align="center" style="font-size: 8pt;">
<a href="$html_test_index_file">Traceability Matrix</a>-
<a href="$html_test_tree_small_file">Tree View (small)</a>-
<a href="$html_test_tree_big_file">Tree View (big)</a>-
<a href="$html_test_spreadsheet_file">Spreadsheet View</a>-
<a href="$html_test_priorities_file">Priorities View</a>
</div>
END_OF_TEXT

    my $task_nav_links = <<"END_OF_TEXT";
<div align="center" style="font-size: 8pt;">
<a href="$html_task_index_file">Traceability Matrix</a>-
<a href="$html_task_tree_small_file">Tree View (small)</a>-
<a href="$html_task_tree_big_file">Tree View (big)</a>-
<a href="$html_task_spreadsheet_file">Spreadsheet View</a>-
<a href="$html_task_priorities_file">Priorities View</a>
</div>
END_OF_TEXT

    my $result_nav_links = <<"END_OF_TEXT";
<div align="center" style="font-size: 8pt;">
<a href="$html_result_index_file">Traceability Matrix</a>-
<a href="$html_result_tree_small_file">Tree View (small)</a>-
<a href="$html_result_tree_big_file">Tree View (big)</a>-
<a href="$html_result_spreadsheet_file">Spreadsheet View</a>-
<a href="$html_result_priorities_file">Priorities View</a>
</div>
END_OF_TEXT

    my $role_nav_links = <<"END_OF_TEXT";
<div align="center" style="font-size: 8pt;">
<a href="$html_role_index_file">Traceability Matrix</a>-
<a href="$html_role_tree_small_file">Tree View (small)</a>-
<a href="$html_role_tree_big_file">Tree View (big)</a>-
<a href="$html_role_spreadsheet_file">Spreadsheet View</a>-
<a href="$html_role_priorities_file">Priorities View</a>
</div>
END_OF_TEXT

    push @{ $html{'problem'}{'index'} },          "$problem_nav_links";
    push @{ $html{'solution'}{'index'} },         "$solution_nav_links";
    push @{ $html{'allocation'}{'index'} },       "$allocation_nav_links";
    push @{ $html{'assignment'}{'index'} },       "$assignment_nav_links";
    push @{ $html{'test'}{'index'} },             "$test_nav_links";
    push @{ $html{'task'}{'index'} },             "$task_nav_links";
    push @{ $html{'result'}{'index'} },           "$result_nav_links";
    push @{ $html{'role'}{'index'} },             "$role_nav_links";

    push @{ $html{'problem'}{'tree_big'} },       "$problem_nav_links";
    push @{ $html{'solution'}{'tree_big'} },      "$solution_nav_links";
    push @{ $html{'allocation'}{'tree_big'} },    "$allocation_nav_links";
    push @{ $html{'assignment'}{'tree_big'} },    "$assignment_nav_links";
    push @{ $html{'test'}{'tree_big'} },          "$test_nav_links";
    push @{ $html{'task'}{'tree_big'} },          "$task_nav_links";
    push @{ $html{'result'}{'tree_big'} },        "$result_nav_links";
    push @{ $html{'role'}{'tree_big'} },          "$role_nav_links";

    push @{ $html{'problem'}{'tree_small'} },     "$problem_nav_links";
    push @{ $html{'solution'}{'tree_small'} },    "$solution_nav_links";
    push @{ $html{'allocation'}{'tree_small'} },  "$allocation_nav_links";
    push @{ $html{'assignment'}{'tree_small'} },  "$assignment_nav_links";
    push @{ $html{'test'}{'tree_small'} },        "$test_nav_links";
    push @{ $html{'task'}{'tree_small'} },        "$task_nav_links";
    push @{ $html{'result'}{'tree_small'} },      "$result_nav_links";
    push @{ $html{'role'}{'tree_small'} },        "$role_nav_links";

    push @{ $html{'problem'}{'spreadsheet'} },    "$problem_nav_links";
    push @{ $html{'solution'}{'spreadsheet'} },   "$solution_nav_links";
    push @{ $html{'allocation'}{'spreadsheet'} }, "$allocation_nav_links";
    push @{ $html{'assignment'}{'spreadsheet'} }, "$assignment_nav_links";
    push @{ $html{'task'}{'spreadsheet'} },       "$task_nav_links";
    push @{ $html{'test'}{'spreadsheet'} },       "$test_nav_links";
    push @{ $html{'result'}{'spreadsheet'} },     "$result_nav_links";
    push @{ $html{'role'}{'spreadsheet'} },       "$role_nav_links";

    push @{ $html{'problem'}{'priorities'} },     "$problem_nav_links";
    push @{ $html{'solution'}{'priorities'} },    "$solution_nav_links";
    push @{ $html{'allocation'}{'priorities'} },  "$allocation_nav_links";
    push @{ $html{'assignment'}{'priorities'} },  "$assignment_nav_links";
    push @{ $html{'test'}{'priorities'} },        "$test_nav_links";
    push @{ $html{'task'}{'priorities'} },        "$task_nav_links";
    push @{ $html{'result'}{'priorities'} },      "$result_nav_links";
    push @{ $html{'role'}{'priorities'} },        "$role_nav_links";

  }

  #-----------------------------------------------------------------
  # 22 - IF rendering HTML
  #
  #     Insert headings for each HTML output file into the array that
  #     accumulates content for that file.
  #
  if ($rendering{'html'}) {

    push @{ $html{'toc'} },                     "<h3 align=\"center\">Table of Contents</h3>\n";
    push @{ $html{'revisions'} },               "<h3 align=\"center\">List Of Revisions</h3>\n";
    push @{ $html{'updates'} },                 "<h3 align=\"center\">Recent Updates</h3>\n";
    push @{ $html{'slide'}{'index'} },          "<h3 align=\"center\">List of Slides</h3>\n";
    push @{ $html{'sidebar'}{'index'} },        "<h3 align=\"center\">List of Sidebars</h3>\n";
    push @{ $html{'quotation'}{'index'} },      "<h3 align=\"center\">List of Quotations</h3>\n";
    push @{ $html{'demo'}{'index'} },           "<h3 align=\"center\">List of Demonstrations</h3>\n";
    push @{ $html{'exercise'}{'index'} },       "<h3 align=\"center\">List of Exercises</h3>\n";
    push @{ $html{'listing'}{'index'} },        "<h3 align=\"center\">List of Listings</h3>\n";
    push @{ $html{'todo'}{'index'} },           "<h3 align=\"center\">To Do List</h3>\n";
    push @{ $html{'footnote'}{'index'} },       "<h3 align=\"center\">Footnotes</h3>\n";
    push @{ $html{'table'}{'index'} },          "<h3 align=\"center\">List of Tables</h3>\n";
    push @{ $html{'figure'}{'index'} },         "<h3 align=\"center\">List of Figures</h3>\n";
    push @{ $html{'attachment'}{'index'} },     "<h3 align=\"center\">List of Attachments</h3>\n";
    push @{ $html{'source'}{'index'} },         "<h3 align=\"center\">List of References</h3>\n";
    push @{ $html{'glossary'} },                "<h3 align=\"center\">Glossary</h3>\n";
    push @{ $html{'acronym'} },                 "<h3 align=\"center\">Acronyms</h3>\n";
    push @{ $html{'changelog'} },               "<h3 align=\"center\">Changelog</h3>\n";

    push @{ $html{'problem'}{'index'} },        "<h3 align=\"center\">Requirement Traceability Matrix</h3>\n";
    push @{ $html{'solution'}{'index'} },       "<h3 align=\"center\">Solution Traceability Matrix</h3>\n";
    push @{ $html{'allocation'}{'index'} },     "<h3 align=\"center\">Allocation Traceability Matrix</h3>\n";
    push @{ $html{'assignment'}{'index'} },     "<h3 align=\"center\">Assignment Traceability Matrix</h3>\n";
    push @{ $html{'test'}{'index'} },           "<h3 align=\"center\">Test Traceability Matrix</h3>\n";
    push @{ $html{'task'}{'index'} },           "<h3 align=\"center\">Task Traceability Matrix</h3>\n";
    push @{ $html{'result'}{'index'} },         "<h3 align=\"center\">Result Traceability Matrix</h3>\n";
    push @{ $html{'role'}{'index'} },           "<h3 align=\"center\">Role Traceability Matrix</h3>\n";

    push @{ $html{'problem'}{'tree_big'} },     "<h3 align=\"center\">Requirement Tree (big)</h3>\n";
    push @{ $html{'solution'}{'tree_big'} },    "<h3 align=\"center\">Solution Tree (big)</h3>\n";
    push @{ $html{'allocation'}{'tree_big'} },  "<h3 align=\"center\">Allocation Tree (big)</h3>\n";
    push @{ $html{'assignment'}{'tree_big'} },  "<h3 align=\"center\">Assignment Tree (big)</h3>\n";
    push @{ $html{'test'}{'tree_big'} },        "<h3 align=\"center\">Test Tree (big)</h3>\n";
    push @{ $html{'task'}{'tree_big'} },        "<h3 align=\"center\">Task Tree (big)</h3>\n";
    push @{ $html{'result'}{'tree_big'} },      "<h3 align=\"center\">Result Tree (big)</h3>\n";
    push @{ $html{'role'}{'tree_big'} },        "<h3 align=\"center\">Role Tree (big)</h3>\n";

    push @{ $html{'problem'}{'tree_small'} },     "<h3 align=\"center\">Requirement Tree (small)</h3>\n";
    push @{ $html{'solution'}{'tree_small'} },    "<h3 align=\"center\">Solution Tree (small)</h3>\n";
    push @{ $html{'allocation'}{'tree_small'} },  "<h3 align=\"center\">Allocation Tree (small)</h3>\n";
    push @{ $html{'assignment'}{'tree_small'} },  "<h3 align=\"center\">Assignment Tree (small)</h3>\n";
    push @{ $html{'test'}{'tree_small'} },        "<h3 align=\"center\">Test Tree (small)</h3>\n";
    push @{ $html{'task'}{'tree_small'} },        "<h3 align=\"center\">Task Tree (small)</h3>\n";
    push @{ $html{'result'}{'tree_small'} },      "<h3 align=\"center\">Result Tree (small)</h3>\n";
    push @{ $html{'role'}{'tree_small'} },        "<h3 align=\"center\">Role Tree (small)</h3>\n";

    push @{ $html{'problem'}{'spreadsheet'} },    "<h3 align=\"center\">Requirement Spreadsheet</h3>\n";
    push @{ $html{'solution'}{'spreadsheet'} },   "<h3 align=\"center\">Solution Spreadsheet</h3>\n";
    push @{ $html{'allocation'}{'spreadsheet'} }, "<h3 align=\"center\">Allocation Spreadsheet</h3>\n";
    push @{ $html{'assignment'}{'spreadsheet'} }, "<h3 align=\"center\">Assignment Spreadsheet</h3>\n";
    push @{ $html{'task'}{'spreadsheet'} },       "<h3 align=\"center\">Task Spreadsheet</h3>\n";
    push @{ $html{'test'}{'spreadsheet'} },       "<h3 align=\"center\">Test Spreadsheet</h3>\n";
    push @{ $html{'result'}{'spreadsheet'} },     "<h3 align=\"center\">Result Spreadsheet</h3>\n";
    push @{ $html{'role'}{'spreadsheet'} },       "<h3 align=\"center\">Role Spreadsheet</h3>\n";

    push @{ $html{'problem'}{'priorities'} },   "<h3 align=\"center\">Requirement Priorities</h3>\n";
    push @{ $html{'solution'}{'priorities'} },  "<h3 align=\"center\">Solution Priorities</h3>\n";
    push @{ $html{'allocation'}{'priorities'} },  "<h3 align=\"center\">Allocation Priorities</h3>\n";
    push @{ $html{'assignment'}{'priorities'} },  "<h3 align=\"center\">Assignment Priorities</h3>\n";
    push @{ $html{'test'}{'priorities'} },      "<h3 align=\"center\">Test Priorities</h3>\n";
    push @{ $html{'task'}{'priorities'} },      "<h3 align=\"center\">Task Priorities</h3>\n";
    push @{ $html{'result'}{'priorities'} },    "<h3 align=\"center\">Result Priorities</h3>\n";
    push @{ $html{'role'}{'priorities'} },      "<h3 align=\"center\">Role Priorities</h3>\n";

  }

  #-------------------------------------------------------------------
  # 23 - Execute pass one
  #
  #     The purpose of pass one is to resolve all "include:"
  #     directives and create a single combined array containing all
  #     the text of the document.
  #
  pass_one();

  #-------------------------------------------------------------------
  # 24 - IF not using the GUI and not using verbose
  #
  #     Insert a newline for tidiness.
  #
  # if ( not $option{'gui'} and not $option{'verbose'} ) {
  #   print "\n";
  # }

  #-------------------------------------------------------------------
  # 25 - Set pass_two_count = 0
  #
  #    Prepare for pass two.
  #
  #    The purpose of pass two is to (1) gather data elements from the
  #    text, (2) resolve any "generate:" directives and, (3) resolve
  #    any "script:" directives.
  #
  #    Pass two gets repeated until all requests to generate content
  #    and run scripts are satisfied.
  #
  #    SAFETY VALVE: Just in case there is an infinite loop in the
  #    document (i.e. generate requests that generate more generate
  #    requests, that generate...) stop the madness after
  #    MAX_PASS_TWO_ITERATIONS iterations.
  #
  #    Then run it one more time to insert generated content and to
  #    ensure numbering is right.
  #
  $pass_two_count = 0;

  #-------------------------------------------------------------------
  # 26 - WHILE text contains requests
  #
  #     While the text contains unresolved 'generate:', 'script:', or
  #     'insert:' requests, continue to run pass 2. (Rinse, Lather,
  #     Repeat)
  #
  while ( text_contains_requests() ) {

    #-----------------------------------------------------------------
    # 26.1 - Increment pass_two_count
    #
    #     Count the number of times we run pass 2 just in case we need
    #     to break out of an infinite loop.
    #
    ++ $pass_two_count;

    #-----------------------------------------------------------------
    # 26.2 - Print status 'beginning pass 2 iteration n'
    #
    printstatus("beginning pass 2 iteration $pass_two_count");

    #-----------------------------------------------------------------
    # 26.3 - IF pass_two_count exceeds maximum allowed
    #
    #     Just in case there is an infinite loop, stop the madness
    #     after a certain number of iterations of pass 2.
    #
    if ( $pass_two_count > $MAX_PASS_TWO_ITERATIONS ) {
      printerror("Documented might contain infinite loop, Exceeded maximum number of PASS 2 iterations ($MAX_PASS_TWO_ITERATIONS)");
      last;
    }

    #-----------------------------------------------------------------
    # 26.4 - Execute pass 2
    #
    pass_two();

    #-----------------------------------------------------------------
    # 26.5 - Create the 'lookup' datastructure
    #
    #    The lookup data structure needs to be created here because
    #    the generated content subroutine depends on it.
    #
    create_lookup_datastructure();

    #-----------------------------------------------------------------
    # 26.x - Generate 'allocation' titles
    #
    #    'Allocation' regions don't have explicit titles.  Allocation
    #    titles are automatically assembled from the problem and
    #    solution titles.
    #
    create_allocation_titles();

    #-----------------------------------------------------------------
    # 26.x - Generate 'assignment' titles
    #
    #    'Assignment' regions don't have explicit titles.  Assignment
    #    titles are automatically assembled from the problem and
    #    solution titles.
    #
    create_assignment_titles();

    #-----------------------------------------------------------------
    # 26.6 - Create the 'attributes' datastructure
    #
    #    The attributes data structure contains the key/value pair
    #    information from all 'attr' data elements
    #
    create_attribute_datastructure();

    #-----------------------------------------------------------------
    # 26.7 - Create the 'specials' datastructure
    #
    #    The specials data structure allows easy determination of
    #    which sections contain special items (listings, slides,
    #    exercises, demonstrations, problems, solutions, allocations,
    #    assignments, tests, tasks, results, and roles).
    #
    create_specials_datastructure();

    #-----------------------------------------------------------------
    # 26.8 - Create 'generated' content
    #
    #    The generate_content() subroutine generates various
    #    automatically generated listings like:
    #
    #      - problem-domain-listing
    #      - solution-domain-listing
    #      - prioritized-problem-listing
    #      - prioritized-solution-listing
    #      - associated-problem-listing
    #      - associated-solution-listing
    #
    generate_content();

  }

  #-------------------------------------------------------------------
  # Run at least twice.
  #
  #     It's possible the preceding while loop would not execute even
  #     once (if there are no requests).
  #
  #     Run pass two at least twice to resolve title references,
  #     lookups, attributes, and other substitutions that require two
  #     iterations to resolve.
  #
  #-------------------------------------------------------------------

  #-------------------------------------------------------------------
  # 27 - Increment pass_two_count
  #
  ++ $pass_two_count;

  #-------------------------------------------------------------------
  # 28 - Print status 'beginning pass 2 iteration n'
  #
  printstatus("beginning pass 2 iteration $pass_two_count");

  #-------------------------------------------------------------------
  # 29 - Execute pass two
  #
  pass_two();

  #-------------------------------------------------------------------
  # 30 - Create 'lookup' data structure
  #
  create_lookup_datastructure();

  #-----------------------------------------------------------------
  # 3x - Generate 'allocation' titles
  #
  create_allocation_titles();

  #-----------------------------------------------------------------
  # 3x - Generate 'assignment' titles
  #
  create_assignment_titles();

  #-------------------------------------------------------------------
  # 32 - Create 'attribute' data structure
  #
  create_attribute_datastructure();

  #-------------------------------------------------------------------
  # 31 - Create 'specials' data structure
  #
  create_specials_datastructure();

  #-------------------------------------------------------------------
  # 33 - Increment pass_two_count
  #
  ++ $pass_two_count;

  #-------------------------------------------------------------------
  # 34 - Print status 'beginning pass 2 iteration n'
  #
  printstatus("beginning pass 2 iteration $pass_two_count");

  #-------------------------------------------------------------------
  # 35 - Execute pass two
  #
  pass_two();

  ####################################################################
  ####################################################################
  ##                                                                ##
  ##                 BETWEEN PASS TWO AND THREE                     ##
  ##                                                                ##
  ####################################################################
  ####################################################################

  #-------------------------------------------------------------------
  # 36 - IF debugging
  #
  #     Print debugging message.
  #
  if ($DEBUGGING) {
    my $text = <<"END_OF_TEXT";
------------------------------------------------------------
BETWEEN PASS 2 AND 3
------------------------------------------------------------

END_OF_TEXT

    printdebug($text);
  }

  #-------------------------------------------------------------------
  # 37 - Create the lookup data structure.
  #
  #     During pass 2, data was gathered into the 'data' data
  #     structure and indexed by environment or region number.  Now
  #     that all the data has been gathered, we need to index it by
  #     label for ease of lookup during pass 3.
  #
  #     First, make separate lists of regions and environments.
  #     We'll need these lists inside the next block of code.
  #
  create_lookup_datastructure();

  #-----------------------------------------------------------------
  # 3x - Generate 'allocation' titles
  #
  create_allocation_titles();

  #-----------------------------------------------------------------
  # 3x - Generate 'assignment' titles
  #
  create_assignment_titles();

  #-------------------------------------------------------------------
  # 39 - Create the attribute data structure.
  #
  #    The attributes data structure contains the key/value pair
  #    information from all 'attr' data elements
  #
  #
  create_attribute_datastructure();

  #-----------------------------------------------------------------
  # 38 - Create the specials datastructure
  #
  #    The specials data structure allows easy determination of which
  #    sections contain special items (listings, slides, exercises,
  #    demonstrations, problems, solutions, tests, tasks, results, and
  #    roles).
  #
  create_specials_datastructure();

  #-------------------------------------------------------------------
  # 53 - Update files
  #
  update_files();

  #-------------------------------------------------------------------
  # 40 - Organize document metadata
  #
  #     During pass 2, document metadata in the preamble was gathered
  #     into the 'data' data structure.  Now that all the data has
  #     been gathered, we need to organize it into the %document hash
  #     for easy lookup.
  #
  organize_document_metadata();

  #-------------------------------------------------------------------
  # 41 - Normalize glossary definitions
  #
  normalize_glossary_definitions();

  #-------------------------------------------------------------------
  # 42 - Normalize variable values
  #
  normalize_variable_values();

  #-------------------------------------------------------------------
  # 43 - Normalize acronym definitions
  #
  normalize_acronym_definitions();

  #-------------------------------------------------------------------
  # 44 - IF rendering HTML
  #
  #     BETWEEN PASS 2 and PASS 3: Create HTML index, tree
  #     (big/small), spreadsheet, and priorities for problems,
  #     solutions, allocations, assignments, tests, tasks, results,
  #     and roles.
  #
  #     The "index" page lists top level items first, followed by each
  #     lower level.  An index is like a traceability matrix.  In
  #     fact, I'm thinking of renaming 'index' to 'matrix'.
  #
  #     The "tree" pages list the item hierarchy in an indented table
  #     with hideable rows.
  #
  #     The "spreadsheet" page provides a spreadsheet-like view of all
  #     items with their data elements and attributes.
  #
  #     The "priorities" page lists problems in priority order
  #     according to urgency calculated from priority and status.
  #
  if ($rendering{'html'}) {

    printstatus("rendering special HTML views...");

    #-------------------------------------------------------------------
    # 44.1 - FOREACH type of item
    #
    foreach my $type ('problem', 'solution', 'allocation', 'assignment',
                      'task',    'test',     'result',     'role') {

      render_matrix($type);
      render_tree($type,'big');
      render_tree($type,'small');
      render_spreadsheet($type);
      render_priorities($type);

    }
  }

  #-------------------------------------------------------------------
  # 45 - IF rendering CSV
  #
  #    Each CSV file can be opened as a spreadsheet.
  #
  if ($rendering{'csv'}) {

    printstatus("rendering special CSV files...");

    #-------------------------------------------------------------------
    # 45.1 - FOREACH type of item
    #
    foreach my $type
      (
       'problem', 'solution', 'allocation', 'assignment',
       'task',    'test',     'result',     'role',
      ) {

      render_csvfile($type);
    }
  }

  #-----------------------------------------------------------------
  # 46 - IF document contains images
  #
  #     Create images subdirectories
  #
  #     If the text includes any images (images are contained in
  #     seperate files) then create subdirectories for 'images',
  #     'images-scaled', and 'images-thumbnails'.
  #
  if ( $count{'image'}{'total'} > 0
       or
       $document{'logo_image_small'}
       or
       $document{'logo_image_left'}
       or
       $document{'logo_image_center'}
       or
       $document{'logo_image_right'}
     ) {

    if ( $DEBUGGING ) {
      printdebug("found $count{'image'}{'total'} images");
    }

    foreach my $directory (@image_directories) {
      if (not -d "$output_dir/$directory") {
        printstatus("creating $directory dir: $output_dir/$directory");
        mkdir "$output_dir/$directory", 0755;
      }
    }
  }

  #-----------------------------------------------------------------
  # 47 - IF document contains files
  #
  #     Create 'files' subdirectory
  #
  #     If the text includes any files (contained in separate files)
  #     then create an subdirectory called 'files'.
  #
  if ($count{'file'}{'total'}) {

    if ( $DEBUGGING ) {
      printdebug("found $count{'file'}{'total'} \"included\" files");
    }

    if (not -d "$output_dir/files") {
      printstatus("creating files dir: $output_dir/files");
      mkdir "$output_dir/files", 0755;
    }
  }

  #-----------------------------------------------------------------
  # 48 - IF 'list of sources' is required
  #
  #     Render bibliography
  #
  if ($option{'losources'}) {
    render_bibliography();
  }

  #-----------------------------------------------------------------
  # 49 - IF 'glossary' is required
  #
  #     Render glossary
  #
  if ($option{'glossary'}) {
    render_glossary();
  }

  #-----------------------------------------------------------------
  # 49a - IF 'updates' is required
  #
  #     Render list of recent updates
  #
  if ($option{'updates'}) {
    render_recent_update_listing();
  }

  #-----------------------------------------------------------------
  # 50 - IF change log is required
  #
  #     Render change log
  #
  if ($option{'changelog'}) {
    render_changelog();
  }

  #-----------------------------------------------------------------
  # 51 - IF 'list of acronyms' is required
  #
  #     Render list of acronyms
  #
  # if ($option{'acronym'}) {
  #   render_acronym();
  # }

  #-------------------------------------------------------------------
  # 52 - Execute pass three
  #
  pass_three();

  ####################################################################
  ####################################################################
  #
  # DONE WITH PASSES 1, 2 and 3 - now assemble renditions...
  #
  ####################################################################
  ####################################################################

  #-------------------------------------------------------------------
  # 54 - IF rendering HTML
  #
  if ($rendering{'html'}) {

    #-----------------------------------------------------------------
    # 54.1 - Assemble HTML header array
    #
    assemble_html_head_array();

    #-----------------------------------------------------------------
    # 54.2 - Assemble HTML navigation array
    #
    assemble_html_nav_array();

    #-----------------------------------------------------------------
    # 54.3 - Assemble HTML title array
    #
    assemble_html_title_array();

    #-----------------------------------------------------------------
    # 54.4 - Assemble HTML footer array
    #
    assemble_html_foot_array();

    #---------------------------------------------------------------
    # 54.5 - FOREACH section of the document
    #
    foreach my $section ( keys %{ $html{'body'} } ) {

      printstatus("Writing HTML document file $section");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $outfile  = html_outfile_for_secnum($section);
      my $aref     = $html{'body'}{$section};

      my $document = '';

      if (scalar keys %{ $html{'body'} } > 1) {
	$document = join
	  (
	   $EMPTY_STRING,
	   @{ $html{'head'} },
	   @{ $html{'nav'} },
	   "<div id=\"content\">\n",
	   @{ $aref },
	   @{ $html{'foot'} },
	  );
      } else {
	$document = join
	  (
	   $EMPTY_STRING,
	   @{ $html{'head'} },
	   @{ $html{'nav'} },
	   @{ $html{'title'} },
	   @{ $aref },
	   @{ $html{'foot'} },
	  );
      }

      open DOCUMENT, ">$output_dir/$outfile";
      print DOCUMENT $document;
      close DOCUMENT;
    }

    #---------------------------------------------------------------
    # 54.6 - IF document contains sections and TOC is required
    #
    #     Output the table of contents if there were any section
    #     headings.
    #
    if ( $count{'section'}{'total'} > 0 and $option{'toc'} ) {

      printstatus("Writing HTML table of contents");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $toc = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} }, @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'toc'} }, @{ $html{'foot'} },
      );

      open TOC, ">$output_dir/$html_toc_file";
      print TOC $toc;
      close TOC;
    }

    #---------------------------------------------------------------
    # 54.6 - IF document contains a list of revisions
    #
    #     Output the list of revisions
    #
    if ( $count{'revenv'}{'total'} > 0 and $option{'revisions'} ) {

      printstatus("Writing HTML list of revisions");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $revisions = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },       @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'revisions'} }, @{ $html{'foot'} },
      );

      open REVISIONS, ">$output_dir/$html_revisions_file";
      print REVISIONS $revisions;
      close REVISIONS;
    }

    #---------------------------------------------------------------
    # 54.6 - IF document contains a list of revisions
    #
    #     Output the list of revisions
    #
    if ( $count{'update'}{'total'} > 0 and $option{'updates'} ) {

      printstatus("Writing HTML list of recent updates");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $updates = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },     @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'updates'} }, @{ $html{'foot'} },
      );

      open UPDATES, ">$output_dir/$html_updates_file";
      print UPDATES $updates;
      close UPDATES;
    }

    #---------------------------------------------------------------
    # 54.7 - IF document contains slides and list os slides is required
    #
    if ( $count{'slide'}{'total'} > 0 and $option{'loslides'} ) {

      printstatus("Writing HTML slide index");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $slides = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },            @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'slide'}{'index'} }, @{ $html{'foot'} },
      );

      open SLIDES, ">$output_dir/$html_slide_index_file";
      print SLIDES $slides;
      close SLIDES;
    }

    #---------------------------------------------------------------
    # 54.8 - IF document contains sidebars and list of sidebase is required
    #
    if ( $count{'sidebar'}{'total'} > 0 and $option{'losidebars'} ) {

      printstatus("Writing HTML sidebar index");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $sidebars = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },              @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'sidebar'}{'index'} }, @{ $html{'foot'} },
      );

      open SIDEBARS, ">$output_dir/$html_sidebar_index_file";
      print SIDEBARS $sidebars;
      close SIDEBARS;
    }

    #---------------------------------------------------------------
    # 54.9 - IF document contains quotations and list of quotations is required
    #
    if ( $count{'quotation'}{'total'} > 0 and $option{'loquotations'} ) {

      printstatus("Writing HTML quotation index");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $quotations = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'quotation'}{'index'} }, @{ $html{'foot'} },
      );

      open QUOTATIONS, ">$output_dir/$html_quotation_index_file";
      print QUOTATIONS $quotations;
      close QUOTATIONS;
    }

    #---------------------------------------------------------------
    # 54.10 - IF document contains problems and list of problems is required
    #
    if ( $count{'problem'}{'total'} > 0 ) {

      printstatus("Writing HTML problem index");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $problems = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },              @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'problem'}{'index'} }, @{ $html{'foot'} },
      );

      open PROBLEMS, ">$output_dir/$html_problem_index_file";
      print PROBLEMS $problems;
      close PROBLEMS;
    }

    #---------------------------------------------------------------
    # 54.11 - IF document contains solutions and list of solutions is required
    #
    if ( $count{'solution'}{'total'} > 0 ) {

      printstatus("Writing HTML solution index");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $solutions = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },               @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'solution'}{'index'} }, @{ $html{'foot'} },
      );

      open SOLUTIONS, ">$output_dir/$html_solution_index_file";
      print SOLUTIONS $solutions;
      close SOLUTIONS;
    }

    #---------------------------------------------------------------
    # 54.xx - IF document contains allocations and list of allocations is required
    #
    if ( $count{'allocation'}{'total'} > 0 ) {

      printstatus("Writing HTML allocation index");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $allocations = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                 @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'allocation'}{'index'} }, @{ $html{'foot'} },
      );

      open ALLOCATIONS, ">$output_dir/$html_allocation_index_file";
      print ALLOCATIONS $allocations;
      close ALLOCATIONS;
    }

    #---------------------------------------------------------------
    # 54.xx - IF document contains assignments and list of assignments is required
    #
    if ( $count{'assignment'}{'total'} > 0 ) {

      printstatus("Writing HTML assignment index");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $assignments = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                 @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'assignment'}{'index'} }, @{ $html{'foot'} },
      );

      open ASSIGNMENTS, ">$output_dir/$html_assignment_index_file";
      print ASSIGNMENTS $assignments;
      close ASSIGNMENTS;
    }

    #---------------------------------------------------------------
    # HTML: output the test index if there were any tests
    #
    if ( $count{'test'}{'total'} > 0 ) {

      printstatus("Writing HTML test index");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $tests = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },           @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'test'}{'index'} }, @{ $html{'foot'} },
      );
      open TESTS, ">$output_dir/$html_test_index_file";
      print TESTS $tests;
      close TESTS;
    }

    #---------------------------------------------------------------
    # HTML: output the task index if there were any tasks
    #
    if ( $count{'task'}{'total'} > 0 ) {

      printstatus("Writing HTML task index");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $tasks = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },           @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'task'}{'index'} }, @{ $html{'foot'} },
      );
      open TASKS, ">$output_dir/$html_task_index_file";
      print TASKS $tasks;
      close TASKS;
    }

    #---------------------------------------------------------------
    # HTML: output the result index if there were any results
    #
    if ( $count{'result'}{'total'} > 0 ) {

      printstatus("Writing HTML result index");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $results = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },             @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'result'}{'index'} }, @{ $html{'foot'} },
      );
      open RESULTS, ">$output_dir/$html_result_index_file";
      print RESULTS $results;
      close RESULTS;
    }

    #---------------------------------------------------------------
    # HTML: output the role index if there were any roles
    #
    if ( $count{'role'}{'total'} > 0 ) {

      printstatus("Writing HTML role index");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $roles = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },           @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'role'}{'index'} }, @{ $html{'foot'} },
      );
      open ROLES, ">$output_dir/$html_role_index_file";
      print ROLES $roles;
      close ROLES;
    }

    #---------------------------------------------------------------
    # HTML: output the problem tree (big) if there were any
    # problems
    #
    if ( $count{'problem'}{'total'} > 0 ) {

      printstatus("Writing HTML problem tree (big)");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $problems = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                 @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'problem'}{'tree_big'} }, @{ $html{'foot'} },
      );
      open PROBLEMS, ">$output_dir/$html_problem_tree_big_file";
      print PROBLEMS $problems;
      close PROBLEMS;
    }

    #---------------------------------------------------------------
    # HTML: output the problem tree (small) if there were any
    # problems
    #
    if ( $count{'problem'}{'total'} > 0 ) {

      printstatus("Writing HTML problem tree (small)");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $problems = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                   @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'problem'}{'tree_small'} }, @{ $html{'foot'} },
      );
      open PROBLEMS, ">$output_dir/$html_problem_tree_small_file";
      print PROBLEMS $problems;
      close PROBLEMS;
    }

    #---------------------------------------------------------------
    # HTML: output the solution tree (big) if there were any solutions
    #
    if ( $count{'solution'}{'total'} > 0 ) {

      printstatus("Writing HTML solution tree (big)");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $solutions = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                  @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'solution'}{'tree_big'} }, @{ $html{'foot'} },
      );
      open SOLUTIONS, ">$output_dir/$html_solution_tree_big_file";
      print SOLUTIONS $solutions;
      close SOLUTIONS;
    }

    #---------------------------------------------------------------
    # HTML: output the allocation tree (big) if there were any allocations
    #
    if ( $count{'allocation'}{'total'} > 0 ) {

      printstatus("Writing HTML allocation tree (big)");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $allocations = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                  @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'allocation'}{'tree_big'} }, @{ $html{'foot'} },
      );
      open ALLOCATIONS, ">$output_dir/$html_allocation_tree_big_file";
      print ALLOCATIONS $allocations;
      close ALLOCATIONS;
    }

    #---------------------------------------------------------------
    # HTML: output the assignment tree (big) if there were any assignments
    #
    if ( $count{'assignment'}{'total'} > 0 ) {

      printstatus("Writing HTML assignment tree (big)");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $assignments = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                  @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'assignment'}{'tree_big'} }, @{ $html{'foot'} },
      );
      open ASSIGNMENTS, ">$output_dir/$html_assignment_tree_big_file";
      print ASSIGNMENTS $assignments;
      close ASSIGNMENTS;
    }

    #---------------------------------------------------------------
    # HTML: output the solution tree (small) if there were any
    # solutions
    #
    if ( $count{'solution'}{'total'} > 0 ) {

      printstatus("Writing HTML solution tree (small)");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $solutions = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                    @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'solution'}{'tree_small'} }, @{ $html{'foot'} },
      );
      open SOLUTIONS, ">$output_dir/$html_solution_tree_small_file";
      print SOLUTIONS $solutions;
      close SOLUTIONS;
    }

    #---------------------------------------------------------------
    # HTML: output the allocation tree (small) if there were any
    # allocations
    #
    if ( $count{'allocation'}{'total'} > 0 ) {

      printstatus("Writing HTML allocation tree (small)");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $allocations = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                    @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'allocation'}{'tree_small'} }, @{ $html{'foot'} },
      );
      open ALLOCATIONS, ">$output_dir/$html_allocation_tree_small_file";
      print ALLOCATIONS $allocations;
      close ALLOCATIONS;
    }

    #---------------------------------------------------------------
    # HTML: output the assignment tree (small) if there were any
    # assignments
    #
    if ( $count{'assignment'}{'total'} > 0 ) {

      printstatus("Writing HTML assignment tree (small)");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $assignments = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                    @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'assignment'}{'tree_small'} }, @{ $html{'foot'} },
      );
      open ASSIGNMENTS, ">$output_dir/$html_assignment_tree_small_file";
      print ASSIGNMENTS $assignments;
      close ASSIGNMENTS;
    }

    #---------------------------------------------------------------
    # HTML: output the test tree (big) if there were any tests
    #
    if ( $count{'test'}{'total'} > 0 ) {

      printstatus("Writing HTML test tree (big)");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $tests = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },              @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'test'}{'tree_big'} }, @{ $html{'foot'} },
      );
      open TESTS, ">$output_dir/$html_test_tree_big_file";
      print TESTS $tests;
      close TESTS;
    }

    #---------------------------------------------------------------
    # HTML: output the test tree (small) if there were any tests
    #
    if ( $count{'test'}{'total'} > 0 ) {

      printstatus("Writing HTML test tree (small)");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $tests = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'test'}{'tree_small'} }, @{ $html{'foot'} },
      );
      open TESTS, ">$output_dir/$html_test_tree_small_file";
      print TESTS $tests;
      close TESTS;
    }

    #---------------------------------------------------------------
    # HTML: output the task tree (big) if there were any tasks
    #
    if ( $count{'task'}{'total'} > 0 ) {

      printstatus("Writing HTML task tree (big)");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $tasks = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },              @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'task'}{'tree_big'} }, @{ $html{'foot'} },
      );
      open TASKS, ">$output_dir/$html_task_tree_big_file";
      print TASKS $tasks;
      close TASKS;
    }

    #---------------------------------------------------------------
    # HTML: output the result tree (big) if there were any results
    #
    if ( $count{'result'}{'total'} > 0 ) {

      printstatus("Writing HTML result tree (big)");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $results = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'result'}{'tree_big'} }, @{ $html{'foot'} },
      );
      open RESULTS, ">$output_dir/$html_result_tree_big_file";
      print RESULTS $results;
      close RESULTS;
    }

    #---------------------------------------------------------------
    # HTML: output the role tree (big) if there were any roles
    #
    if ( $count{'role'}{'total'} > 0 ) {

      printstatus("Writing HTML role tree (big)");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $roles = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },              @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'role'}{'tree_big'} }, @{ $html{'foot'} },
      );
      open ROLES, ">$output_dir/$html_role_tree_big_file";
      print ROLES $roles;
      close ROLES;
    }

    #---------------------------------------------------------------
    # HTML: output the task tree (small) if there were any tasks
    #
    if ( $count{'task'}{'total'} > 0 ) {

      printstatus("Writing HTML task tree (small)");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $tasks = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'task'}{'tree_small'} }, @{ $html{'foot'} },
      );
      open TASKS, ">$output_dir/$html_task_tree_small_file";
      print TASKS $tasks;
      close TASKS;
    }

    #---------------------------------------------------------------
    # HTML: output the result tree (small) if there were any results
    #
    if ( $count{'result'}{'total'} > 0 ) {

      printstatus("Writing HTML result tree (small)");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $results = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                  @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'result'}{'tree_small'} }, @{ $html{'foot'} },
      );
      open RESULTS, ">$output_dir/$html_result_tree_small_file";
      print RESULTS $results;
      close RESULTS;
    }

    #---------------------------------------------------------------
    # HTML: output the role tree (small) if there were any roles
    #
    if ( $count{'role'}{'total'} > 0 ) {

      printstatus("Writing HTML role tree (small)");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $roles = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'role'}{'tree_small'} }, @{ $html{'foot'} },
      );
      open ROLES, ">$output_dir/$html_role_tree_small_file";
      print ROLES $roles;
      close ROLES;
    }

    #---------------------------------------------------------------
    # HTML: output the problem spreadsheet if there were any problems
    #
    if ( $count{'problem'}{'total'} > 0 ) {

      printstatus("Writing HTML problem spreadsheet");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $problems = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                    @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'problem'}{'spreadsheet'} }, @{ $html{'foot'} },
      );
      open PROBLEMS, ">$output_dir/$html_problem_spreadsheet_file";
      print PROBLEMS $problems;
      close PROBLEMS;
    }

    #---------------------------------------------------------------
    # HTML: output the solution spreadsheet if there were any solutions
    #
    if ( $count{'solution'}{'total'} > 0 ) {

      printstatus("Writing HTML solution spreadsheet");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $solutions = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                     @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'solution'}{'spreadsheet'} }, @{ $html{'foot'} },
      );
      open SOLUTIONS, ">$output_dir/$html_solution_spreadsheet_file";
      print SOLUTIONS $solutions;
      close SOLUTIONS;
    }

    #---------------------------------------------------------------
    # HTML: output the allocation spreadsheet if there were any allocations
    #
    if ( $count{'allocation'}{'total'} > 0 ) {

      printstatus("Writing HTML allocation spreadsheet");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $allocations = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                     @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'allocation'}{'spreadsheet'} }, @{ $html{'foot'} },
      );
      open ALLOCATIONS, ">$output_dir/$html_allocation_spreadsheet_file";
      print ALLOCATIONS $allocations;
      close ALLOCATIONS;
    }

    #---------------------------------------------------------------
    # HTML: output the assignment spreadsheet if there were any assignments
    #
    if ( $count{'assignment'}{'total'} > 0 ) {

      printstatus("Writing HTML assignment spreadsheet");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $assignments = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                     @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'assignment'}{'spreadsheet'} }, @{ $html{'foot'} },
      );
      open ASSIGNMENTS, ">$output_dir/$html_assignment_spreadsheet_file";
      print ASSIGNMENTS $assignments;
      close ASSIGNMENTS;
    }

    #---------------------------------------------------------------
    # HTML: output the test spreadsheet if there were any tests
    #
    if ( $count{'test'}{'total'} > 0 ) {

      printstatus("Writing HTML test spreadsheet");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $tests = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                 @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'test'}{'spreadsheet'} }, @{ $html{'foot'} },
      );
      open TESTS, ">$output_dir/$html_test_spreadsheet_file";
      print TESTS $tests;
      close TESTS;
    }

    #---------------------------------------------------------------
    # HTML: output the task spreadsheet if there were any tasks
    #
    if ( $count{'task'}{'total'} > 0 ) {

      printstatus("Writing HTML task spreadsheet");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $tasks = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                 @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'task'}{'spreadsheet'} }, @{ $html{'foot'} },
      );
      open TASKS, ">$output_dir/$html_task_spreadsheet_file";
      print TASKS $tasks;
      close TASKS;
    }

    #---------------------------------------------------------------
    # HTML: output the result spreadsheet if there were any results
    #
    if ( $count{'result'}{'total'} > 0 ) {

      printstatus("Writing HTML result spreadsheet");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $results = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                   @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'result'}{'spreadsheet'} }, @{ $html{'foot'} },
      );
      open RESULTS, ">$output_dir/$html_result_spreadsheet_file";
      print RESULTS $results;
      close RESULTS;
    }

    #---------------------------------------------------------------
    # HTML: output the role spreadsheet if there were any roles
    #
    if ( $count{'role'}{'total'} > 0 ) {

      printstatus("Writing HTML role spreadsheet");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $roles = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                 @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'role'}{'spreadsheet'} }, @{ $html{'foot'} },
      );
      open ROLES, ">$output_dir/$html_role_spreadsheet_file";
      print ROLES $roles;
      close ROLES;
    }

    #-----------------------------------------------------------------
    # HTML: output the problem priorities if there were any problems
    #
    if ( $count{'problem'}{'total'} > 0 ) {

      printstatus("Writing HTML problem priorities");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $problems = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                   @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'problem'}{'priorities'} }, @{ $html{'foot'} },
      );
      open PROBLEMS, ">$output_dir/$html_problem_priorities_file";
      print PROBLEMS $problems;
      close PROBLEMS;
    }

    #-----------------------------------------------------------------
    # HTML: output the solution priorities if there were any solutions
    #
    if ( $count{'solution'}{'total'} > 0 ) {

      printstatus("Writing HTML solution priorities");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $solutions = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                    @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'solution'}{'priorities'} }, @{ $html{'foot'} },
      );
      open SOLUTIONS, ">$output_dir/$html_solution_priorities_file";
      print SOLUTIONS $solutions;
      close SOLUTIONS;
    }

    #-----------------------------------------------------------------
    # HTML: output the allocation priorities if there were any allocations
    #
    if ( $count{'allocation'}{'total'} > 0 ) {

      printstatus("Writing HTML allocation priorities");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $allocations = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                    @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'allocation'}{'priorities'} }, @{ $html{'foot'} },
      );
      open ALLOCATIONS, ">$output_dir/$html_allocation_priorities_file";
      print ALLOCATIONS $allocations;
      close ALLOCATIONS;
    }

    #-----------------------------------------------------------------
    # HTML: output the assignment priorities if there were any assignments
    #
    if ( $count{'assignment'}{'total'} > 0 ) {

      printstatus("Writing HTML assignment priorities");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $assignments = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                    @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'assignment'}{'priorities'} }, @{ $html{'foot'} },
      );
      open ASSIGNMENTS, ">$output_dir/$html_assignment_priorities_file";
      print ASSIGNMENTS $assignments;
      close ASSIGNMENTS;
    }

    #---------------------------------------------------------------
    # HTML: output the test priorities if there were any tests
    #
    if ( $count{'test'}{'total'} > 0 ) {

      printstatus("Writing HTML test priorities");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $tests = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'test'}{'priorities'} }, @{ $html{'foot'} },
      );
      open TESTS, ">$output_dir/$html_test_priorities_file";
      print TESTS $tests;
      close TESTS;
    }

    #---------------------------------------------------------------
    # HTML: output the task priorities if there were any tasks
    #
    if ( $count{'task'}{'total'} > 0 ) {

      printstatus("Writing HTML task priorities");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $tasks = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'task'}{'priorities'} }, @{ $html{'foot'} },
      );
      open TASKS, ">$output_dir/$html_task_priorities_file";
      print TASKS $tasks;
      close TASKS;
    }

    #---------------------------------------------------------------
    # HTML: output the result priorities if there were any results
    #
    if ( $count{'result'}{'total'} > 0 ) {

      printstatus("Writing HTML result priorities");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $results = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                  @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'result'}{'priorities'} }, @{ $html{'foot'} },
      );
      open RESULTS, ">$output_dir/$html_result_priorities_file";
      print RESULTS $results;
      close RESULTS;
    }

    #---------------------------------------------------------------
    # HTML: output the role priorities if there were any roles
    #
    if ( $count{'role'}{'total'} > 0 ) {

      printstatus("Writing HTML role priorities");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $roles = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'role'}{'priorities'} }, @{ $html{'foot'} },
      );
      open ROLES, ">$output_dir/$html_role_priorities_file";
      print ROLES $roles;
      close ROLES;
    }

    #---------------------------------------------------------------
    # HTML: output the demo index if there were any demos
    #
    if ( $count{'demo'}{'total'} > 0 ) {

      printstatus("Writing HTML demo index");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $demos = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },           @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'demo'}{'index'} }, @{ $html{'foot'} },
      );
      open DEMOS, ">$output_dir/$html_demo_index_file";
      print DEMOS $demos;
      close DEMOS;
    }

    #---------------------------------------------------------------
    # HTML: output the exercise index if there were any exercises
    #
    if ( $count{'exercise'}{'total'} > 0 ) {

      printstatus("Writing HTML exercise index");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $exercises = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },               @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'exercise'}{'index'} }, @{ $html{'foot'} },
      );
      open EXERCISES, ">$output_dir/$html_exercise_index_file";
      print EXERCISES $exercises;
      close EXERCISES;
    }

    #---------------------------------------------------------------
    # HTML: output the listing index if there were any listings
    #
    if ( $count{'listing'}{'total'} > 0 ) {

      printstatus("Writing HTML listing index");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $listings = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },              @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'listing'}{'index'} }, @{ $html{'foot'} },
      );
      open LISTINGS, ">$output_dir/$html_listing_index_file";
      print LISTINGS $listings;
      close LISTINGS;
    }

    #---------------------------------------------------------------
    # HTML: output the todo index if there were any todo items
    #
    if ( $count{'todo'}{'total'} > 0 ) {

      printstatus("Writing HTML todo index");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $todos = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },           @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'todo'}{'index'} }, @{ $html{'foot'} },
      );
      open TODOS, ">$output_dir/$html_todo_index_file";
      print TODOS $todos;
      close TODOS;
    }

    #---------------------------------------------------------------
    # HTML: output the footnote index if there were any footnotes
    #
    if ( $count{'footnote'}{'total'} > 0 ) {

      printstatus("Writing HTML footnote index");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $footnotes = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },               @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'footnote'}{'index'} }, @{ $html{'foot'} },
      );
      open FOOTNOTES, ">$output_dir/$html_footnote_index_file";
      print FOOTNOTES $footnotes;
      close FOOTNOTES;
    }

    #---------------------------------------------------------------
    # HTML: output the table index if there were any tables
    #
    if ( $count{'table'}{'total'} > 0 ) {

      printstatus("Writing HTML list of tables");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $tables = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },            @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'table'}{'index'} }, @{ $html{'foot'} },
      );
      open TABLES, ">$output_dir/$html_table_index_file";
      print TABLES $tables;
      close TABLES;
    }

    #---------------------------------------------------------------
    # HTML: output the figure index if there were any figures
    #
    if ($count{'figure'}{'total'} > 0) {

      printstatus("Writing HTML list of figures");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $figures = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },             @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'figure'}{'index'} }, @{ $html{'foot'} },
      );
      open FIGURES, ">$output_dir/$html_figure_index_file";
      print FIGURES $figures;
      close FIGURES;
    }

    #---------------------------------------------------------------
    # HTML: output the attachment index if there were any attachments
    #
    if ($count{'attachment'}{'total'} > 0) {

      printstatus("Writing HTML list of attachments");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $attachments = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },                 @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'attachment'}{'index'} }, @{ $html{'foot'} },
      );
      open ATTACHMENTS, ">$output_dir/$html_attachment_index_file";
      print ATTACHMENTS $attachments;
      close ATTACHMENTS;
    }

    #---------------------------------------------------------------
    # HTML: output the source index if there were any sources
    #
    if ( $count{'source'}{'total'} > 0 ) {

      printstatus("Writing HTML list of sources");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $sources = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },             @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'source'}{'index'} }, @{ $html{'foot'} },
      );
      open SOURCES, ">$output_dir/$html_source_index_file";
      print SOURCES $sources;
      close SOURCES;
    }

    #---------------------------------------------------------------
    # HTML: output the glossary if there were any glossary entries
    #
    if ($count{'glossary'}{'total'} > 0) {

      printstatus("Writing HTML glossary");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $glossary = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },      @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'glossary'} }, @{ $html{'foot'} },
      );
      open GLOSSARY, ">$output_dir/$html_glossary_file";
      print GLOSSARY $glossary;
      close GLOSSARY;
    }

    #---------------------------------------------------------------
    # HTML: output the changelog if requested
    #
    if ( $option{'changelog'} ) {

      printstatus("Writing HTML changelog");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $changelog = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },       @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'changelog'} }, @{ $html{'foot'} },
      );
      open CHANGELOG, ">$output_dir/$html_changelog_file";
      print CHANGELOG $changelog;
      close CHANGELOG;
    }

    #---------------------------------------------------------------
    # HTML: output the acronyms file if there were any acronyms
    #
    if ($count{'acronym'}{'total'} > 0) {

      printstatus("Writing HTML acronyms");

      print '.' if not $option{'gui'} and not $option{'verbose'};

      my $acronym = join(
        $EMPTY_STRING,
        @{ $html{'head'} },     @{ $html{'nav'} },      @{ $html{'title'} },
        @{ $html{'preamble'} }, @{ $html{'acronym'} }, @{ $html{'foot'} },
      );
      open ACRONYM, ">$output_dir/$html_acronym_file";
      print ACRONYM $acronym;
      close ACRONYM;
    }

    #---------------------------------------------------------------
    # HTML: output javascript files
    #
    write_popimage_js();
    write_treetable_js();

  }

  #-----------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'}) {

    my $pdflatex       = $option{'pdflatex'};
    my $pdflatex_args  = $option{'pdflatex_args'};
    my $bibtex         = $option{'bibtex'};
    my $makeindex      = $option{'makeindex'};
    my $makeglossaries = $option{'makeglossaries'};

    #---------------------------------------------------------------
    # PDF: nonstopmode?
    #
    if ($option{'pdf_nonstop'}) {
      $pdflatex_args .= ' --interaction=nonstopmode';
    }

    #---------------------------------------------------------------
    # PDF: assemble parts of the LaTeX file
    #
    assemble_latex_head_array();
    assemble_latex_nav_array();
    assemble_latex_title_array();
    assemble_latex_changelog_array();
    assemble_latex_foot_array();

    #---------------------------------------------------------------
    # PDF: output the LaTeX document
    #
    printstatus("Writing LaTeX file");
    my $latex = join(
        $EMPTY_STRING,
        @latex_head,       @latex_title,
        @latex_nav,        @latex_cvsinfo,     @latex,
        @latex_acronym,    @latex_changelog,   @latex_foot,
    );
    open LATEX, ">$output_dir/$latex_file";
    print LATEX $latex;
    close LATEX;

    #---------------------------------------------------------------
    # PDF: output the PDF make file (Windows Batch File)
    #
    printstatus("Creating Windows batchfile (makepdf.bat) for running pdflatex");
    open MAKEFILE, ">$output_dir/makepdf.bat";
    print MAKEFILE <<"END_OF_TEXT";
$pdflatex $pdflatex_args $latex_file
$bibtex $output_file
$pdflatex $pdflatex_args $latex_file
$makeindex $index_file
$makeindex  -s "$output_file.ist" -t "$output_file.glg" -o "$output_file.gls" "$output_file.glo"
$pdflatex $pdflatex_args $latex_file
exit

END_OF_TEXT
    close MAKEFILE;

    #---------------------------------------------------------------
    # PDF: output the PDF make file (Unix Shell Script)
    #
    printstatus("Creating Bash script (makepdf.sh) for running pdflatex");
    open MAKEFILE, ">$output_dir/makepdf.sh";
    print MAKEFILE <<"END_OF_TEXT";
#!/bin/sh
$pdflatex $pdflatex_args $latex_file
$bibtex $output_file
$pdflatex $pdflatex_args $latex_file
$makeindex $index_file
$makeindex  -s "$output_file.ist" -t "$output_file.glg" -o "$output_file.gls" "$output_file.glo"
$pdflatex $pdflatex_args $latex_file

END_OF_TEXT
    close MAKEFILE;
  }

  #-----------------------------------------------------------------
  # Render XML
  #
  if ($rendering{'xml'}) {

    #---------------------------------------------------------------
    # XML: assemble the parts of the XML file
    #
    assemble_xml_head_array();
    assemble_xml_stylesheet();
    assemble_xml_dtd();
    assemble_xml_foot_array();

    #---------------------------------------------------------------
    # XML: output the XML document
    #
    printstatus("Writing XML document");
    my $document = join($EMPTY_STRING, @xml_head, @xml, @xml_foot);
    open XML, ">$output_dir/$xml_doc_file";
    print XML $document;
    close XML;

    #---------------------------------------------------------------
    # XML: output the XML stylesheet
    #
    printstatus("Writing XML stylesheet");
    my $stylesheet = join($EMPTY_STRING, @xml_stylesheet);
    open XML, ">$output_dir/$xml_stylesheet_file";
    print XML $stylesheet;
    close XML;

    #---------------------------------------------------------------
    # XML: output the XML dtd
    #
    printstatus("Writing XML dtd");
    my $dtd = join($EMPTY_STRING, @xml_dtd);
    open XML, ">$output_dir/$xml_dtd_file";
    print XML $dtd;
    close XML;
  }

  #-----------------------------------------------------------------
  # Render CSV.
  #
  if ($rendering{'csv'}) {

    #---------------------------------------------------------------
    # CSV: output the problem index if there were any
    # problems
    #
    # print "DEBUG: problem count: $count{'problem'}{'total'}\n";
    if ($count{'problem'}{'total'} > 0) {
      printstatus("Writing problems CSV file");
      my $problems = join($EMPTY_STRING, @{ $csv{'problem'} });
      open PROBLEMS, ">$output_dir/$csv_problem_index_file";
      print PROBLEMS $problems;
      close PROBLEMS;
    }

    #---------------------------------------------------------------
    # CSV: output the solution index if there were any solutions
    #
    # print "DEBUG: solution count: $count{'solution'}{'total'}\n";
    if ($count{'solution'}{'total'} > 0) {
      printstatus("Writing solutions CSV file");
      my $solutions = join($EMPTY_STRING, @{ $csv{'solution'} });
      open SOLUTIONS, ">$output_dir/$csv_solution_index_file";
      print SOLUTIONS $solutions;
      close SOLUTIONS;
    }

    #---------------------------------------------------------------
    # CSV: output the allocation index if there were any allocations
    #
    # print "DEBUG: allocation count: $count{'allocation'}{'total'}\n";
    if ($count{'allocation'}{'total'} > 0) {
      printstatus("Writing allocations CSV file");
      my $allocations = join($EMPTY_STRING, @{ $csv{'allocation'} });
      open ALLOCATIONS, ">$output_dir/$csv_allocation_index_file";
      print ALLOCATIONS $allocations;
      close ALLOCATIONS;
    }

    #---------------------------------------------------------------
    # CSV: output the assignment index if there were any assignments
    #
    # print "DEBUG: assignment count: $count{'assignment'}{'total'}\n";
    if ($count{'assignment'}{'total'} > 0) {
      printstatus("Writing assignments CSV file");
      my $assignments = join($EMPTY_STRING, @{ $csv{'assignment'} });
      open ASSIGNMENTS, ">$output_dir/$csv_assignment_index_file";
      print ASSIGNMENTS $assignments;
      close ASSIGNMENTS;
    }

    #---------------------------------------------------------------
    # CSV: output the test index if there were any tests
    #
    # print "DEBUG: test count: $count{'test'}{'total'}\n";
    if ($count{'test'}{'total'} > 0) {
      printstatus("Writing tests CSV file");
      my $tests = join($EMPTY_STRING, @{ $csv{'test'} });
      open TESTS, ">$output_dir/$csv_test_index_file";
      print TESTS $tests;
      close TESTS;
    }

    #---------------------------------------------------------------
    # CSV: output the task index if there were any tasks
    #
    # print "DEBUG: task count: $count{'task'}{'total'}\n";
    if ($count{'task'}{'total'} > 0) {
      printstatus("Writing tasks CSV file");
      my $tasks = join($EMPTY_STRING, @{ $csv{'task'} });
      open TASKS, ">$output_dir/$csv_task_index_file";
      print TASKS $tasks;
      close TASKS;
    }

    #---------------------------------------------------------------
    # CSV: output the result index if there were any results
    #
    # print "DEBUG: result count: $count{'result'}{'total'}\n";
    if ($count{'result'}{'total'} > 0) {
      printstatus("Writing results CSV file");
      my $results = join($EMPTY_STRING, @{ $csv{'result'} });
      open RESULTS, ">$output_dir/$csv_result_index_file";
      print RESULTS $results;
      close RESULTS;
    }

    #---------------------------------------------------------------
    # CSV: output the role index if there were any roles
    #
    # print "DEBUG: role count: $count{'role'}{'total'}\n";
    if ($count{'role'}{'total'} > 0) {
      printstatus("Writing roles CSV file");
      my $roles = join($EMPTY_STRING, @{ $csv{'role'} });
      open ROLES, ">$output_dir/$csv_role_index_file";
      print ROLES $roles;
      close ROLES;
    }

  }

  #-------------------------------------------------------------------
  # Render the raw text
  #
  printstatus("Writing TEXT document");
  my $text = join($EMPTY_STRING,@text);
  open TEXT, ">$output_dir/$text_out_file";
  print TEXT $text;
  close TEXT;

  #-------------------------------------------------------------------
  # Open the HTML document in a browser if you've rendered an HTML
  # rendition and the user wants to see it after publishing is
  # complete ($option{'launch_browser'})
  #
  if ($rendering{'html'} and $option{'launch_browser'}) {

    #-----------------------------------------------------------------
    # HTML: Display the HTML document just published.  If there were
    # headings display the table of contents, otherwise display the
    # document itself
    #
    printstatus("Launching web browser");

    if ($count{'section'}{'total'} > 0) {
      launch_browser("$output_dir/$html_toc_file");
    }

    elsif ( defined $html{'body'}{'1'} ) {
      launch_browser("$output_dir/$output_file-1.html");
    }

    else {
      launch_browser("$output_dir/$output_file-DEFAULT.html");
    }
  }

  #-------------------------------------------------------------------
  # Run the makepdf.bat batchfile if running on Windows, or makepdf.sh
  # if running on UNIX to render PDF using pdflatex.
  #
  if ($rendering{'pdf'}) {
    printstatus("Making PDF document using pdflatex");

    chdir($output_dir);

    if ($^O eq 'MSWin32') {
      `start makepdf.bat`;
    }

    else {
      system("bash ./makepdf.sh");
    }

    chdir($startdir);
  }

  #-------------------------------------------------------------------
  # Copy the PDF file if the rev_in_filename option is true
  #
  if ($option{'rev_in_filename'}) {

    my $version  = $document{'version'}  || '';
    my $revision = $document{'revision'} || '';
    my $modified = $document{'modified'} || 0;

    $version  = trim_whitespace($version);
    $revision = trim_whitespace($revision);

    my $string = '';

    if ($version and $revision) {
      $string = "v" . "$version" . "." . "$revision";
    }

    elsif ($revision) {
      $string = "r" . "$revision";
    }

    if ($modified) {
      $string .= "-CHANGES";
    }

    if ($string) {
      my $fromfile = "$output_dir/$output_file.pdf";
      my $tofile   = "$output_dir/$output_file.$string.pdf";
      File::Copy::copy("$fromfile","$tofile");
    }
  }

  #-------------------------------------------------------------------
  # Open the PDF document in a PDF viewer if you've rendered a PDF
  # rendition and the user wants to see it after publishing is
  # complete ($option{'launch_pdfview'})
  #
  if ($rendering{'pdf'} and $option{'launch_pdfview'}) {

    if ($^O eq 'MSWin32') {
      printstatus("launching PDF viewer");
      chdir $output_dir;
      system("start $output_file.pdf");
      chdir $startdir;
    }

  }

  #-------------------------------------------------------------------
  # Clean up temp files
  #
  cleanup_tempfiles();

  #-----------------------------------------------------------------
  # Change back to the original directory
  #
  chdir($startdir);

  #-----------------------------------------------------------------
  # Display page1 (the messages tab) and turn the "publish" button red
  # while publishing.
  #
  if ($option{'gui'}) {

    $b2->configure(
        -text             => 'Publish Document',
        -background       => 'green',
        -activebackground => 'green',
    );

    $main->update();
  }

  #-----------------------------------------------------------------
  # Tell the user that publishing is complete.
  #
  my $t1       = new Benchmark;
  my $td       = timediff($t1,$t0);
  my $duration = timestr($td,'nop');
  printstatus("publishing took: $duration");
  printstatus("PUBLISHING COMPLETE");

  #-------------------------------------------------------------------
  # Write Logs
  #
  printstatus("Writing log files");

  open LOG,      ">$output_dir/$LOG_FILE";
  foreach (@LOG_FILE) { print LOG };
  close LOG;

  open WARNINGS, ">$output_dir/$LOG_WARNINGS_FILE";
  foreach (@LOG_WARNINGS_FILE) { print WARNINGS };
  close WARNINGS;

  open ERRORS,   ">$output_dir/$LOG_ERRORS_FILE";
  foreach (@LOG_ERRORS_FILE) { print ERRORS };
  close ERRORS;

  open CHANGES,   ">$output_dir/$LOG_CHANGES_FILE";
  foreach (@LOG_CHANGES_FILE) { print CHANGES };
  close CHANGES;

  print "\n" if not $option{'gui'} and not $option{'verbose'};
}

######################################################################

sub display_gui {

  $main = MainWindow->new(
      -title => "Publish ($VERSION)",
  );
  $main->resizable(1,1);

  #-------------------------------------------------------------------
  # Frame: menubar
  #
  my $mb = $main->Frame()->pack(
      -side => 'top',
      -fill => 'x',
  );

  my $filemenu = [[Button=>'Exit',-command=>[\&menu_exit]]];

  my $f = $mb->Menubutton(
      -text      => "File",
      -underline => 0,
      -menuitems => $filemenu,
  )->pack(
      -side      => 'left',
  );

  my $helpmenu = [[Button=>'About',-command=>[\&menu_about]]];

  my $h = $mb->Menubutton(
      -text      => "Help",
      -underline => 0,
      -menuitems => $helpmenu,
  )->pack(
      -side      => 'right',
  );

  #-------------------------------------------------------------------
  # Frame: choose file and renditions
  #
  my $choices = $main->Frame;
  $choices->pack(
      -side => 'top',
      -pady => '6',
      -fill => 'x',
  );

  #-------------------------------------------------------------------
  # LabFrame: file picker
  #
  my $fp = $choices->LabFrame(
      -label     => 'Choose a file to publish',
      -labelside => 'acrosstop',
  )->pack(
      -side      => 'left',
      -anchor    => 'n',
  );

  #-------------------------------------------------------------------
  # browse button
  #
  $fp->Button(
      -text    => 'browse...',
      -command => \&choose_text_file,
  )->pack(
      -side    => 'left',
      -padx    => '4',
      -pady    => '4',
  );

  #-------------------------------------------------------------------
  # text entry area
  #
  $fp->Entry(
      -width        => '40',
      -textvariable => \$text_file,
  )->pack(
      -side         => 'left',
      -padx         => '4',
      -fill         => 'x',
  );

  #-------------------------------------------------------------------
  # LabFrame: rp = rendition picker (assume we're rendering the
  # DEFAULT_RENDITION)
  #
  $rendering{$DEFAULT_RENDITION} = 1;
  my $rp = $choices->LabFrame(
      -label     => 'Choose renditions to publish',
      -labelside => 'acrosstop',
  )->pack(
      -side      => 'left',
      -anchor    => 'n',
  );

  #-------------------------------------------------------------------
  # The rendition options are defined in this array of anonymous
  # arrays.
  #
  my @rendition_options = (
      [ 'HTML'  => 'html' ],
      [ 'PDF'   => 'pdf'  ],
      [ 'XML'   => 'xml'  ],
      [ 'CSV'   => 'csv'  ],
  );

  #-------------------------------------------------------------------
  # Make a checkbutton for each rendition option
  #
  foreach my $option (@rendition_options) {

    my $label     = $option->[0];
    my $rendition = $option->[1];

    $rp->Checkbutton(
      -text     => $label,
      -variable => \$rendering{$rendition},
    )->pack(
      -side     => 'left',
      -pady     => '4',
    );

  }

  #-------------------------------------------------------------------
  # notebook
  #
  $nb = $main->NoteBook()->pack(
      -side   => 'top',
      -expand => 'yes',
      -fill   => 'both',
  );

  $pg0 = $nb->add( 'page0', -label => 'Options'      );
  $pg2 = $nb->add( 'page2', -label => 'HTML Options' );
  $pg3 = $nb->add( 'page3', -label => 'PDF Options'  );
  $pg5 = $nb->add( 'page5', -label => 'XML Options'  );
  $pg1 = $nb->add( 'page1', -label => 'Messages'     );

  #-------------------------------------------------------------------
  # Options
  #
  my $oframe = $pg0->Frame()->pack(
      -side   => 'top',
      -fill   => 'both',
  );

  #-------------------------------------------------------------------
  # frame for content options
  #
  my $oframe1 = $pg0->LabFrame(
      -label     => 'Optional Content',
      -labelside => 'acrosstop',
  )->pack(
      -side      => 'left',
      -anchor    => 'n',
      -ipadx     => '10',
  );

  #-------------------------------------------------------------------
  # ignorable content
  #
  #     Build a list of ignorable content types by looking through the
  #     %structure array to see which ones are 'ignorable' (i.e. the
  #     ones the user can elect to ignore when publishing the
  #     document).
  #
  my @ignorable_content_types = ();
  foreach my $type (sort keys %structure) {
    my $ignorable = $structure{$type}{'ignorable'};
    if ($ignorable eq 'yes') {
      my $plural_name = $structure{$type}{'plural_name'};
      push @ignorable_content_types, [$plural_name => $type];
    }
  }

  #-------------------------------------------------------------------
  # make a checkbutton for each content option
  #
  foreach my $content_type (@ignorable_content_types) {

    my $label    = $content_type->[0];
    my $variable = $content_type->[1];

    $oframe1->Checkbutton(
        -text     => $label,
        -variable => \$option{$variable},
    )->pack(
        -anchor   => 'w',
    );

  }

  #-------------------------------------------------------------------
  # options frame document options
  #
  my $oframe2 = $pg0->LabFrame(
      -label     => 'Document Options',
      -labelside => 'acrosstop',
  )->pack(
      -side      => 'left',
      -anchor    => 'n',
      -ipadx     => '10',
  );

  #-------------------------------------------------------------------
  # Document options are defined in this array of anonymous arrays
  #
  my @document_options = (
      [ 'Title Page'              => 'titlepage'     ],
      [ 'Table of Contents'       => 'toc'           ],
      [ 'List of Revisions'       => 'revisions'     ],
      [ 'Recent Updates'          => 'updates'       ],
      [ 'List of Tables'          => 'lot'           ],
      [ 'List of Figures'         => 'lof'           ],
      [ 'List of Attachments'     => 'loa'           ],
      [ 'List of Listings'        => 'lolistings'    ],
      [ 'List of Slides'          => 'loslides'      ],
      [ 'List of Exercises'       => 'loexercises'   ],
      [ 'List of Demonstrations'  => 'lodemos'       ],
      [ 'List of Footnotes'       => 'lofootnotes'   ],
      [ 'List of To-Do Items'     => 'lotodo'        ],
      [ 'List of Problems'        => 'loproblems'    ],
      [ 'List of Solutions'       => 'losolutions'   ],
      [ 'List of Allocations'     => 'loallocations' ],
      [ 'List of Assignments'     => 'loassignments' ],
      [ 'List of Tests'           => 'lotests'       ],
      [ 'List of Tasks'           => 'lotasks'       ],
      [ 'List of Results'         => 'loresults'     ],
      [ 'List of Roles'           => 'loroles'       ],
      [ 'List of Sources'         => 'losources'     ],
      [ 'Glossary'                => 'glossary'      ],
      [ 'Acronyms'                => 'acronym'       ],
      [ 'Index'                   => 'index'         ],
      [ 'Changelog'               => 'changelog'     ],
  );

  #-------------------------------------------------------------------
  # make a checkbutton for each document option
  #
  foreach my $option (@document_options) {

    my $label    = $option->[0];
    my $variable = $option->[1];

    $oframe2->Checkbutton(
        -text     => $label,
        -variable => \$option{$variable},
    )->pack(
        -anchor   => 'w',
    );
  }

  #-------------------------------------------------------------------
  # options frame for other options
  #
  my $oframe3 = $pg0->LabFrame(
      -label     => 'Other Options',
      -labelside => 'acrosstop',
  )->pack(
      -side      => 'left',
      -anchor    => 'n',
      -ipadx     => '10',
  );

  #-------------------------------------------------------------------
  # Other options are defined in this array of anonymous arrays
  #
  my @other_options = (
      [ 'Draft copy?'                  => 'draft'            ],
      [ 'Number sections?'             => 'secnums'          ],
      [ 'Frontmatter list headings?'   => 'front_list_heads' ],
      [ 'Hide Data IDs?'               => 'hide_ids'         ],
      [ 'Resolve "generate" requests?' => 'generate'         ],
      [ 'Run requested scripts?'       => 'scripts'          ],
      [ 'Clean up temp files?'         => 'cleanup_files'    ],
      [ 'Verbose messages?'            => 'verbose'          ],
      [ 'Debugging mode?'              => 'debugging'        ],
  );

  #-------------------------------------------------------------------
  # make a checkbutton for each other option
  #
  foreach my $option (@other_options) {

    my $label    = $option->[0];
    my $variable = $option->[1];

    $oframe3->Checkbutton(
        -text     => $label,
        -variable => \$option{$variable},
    )->pack(
        -anchor   => 'w',
    );
  }

  #-------------------------------------------------------------------
  # HTML Options
  #
  my $hframe1 = $pg2->LabFrame(
      -label     => 'Styles',
      -labelside => 'acrosstop',
  )->pack(
      -side      => 'top',
      -fill      => 'x',
  );

  #-------------------------------------------------------------------
  # HTML Styles
  #
  my $hframe2 = $pg2->LabFrame(
      -label     => 'Options',
      -labelside => 'acrosstop',
  )->pack(
      -side      => 'top',
      -fill      => 'x',
  );

  #-------------------------------------------------------------------
  # PDF Options: font
  #
  $fontsize = $option{'pdf_fontsize'};
  $fontfam  = $option{'pdf_fontfam'};

  my $pframe1 = $pg3->LabFrame(
      -label     => 'Font',
      -labelside => 'acrosstop',
  )->pack(
      -side      => 'top',
      -fill      => 'x',
  );

  #-------------------------------------------------------------------
  # frame: select font size (10, 11 or 12)
  #
  my $pframe1_1 = $pframe1->Frame()->pack(
      -fill => 'x',
      -pady => 4,
  );

  my @fontsize_options = ( '10pt', '11pt', '12pt' );

  #-------------------------------------------------------------------
  # make a radio button for each font size option
  #
  foreach my $option (@fontsize_options) {

    $pframe1_1->Radiobutton(
      -text     => $option,
      -variable => \$fontsize,
      -value    => $option,
    )->pack(
      -side     => 'left',
    );

  }

  #-------------------------------------------------------------------
  # frame: select font family
  #
  my $pframe1_2 = $pframe1->Frame()->pack(
      -fill => 'x',
      -pady => 4,
  );

  #-------------------------------------------------------------------
  # Font family options are defined in this array of anonymous arrays
  #
  my @fontfam_options = (
      [ 'Computer Modern'    => 'computer_modern'  ],
      [ 'Times'              => 'times'            ],
      [ 'Bookman'            => 'bookman'          ],
      [ 'Chancery'           => 'chancery'         ],
      [ 'Charter'            => 'charter'          ],
      [ 'New Century'        => 'new_century'      ],
      [ 'Palatino'           => 'palatino'         ],
  );

  #-------------------------------------------------------------------
  # make a radiobutton for each font family option
  #
  foreach my $option (@fontfam_options) {

    my $label = $option->[0];
    my $value = $option->[1];

    $pframe1_2->Radiobutton(
        -text     => $label,
        -variable => \$fontfam,
        -value    => $value,
    )->pack(
        -side     => 'left',
    );

  }

  #-------------------------------------------------------------------
  # PDF Options: link color
  #
  $linkcolor = $option{'pdf_link_color'};

  my $pframe2 = $pg3->LabFrame(
      -label     => 'Link Color',
      -labelside => 'acrosstop',
  )->pack(
      -side      => 'top',
      -fill      => 'x',
  );

  #-------------------------------------------------------------------
  # frame: select link color
  #
  my $pframe2_1 = $pframe2->Frame()->pack(
      -fill => 'x',
      -pady => 4,
  );

  #-------------------------------------------------------------------
  # Link color options are defined in this array of anonymous arrays
  #
  my @link_color_options = (
      [ 'Black'    => 'black'  ],
      [ 'Blue'     => 'blue'   ],
      [ 'Red'      => 'red'    ],
  );

  #-------------------------------------------------------------------
  # make a radio button for each link color option
  #
  foreach my $option (@link_color_options) {

    my $label = $option->[0];
    my $value = $option->[1];

    $pframe2_1->Radiobutton(
        -text     => $label,
        -variable => \$linkcolor,
        -value    => $value,
    )->pack(
        -side     => 'left',
    );

  }

  #-------------------------------------------------------------------
  # PDF Options: margins
  #
  my @sides = ( 'left', 'right', 'top', 'bottom' );

  my $pframe3 = $pg3->LabFrame(
      -label     => 'Margin Sizes',
      -labelside => 'acrosstop',
  )->pack(
      -side      => 'top',
      -fill      => 'x',
  );

  #-------------------------------------------------------------------
  # frame: specify margins
  #
  my $pframe3_1 = $pframe3->Frame()->pack(
      -fill => 'x',
      -pady => 4,
  );

  #-------------------------------------------------------------------
  # make a text entry for each margin size
  #
  foreach my $side (@sides) {

    my $label = ucfirst $side;
    my $value = $margin{$side};

    $pframe3_1->Label(
        -text     => "$label: ",
    )->pack(
        -side     => 'left',
    );

    $pframe3_1->Entry(
        -textvariable => \$margin{$side},
        -width    => 4,
    )->pack(
        -side     => 'left',
    );

    $pframe3_1->Label(
        -text     => 'inches    ',
    )->pack(
        -side     => 'left',
    );

  }

  #-------------------------------------------------------------------
  # allowable font sizes, text justifications
  #
  my @sizes = ( 'tiny',     'scriptsize',   'footnotesize',
                'small',    'normalsize',
                'large',    'Large',        'LARGE',
                'huge',     'Huge',
              );

  my @justifications = ( 'left', 'center', 'right' );

  #-------------------------------------------------------------------
  # Messages Page
  #
  my $mframe = $pg1->Frame()->pack(
      -side   => 'top',
      -expand => 'yes',
      -fill   => 'both',
  );

  $messages = $mframe->Scrolled(
      'Text',
      -setgrid    => '1',
      -scrollbars => 'e',
  )->pack(
      -expand     => 'yes',
      -fill       => 'both',
  );

  $messages->configure(
      -state => 'disabled',
  );

  $messages->tagConfigure( 'status',  -foreground => 'black'   );
  $messages->tagConfigure( 'debug',   -foreground => 'blue'    );
  $messages->tagConfigure( 'warning', -foreground => 'orange'  );
  $messages->tagConfigure( 'error',   -foreground => 'red'     );

  #-------------------------------------------------------------------
  # Status frame
  #
  my $sframe = $main->Frame()->pack(
      -side => 'bottom',
      -fill => 'x',
  );

  #-------------------------------------------------------------------
  # Action button
  #
  $b2 = $sframe->Button(
      -text             => 'Publish Document',
      -command          => \&publish,
      -background       => 'green',
      -activebackground => 'green',
      -padx             => 4,
      -pady             => 4,
  )->pack(
      -side             => 'left',
      -padx             => '5',
      -pady             => '5',
  );

  #-------------------------------------------------------------------
  # Status label
  #
  $guistatus = $sframe->Label(
      -width  => '80',
      -anchor => 'w',
  )->pack(
      -side  => 'left',
  );

  printdebug("debugging") if $DEBUGGING;

  return $main;
}

######################################################################

sub menu_exit { $main->destroy };

######################################################################

sub menu_about {

  my $text = <<"END_OF_TEXT";
Publish

Copyright (c) 2003-2007, Don Johnson
Copyright (c) 2007, Futures, Inc
Copyright (c) 2008-2012, Don Johnson

drj826\@acm.org

END_OF_TEXT

  my $dialog = $main->Dialog(
      -title   => 'About...',
      -text    => "$text",
      -buttons => ["OK"],
  );
  $dialog->Show;
}

######################################################################

sub choose_text_file {

  my $types = [
               [ 'text files' =>   '.txt'    ],
               [ 'All files'  =>   '*'       ],
              ];

  $text_file = $main->getOpenFile(
      -filetypes => $types,
  );

  $main->update();
}

######################################################################

sub printmessage {

  my $text = shift;
  $text = trim_whitespace($text);

  push @LOG_FILE, "$text\n";

  #-------------------------------------------------------------------
  # If we're using the GUI, output the text to the messages widget.
  #
  if ($option{'gui'}) {
    $messages->configure(-state=>'normal');
    $messages->insert('end',$text . "\n",'status');
    $messages->yview('end');
    $messages->configure(-state=>'disabled');
    $main->update();
  }

  #-------------------------------------------------------------------
  # ...otherwise, print it to standard out.
  #
  else {
    print "\n$text";
  }

}

######################################################################

sub printstatus {

  my $text = shift;
  $text = trim_whitespace($text);

  push @LOG_FILE, "$text\n";

  #-------------------------------------------------------------------
  # Update the guistatus label widget if we're using the GUI
  #
  if ($option{'gui'}) {
    $guistatus->configure(-text=>$text);
    $main->update();

    #-----------------------------------------------------------------
    # Update the messages widget if we're producing verbose messages
    #
    if ($option{'verbose'}) {
      $messages->configure(-state=>'normal');
      $messages->insert('end',$text . "\n",'status');
      $messages->yview('end');
      $messages->configure(-state=>'disabled');
      $main->update();
    }
  }

  #-------------------------------------------------------------------
  # Print to standard out if we're being verbose and not using the GUI
  #
  elsif ($option{'verbose'}) {
    print "\n$text";
  }

}

######################################################################

sub printdebug {

  my $text = shift;
  $text = trim_whitespace($text);
  $text = remove_newlines($text);

  my $file = $current{'file'};
  my $line = $current{'line'};

  if ($option{'gui'}) {
    $messages->configure(-state=>'normal');
  }

  my $debug = "DEBUG: $file:$line: $text\n";
  push @LOG_FILE, "$debug\n";

  #-------------------------------------------------------------------
  # If we're using the GUI, output the text to the messages widget.
  #
  if ($option{'gui'}) {
    $messages->insert('end',$debug,'debug');
    $messages->yview('end');
    $messages->configure(-state=>'disabled');
    $main->update();
  }

  #-------------------------------------------------------------------
  # ...otherwise, print it to standard out.
  #
  else {
    print "\n$debug";
  }

}

######################################################################

sub printwarning {

  my $text = shift;
  $text = trim_whitespace($text);

  my $file = $current{'file'};
  my $line = $current{'line'};

  my $warning = "WARNING: $file:$line: $text";
  push @LOG_WARNINGS_FILE, "$warning\n";

  #-------------------------------------------------------------------
  # If we're using the GUI, output the text to the messages widget.
  #
  if ($option{'gui'}) {
    $messages->configure(-state=>'normal');
    $messages->insert('end',$warning,'warning');
    $messages->yview('end');
    $messages->configure(-state=>'disabled');
    $main->update();
  }

  #-------------------------------------------------------------------
  # ...otherwise, print it to standard out.
  #
  else {
    print "\n$warning";
  }

}

######################################################################

sub printerror {

  my $text = shift;
  $text = trim_whitespace($text);

  my $file = $current{'file'};
  my $line = $current{'line'};

  my $error = "ERROR: $file:$line: $text\n";
  push @LOG_ERRORS_FILE, "$error\n";

  #-------------------------------------------------------------------
  # If we're using the GUI, output the text to the messages widget.
  #
  if ($option{'gui'}) {
    $messages->configure(-state=>'normal');
    $messages->insert('end',$error,'error');
    $messages->yview('end');
    $messages->configure(-state=>'disabled');
    $main->update();
  }

  #-------------------------------------------------------------------
  # ...otherwise, print it to standard out.
  #
  else {
    print "\n$error";
  }

}

######################################################################

sub systemnw {

  # create a hidden process simpler version, but does not allow io
  # redirection
  #
  my ($cmd) = @_;             # must contain fullpath or be in current
                              # directoryextension must also be supplied

  if ($^O eq 'MWWin32') {
    my @cmd = split (" ", $cmd);
    my $ProcessObj;
    Win32::Process::Create(
        $ProcessObj,
        $cmd[0],
        $cmd,
        0,
        'NORMAL_PRIORITY_CLASS' | 'CREATE_NO_WINDOW',
        ".",
    ) || die ErrorReport();

    $ProcessObj->Wait('INFINITE');
  }

  else {
    system($cmd);
  }
}

######################################################################

sub ErrorReport {
  Win32::MsgBox(
    Win32::FormatMessage(
      Win32::GetLastError()
    ),
    16,
    'Error',
  );
}

######################################################################

sub pass_one {

  ####################################################################
  ####################################################################
  #
  # P1: resolve included content, gather file meta-data
  #
  ####################################################################
  ####################################################################

  #-------------------------------------------------------------------
  # RESOLVE INCLUDED CONTENT
  #
  #    This function is recursive.  You can include documents that
  #    include documents.  It combines all content into one array
  #    (@intext). This array is actually an array of arrays like:
  #
  #      @intext =
  #      [
  #        ["mainfile.txt",0,0,"line 0 of mainfile.txt"],
  #        ["mainfile.txt",0,1,"line 1 of mainfile.txt"],
  #        ["mainfile.txt",0,2,"line 2 of mainfile.txt"],
  #        ["mainfile.txt",0,3,"line 3 of mainfile.txt"],
  #        ["mainfile.txt",0,4,"line 4 of mainfile.txt"],
  #        ["mainfile.txt",0,5,"line 5 of mainfile.txt"],
  #        ["mainfile.txt",0,6,"include: files/subfile.txt"],
  #        ["mainfile.txt,files/subfile.txt",1,0,"line 0 of subfile.txt"],
  #        ["mainfile.txt,files/subfile.txt",1,1,"line 1 of subfile.txt"],
  #        ["mainfile.txt",0,7,"include: subfile.txt"],
  #        ["mainfile.txt",0,8,"include: subfile.txt"],
  #      ]
  #
  #    As you can see, each sub-array has four elements: (1) the file
  #    being read, (2) the current nesting level, (3) the number of
  #    the current line in this file (count starts at 0), and (3) the
  #    text of the line.
  #
  #    The reason for going to all this trouble is to maintain a
  #    context so that if you find an error in the input you can give
  #    the author an informative error message like:
  #
  #      error at line 1 at mainfile.txt > files/subfile.txt...
  #            section begins inside table
  #
  #-------------------------------------------------------------------
  # GATHER FILE META-DATA
  #
  #-------------------------------------------------------------------
  # Error Checking
  #
  #     The following errors need to be identified in pass one:
  #
  #     [ ] 'insert_gen_content:' reserved for internal use
  #
  #-------------------------------------------------------------------
  # SUBROUTINE OUTLINE
  #
  # 2 1  IF debugging
  # 4    1  Print debugging message "begin pass 1 of 3"
  # 2 2  Print message "pass 1 of 3 assembling document parts"
  # 2 3  Resolve included files in main document file
  # 2 4  IF debugging
  # 4    1  Print debugging message "end pass 1"
  #
  #-------------------------------------------------------------------

  #-------------------------------------------------------------------
  # P1: 1 - IF debugging
  #
  if ($DEBUGGING) {

    #-----------------------------------------------------------------
    # P1: 1.1 - Print debugging message "begin pass 1 of 3"
    #
    my $text = <<"END_OF_TEXT";
------------------------------------------------------------
BEGIN PASS 1 of 3
------------------------------------------------------------

END_OF_TEXT

    printdebug($text);
  }

  #-------------------------------------------------------------------
  # P1: 2 - Print message "Pass 1 of 3 assembling document parts"
  #
  printmessage("[$text_file->$renditions] Pass 1 of 3 assembling document parts");

  #-------------------------------------------------------------------
  # P1: 3 - Resolve included file in main document file
  #
  my $vars = [];
  resolve_includes($text_file,$vars);
  @intext  = @outtext;
  @outtext = ();

  #-------------------------------------------------------------------
  # P1: 4 - IF debugging
  #
  if ($DEBUGGING) {

    #-----------------------------------------------------------------
    # P1: 4.1 - Print debugging message "end pass 1"
    #
    my $text = <<"END_OF_TEXT";
------------------------------------------------------------
END PASS 1
------------------------------------------------------------

END_OF_TEXT

    printdebug($text);
  }
}

######################################################################

sub pass_two {

  ####################################################################
  ####################################################################
  #
  # P2: assemble generated text and gather data
  #
  ####################################################################
  ####################################################################
  #
  #    The purpose of pass 2 is to:
  #
  #    - gather data from the preamble, text, regions, environments
  #
  #    - count things
  #
  #    - gather table size metrics
  #
  #    - make a list of generate and script content requests
  #
  #    - insert generated content from the previous pass
  #
  #    - insert script output from the previous pass
  #
  #    - collect information about sections (%section)
  #
  #        $section{$section}{'previous'}
  #        $section{$section}{'next'}
  #        $section{$section}{'label'}
  #
  #    IMPORTANT: This subroutine is called repeatedly (but not
  #    recursively) because generated content or the output of scripts
  #    can insert additional 'generate:' or 'script:' lines.
  #
  #-------------------------------------------------------------------
  # PARSING ORDER
  #
  #     As the file is parsed line-by-line, each line must be checked
  #     for the following things in order:
  #
  #         1  Comment block marker
  #         2  Conditional block marker
  #         3  Begin region marker
  #         4  End region marker
  #         5  Environment marker
  #         6  Begin any data element
  #         7  Blank line ending any data element
  #         8  Continuation of any data element
  #
  #-------------------------------------------------------------------
  # SUBROUTINE OUTLINE
  #
  # 2  1  IF debugging
  # 4     1  Print debugging message "begin pass 2 of 3"
  # 2  2  Print progress message
  # 2  3  Initialize data structures
  # 2  4  Initialize 'current' state
  # 2  5  Push current name, label, and title on stacks
  # 2  6  Initialize 'in' state
  # 2  7  Initialize output text array
  #
  # Process each line of the intext array
  #
  # 2  8  FOR each LINE in intext array
  # 4     1  Break out the four line elements
  # 4     2  Initialize 'line' variable
  # 4     3  Print debugging message
  # 4     4  Current file, name, num, type
  # 4     5  Count markup in line
  #
  # Comment block
  #
  # 4     6  IF line is a comment block marker
  # 6        1  IF already in comment block
  # 8           1  Print debug message 'end comment block'
  # 8           2  Set state in comment block = 0
  # 6        2  ELSE not already in comment block
  # 8           1  Print debug message 'begin comment block'
  # 8           2  Set state in comment block = 1
  # 8           3  End any data element
  # 6        3  Push line onto outtext array
  # 6        4  next LINE
  # 4     7  ELSIF line is comment or in comment block
  # 6        1  Print debug message 'comment line'
  # 6        2  Push line onto outtext array
  # 6        3  next LINE
  #
  # Conditional block
  #
  # 4     8  ELSIF line is conditional block marker
  # 6        1  Parse comma separated list of conditionals
  # 6        2  FOREACH conditional
  # 8            1  IF in conditional block, exit
  # 10              1  Print debug message 'end conditional block'
  # 10              2  Set state in conditional = 0
  # 8            2  ELSE not in conditional block, enter
  # 10              1  Print debug message 'begin conditional block'
  # 10              2  Set state in conditional = 1
  # 10              3  End any data element
  # 6        3  Push line onto outtext array
  # 6        4  next LINE
  #
  ####################################################################
  # Begin graft from resolve_includes()
  ####################################################################
  #
  # Found One-line Include Directive
  #
  # 4    --  ELSIF line is a one-line include directive
  # 6        1  Parse one-line include directive
  # 6        2  Print debugging message
  # 6        3  FOREACH attr in list of include attributes
  # 8           1  Skip if this is a revision attribute
  # 8           2  Add this attr to the include_attrs hash
  # 6        4  Initialize the region marker
  # 6        5  Initialize the array for passing variables
  # 6        6  FOREACH attr in include_attrs hash
  # 8           1  FOREACH region name
  # 10             1  IF attr equals name
  # 12                1  set region marker for this level to name
  # 8           2  Initialize include_as_section for next level
  # 8           3  IF include attr is asterisks
  # 10             1  Remember section depth for next level
  # 10             2  Clear region_marker
  # 8           4  ELSIF include attr is 'hide'
  # 10             1  Set hide marker for this level to 1
  # 8           5  ELSIF include attr is 'raw'
  # 10             1  Set raw marker for next level to 1
  # 8           6  ELSIF include attr is a variable
  # 10             1  Parse variable name and value
  # 10             2  Push the name/value pair onto the array
  # 6        7  IF region_marker is set for this level
  # 8           1  Set region_baton to region_marker for this level
  # 6        8  IF included file is readable
  # 8           1  IF include as hidden
  # 10             1  Insert begin hide marker
  # 10             2  Print debugging message
  # 10             3  IF include as region
  # 12                1  Prepare region begin and end markers
  # 12                2  Insert begin region marker
  # 12                3  Print debugging message
  # 12                4  Recurse
  # 12                5  Insert end region marker
  # 12                6  Print debugging message
  # 10             4  ELSE not include as region
  # 12                1  Recurse
  # 10             5  Insert end hide marker
  # 8           2  ELSIF include as region
  # 10             1  Prepare region begin and end markers
  # 10             2  Add begin region marker
  # 10             3  Print debugging message
  # 10             4  recurse
  # 10             5  Add end region marker
  # 10             6  Print debugging message
  # 8           3  ELSE Include as a section
  # 10             1  Recurse
  # 6        9  ELSE included file is NOT readable, warn user
  # 8           1  Warn user
  # 8           2  Put line in outtext data structure
  #
  # Found Include Environment Marker
  #
  # 4    --  ELSIF line is include environment marker
  # 6        1  IF not in include environment
  # 8           1  Set in include environment flag
  # 8           2  Initialize data datastructure
  # 8           3  Print debugging message
  # 6        2  ELSE in include enviroment
  # 8           1  Set state in include environment = 0
  # 8           2  Print debugging message
  # 8           3  Get included file name
  # 8           4  Initialize anonymous variable passing array
  # 8           5  FOREACH variable to be passed
  # 10             1  IF variable is well formed
  # 12                1  Trim whitespace around key
  # 12                2  Trim whitespace around value
  # 12                3  Push key/value pair onto 'vars' array
  # 10             2  ELSE incorrect variable syntax
  # 12                1  Print error
  # 8           6  Initialize region variable
  # 8           7  IF region is true
  # 10             1  Set region marker for this nesting level
  # 8           8  Initialize 'include_as_section' for next level
  # 8           9  Get 'section' inclusion variable
  # 8          10  IF this file should be included as a section
  # 10             1  Set 'include_as_section' next level
  # 10             2  Initialize region_marker for this nesting level
  # 8          11  Get 'hide' inclusion variable
  # 8          12  IF this included file should be hidden
  # 10             1  Set hide marker for this nesting level = 1
  # 8          13  Get 'raw' inclusion variable
  # 8          14  IF this file should be included 'raw'
  # 10             1  Set raw marker for next level = 1
  # 8          15  IF region_marker is set for this level
  # 10             1  Set region_baton to that region marker
  # 8          16  IF included file is readable
  # 10             1  IF include as hidden
  # 12                1  Insert begin hide marker
  # 12                2  Print debugging message
  # 12                3  IF include as region
  # 14                   1  Prepare region begin and end markers
  # 14                   2  Insert begin region marker
  # 14                   3  Print debugging message
  # 14                   4  Recursively call resolve_includes()
  # 14                   5  Insert end region marker
  # 14                   6  Print debugging message
  # 12                4  ELSE not include as region
  # 14                   1  Recursively call resolve_includes()
  # 12                5  Insert end hide marker
  # 12                6  Print debugging message
  # 10             2  ELSIF include as region
  # 12                1  Prepare region begin and end markers
  # 12                2  Insert begin region marker
  # 12                3  Print debugging message
  # 12                4  Recursively call resolve_includes()
  # 12                5  Insert end region marker
  # 12                6  Print debugging message
  # 10             3  ELSE include as section
  # 8          17  ELSE included file is not readable
  # 10             1  Print warning "included file is not readable"
  # 10             2  Put line in outtext data structure
  #
  # Already In Include Environment
  #
  # 4    --  ELSIF in include environment
  # 6        1  FOREACH allowed data element
  # 8           1  Initialize is_multivalued to 0
  # 8           2  IF allowed data element may be multivalued
  # 10             1  Set is_multivalued to 1
  # 8           3  IF beginning of data element
  # 10              1  Parse first line of data element
  # 10              2  FOREACH other allowed element
  # 12                 1  No longer in this other element
  # 10              3  Remember that we're in current element
  # 10              4  IF is_multivalued
  # 12                 1  Push line onto array in data structure
  # 10              5  ELSE not multivalued
  # 12                 1  Place in scalar in data structure
  # 10              6  next LINE
  # 8           4  ELSIF already in data element and line not blank
  # 10              1  Prepare line
  # 10              2  IF is_multivalued
  # 12                 1  Push line onto array in data structure
  # 10              3  ELSE not multivalued
  # 12                 1  Place in scalar in data structure
  # 10              4  next LINE
  # 8           5  ELSIF already in data element and line IS blank
  # 10              1  FOREACH other allowed element
  # 12                 1  No longer in this other element
  #
  ####################################################################
  # End graft from resolve_includes()
  ####################################################################
  #
  # Begin region
  #
  # 4     9  ELSIF line is begin region marker
  # 6        1  Remember region marker (region name)
  # 6        2  IF this marker is an unknown region name
  # 8           1  Print unknown region name error
  # 6        3  In preamble text = 0
  # 6        4  End any data element
  # 6        5  In specific region preamble = 1
  # 6        6  In region preamble = 1
  # 6        7  Current table column = 0
  # 6        8  No longer in any environment
  # 6        9  Remember we're in a region named $marker
  # 6       10  Remeber the current type is 'region'
  # 6       11  Increment region counts: section, total, last
  # 6       12  IF current topnum is true
  # 8           1  Construct current number using topnum and section count
  # 6       13  ELSE current topnum is not true
  # 8           1  Construct current number using only section count
  # 6       14  Construct temporary fake label and title
  # 6       15  Remember current name, label, and title
  # 6       16  Push values onto name, label, and title stacks
  # 6       17  Remember current secnum in data structure
  # 6       18  Print debug message
  # 6       19  Push line onto outtext array
  # 6       20  next LINE
  #
  # End region
  #
  # 4    10  ELSIF line is end region marker
  # 6        1  Remember region marker (region name)
  # 6        2  IF this marker is an unknown region name
  # 8           1  Print unknown region name error
  # 6        3  End any data element
  # 6        4  Reset table column and row counts to 0
  # 6        5  IF currently in region denoted by marker
  # 8           1  Set state: in marker region = 0
  # 8           2  Pop values from name, label, and title stacks
  # 8           3  Remember current name, label and title
  # 8           4  Revert name and type to previous context
  # 6        6  ELSE not currently in region denoted by marker
  # 8           1  Print error message 'not in marker region'
  # 6        7  Print debug message 'P2 end of region'
  # 6        8  Push line onto outtext array
  # 6        9  next LINE
  #
  # Begin or end environment
  #
  # 4    11  ELSIF line is environment marker
  # 6        1  Remember environment marker (environment name)
  # 6        2  IF this marker is an unknown environment name
  # 8           1  Print unknown environment name error
  # 6        3  Set state: in preamble text = 0
  # 6        4  End any data element
  # 6        5  Set current table column and row to 0
  # 6        6  IF not currently in marker environment
  # 8           1  Print debugging message
  # 8           2  No longer in any environment
  # 8           3  Set state: in this environment = 1
  # 8           4  Set state: current type = environment
  # 8           5  Increment marker counts: section, total, last
  # 8           6  IF current topnum is true
  # 10             1  Construct current number using topnum and section count
  # 8           7  ELSE current topnum is not true
  # 10             1  Construct current number using only section count
  # 8           8  Construct temporary fake label and title
  # 8           9  Remember current name, label, title
  # 8          10  Push values onto name, label, title stacks
  # 8          11  Store current secnum in data structure
  # 8          12  Print debugging message
  # 6        7  ELSE currently in marker environment
  # 8           1  Print debugging message
  # 8           2  Set state: in marker environment = 0
  # 8           3  Pop stacks: name, label, title
  # 8           4  Remember current name, label, title
  # 8           5  Revert to previous context
  # 6        8  Push line onto outtext array
  # 6        9  next LINE
  #
  ####################################################################
  # LOOK FOR BEGINNING OF DATA ELEMENTS
  ####################################################################
  #
  # Begin 'file' data element
  #
  # 4    12  ELSIF line is file data element
  # 6        1  Get file name
  # 6        2  End any data element
  # 6        3  Set state: in file = 1
  # 6        4  Publish file
  # 6        5  Increment count: file total
  # 6        6  Print debugging message
  # 6        7  Push line onto outtext array
  # 6        8  next LINE
  #
  # Begin 'generate' data element
  #
  # 4    13  ELSIF line is a 'generate' directive
  # 6        1  Parse 'generate' directive
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Set state: in generate = 1
  # 6        5  Increment count: generate total
  # 6        6  IF 'generate' request is not valid
  # 8           1  Print warning
  # 8           2  Comment out the line
  # 8           3  Push line onto outtext array
  # 8           4  next LINE
  # 6        7  ELSE 'generate' request is valid
  # 8           1  Get current label
  # 8           2  Set state: to_be_generated name, label, args = 1
  # 8           3  Change line to 'insert_gen_content'
  # 8           4  Push line onto outtext array
  # 8           5  next LINE
  #
  # Begin 'insert' data element
  #
  # 4    14  ELSIF line is an 'insert' directive
  # 6        1  Parse 'insert' directive
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Set state: in insert = 1
  # 6        5  Increment count: insert total
  # 6        6  IF 'insert' directive is NOT valid
  # 8           1  Print warning
  # 8           2  Comment out the line
  # 8           3  Push line onto outtext array
  # 8           4  next LINE
  # 6        7  ELSE 'insert' directive is valid
  # 8           1  Get current label
  # 8           2  Change line to 'insert_ins_content'
  # 8           3  Push line onto outtext array
  # 8           4  next LINE
  #
  # Begin 'script' data element
  #
  # 4    15  ELSIF line is a 'script' directive
  # 6        1  Parse 'script' directive
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Set state: in script = 1
  # 6        5  Increment count: script total
  # 6        6  IF option 'scripts'
  # 8           1  IF OS is Windows
  # 10             1  Replace forward slashes with backslashes
  # 8           2  Print debugging message
  # 8           3  Execute requested script
  # 8           4  IF 'hide' attribute NOT passed
  # 10             1  FOREACH line of script output
  # 12                1  Push line onto outtext array
  # 10             2  Next LINE
  # 8           5  ELSE 'hide' attribute passed
  # 10             1  Push line onto outtext array
  # 10             2  Next LINE
  # 6        7  ELSE 'scripts' are disabled
  # 8           1  Print debugging message 'ignoring script'
  # 8           2  Construct preformatted notification
  # 8           3  FOREACH line of the preformatted notification
  # 10             1  Push line onto outtext array
  # 8           4  Next LINE
  #
  # Begin 'insert_gen_content' data element
  #
  # 4    16  ELSIF line is 'insert_gen_content' directive
  # 6        1  Parse request
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Print status message
  # 6        5  Initialize text variable
  # 6        6  IF generated text is context sensitive
  # 8           1  Retrieve previously generated content
  # 6        7  ELSE generated text is NOT context sensitive
  # 8           1  Retrieve previously generated content w/ args
  # 6        8  Split content into lines
  # 6        9  FOREACH line of generated content
  # 8           1  Push line onto outtext array
  # 6       10  Next LINE
  #
  # Begin 'insert_ins_content' data element
  #
  # 4    17  ELSIF line is 'insert_ins_content' directive
  # 6        1  Parse request
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Print status message
  # 6        5  Retrieve inserted content
  # 6        6  Split content into lines
  # 6        7  FOREACH line of inserted content
  # 8           1  Push line onto outtext array
  # 6        8  Next LINE
  #
  # Begin 'image' data element
  #
  # 4    18  ELSIF line begins 'image' data element
  # 6        1  Get image filename
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Set state: in image = 1
  # 6        5  Publish image
  # 6        6  Increment count: image total
  # 6        7  Push line onto outtext array
  # 6        8  Next LINE
  #
  # Begin 'footnote' data element
  #
  # 4    19  ELSIF begin 'footnote' data element
  # 6        1  Get footnote text
  # 6        2  End any data element
  # 6        3  Set state: in footnote = 1
  # 6        4  Increment count: footnote total
  # 6        5  Store text to footnote array
  # 6        6  Print debugging message
  # 6        7  Push line onto outtext array
  # 6        8  Next LINE
  #
  # Begin 'glossary' data element
  #
  # 4    20  ELSIF begin 'glossary' data element
  # 6        1  Parse glossary term and text
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Set state: in glossary = 1
  # 6        5  Increment count: glossary total
  # 6        6  Remember current glossary term
  # 6        7  Store text of glossary term definition
  # 6        8  IF the term contains an ampersand
  # 8           1  Replace ampersand with ' and '
  # 8           2  Store text of glossary term definition
  # 6        9  Push line onto outtext array
  # 6       10  Next LINE
  #
  # Begin 'var' data element
  #
  # 4    21  ELSIF begin 'var' data element
  # 6        1  Parse variable name and value
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Set state: in var = 1
  # 6        5  Increment count: var total
  # 6        6  Remember current variable name
  # 6        7  Store variable name/value in data structure
  # 6        8  Push line onto outtext array
  # 6        9  Next LINE
  #
  # Begin 'acronym' data element
  #
  # 4    22  ELSIF begin 'acronym' data element
  # 6        1  Parse term and text
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Set state: in acronym = 1
  # 6        5  Increment count: acronym total
  # 6        6  Remember current acronym
  # 6        7  Store acronym text in data structure
  # 6        8  Push line onto outtext array
  # 6        9  Next LINE
  #
  # Begin 'index' data element
  #
  # 4    23  ELSIF begin 'index' data element
  # 6        1  Parse index attributes and text
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Set state: in index = 1
  # 6        5  Increment count: index total
  # 6        6  Split index entries by semi-colon
  # 6        7  FOREACH index entry in list of entries
  # 8           1  Increment index entry count in data structure
  # 6        8  Push line onto outtext array
  # 6        9  Next LINE
  #
  # Begin 'outcome' data element
  #
  # 4    24  ELSIF begin 'outcome' data element
  # 6        1  Parse attributes and text
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Set state: in outcome = 1
  # 6        5  Increment count: outcome total
  # 6        6  Initialize date, item, and status values
  # 6        7  IF attribute syntax is correct
  # 8           1  Parse date, item, and status
  # 6        8  ELSE attribute syntax is NOT correct
  # 8           1  print error 'outcome attribute syntax not correct'
  # 6        9  Remember current outcome item and date
  # 6       10  Store this outcome in outcomes data structure
  # 6       11  Push line onto outtext array
  # 6       12  Next LINE
  #
  # Begin 'review' data element
  #
  # 4    25  ELSIF begin 'review' data element
  # 6        1  Parse attributes and text
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Set state: in review = 1
  # 6        5  Increment count: review total
  # 6        6  Initialize date, item, and status values
  # 6        7  IF attribute syntax is correct
  # 8           1  Parse date, item, and status
  # 6        8  ELSE attribute syntax is NOT correct
  # 8           1  Print error 'review attribute syntax not correct'
  # 6        9  Remember current review item and date
  # 6       10  Store this review in reviews data structure
  # 6       11  Push line onto outtext array
  # 6       12  Next LINE
  #
  # Begin 'step' data element
  #
  # 4    26  ELSIF begin 'step' data element
  # 6        1  Print debugging message
  # 6        2  End any data element
  # 6        3  Set state: in step = 1
  # 6        4  Increment count: step total
  # 6        5  Push line onto outtext array
  # 6        6  Next LINE
  #
  # Begin 'label' data element
  #
  # 4    27  ELSIF begin 'label' data element
  # 6        1  Parse label
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Set state: in label = 1
  # 6        5  Remember previous label
  # 6        6  Set the current label
  # 6        7  Increment count: label total
  # 6        8  Replace top label on label stack
  # 6        9  Store label in data structure
  # 6       10  Print detailed debugging message
  # 6       11  Store data in label data structure
  # 6       12  Push line onto outtext array
  # 6       13  Next LINE
  #
  # Begin 'title' data element
  #
  # 4    28  ELSIF begin 'title' data element
  # 6        1  Parse title
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Set current title
  # 6        5  Set state: in title = 1
  # 6        6  Increment count: title total
  # 6        7  Replace top title on title stack
  # 6        8  Store title in data structure
  # 6        9  Push line onto outtext array
  # 6       10  Next LINE
  #
  # Begin 'date' data element
  #
  # 4    29  ELSIF line begins 'date' element
  # 6        1  Parse date
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Strip any change control keywords
  # 6        5  Set state: in date = 1
  # 6        6  Increment count: date total
  # 6        7  Store date in data structure
  # 6        8  Push line onto outtext array
  # 6        9  Next LINE
  #
  # Begin 'revision' data element
  #
  # 4    30  ELSIF line begins 'revision' element
  # 6        1  Parse revision
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Strip any change control keywords
  # 6        5  Set state: in revision = 1
  # 6        6  Increment count: revision total
  # 6        7  Store revision in data structure
  # 6        8  Push line onto outtext array
  # 6        9  Next LINE
  #
  # Begin 'author' data element
  #
  # 4    31  ELSIF line begins 'author' element
  # 6        1  Parse author
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Strip any change control keywords
  # 6        5  Set state: in author = 1
  # 6        6  Increment count: author total
  # 6        7  IF element may be multivalued
  # 8           1  Store author in data structure array
  # 6        8  ELSE element must be a scalar
  # 8           1  Store author in data structure scalar
  # 6        9  Push line onto outtext array
  # 6       10  Next LINE
  #
  # Begin 'type' data element
  #
  # 4    32  ELSIF line begins 'type' element
  # 6        1  Parse type
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Set state: in type = 1
  # 6        5  Increment count: type total
  # 6        6  IF element may be multivalued
  # 8           1  Store type in data structure array
  # 6        7  ELSE element must be a scalar
  # 8           1  Store type in data structure scalar
  # 6        8  IF in section
  # 8           1  Get current label
  # 8           2  Store sectype in label data structure
  # 6        9  Push line onto outtext array
  # 6       10  Next LINE
  #
  # Begin 'use_formal_status' data element
  #
  # 4    33  ELSIF line begins 'use_formal_status' element
  # 6        1  Parse use_formal_status
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Set state: in use_formal_status = 1
  # 6        5  Increment count: use_formal_status total
  # 6        6  IF use_formal_status value is 1
  # 8           1  Store value (1) in document data structure
  # 8           2  Store value (1) in option data structure
  # 6        7  ELSIF use_formal_status value is 0
  # 8           1  Store value (0) in document data structure
  # 8           2  Store value (0) in option data structure
  # 6        8  ELSE value is neither 1 or 0
  # 8           1 Print error 'value must be 1 or 0'
  # 6        9  Push line onto outtext array
  # 6       10  Next LINE
  #
  # Begin 'effort_units' data element
  #
  # 4    34  ELSIF line begins 'effort_units' element
  # 6        1  Parse effort_units
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Set state: in effort_units = 1
  # 6        5  Increment count: effort_units total
  # 6        6  Store value in document data structure
  # 6        7  Store value in option data streucture
  # 6        8  Push line onto outtext array
  # 6        9  Next LINE
  #
  # Begin 'column' data element
  #
  # 4    35  ELSIF line begins 'column' data element
  # 6        1  Parse attributes and value
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Set state: in column = 1
  # 6        5  IF not in a table
  # 8           1  Print error 'column parameter found outside table'
  # 8           2  Push line onto outtext array
  # 8           3  Next LINE
  # 6        6  Initialize column and param values
  # 6        7  IF attributes have correct syntax
  # 8           1  Remember column and param values
  # 6        8  ELSE attributes do NOT have correct syntax
  # 8           1  Print error 'column parameter syntax error'
  # 8           2  Push line onto outtext array
  # 8           3  Next LINE
  # 6        9  Get current table number
  # 6       10  IF parameter is column 'width'
  # 8           1  Value is column width
  # 8           2  IF width is not an integer between 1 and 100
  # 10             1  Print error
  # 8           3  ELSE width is an integer between 1 and 100
  # 10             1  Store width in data structure
  # 6       11  ELSIF param is column 'head'
  # 8           1  Store head in data structure
  # 6       12  ELSIF param is column 'background' color
  # 8           1  Store background color in data structure
  # 6       13  Push line onto outtext array
  # 6       14  Next LINE
  #
  # Begin any header/footer data element
  #
  # 4    36  FOREACH header/footer data element
  # 6        1  IF line begins this element AND in doc preamble
  # 8           1  Parse attributes and text
  # 8           2  Print debugging message
  # 8           3  End any data element
  # 8           4  Set state: in this element = 1
  # 8           5  Initialize anonymous struct hash
  # 8           6  Store text in anonymous struct
  # 8           7  IF attrs present
  # 10             1  Split attributes into list
  # 10             2  FOREACH attribute in list
  # 12                1  FOREACH allowable font size
  # 14                   1  IF attribute is this size
  # 16                      1  Store size in anonymous struct
  # 12                2  FOREACH allowable font weight
  # 14                   1  IF attribute is this weight
  # 16                      1  Store weight in anonymous struct
  # 12                3  FOREACH allowable font shape
  # 14                   1  IF attribute is this shape
  # 16                      1  Store shape in anonymous struct
  # 12                4  FOREACH allowable font family
  # 14                   1  IF attribute is this family
  # 16                      1  Store family in anonymous struct
  # 8           8  Store anonymous struct in document data structure
  # 8           9  Push line onto outtext array
  # 8          10  Next LINE
  #
  # Begin any allowed data element
  #
  # 4    37  IF in this name/type
  # 6        1  Get current num
  # 6        2  Make list of allowed data elements
  # 6        3  FOREACH element in allowed elements
  # 8           1  IF this line begins this data element
  # 10             1  Parse attributes from line
  # 10             2  Print debugging message
  # 10             3  End any data element
  # 10             4  Remember we're in this element
  # 10             5  IF element may be multivalued
  # 12                1  Push line onto data structure array
  # 10             6  ELSE element may not be multivalued
  # 12                1  Store line into data structure scalar
  # 10             7  Push line onto outtext array
  # 10             8  Next LINE
  #
  ####################################################################
  # LOOK FOR END OF DATA ELEMENTS
  ####################################################################
  #
  # End of 'file' data element
  #
  # 4    38  ELSIF in file and line blank
  # 6        1  Set state: in file = 0
  # 6        2  Print debugging message
  # 6        3  Push line onto outtext array
  # 6        4  next LINE
  #
  # End of 'generate' data element
  #
  # 4    39  ELSIF in 'generate' and line blank
  # 6        1  Set state: in generate = 0
  # 6        2  Print debugging message
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # End of 'insert' data element
  #
  # 4    40  ELSIF in 'insert' and line blank
  # 6        1  Set state: in insert = 0
  # 6        2  Print debugging message
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # End of 'script' data element
  #
  # 4    41  ELSIF in 'script' line blank
  # 6        1  Set state: in script = 0
  # 6        2 Print debugging message
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # End of 'insert_gen_content' data element
  #
  # 4    42  ELSIF in 'insert_gen_content' line blank
  # 6        1  Set state: in insert_gen_content = 0
  # 6        2  Print debugging message
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # End of 'insert_ins_content' data element
  #
  # 4    43  ELSIF in 'insert_ins_content' line blank
  # 6        1  Set state: in insert_ins_content = 0
  # 6        2  Print debugging message
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # End of 'image' data element
  #
  # 4    44  ELSIF in 'image' and line blank
  # 6        1  Set state: in image = 0
  # 6        2  Print debugging message
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # End of 'footnote' data element
  #
  # 4    45  ELSIF in 'footnote' and line blank
  # 6        1  Set state: in footnote = 0
  # 6        2  Print debugging message
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # End of 'glossary' data element
  #
  # 4    46  ELSIF in 'glossary' and line blank
  # 6        1  Set state: in glossary = 0
  # 6        2  Initialize current glossary term to ''
  # 6        3  Print debugging message
  # 6        4  Push line onto outtext array
  # 6        5  Next LINE
  #
  # End of 'var' data element
  #
  # 4    47  ELSIF in 'var' and line blank
  # 6        1  Set state: in var = 0
  # 6        2  Initialize current variable name to ''
  # 6        3  Print debugging message
  # 6        4  Push line onto outtext array
  # 6        5  Next LINE
  #
  # End of 'acronymn' data element
  #
  # 4    48  ELSIF in 'acronym' and line blank
  # 6        1  Set state: in acronym = 0
  # 6        2  Initialize current acronym to ''
  # 6        3  Print debugging message
  # 6        4  Push line onto outtext array
  # 6        5  Next LINE
  #
  # End of 'index' data element
  #
  # 4    49  ELSIF in 'index' and line blank
  # 6        1  Set state: in index = 0
  # 6        2  Print debugging message
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # End of 'outcome' data element
  #
  # 4    50  ELSIF in 'outcome' and line blank
  # 6        1  Set state: in outcome = 0
  # 6        2  Initialize current outcome item = ''
  # 6        3  Initialize current outcome date = ''
  # 6        4  Print debugging message
  # 6        5  Push line onto outtext array
  # 6        6  Next LINE
  #
  # End of 'review' data element
  #
  # 4    51  ELSIF in 'review' and line blank
  # 6        1  Set state: in review = 0
  # 6        2  Initialize current review item = ''
  # 6        3  Initialize current review date = ''
  # 6        4  Print debugging message
  # 6        5  Push line onto outtext array
  # 6        6  Next LINE
  #
  # End of 'step' data element
  #
  # 4    52  ELSIF in 'step' and line blank
  # 6        1  Set state: in step = 0
  # 6        2  Print debugging message
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # End of 'label' data element
  #
  # 4    53  ELSIF in label and line blank
  # 6        1  Set state: in label = 0
  # 6        2  Print debugging message
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # End of 'title' data element
  #
  # 4    54  ELSIF in title and line blank
  # 6        1  Set state: in title = 0
  # 6        2  Print debugging message
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # End of 'date' data element
  #
  # 4    55  ELSIF in 'date' and line blank
  # 6        1  Set state: in date = 0
  # 6        2  Print debugging message
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # End of 'revision' data element
  #
  # 4    56  ELSIF in 'revision' and line blank
  # 6        1  Set state: in revision = 0
  # 6        2  Print debugging message
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # End of 'author' data element
  #
  # 4    57  ELSIF in 'author' and line blank
  # 6        1  Set state: in author = 0
  # 6        2  Print debugging message
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # End of 'type' data element
  #
  # 4    58  ELSIF in 'type' and line blank
  # 6        1  Set state: in type = 0
  # 6        2  Print debugging message
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # End of 'use_formal_status' data element
  #
  # 4    59  ELSIF in 'use_formal_status' and line blank
  # 6        1  Set state: in use_formal_status = 0
  # 6        2  Print debugging message
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # End of 'effort_units' data element
  #
  # 4    60  ELSIF in 'effort_units' and line blank
  # 6        1  Set state: in effort_units = 0
  # 6        2  Print debugging message
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # End of 'column' data element
  #
  # 4    61  ELSIF in 'column' and line blank
  # 6        1  Set state: in column = 0
  # 6        2  Print debugging message
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # End of any header/footer data element
  #
  # 4    62  FOREACH element in list of header/footer elements
  # 6        1  IF in this header/footer element and line blank
  # 8           1  Set state: in this element = 0
  # 8           2  Print debugging message
  # 8           3  Push line onto outtext array
  # 8           4  Next LINE
  #
  ####################################################################
  # LOOK FOR CONTINUATION OF DATA ELEMENTS
  ####################################################################
  #
  # Continuation of 'file' data element
  #
  # 4    63  ELSIF in file and line not blank
  # 6        1  Print debugging message
  # 6        2  Print error 'filename must be contained on one line"
  # 6        3  Push line onto outtext array
  # 6        4  next LINE
  #
  # Continuation of 'generate' data element
  #
  # 4    64  ELSIF line is a 'generate' continuation line
  # 6        1  Print debugging message
  # 6        2  Print error 'generate directive must be one line'
  # 6        3  Push line onto outtext array
  # 6        4  next LINE
  #
  # Continuation of 'insert' data element
  #
  # 4    65  ELSIF line is an 'insert' continuation line
  # 6        1  Print debugging message
  # 6        2  Print error 'insert directive must be one line'
  # 6        3  Push line onto outtext array
  # 6        4  next LINE
  #
  # Continuation of 'script' data element
  #
  # 4    66  ELSIF in 'script' and line not blank
  # 6        1  Print debugging message
  # 6        2  Print error 'script directive must be one line
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # Continuation of 'insert_gen_content' data element
  #
  # 4    67  ELSIF in 'insert_gen_content' and line not blank
  # 6        1  Print debugging message
  # 6        2  Print error 'insert_gen_content directive must be one line
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # Continuation of 'insert_ins_content' data element
  #
  # 4    68  ELSIF in 'insert_ins_content' and line not blank
  # 6        1  Print debugging message
  # 6        2  Print error 'insert_ins_content directive must be one line
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # Continuation of 'image' data element
  #
  # 4    69  ELSIF in 'image' and line not blank
  # 6        1  Print debugging message
  # 6        2  Print error 'image must be one line'
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # Continuation of 'footnote' data element
  #
  # 4    70  ELSIF in 'footnote' and line not blank
  # 6        1  Parse text
  # 6        2  Get current footnote number
  # 6        3  Append text to footnote value in array
  # 6        4  Print debugging message
  # 6        5  Push line onto outtext array
  # 6        6  Next LINE
  #
  # Continuation of 'glossary' data element
  #
  # 4    71  ELSIF in 'glossary' and line not blank
  # 6        1  Parse text
  # 6        2  Get current glossary term
  # 6        3  Append text to glossary term definition
  # 6        4  IF the term contains an ampersand
  # 8           1  Replace ampersand with ' and '
  # 8           2  Append text to glossary term definition
  # 6        5  Print debugging message
  # 6        6  Push line onto outtext array
  # 6        7  Next LINE
  #
  # Continuation of 'var' data element
  #
  # 4    72  ELSIF in 'var' and line not blank
  # 6        1  Parse value
  # 6        2  Get current variable name
  # 6        3  Append value to variable in data structure
  # 6        4  Print debugging message
  # 6        5  Push line onto outtext array
  # 6        6  Next LINE
  #
  # Continuation of 'acronym' data element
  #
  # 4    73  ELSIF in 'acronym' and line not blank
  # 6        1  Parse text
  # 6        2  Get current acronym
  # 6        3  Append text to acronym definition
  # 6        4  Print debugging message
  # 6        5  Push line onto outtext array
  # 6        6  Next LINE
  #
  # Continuation of 'index' data element
  #
  # 4    74  ELSIF in 'index' and line not blank
  # 6        1  Parse text
  # 6        2  Split index entries by semi-colon
  # 6        3  FOREACH index entry in list of entries
  # 8           1  Increment index entry count in data structure
  # 6        4  Print debugging message
  # 6        5  Push line onto outtext array
  # 6        6  Next LINE
  #
  # Continuation of 'outcome' data element
  #
  # 4    75  ELSIF in 'outcome' and line not blank
  # 6        1  Parse text
  # 6        2  Get current outcome item
  # 6        3  Get current outcome date
  # 6        4  Append text to current outcome description
  # 6        5  Print debugging message
  # 6        6  Push line onto outtext array
  # 6        7  Next LINE
  #
  # Continuation of 'review' data element
  #
  # 4    76  ELSIF in 'review' and line not blank
  # 6        1  Parse text
  # 6        2  Get current review item
  # 6        3  Get current review date
  # 6        4  Append text to current review description
  # 6        5  Print debugging line
  # 6        6  Push line onto outtext array
  # 6        7  Next LINE
  #
  # Continuation of 'step' data element
  #
  # 4    77  ELSIF in 'step' and line not blank
  # 6        1  Print debugging message
  # 6        2  Push line onto outtext array
  # 6        3  Next LINE
  #
  # Continuation of 'label' data element
  #
  # 4    78  ELSIF in label and line not blank
  # 6        1  Print debugging message
  # 6        2  Print error 'label must be one line'
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # Continuation of 'title' data element
  #
  # 4    79  ELSIF in title and line not blank
  # 6        1  Parse text
  # 6        2  Append this line to the current title
  # 6        3  Replace top title on title stack
  # 6        4  Store title in data structure
  # 6        5  Print debugging message
  # 6        6  Push line onto outtext array
  # 6        7  Next LINE
  #
  # Continuation of 'date' data element
  #
  # 4    80  ELSIF in 'date' and line not blank
  # 6        1  Print debugging message
  # 6        2  Print error 'date must be on one line'
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # Continuation of 'revision' data element
  #
  # 4    81  ELSIF in 'revision' and line not blank
  # 6        1  Print debugging message
  # 6        2  Print error 'revision must be on one line'
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # Continuation of 'author' data element
  #
  # 4    82  ELSIF in 'author' and line not blank
  # 6        1  Print debugging message
  # 6        2  Print error 'author must be on one line'
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # Continuation of 'type' data element
  #
  # 4    83  ELSIF in 'type' and line not blank
  # 6        1  Print debugging message
  # 6        2  Print error 'type must be on one line'
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # Continuation of 'use_formal_status' data element
  #
  # 4    84  ELSIF in 'use_formal_status' and line not blank
  # 6        1  Print debugging message
  # 6        2  Print error 'use_formal_status must be on one line'
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # Continuation of 'effort_units' data element
  #
  # 4    85  ELSIF in 'effort_units' and line not blank
  # 6        1  Print debugging message
  # 6        2  Print error 'effort_units must be on one line'
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # Continuation of 'column' data element
  #
  # 4    86  ELSIF in 'column' and line not blank
  # 6        1  Print debugging message
  # 6        2  Print error 'column must be on one line'
  # 6        3  Push line onto outtext array
  # 6        4  Next LINE
  #
  # Continuation of any header/footer element
  #
  # 4    87  FOREACH header/footer element
  # 6        1  IF in this element and line not blank
  # 8           1  Parse line
  # 8           2  Get struct for this element
  # 8           3  Append line to struct text
  # 8           4  Print debugging message
  # 8           5  Push line onto outtext array
  # 8           6  Next LINE
  #
  # Continuation of any other element
  #
  # 4    88  IF in this name/type and line not blank
  # 6        1  Make list of allowed data elements
  # 6        2  FOREACH element in allowed elements
  # 8           1  IF in name/element and line not blank
  # 10             1  Parse line
  # 10             2  Print debugging message
  # 10             3  IF this element may be multivalued
  # 12                1  Store line in data structure array
  # 10             4  ELSE this element is single-valued
  # 12                1  Store line in data structure scalar
  # 10             5  Push line onto outtext array
  # 10             6  Next LINE
  #
  # Blank line
  #
  # 4    89  IF line is blank
  # 6        1  Print debugging message
  # 6        2  IF in any region and not in region preamble
  # 8           1  Get current name and num
  # 8           2  Append narrative line in data structure
  # 6        3  End any data element
  # 6        4  Push line onto outtext array
  # 6        5  Next LINE
  #
  # Must be in narrative content
  #
  # 4    90  End region preamble
  # 4    91  Append narrative line in data structure
  #
  # Section heading
  #
  # 4    92  IF line is a section heading
  # 6        1  Parse section heading
  # 6        2  Print debugging message
  # 6        3  Set current title to section heading
  # 6        4  Clear the title stack
  # 6        5  Push section heading onto title stack
  # 6        6  Increment count: section total
  # 6        7  Set current name = 'section'
  # 6        8  Replace top name on name stack
  # 6        9  Create temporary fake section label
  # 6       10  Replace top label on label stack
  # 6       11  Store section type in data structure
  # 6       12  Store section heading in data structure
  # 6       13  Set state: no longer in preamble text
  # 6       14  End any data element
  # 6       15  Remember previous section depth
  # 6       16  Set current section depth
  # 6       17  Get current section type and depth
  # 6       18  IF previous depth was greater than current depth
  # 8           1  Set temp_depth = previous depth
  # 8           2  WHILE temp_depth is greater than current depth
  # 10             1  Set section counter for temp_depth to 0
  # 10             2  Decrement temp_depth
  # 6       19  Increment section counter for current depth
  # 6       20  Initialize current type to ''
  # 6       21  Remember previous section number
  # 6       22  Set temp_depth = 1
  # 6       23  Set current secnum to section counter for temp_depth
  # 6       24  WHILE temp_depth is less than current depth
  # 8           1  Increment temp_depth
  # 8           2  Append to current secnum section counter for temp_depth
  # 6       25  Initialize section array in html data structure
  # 6       26  Store data in section data structure
  # 6       27  Set level = current depth
  # 6       28  Truncate level at MAX_SEC_DEPTH
  # 6       29  IF this is a toplevel section
  # 8           1  Set current topnum = toplevel section counter
  # 8           2  FOREACH allowable block name
  # 10             1  Set count name section = 0
  # 6       30  Push line onto outtext array
  # 6       31  Next LINE
  #
  # Table row
  #
  # 4    93  IF line is end of table row
  # 6        1  Print debugging message
  # 6        2  Reset column count to zero
  # 6        3  End any data element
  # 6        4  Push line onto outtext array
  # 6        5  Next LINE
  #
  # Table header or cell
  #
  # 4    94  IF line is beginning of table header or cell
  # 6        1  Parse header or cell attributes and text
  # 6        2  Print debugging message
  # 6        3  End any data element
  # 6        4  Convert to plain text for column width calculation
  # 6        5  Set size = length of plain text
  # 6        6  IF current column is 0
  # 8           1  Increment current row
  # 6        7  Increment current column
  # 6        8  IF not in table and not in baretable
  # 8           1  Set state: in baretable = 1
  # 8           2  Increment count: baretable total
  # 8           3  Reset current column and row to 1
  # 8           4  Add to baretable size in data structure
  # 8           5  Increment column count in data structure
  # 8           6  Remember the size of this line
  # 8           7  Print debugging message
  # 8           8  FOREACH color in allowed background colors
  # 10             1  IF this color is in the passed attributes
  # 12                1  Store uses_color = 1 in data structure
  # 6        9  ELSIF already in table environment
  # 8           1  Get current table number
  # 8           2  Add to overall table size
  # 8           3  Get current column number
  # 8           4  IF this is the biggest line seen for this column
  # 10             1  Store this column size in the data structure
  # 8           5  Print debugging message
  # 8           6  FOREACH color in allowed background colors
  # 10             1  IF this color is in the passed attributes
  # 12                1  Store uses_color = 1 in data structure
  # 6       10  ELSE in baretable environment
  # 8           1  Get current baretable number
  # 8           2  Add to overall baretable size
  # 8           3  Get current column number
  # 8           4  IF this is the biggest line seen for this column
  # 10             1  Store this column size in the data structure
  # 8           5  Print debugging message
  # 8           6  FOREACH color in allowed background colors
  # 10             1  IF this color is in the passed attributes
  # 12                1  Store uses_color = 1 in data structure
  # 6       11  Push line onto outtext array
  # 6       12  Next LINE
  #
  # End of baretable
  #
  # 4    95  IF this line ends a baretable
  # 6        1  Set state: in baretable = 0
  # 6        2  Set current column and row to 0
  # 6        3  Print debugging message
  # 6        4  End any data element
  # 6        5  Push line onto outtext array
  # 6        6  Next LINE
  #
  # Baretable content
  #
  # 4    96  IF this line is baretable content
  # 6        1  Get current baretable number
  # 6        2  Get current column and row
  # 6        3  Compute size of plain text
  # 6        4  Add to baretable size in data structure
  # 6        5  IF biggest line seen for this column
  # 8           1  Set column size in data structure to line size
  # 6        6  Print debugging message
  # 6        7  Push line onto outtext array
  # 6        8  Next LINE
  #
  # Table content
  #
  # 4    97  IF this line is table content
  # 6        1  Get current table number
  # 6        2  Get current column and row
  # 6        3  Compute size of plain text
  # 6        4  Add to table size in data structure
  # 6        5  IF biggest line seen for this column
  # 8           1  Set column size in data structure to line size
  # 6        6  Print debugging message
  # 6        7  Push line onto outtext array
  # 6        8  Next LINE
  # 4    98  Push line onto outtext array
  # 4    99  Next LINE
  # 2  9  IF debugging
  # 4     1  Print debugging message "end pass 2 of 3"
  # 2 10  Copy outtext to intext
  #
  #-------------------------------------------------------------------

  #-------------------------------------------------------------------
  # P2: 1 - IF debugging
  #
  if ($DEBUGGING) {

    #-----------------------------------------------------------------
    # P2: 1.1 - Print debugging message "begin pass 2 of 3"
    #
    my $text = <<"END_OF_TEXT";
------------------------------------------------------------
BEGIN PASS 2 of 3
------------------------------------------------------------

END_OF_TEXT

    printdebug($text);
  }

  #-------------------------------------------------------------------
  # P2: 2 - Print progress message
  #
  # print "\n" if not $option{'gui'} and not $option{'verbose'};
  printmessage("[$text_file->$renditions] Pass 2 of 3 (iteration $pass_two_count) gather data, resolve requests");

  #-------------------------------------------------------------------
  # P2: 3 - Initialize data structures.
  #
  #    Pass 2 may be run multiple times for the purpose of
  #    re-populating the 'data' data structure after resolving
  #    'generate:' or 'script:' directives.
  #
  #    Note that a full 'init' isn't necessary and would delete needed
  #    data.  The 'init' subroutine is designed to reset all variables
  #    in preparation for another publishing run, not another run of
  #    pass 2.
  #
  #    DON''T INITIALIZE THE %label HASH!  This hash contains
  #    information that must survive multiple pass 2 iterations.  For
  #    instance, if a title reference (i.e. [t:my-label]) occurs in a
  #    table cell, pass 2 looks it up in $label{'my-label'}{'title'}
  #    to support column width determination.
  #
  #    DON'T INITIALIZE THE %lookup HASH!  The 'plain_text' and
  #    'resolve_references' subroutines called during pass_two uses
  #    the lookup data structure to perform substitutions: title,
  #    description, lookup, glossary, command, url, and cross
  #    reference.
  #
  #    DON'T INITIALIZE THE %attribute HASH!  The 'plain_text' and
  #    'resolve_references' subroutines called during pass_two uses
  #    the attribute data structure to perform substitutions: title,
  #    description, lookup, glossary, command, url, and cross
  #    reference.
  #
  %data      = ();  %specials  = ();  %in        = ();
  %count     = ();  %document  = ();  %current   = ();
  %scounter  = ();  %dcounter  = ();  %section   = ();
  $csvdata   = {};

  #-------------------------------------------------------------------
  # P2: 4 - Initialize 'current' state
  #
  #    Build a hash of labels and their values.  As the intext is
  #    processed line-by-line, the following variables need to be kept
  #    up to date:
  #
  #      type         type of current section (i.e. section,
  #                   appendix, chapter, module, etc.)
  #
  #      region       current region (i.e. table, figure, attachment,
  #                   slide, sidebar, quotation, problem, solution,
  #                   allocation, assignment, test, task, result,
  #                   role, listing, etc.)
  #
  #      toplevel     The number of the current toplevel section
  #                   (i.e. 1, 2, 3)
  #
  #      section      The current section number (i.e. 3.12.4)
  #
  #      title        The title of the current region (i.e. section
  #                   title, figure title, table title, etc)
  #
  #      number       The number of the current figure, table, or listing
  #
  $current{'column'}  = 0;
  $current{'sectype'} = 'section';
  $current{'name'}    = 'preamble';
  $current{'label'}   = 'preamble';
  $current{'title'}   = 'no title';

  $html{'body'}{'DEFAULT'} = [];

  #-------------------------------------------------------------------
  # P2: 5 - Push current name, label, and title on stacks
  #
  push(@{$current{'name_stack'}},$current{'name'});
  push(@{$current{'label_stack'}},$current{'label'});
  push(@{$current{'title_stack'}},$current{'title'});

  #-------------------------------------------------------------------
  # P2: 6 - Initialize 'in' state
  #
  #     During parsing, we are NOT always in 'universal' text.  Assume
  #     here at the beginning of pass 2 processing that we are not in
  #     universal text because documents normally begin with a
  #     preamble.
  #
  #     Assume the document begins with a preamble
  #
  $in{'universal'}{'text'}    = 0;
  $in{'preamble'}{'text'}     = 1;
  $count{'preamble'}{'total'} = 1;

  #-------------------------------------------------------------------
  # P2: 7 - Initialize Output Text array
  #
  #     Initialize the outtext array.  Pass 2 processing makes changes
  #     to the text.  The input is an array named @intext, and the
  #     output is an array named @outtext.  At the end of pass 2
  #     processing, @outtext will be written back to @intext in
  #     preparation for another pass 2 run.
  #
  @outtext = ();

  #-------------------------------------------------------------------
  # P2: 8 - FOR each LINE in intext array
  #
  #    Process all input line-by-line.
  #
  #    Since we will be modifying lines as we go, we need to push each
  #    line onto a new array after it's processed.  The new array is
  #    named @outtext.  At the end of pass 2, we'll assign @outtext
  #    back to @intext so we can repeat pass 2 as many times as
  #    necessary to resolve all 'generate:' and 'script:' lines.
  #
  #    I need to be careful in pass 2 to assign each processed line to
  #    @outtext.  If I miss one, the content will be gone.
  #
  #    Each element of the @outtext array is actually an anonymous
  #    array:
  #
  #      [$nest,$nesting_level,$current{'line'},$content]
  #
  #    This enables us to keep a sense of context (i.e. what line in
  #    what file, the current content comes from). This is useful when
  #    reporting errors.

 LINE:
  for (@intext) {

    #-----------------------------------------------------------------
    # P2: 8.1 - Break out the four line Elements
    #
    #    Each element of the @intext array is itself a four element
    #    array where the four elements are:
    #
    #        0 - filename "nest"
    #        1 - current nesting level
    #        2 - current line number
    #        3 - current line text
    #
    my $nest          = @{$_}[0]; # filename nest
    my $nesting_level = @{$_}[1]; # current nesting level
    $current{'line'}  = @{$_}[2]; # current line number
    $_                = @{$_}[3]; # current line

    #-----------------------------------------------------------------
    # P2: 8.2 - Initialize Line Variable
    #
    #     From time to time I'll need to modify the current line.  In
    #     these cases I'll take the value of the current line ($_) and
    #     put it in $line.
    #
    my $line;

    #-----------------------------------------------------------------
    # P2: 8.3 - Print debugging message
    #
    #     Print this line if we're debugging.
    #
    printmessage("P2---- $_") if $DEBUGGING;

    #-----------------------------------------------------------------
    # P2: 8.4 - Remember current file state (get from nest)
    #
    #     Detemine current file name. Figure out the name of the
    #     current file by breaking up the 'nest'.  The 'nest' looks
    #     like:
    #
    #       file1.txt > file2.txt > file3.txt
    #
    #     This means you cannot use a filename containing a '>'
    #     character.
    #
    my @files = split(/\s*>\s*/,$nest);
    $current{'file'} = $files[-1];
    my $name = $current{'name'};
    my $type = $structure{$name}{'type'};

    #-----------------------------------------------------------------
    # P2: 8.5 - Count markup in line
    #
    #     Count the number of certain markup strings in a line of
    #     text.
    #
    count_markup_in_line($_);

    ##################################################################
    ##################################################################
    ##################################################################
    ###                                                            ###
    ###                      Comment Block                         ###
    ###                                                            ###
    ##################################################################
    ##################################################################
    ##################################################################

    #-----------------------------------------------------------------
    # P2: 8.6 - IF line is a comment block marker
    #
    #     Look for the beginning or end of a comment block
    #     (###comment)
    #
    #     This MUST be the first condition tested when going
    #     line-by-line through pass two.
    #
    if (/^(#){3,}comment\s*$/) {

      #---------------------------------------------------------------
      # P2: 8.6.1 - IF already in comment block
      #
      if ($in{'comment'}{'block'}) {
        printdebug("P2 end comment block") if $DEBUGGING;
        $in{'comment'}{'block'} = 0;
      }

      #---------------------------------------------------------------
      # P2: 8.6.2 - ELSE not already in comment block
      #
      else {
        printdebug("P2 begin comment block") if $DEBUGGING;
	++ $count{'division'};
        $in{'comment'}{'block'} = 1;
        end_any_data_element();
      }

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.7 - ELSIF line is comment or in comment block
    #
    #     Look for a comment line or comment block content.
    #
    elsif (/^#/ or $in{'comment'}{'block'}) {
      printdebug("P2 comment line") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    ##################################################################
    ##################################################################
    ##################################################################
    ###                                                            ###
    ###                   Conditional Block                        ###
    ###                                                            ###
    ##################################################################
    ##################################################################
    ##################################################################

    #-----------------------------------------------------------------
    # P2: 8.8 - ELSIF line is conditional block marker
    #
    #     Look for the beginning or end of a conditional block
    #     (???rh9,knoppix)
    #
    #     !!! Bug Here !!!
    #
    #     Finish coding the conditional text machinery.
    #
    if (/^(\?){3,}(.*)\s*$/) {

      #---------------------------------------------------------------
      # P2: 8.8.1 - Parse comma separated list of conditionals
      #
      my @conditionals = split(q{,},$2);

      #---------------------------------------------------------------
      # P2: 8.8.2 - FOREACH conditional
      #
      foreach my $conditional (@conditionals) {

        #-------------------------------------------------------------
	# P2: 8.8.2.1 - IF in conditional block, exit
        #
        if ($in{$conditional}{'conditional'}) {
          printdebug("P2 end conditional block") if $DEBUGGING;
          $in{$conditional}{'conditional'} = 0;
        }

        #-------------------------------------------------------------
	# P2: 8.8.2.2 - ELSE not in conditional block, enter
        #
        else {
          printdebug("P2 begin conditional block") if $DEBUGGING;
	  ++ $count{'division'};
          $in{$conditional}{'conditional'} = 1;
          end_any_data_element();
        }
      }

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    ##################################################################
    ##################################################################
    ##################################################################
    ###                                                            ###
    ###                        Begin Region                        ###
    ###                                                            ###
    ##################################################################
    ##################################################################
    ##################################################################

    #-----------------------------------------------------------------
    # P2: 8.9 - ELSIF line is begin region marker
    #
    #     Look for the beginning of a region (>>>marker).  The
    #     beginning of a region is indicated by three or more '>'
    #     signs beginning at the beginning of a line.
    #
    elsif (/^(>){3,}(\w+)/) {

      ++ $count{'division'};

      #---------------------------------------------------------------
      # P2: 8.9.1 - Remember region marker (region name)
      #
      my $marker = $2;

      #---------------------------------------------------------------
      # P2: 8.9.2 - IF this marker is an unknown region name
      #
      #     If this marker is an unknown region name, print an error
      #     and go on.
      #
      #     !!! BUG HERE !!!
      #
      #     I don't think 'going on' is the right thing to do when you
      #     discover an unknown region marker.
      #
      if (not exists $structure{$marker}) {
        printerror("beginning of unknown region: $marker\n");
      }

      #---------------------------------------------------------------
      # P2: 8.9.3 - In preamble text = 0
      #
      #     Since we've found the beginning of a region we can no
      #     longer be in the document preamble.  (We will, however, be
      #     in the region's preamble.)
      #
      $in{'preamble'}{'text'} = 0;

      #---------------------------------------------------------------
      # P2: 8.9.4 - End any data element
      #
      #     In the unlikely event we were parsing a data element, end
      #     it.
      #
      end_any_data_element();

      #---------------------------------------------------------------
      # P2: 8.9.5 - In specific region preamble = 1
      #
      #     Each region consists of a preamble followed by narrative.
      #     The preamble contains all of the data elements and the
      #     narrative contains all of the narrative content.
      #
      $in{$marker}{'preamble'}  = 1;

      #---------------------------------------------------------------
      # P2: 8.9.6 - In region preamble = 1
      #
      $in{'region'}{'preamble'} = 1;

      #---------------------------------------------------------------
      # P2: 8.9.7 - Current table column = 0
      #
      #     Since tables cannot span the beginning of a region, reset
      #     the table column counter.
      #
      $current{'column'} = 0;

      #-------------------------------------------------------------
      # P2: 8.9.8 - No longer in any environment
      #
      #     Environments cannot contain regions.  Since we've found
      #     the beginning of a region, we're no longer in any
      #     environment.
      #
      no_longer_in_any_environment();

      #---------------------------------------------------------------
      # P2: 8.9.9 - Remember we're in a region named $marker
      #
      $in{$marker}{'region'} = 1;

      #-------------------------------------------------------------
      # P2: 8.9.10 - Remeber the current type is 'region'
      #
      $current{'type'} = 'region';

      #-------------------------------------------------------------
      # P2: 8.9.11 - Increment region counts: section, total, last
      #
      ++ $count{$marker}{'section'}; # number of these in section
      ++ $count{$marker}{'total'};   # total number of these
      ++ $count{$marker}{'last'};    # number of last one of these

      #-------------------------------------------------------------
      # P2: 8.9.12 - IF current topnum is true
      #
      #     Formulate current region number using the top-level number
      #     plus the section number.
      #
      if ($current{'topnum'}) {
	$current{'number'} = "$current{'topnum'}-$count{$marker}{'section'}";
      }

      #-------------------------------------------------------------
      # P2: 8.9.13 - ELSE current topnum is not true
      #
      #     Formulate current region number just the section number.
      #
      else {
	$current{'number'} = "$count{$marker}{'section'}";
      }

      #-------------------------------------------------------------
      # P2: 8.9.14 - Construct temporary fake label and title
      #
      #     Make up a fake label and title to use until we find the
      #     real ones.
      #
      my $num   = $count{$marker}{'total'};
      my $label = $marker . "-" . $num;
      my $title = $marker . "-" . $num . " Title";

      #-------------------------------------------------------------
      # P2: 8.9.15 - Push values onto name, label, and title stacks
      #
      $current{'name'}  = $marker;
      $current{'label'} = $label;
      $current{'title'} = $title;

      #-------------------------------------------------------------
      # P2: 8.9.16 - Push values onto name, label, and title stacks
      #
      push(@{ $current{'name_stack'} }, $current{'name'});
      push(@{ $current{'label_stack'} }, $current{'label'});
      push(@{ $current{'title_stack'} }, $current{'title'});

      #-------------------------------------------------------------
      # P2: 8.9.17 - Remember current secnum in data structure
      #
      $data{$marker}{$num}{'section'} = $current{'secnum'};

      #---------------------------------------------------------------
      # P2: 8.9.18 - Print debug message
      #
      printdebug("P2 begin region $marker $num $label $title") if $DEBUGGING;

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;

    }

    ##################################################################
    ##################################################################
    ##################################################################
    ###                                                            ###
    ###                         End Region                         ###
    ###                                                            ###
    ##################################################################
    ##################################################################
    ##################################################################

    #-----------------------------------------------------------------
    # P2: 8.10 - ELSIF line is end region marker
    #
    #     Look for the end of a region (<<<marker).
    #
    elsif (/^(<){3,}\s*(\w+)/) {

      #---------------------------------------------------------------
      # P2: 8.10.1 - Remember region marker (region name)
      #
      my $marker = $2;

      #---------------------------------------------------------------
      # P2: 8.10.2 - IF this marker is an unknown region name
      #
      #     Make sure this is a known region.
      #
      if (not exists $structure{$marker}) {
        printerror("end of unknown region: $marker\n");
      }

      #---------------------------------------------------------------
      # P2: 8.10.3 - End any data element
      #
      #     In the unlikely event we were parsing a data element, end
      #     it.
      #
      end_any_data_element();

      #---------------------------------------------------------------
      # P2: 8.10.4 - Reset table column and row counts to 0
      #
      $current{'column'} = 0;
      $current{'row'}    = 0;

      #---------------------------------------------------------------
      # P2: 8.10.5 - IF currently in region denoted by marker
      #
      #    Since we're no longer in this region we revert back to
      #    being in whatever we were in before (section, chapter,
      #    appendix, etc.)
      #
      #    !!! Bug Here !!!
      #
      #    Shouldn't this be implemented as a stack rather than a
      #    simple register that remembers the name of the previous
      #    name?  What if regions are nested several deep, would this
      #    break?
      #
      if ( $in{$marker}{'region'} ) {

	#-------------------------------------------------------------
	# P2: 8.10.5.1 - Set state: in marker region = 0
	#
        $in{$marker}{'region'} = 0;

	#-------------------------------------------------------------
	# P2: 8.10.5.2 - Pop values from name, label, and title stacks
	#
	#     Revert name, label and title to what they were before we
	#     entered the region.
	#
	pop(@{ $current{'name_stack'} });
	pop(@{ $current{'label_stack'} });
	pop(@{ $current{'title_stack'} });

	#-------------------------------------------------------------
	# P2: 8.10.5.3 - Remember current name, label and title
	#
	$current{'name'}  = (@{ $current{'name_stack'} })[-1];
	$current{'label'} = (@{ $current{'label_stack'} })[-1];
	$current{'title'} = (@{ $current{'title_stack'} })[-1];

	#-------------------------------------------------------------
	# P2: 8.10.5.4 - Revert name and type to previous context
	#
	#     We're back in the context we were in before entering the
	#     region.
	#
	my $name = $current{'name'};
	my $type = $structure{$name}{'type'};
	$in{$name}{$type} = 1;

      }

      #---------------------------------------------------------------
      # P2: 8.10.6 - ELSE not currently in region denoted by marker
      #
      #     We've found the end marker for a region we were not in.
      #     Tell the user of the error.
      #
      else {
        printerror("Can't end $marker here, not in a $marker!\n");
      }

      #---------------------------------------------------------------
      # P2: 8.10.7 - Print debug message 'P2 end of region'
      #
      #     Inform the user of the region we found.
      #
      my $num   = $count{$marker}{'total'};
      my $label = $data{$marker}{$num}{'label'};
      my $title = $data{$marker}{$num}{'title'};
      printdebug("P2 end region $marker $num $label $title") if $DEBUGGING;

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;

    }

    ##################################################################
    ##################################################################
    ##################################################################
    ###                                                            ###
    ###                         Environment                        ###
    ###                                                            ###
    ##################################################################
    ##################################################################
    ##################################################################

    #-----------------------------------------------------------------
    # P2: 8.11 - ELSIF line is environment marker
    #
    #     Look for the begin or end of an environment. (---marker)
    #
    #     The beginning and end of an environment is indicated by
    #     three or more '-' signs and an environment name at the
    #     beginning of a line.
    #
    elsif (/^(-){3,}(\w+)\s*$/) {

      #---------------------------------------------------------------
      # P2: 8.11.1 - Remember environment marker (environment name)
      #
      my $marker = $2;

      printdebug("P2 environment $marker") if $DEBUGGING;

      #---------------------------------------------------------------
      # P2: 8.11.2 - IF this marker is an unknown environment name
      #
      #     Make sure this marker represents a known environment.
      #
      if (not exists $structure{$marker}) {
        printerror("unknown environment: $marker\n");
      }

      #---------------------------------------------------------------
      # P2: 8.11.3 - Set state: in preamble text = 0
      #
      #     Since we've found the beginning of an environment we can
      #     no longer be in the preamble.
      #
      $in{'preamble'}{'text'} = 0;

      #---------------------------------------------------------------
      # P2: 8.11.4 - End any data element
      #
      #     In the unlikely event we were parsing a data element, end
      #     it.
      #
      end_any_data_element();

      #---------------------------------------------------------------
      # P2: 8.11.5 Set current table column and row to 0
      #
      #     Since a table can't span across the beginning or end of an
      #     environment, reset table column and row counters.
      #
      $current{'column'} = 0;
      $current{'row'}    = 0;

      #-------------------------------------------------------------
      # P2: 8.11.6 - IF not currently in marker environment
      #
      #     Determine whether this is the beginning or end of
      #     the environment.  If we're not already in this
      #     environment, this environment marking must mark the
      #     beginning.
      #
      if (not $in{$marker}{'environment'}) {

	++ $count{'division'};

        #-------------------------------------------------------------
	# P2: 8.11.6.1 - Print debugging message
	#
        printdebug("P2 begin environment $marker") if $DEBUGGING;

        #-------------------------------------------------------------
	# P2: 8.11.6.2 - No longer in any environment
	#
	#     Environments cannot contain other environments.
	#     Therefore since we've found the beginning of an
	#     environment, it means we're no longer in any other
	#     environment.
	#
	no_longer_in_any_environment();

        #-------------------------------------------------------------
	# P2: 8.11.6.3 - Set state: in this environment = 1
	#
        $in{$marker}{'environment'} = 1;

        #-------------------------------------------------------------
	# P2: 8.11.6.4 - Set state: current type = environment
	#
	#     Remember current name and type.
	#
        $current{'type'} = 'environment';

        #-------------------------------------------------------------
	# P2: 8.11.6.5 - Increment marker counts: section, total, last
	#
        ++ $count{$marker}{'section'};
        ++ $count{$marker}{'total'};
        ++ $count{$marker}{'last'};

        #-------------------------------------------------------------
	# P2: 8.11.6.6 - IF current topnum is true
	#
	#     Formulate current environment number using top number
	#     plus section number.
	#
        if ($current{'topnum'}) {
          $current{'number'} = "$current{'topnum'}-$count{$marker}{'section'}";
        }

        #-------------------------------------------------------------
	# P2: 8.11.6.7 - ELSE current topnum is not true
	#
	#     Formulate current environment number using only section
	#     number.
	#
        else {
          $current{'number'} = "$count{$marker}{'section'}";
        }

	#-------------------------------------------------------------
	# P2: 8.11.6.8 - Construct temporary fake label and title
	#
	#     Make up a fake label and title to use until we find the
	#     real ones
	#
	my $num   = $count{$marker}{'total'};
	my $label = $marker . "-" . $num;
	my $title = $marker . "-" . $num . " Title";

	#-------------------------------------------------------------
	# P2: 8.11.6.9 - Remember current name, label, title
	#
	$current{'name'} = $marker;
	$current{'label'} = $label;
	$current{'title'} = $title;

	#-------------------------------------------------------------
	# P2: 8.11.6.10 - Push values onto name, label, title stacks
	#
	push(@{ $current{'name_stack'} }, $current{'name'});
	push(@{ $current{'label_stack'} }, $current{'label'});
	push(@{ $current{'title_stack'} }, $current{'title'});

	#-------------------------------------------------------------
	# P2: 8.11.6.11 - Store current secnum in data structure
	#
	#     Remember the section in which this environment occurred.
	#
	$data{$marker}{$num}{'section'} = $current{'secnum'};

	#-----------------------------------------------------------
	# P2: 8.11.6.12 - Print debugging message
	#
	#     Tell what we're in.
	#
	list_current_contexts() if $DEBUGGING;

      }

      #---------------------------------------------------------------
      # P2: 8.11.7 - ELSE currently in marker environment
      #
      else {

        #-------------------------------------------------------------
	# P2: 8.11.7.1 - Print debugging message
	#
        printdebug("P2 end environment $marker") if $DEBUGGING;

        #-------------------------------------------------------------
	# P2: 8.11.7.2 - Set state: in marker environment = 0
	#
        $in{$marker}{'environment'} = 0;

	#-------------------------------------------------------------
	# P2: 8.11.7.3 - Pop stacks: name, label, title
	#
	#     Revert name, label and title to what they were before we
	#     entered the region.
	#
	pop(@{ $current{'name_stack'} });
	pop(@{ $current{'label_stack'} });
	pop(@{ $current{'title_stack'} });

        #-------------------------------------------------------------
	# P2: 8.11.7.4 - Remember current name, label, title
	#
	$current{'name'} = (@{ $current{'name_stack'} })[-1];
	$current{'label'} = (@{ $current{'label_stack'} })[-1];
	$current{'title'} = (@{ $current{'title_stack'} })[-1];

	#-------------------------------------------------------------
	# P2: 8.11.7.5 - Revert to previous context
	#
	#     We're back in the context we were in before entering the
	#     region.
	#
	my $name = $current{'name'};
	my $type = $structure{$name}{'type'};
	$in{$name}{$type} = 1;

      }

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;

    }

    ##################################################################
    ##################################################################
    ##################################################################
    ###                                                            ###
    ###                Beginning of Data Elements                  ###
    ###                                                            ###
    ##################################################################
    ##################################################################
    ##################################################################

    #-----------------------------------------------------------------
    # P2: 8.12 - ELSIF line is file data element
    #
    #     Look for a 'file:' line does NOT end a region preamble.
    #
    elsif ( /^file::\s*(.*?)(\s+\#(.*))?$/
	    and not $in{'attachment'}
	    and not $in{'listing'}
	    and not $in{'audio'}
	    and not $in{'video'}
	    and not $in{'source'} ) {

      #---------------------------------------------------------------
      # P2: 8.12.1 - Get file name
      #
      my $resource_file = $1;

      my $current_file = $current{'file'};
      my $tier         = $nesting_level + 1;

      $files{$current_file}{'resources'}{$resource_file} = 1;
      $files{$resource_file}{'tier'}                     = $tier;

      #---------------------------------------------------------------
      # P2: 8.12.6 - Print debugging message
      #
      printdebug("P2 begin file $resource_file") if $DEBUGGING;

      #---------------------------------------------------------------
      # P2: 8.12.2 - End any data element
      #
      end_any_data_element();

      #---------------------------------------------------------------
      # P2: 8.12.3 - Set state: in file = 1
      #
      $in{'file'} = 1;

      #---------------------------------------------------------------
      # P2: 8.12.4 - Publish file
      #
      publish_file($resource_file);

      #---------------------------------------------------------------
      # P2: 8.12.5 - Increment count: file total
      #
      ++ $count{'file'}{'total'};

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;

    }

    #-----------------------------------------------------------------
    # P2: 8.13 - ELSIF line is a 'generate' directive
    #
    #     A 'generate:' line does NOT end a region preamble.
    #
    if (/^generate::\s*([\w\-]+)(\([\w\-]+\))?(\s+\#(.*))?$/) {

      #---------------------------------------------------------------
      # P2: 8.13.1 - Parse 'generate' directive
      #
      #     OK, we've found a line that starts with 'generate:'
      #     meaning the user wants generated content placed at this
      #     point in the document.  The regular expression caught the
      #     name of the requested generated content in $1.
      #
      my $generated_content_string = $1;
      my $generated_content_name   = $generated_content_string;
      my $generated_content_args   = '';

      if ( $generated_content_string =~ /(.*?)\((.*)\)/ ) {
	$generated_content_name = $1;
	$generated_content_args = $2;
      }

      #---------------------------------------------------------------
      # P2: 8.13.2 - Print debugging message
      #
      printdebug("P2 begin generate $generated_content_name")
	if $DEBUGGING;

      #---------------------------------------------------------------
      # P2: 8.13.3 - End any data element
      #
      end_any_data_element();

      #---------------------------------------------------------------
      # P2: 8.13.4 - Set state: in generate = 1
      #
      $in{'generate'} = 1;

      #---------------------------------------------------------------
      # P2: 8.13.5 - Increment count: generate total
      #
      ++ $count{'generate'}{'total'};

      #---------------------------------------------------------------
      # P2: 8.13.6 - IF 'generate' request is not valid
      #
      #     We need to make sure the content requested CAN be
      #     generated.  Near the top of the script I defined a hash
      #     named %generated_content_types that knows about all
      #     available generated content types.
      #
      #     If this is NOT a known generated content type, then raise
      #     a warning and comment out this line.
      #
      if ( not $generated_content_types{$generated_content_name} ) {

        #-------------------------------------------------------------
	# P2: 8.13.6.1 - Print warning
        #
        printwarning(
          "unknown generated content request: $generated_content_name\n"
        );

        #-------------------------------------------------------------
	# P2: 8.13.6.2 - Comment out the line
        #
        s/^(.*)/# $1/;

        push @outtext, [$nest,$nesting_level,$current{'line'},$_];
        next LINE;
      }

      #---------------------------------------------------------------
      # P2: 8.13.7 - ELSE 'generate' request is valid
      #
      #    Now, it would be tempting to generate the requested content
      #    and insert it into the document RIGHT NOW but there's a
      #    problem with that.  What if the user has requested a
      #    problem domain listing (or any other type of generated
      #    content) near the beginning of the document before all of
      #    the problems have even been discovered by the program?  The
      #    generated problem domain listing would only include the
      #    problems discovered SO FAR.
      #
      #    This problem gets even MORE hairy when you consider the
      #    possibility that generated content might generate even MORE
      #    generated content requests.
      #
      #    What if the same piece of generated content is requested in
      #    multiple places in the same document?  For instance, what
      #    if the author requests a prioritized list of problems in
      #    Chapter 2, then again in an appendix?  We only want to
      #    perform the task of generating the content once.
      #
      #    To avoid these problems we need to make a list of content
      #    to be generated on THIS run, generate the requested comment
      #    AFTER this run of pass 2, and insert it on the NEXT run of
      #    pass 2.
      #
      #    Generated content requests can be context sensitive.  For
      #    example, if the author requests:
      #
      #      generate: associated-problem-listing
      #
      #    he means generate a list of problems associated with the
      #    current context (section, region, etc.).  This means we
      #    need to remember the current label along with this generate
      #    request.
      #
      #    Indicate this content should be generated at the end of
      #    this run of pass 2.
      #
      else {

        #-------------------------------------------------------------
	# P2: 8.13.7.1 - Get current label
	#
	my $label = $current{'label'};

        #-------------------------------------------------------------
	# P2: 8.13.7.2 - Set state: to_be_generated name, label, args = 1
	#
	$to_be_generated{$generated_content_name}{$label}{$generated_content_args} = 1;
	print '.' if not $option{'gui'} and not $option{'verbose'};

	#---------------------------------------------------------------
	# P2: 8.13.7.3 - Change line to 'insert_gen_content'
	#
	#    Now change the 'generate:' at the beginning of the line to
	#    'insert_gen_content:' so on the next pass, the generated
	#    content will be inserted, and this line won't be
	#    interpretted as a generated content request a second time.
	#
	my $line = "insert_gen_content:: $generated_content_name:$label:$generated_content_args\n";

	push @outtext, [$nest,$nesting_level,$current{'line'},$line];
	next LINE;

      }

    }

    #-----------------------------------------------------------------
    # P2: 8.14 - ELSIF line is an 'insert' directive
    #
    elsif (/^insert::\s*(.*)(\s+\#(.*))?$/) {

      #---------------------------------------------------------------
      # P2: 8.14.1 - Parse 'insert' directive
      #
      #     OK, we've found a line that starts with 'insert:' meaning
      #     the user wants to insert content at this point in the
      #     document.  The regular expression caught the name of the
      #     requested content in $1.
      #
      my $inserted_content_string = $1;
      my $inserted_content_name   = $inserted_content_string;
      my $inserted_content_args   = '';

      if ( $inserted_content_string =~ /(.*?)\((.*)\)/ ) {
	$inserted_content_name = $1;
	$inserted_content_args = $2;
      }

      #---------------------------------------------------------------
      # P2: 8.14.2 - Print debugging message
      #
      printdebug("P2 begin insert name: $inserted_content_name args: $inserted_content_args") if $DEBUGGING;

      #---------------------------------------------------------------
      # P2: 8.14.3 - End any data element
      #
      end_any_data_element();

      #---------------------------------------------------------------
      # P2: 8.14.4 - Set state: in insert = 1
      #
      $in{'insert'} = 1;

      #---------------------------------------------------------------
      # P2: 8.14.5 - Increment count: insert total
      #
      ++ $count{'insert'}{'total'};

      #---------------------------------------------------------------
      # P2: 8.14.6 - IF 'insert' directive is NOT valid
      #
      #     We need to make sure the content requested CAN be
      #     inserted.  Near the top of the script I defined a hash
      #     named %inserted_content_types that knows about all
      #     available inserted content types.
      #
      #     If this is NOT a known inserted content type, then raise a
      #     warning and comment out this line.
      #
      if ( not $inserted_content_types{$inserted_content_name} ) {

	#-------------------------------------------------------------
	# P2: 8.14.6.1 - Print warning
	#
        printwarning(
          "unknown insert content request: $inserted_content_name\n"
        );

	#-------------------------------------------------------------
	# P2: 8.14.6.2 - Comment out the line
	#
        s/^(.*)/# $1/;

        push @outtext, [$nest,$nesting_level,$current{'line'},$_];
        next LINE;
      }

      #---------------------------------------------------------------
      # P2: 8.14.7 - ELSE 'insert' directive is valid
      #
      #    Now, it would be tempting to insert the requested content
      #    into the document RIGHT NOW but there's a problem with
      #    that.  What if the user has requested content that has not
      #    yet been read into memory?
      #
      #    This problem gets even MORE hairy when you consider the
      #    possibility that inserted content might generate even MORE
      #    inserted content requests (unlikely but possible).
      #
      #    To avoid this problem we will make a list of content to be
      #    inserted on THIS run and insert it on the NEXT run of pass
      #    2.
      #
      else {

	#---------------------------------------------------------------
	# P2: 8.14.7.1 - Get current label
	#
	my $label = $current{'label'};

	#---------------------------------------------------------------
	# P2: 8.14.7.2 - Change line to 'insert_ins_content'
	#
	#    Change the 'insert:' at the beginning of the line to
	#    'insert_ins_content:' so on the next pass the content will
	#    be inserted and this line won't be interpretted as an
	#    insert content request a second time.
	#
	my $line = "insert_ins_content:: $inserted_content_name;$label;$inserted_content_args\n";

	print '.' if not $option{'gui'} and not $option{'verbose'};

	push @outtext, [$nest,$nesting_level,$current{'line'},$line];
	next LINE;

      }

    }

    #-----------------------------------------------------------------
    # P2: 8.15 - ELSIF line is a 'script' directive
    #
    #     A 'script:' line does NOT end a region preamble.
    #
    elsif (/^script::(\S+?:)?\s*(.*?)(\s+\#(.*))?$/) {

      #---------------------------------------------------------------
      # P2: 8.15.1 - Parse 'script' directive
      #
      #     The regular expression caught the requested command in $1.
      #     Note that all commands must be on a single line.
      #
      #     !!! Bug Here !!!
      #
      #     It might be nice to allow users to create multi-line
      #     commands by escaping the newline with a backslash.
      #
      my $script_attr1 = $1;
      my $command      = $2;
      my @output       = ();

      #---------------------------------------------------------------
      # P2: 8.15.2 - Print debugging message
      #
      printdebug("P2 begin script $command") if $DEBUGGING;

      #---------------------------------------------------------------
      # P2: 8.15.3 - End any data element
      #
      end_any_data_element();

      #---------------------------------------------------------------
      # P2: 8.15.4 - Set state: in script = 1
      #
      $in{'script'} = 1;

      #---------------------------------------------------------------
      # P2: 8.15.5 - Increment count: script total
      #
      ++ $count{'script'}{'total'};

      #---------------------------------------------------------------
      # P2: 8.15.6 - IF option 'scripts'
      #
      #     If scripts are enabled, Run the command and get the
      #     output.
      #
      if ( $option{'scripts'} ) {

        #-------------------------------------------------------------
	# P2: 8.15.6.1 - IF OS is Windows
	#
        #     If we're running on Windows, replace forward slashes to
        #     backslashes in the command.
        #
	if ($^O eq 'MSWin32') {
	  $command =~ s/\//\\/g;
	}

        #-------------------------------------------------------------
	# P2: 8.15.6.2 - Print debugging message
	#
	printmessage("script: $command") if $DEBUGGING;
	print '.' if not $option{'gui'} and not $option{'verbose'};

        #-------------------------------------------------------------
	# P2: 8.15.6.3 - Execute requested script
	#
        @output = eval { `"$command"` };

        #-------------------------------------------------------------
	# P2: 8.15.6.4 - IF 'hide' attribute NOT passed
	#
        #     If the author did not specify the 'hide' attribute to
        #     request the output of the script be hidden, write the
        #     output of the script (merge it) one line at a time into
        #     the document.
        #
	if ($script_attr1 ne 'hide:') {

	  #-----------------------------------------------------------
	  # P2: 8.15.6.4.1 - FOREACH line of script output
	  #
	  foreach my $line (@output) {
	    push @outtext, [$nest,$nesting_level,$current{'line'},$line];
	  }

	  next LINE;
	}

        #-------------------------------------------------------------
	# P2: 8.15.6.5 - ELSE 'hide' attribute passed
	#
	#     DON'T PUT THIS LINE BACK INTO OUTTEXT!
	#
	else {
	  next LINE;
	}

      }

      #---------------------------------------------------------------
      # P2: 8.15.7 - ELSE 'scripts' are disabled
      #
      #     Otherwise, output a message saying the script feature has
      #     been disabled.
      #
      else {

        #-------------------------------------------------------------
	# P2: 8.15.7.1 - Print debugging message 'ignoring script'
	#
	printmessage("ignoring script: \"$command\" (scripts not enabled)")
	  if $DEBUGGING;

        #-------------------------------------------------------------
	# P2: 8.15.7.2 - Construct preformatted notification
	#
        my $output = <<"END_OF_TEXT";
---preformatted

NOTICE:

The script you requested was:

  $command

The script feature was disabled when you published this document.  To
enable it, use the "--script" option from the command line or select
the "run scripts" option in the GUI (under the options tab).

---preformatted

END_OF_TEXT

        #-------------------------------------------------------------
	# P2: 8.15.7.3 - FOREACH line of the preformatted notification
	#
        #     Write the output string one line at a time to the
        #     document.
        #
        foreach my $line (split("/n",$output)) {
          push @outtext, [$nest,$nesting_level,$current{'line'},$line];
        }

	next LINE;

      }
    }

    #-----------------------------------------------------------------
    # P2: 8.16 - ELSIF line is 'insert_gen_content' directive
    #
    #    Users are NOT ALLOWED to put 'insert_gen_content:' at the
    #    beginning of a line in the input file.  This is reserved for
    #    the program to use to indicate where to put generated content
    #    and script output.
    #
    elsif (/^insert_gen_content::\s*(\S+?)\s*(\#\s*(.*))?$/) {

      #---------------------------------------------------------------
      # P2: 8.16.1 - Parse request
      #
      my $request = $1;
      my ($generated_content_name,$label,$generated_content_args)
	= split(':',$request);

      #---------------------------------------------------------------
      # P2: 8.16.2 - Print debugging message
      #
      printdebug("P2 begin insert_gen_content $generated_content_name")
	if $DEBUGGING;
      print '.' if not $option{'gui'} and not $option{'verbose'};

      #---------------------------------------------------------------
      # P2: 8.16.3 - End any data element
      #
      end_any_data_element();

      #---------------------------------------------------------------
      # P2: 8.16.4 - Print status message
      #
      printstatus("inserting $request");

      #---------------------------------------------------------------
      # P2: 8.16.5 - Initialize text variable
      #
      my $text = $EMPTY_STRING;

      #---------------------------------------------------------------
      # P2: 8.16.6 - IF generated text is context sensitive
      #
      #     This content should have been generated at the end of the
      #     previous run of pass 2 and placed in the
      #     %generated_content hash.
      #
      if ( is_context_sensitive($generated_content_name) ) {
	$text = $generated_content{$generated_content_name}{$label};
      }

      #---------------------------------------------------------------
      # P2: 8.16.7 - ELSE generated text is NOT context sensitive
      #
      else {
	$text = $generated_content{$generated_content_name}{$label}{$generated_content_args};
      }

      #---------------------------------------------------------------
      # P2: 8.16.8 - Split content into lines
      #
      my @lines = split /\n/s, "$text";

      #---------------------------------------------------------------
      # P2: 8.16.9 - FOREACH line of generated content
      #
      #    Replace the current line with the generated content. The
      #    generated content might be multiple lines, and some of
      #    those lines might be other 'generate:' or 'script:'
      #    lines. Therefore we need to split the generated content on
      #    newlines and add each line separately.
      #
      #    Note that we intentionally DON'T put the
      #    'insert_gen_content:' line back into the document, that
      #    would cause and infinite loop.
      #
      foreach my $line (@lines) {
        push @outtext, [$nest,$nesting_level,$current{'line'},"$line\n"];
      }

      next LINE;

    }

    #-----------------------------------------------------------------
    # P2: 8.17 - ELSIF line is 'insert_ins_content' directive
    #
    #    Users are NOT ALLOWED to put 'insert_ins_content:' at the
    #    beginning of a line in the input file.  This is reserved for
    #    the program to use to indicate where to put generated content
    #    and script output.
    #
    elsif (/^insert_ins_content::\s*(.*?)\s*(\#\s*(.*))?$/) {

      #-------------------------------------------------------------
      # P2: 8.17.1 - Parse request
      #
      my $request = $1;
      my ($inserted_content_name,$label,$inserted_content_args)
	= split(';',$request);

      #---------------------------------------------------------------
      # P2: 8.17.2 - Print debugging message
      #
      printdebug("P2 begin insert_ins_content name: $inserted_content_name args: $inserted_content_args") if $DEBUGGING;
      print '.' if not $option{'gui'} and not $option{'verbose'};

      #-------------------------------------------------------------
      # P2: 8.17.3 - End any data element
      #
      end_any_data_element();

      #-------------------------------------------------------------
      # P2: 8.17.4 - Print status message
      #
      printstatus("inserting $request");

      #---------------------------------------------------------------
      # P2: 8.17.5 - Retrieve inserted content
      #
      #     This content should have been gathered on the previous
      #     iteration of pass 2 and placed in the %lookup data
      #     structure.
      #
      my $text = '';

      if ($inserted_content_name eq 'narrative') {
	$text = $lookup{$inserted_content_args}{$inserted_content_name};
      }

      #---------------------------------------------------------------
      # !!! BUG HERE !!!
      #
      # Can't lookup glossary entries in pass_two because the
      # %glossary datastructure is not populated until between pass 2
      # and 3.
      #---------------------------------------------------------------

      elsif ($inserted_content_name eq 'definition') {
	my ($alt,$term) = split(':',$inserted_content_args);
	if ($alt) {
	  $text = $glossary{$term}{$alt};
	} else {
	  $text = $glossary{$term};
	}
      }

      #---------------------------------------------------------------
      # P2: 8.17.6 - Split content into lines
      #
      my @lines = split /\n/s, "$text";

      #---------------------------------------------------------------
      # P2: 8.17.7 - FOREACH line of inserted content
      #
      #    Replace the current line with the inserted content. The
      #    inserted content might be multiple lines, and some of those
      #    lines might be 'generate:', 'script:', or 'insert:'
      #    lines. Therefore we need to split the inserted content on
      #    newlines and add each line separately.
      #
      #    Note that we intentionally DON'T put the
      #    'insert_ins_content:' line back into the document, THAT
      #    would cause and infinite loop.
      #
      foreach my $line (@lines) {
        push @outtext, [$nest,$nesting_level,$current{'line'},"$line\n"];
      }

      next LINE;

    }

    #-----------------------------------------------------------------
    # P2: 8.18 - ELSIF line begins 'image' data element
    #
    #     This code only handles "image:" lines outside of a figure
    #     environment (which is rare).
    #
    elsif ( /^image::\s*(.*?)(\s+\#(.*))?$/ and not $in{'figure'} ) {

      #---------------------------------------------------------------
      # P2: 8.18.1 - Get image filename
      #
      my $image_file = $1;

      my $current_file = $current{'file'};
      my $tier         = $nesting_level + 1;

      $files{$current_file}{'resources'}{$image_file} = 1;
      $files{$image_file}{'tier'}                     = $tier;

      #---------------------------------------------------------------
      # P2: 8.18.2 - Print debugging message
      #
      printdebug("P2 begin image $image_file") if $DEBUGGING;

      #---------------------------------------------------------------
      # P2: 8.18.3 - End any data element
      #
      end_any_data_element();

      #---------------------------------------------------------------
      # P2: 8.18.4 - Set state: in image = 1
      #
      $in{'image'} = 1;

      #---------------------------------------------------------------
      # P2: 8.18.5 - Publish image
      #
      publish_image($image_file);

      #---------------------------------------------------------------
      # P2: 8.18.6 - Increment count: image total
      #
      ++ $count{'image'}{'total'};

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;

    }

    #-----------------------------------------------------------------
    # P2: 8.19 - ELSIF begin 'footnote' data element
    #
    elsif ( /^footnote::([^\s\:]+):(([^\s\:]+):)?\s*(.*)(\s+\#(.*))?$/ ) {
#    elsif ( /^footnote::([^\s\:]+):\s*(.*?)(\s+\#(.*))?$/ ) {

      #---------------------------------------------------------------
      # P2: 8.19.1 - Get footnote text
      #
      my $arg1 = $1;
      my $arg2 = $3;
      my $text = $4;

      my ($divid,$tag);

      if ( $arg1 and $arg2 )
	{
	  $divid = $arg1;
	  $tag   = $arg2;
	}
      elsif ( $arg1 )
	{
	  $tag = $arg1;
	}

      #---------------------------------------------------------------
      # P2: 8.19.2 - End any data element
      #
      end_any_data_element();

      #---------------------------------------------------------------
      # P2: 8.19.3 - Set state: in footnote = 1
      #
      $in{'footnote'} = 1;
      $current{'footnote-tag'} = $tag;

      #---------------------------------------------------------------
      # P2: 8.19.4 - Increment count: footnote total
      #
      ++ $count{'footnote'}{'total'};

      #---------------------------------------------------------------
      # P2: 8.19.5 - Store text to footnote data structure
      #
      my $num = $count{'footnote'}{'total'};
      my $label = $current{'label'};

      if ($divid)
	{
	  $footnote{$divid}{$tag} = $text;
	}
      else
	{
	  $footnote{$label}{$tag} = $text;
	}

      #---------------------------------------------------------------
      # P2: 8.19.6 - Print debugging message
      #
      printdebug("P2 begin footnote $label $tag") if $DEBUGGING;

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;

    }

    #-----------------------------------------------------------------
    # P2: 8.20 - ELSIF begin 'glossary' data element
    #
    elsif (/^glossary::\s*(.*?)\s*(\[(.*?)\])?\s*=\s*(.*?)(\s+\#(.*))?$/) {

      #---------------------------------------------------------------
      # P2: 8.20.1 - Parse glossary term and text
      #
      my $term = $1;
      my $alt  = $3 || '';
      my $text = $4;

      #---------------------------------------------------------------
      # P2: 8.20.2 - Print debugging message
      #
      printdebug("P2 begin glossary term $term $alt") if $DEBUGGING;

      #---------------------------------------------------------------
      # P2: 8.20.3 - End any data element
      #
      end_any_data_element();

      #---------------------------------------------------------------
      # P2: 8.20.4 - Set state: in glossary = 1
      #
      $in{'glossary'} = 1;

      #---------------------------------------------------------------
      # P2: 8.20.5 - Increment count: glossary total
      #
      #     Just for the heck of it, maybe this will be useful
      #     information someday.  We need at the very least to detect
      #     whether or not the document contains *any* glossary
      #     entries so we know whether or not it is possible to
      #     generate a glossary.
      #
      ++ $count{'glossary'}{'total'};

      #---------------------------------------------------------------
      # P2: 8.20.6 - Remember current glossary term
      #
      #     Remember the current glossary term to the second and
      #     subsequent lines of the glossary entry can be assigned to
      #     this term.
      #
      $current{'glossary_term'} = [$term,$alt];

      #---------------------------------------------------------------
      # P2: 8.20.7 - Store text of glossary term definition
      #
      $data{'glossary'}{$term}{$alt} = $text;

      #---------------------------------------------------------------
      # P2: 8.20.8 - IF the term contains an ampersand
      #
      if ( $term =~ /&/ ) {

	#-------------------------------------------------------------
	# P2: 8.20.8.1 - Replace ampersand with ' and '
	#
	$term =~ s/&/ and /g;

	#-------------------------------------------------------------
	# P2: 8.20.8.2 - Store text of glossary term definition
	#
	$data{'glossary'}{$term}{$alt} = $text;

      }

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.21 - ELSIF begin 'var' data element
    #
    elsif (/^var::\s*(.*?)\s*=\s*(.*?)(\s+\#\s*(.*))?$/) {

      #---------------------------------------------------------------
      # P2: 8.21.1 - Parse variable name and value
      #
      my $varname = $1;
      my $value   = $2;

      #---------------------------------------------------------------
      # P2: 8.21.2 - Print debugging message
      #
      printdebug("P2 begin var $varname = $value") if $DEBUGGING;

      #---------------------------------------------------------------
      # P2: 8.21.3 - End any data element
      #
      end_any_data_element();

      #---------------------------------------------------------------
      # P2: 8.21.4 - Set state: in var = 1
      #
      $in{'var'} = 1;

      #---------------------------------------------------------------
      # P2: 8.21.5 - Increment count: var total
      #
      #     Just for the heck of it, maybe this will be useful
      #     information someday.
      #
      ++ $count{'var'}{'total'};

      #---------------------------------------------------------------
      # P2: 8.21.6 - Remember current variable name
      #
      #     Remember the current variable name so the second and
      #     subsequent lines of the variable value can be appended to
      #     this name.
      #
      $current{'var_name'} = $varname;

      #---------------------------------------------------------------
      # P2: 8.21.7 - Store variable name/value in data structure
      #
      $data{'var'}{$varname} = $value;

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.22 - ELSIF begin 'acronym' data element
    #
    elsif (/^acronym::\s*(.*?)\s*=\s*(.*?)(\s+\#\s*(.*))?$/) {

      #---------------------------------------------------------------
      # P2: 8.22.1 - Parse term and text
      #
      my $term = $1;
      my $text = $2;

      #---------------------------------------------------------------
      # P2: 8.22.2 - Print debugging message
      #
      printdebug("P2 begin acronym $term = $text") if $DEBUGGING;

      #---------------------------------------------------------------
      # P2: 8.22.3 - End any data element
      #
      end_any_data_element();

      #---------------------------------------------------------------
      # P2: 8.22.4 - Set state: in acronym = 1
      #
      $in{'acronym'} = 1;

      #---------------------------------------------------------------
      # P2: 8.22.5 - Increment count: acronym total
      #
      #     Just for the heck of it, maybe this will be useful
      #     information someday.  We need at the very least to detect
      #     whether or not the document contains any acronym
      #     definitions so we know whether or not it is possible to
      #     generate a list of acronyms.
      #
      ++ $count{'acronym'}{'total'};

      #---------------------------------------------------------------
      # P2: 8.22.6 - Remember current acronym
      #
      #     Remember the current acronym term so the second and
      #     subsequent lines of the acronym definition can be assigned
      #     to this term.
      #
      $current{'acronym'} = $term;

      #---------------------------------------------------------------
      # P2: 8.22.7 - Store acronym text in data structure
      #
      $data{'acronym'}{$term} = $text;

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.23 - ELSIF begin 'index' data element
    #
    elsif (/^index::(\S+:)?\s*(.*?)(\s+\#\s*(.*))?$/) {

      #---------------------------------------------------------------
      # P2: 8.23.1 - Parse index attributes and text
      #
      my $attrs = $1;
      my $text  = $2;

      #---------------------------------------------------------------
      # P2: 8.23.2 - Print debugging message
      #
      printdebug("P2 begin index entry") if $DEBUGGING;

      #---------------------------------------------------------------
      # P2: 8.23.3 - End any data element
      #
      end_any_data_element();

      #---------------------------------------------------------------
      # P2: 8.23.4 - Set state: in index = 1
      #
      $in{'index'} = 1;

      #---------------------------------------------------------------
      # P2: 8.23.5 - Increment count: index total
      #
      ++ $count{'index'}{'total'};

      #---------------------------------------------------------------
      # P2: 8.23.6 - Split index entries by semi-colon
      #
      #     Multiple index entries can be separated by semicolons.
      #
      my @entries = split(/\s*\;\s*/, $text);

      #---------------------------------------------------------------
      # P2: 8.23.7 - FOREACH index entry in list of entries
      #
      #     Count both the number of entries and the number of
      #     instances of each index entry -- just for the heck of it,
      #     maybe this will be useful information someday.  We need at
      #     the very least to detect whether or not the document
      #     contains any index entries so we know whether or not it is
      #     possible to generate an index.
      #
      foreach my $entry (@entries) {
	++ $data{'index'}{$entry};
      }

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.24 - ELSIF begin 'outcome' data element
    #
    elsif (/^outcome::(\S+:)?\s*(.*?)(\s+\#\s*(.*))?$/) {

      #---------------------------------------------------------------
      # P2: 8.24.1 - Parse attributes and text
      #
      my $attrs = $1;
      my $text  = $2;

      #---------------------------------------------------------------
      # P2: 8.24.2 - Print debugging message
      #
      printdebug("P2 begin outcome $attrs") if $DEBUGGING;

      #---------------------------------------------------------------
      # P2: 8.24.3 - End any data element
      #
      end_any_data_element();

      #---------------------------------------------------------------
      # P2: 8.24.4 - Set state: in outcome = 1
      #
      $in{'outcome'} = 1;

      #---------------------------------------------------------------
      # P2: 8.24.5 - Increment count: outcome total
      #
      ++ $count{'outcome'}{'total'};

      #---------------------------------------------------------------
      # P2: 8.24.6 - Initialize date, item, and status values
      #
      my $date   = '';
      my $item   = '';
      my $status = '';

      #---------------------------------------------------------------
      # P2: 8.24.7 - IF attribute syntax is correct
      #
      if ( $attrs =~ /(.*?):(.*?):(.*):/) {
	$date   = $1;
	$item   = $2;
	$status = $3;
      }

      #---------------------------------------------------------------
      # P2: 8.24.8 - ELSE attribute syntax is NOT correct
      #
      else {
	printerror("outcome attribute syntax not correct");
	push @outtext, [$nest,$nesting_level,$current{'line'},$_];
	next LINE;
      }

      #---------------------------------------------------------------
      # P2: 8.24.9 - Remember current outcome item and date
      #
      $current{'outcome'}{'item'}  = $item;
      $current{'outcome'}{'date'}  = $date;

      #---------------------------------------------------------------
      # P2: 8.24.10 - Store this outcome in outcomes data structure
      #
      $outcomes{$item}{$date}{'status'}      = $status;
      $outcomes{$item}{$date}{'description'} = $text;
      $outcomes{$item}{$date}{'source'}      = $current{'label'};

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #---------------------------------------------------------------
    # P2: 8.25 - ELSIF begin 'review' data element
    #
    elsif (/^review::(\S+:)?\s*(.*?)(\s+\#\s*(.*))?$/) {

      #-------------------------------------------------------------
      # P2: 8.25.1 - Parse attributes and text
      #
      my $attrs = $1;
      my $text  = $2;

      #-------------------------------------------------------------
      # P2: 8.25.2 - Print debugging message
      #
      printdebug("P2 begin review $attrs") if $DEBUGGING;

      #-------------------------------------------------------------
      # P2: 8.25.3 - End any data element
      #
      end_any_data_element();

      #-------------------------------------------------------------
      # P2: 8.25.4 - Set state: in review = 1
      #
      $in{'review'} = 1;

      #-------------------------------------------------------------
      # P2: 8.25.5 - Increment count: review total
      #
      ++ $count{'review'}{'total'};

      #---------------------------------------------------------------
      # P2: 8.25.6 - Initialize date, item, and status values
      #
      my $date   = '';
      my $item   = '';
      my $status = '';

      #---------------------------------------------------------------
      # P2: 8.25.7 - IF attribute syntax is correct
      #
      if ( $attrs =~ /(.*?):(.*?):(.*)/) {
	$date   = $1;
	$item   = $2;
	$status = $3;
      }

      #---------------------------------------------------------------
      # P2: 8.25.8 - ELSE attribute syntax is NOT correct
      #
      else {
	printerror("review attribute syntax not correct");
	push @outtext, [$nest,$nesting_level,$current{'line'},$_];
	next LINE;
      }

      #-------------------------------------------------------------
      # P2: 8.25.9 - Remember current review item and date
      #
      $current{'review'}{'item'}  = $item;
      $current{'review'}{'date'}  = $date;

      #-------------------------------------------------------------
      # P2: 8.25.10 - Store this review in reviews data structure
      #
      $reviews{$item}{$date}{'status'}      = $status;
      $reviews{$item}{$date}{'description'} = $text;
      $reviews{$item}{$date}{'source'}      = $current{'label'};

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.26 - ELSIF begin 'step' data element
    #
    #     Don't do anything with steps (all the interesting stuff
    #     happens in pass three).  But, if we've found a step on this
    #     line it means we should end any other data element we might
    #     happen to be in.
    #
    elsif (/^step::\s*(.*?)(\s+\#\s*(.*))?$/) {

      #-----------------------------------------------------------------
      # P2: 8.26.1 - Print debugging message
      #
      printdebug("P2 begin step") if $DEBUGGING;

      #-----------------------------------------------------------------
      # P2: 8.26.2 - End any data element
      #
      end_any_data_element();

      #-----------------------------------------------------------------
      # P2: 8.26.3 - Set state: in step = 1
      #
      $in{'step'} = 1;

      #-----------------------------------------------------------------
      # P2: 8.26.4 - Increment count: step total
      #
      ++ $count{'step'}{'total'};

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;

    }

    #---------------------------------------------------------
    # P2: 8.27 - IF element is a label
    #
    #     If this data element is a label, remember some
    #     additional information about where it occured in the
    #     document.
    #
    #     For example, imagine this label is inside a table
    #     appearing in chapter 2 in section 2.4.14.  The
    #     information we'd remember is:
    #
    #     $label{$label}{'name'}     = 'Table';
    #     $label{$label}{'type'}     = 'environment';
    #     $label{$label}{'toptype'}  = 'Chapter';
    #     $label{$label}{'topnum'}   = '2';
    #     $label{$label}{'secnum'}   = '2.4.14';
    #     $label{$label}{'title'}    = 'My table';
    #     $label{$label}{'number'}   = '2-6';
    #
    elsif (/^(id|label)::\s*(.*?)\s*(\#\s*(.*))?$/ ) {

      #-------------------------------------------------------
      # P2: 8.27.1 - Parse label
      #
      my $label = $2;

      #-------------------------------------------------------
      # P2: 8.27.2 - Print debugging message
      #
      printdebug("P2 begin label $label") if $DEBUGGING;

      #---------------------------------------------------------------
      # P2: 8.27.3 - End any data element
      #
      end_any_data_element();

      #---------------------------------------------------------------
      # P2: 8.27.4 - Set state: in label = 1
      #
      $in{'label'} = 1;

      #---------------------------------------------------------------
      # P2: 8.27.5 - Remember previous label
      #
      my $previous_label = $current{'label'};

      #-------------------------------------------------------
      # P2: 8.27.6 - Set current label
      #
      $current{'label'} = $label;

      #---------------------------------------------------------------
      # P2: 8.27.7 - Increment count: label total
      #
      ++ $count{'label'}{'total'};

      #-------------------------------------------------------
      # P2: 8.27.8 - Replace top label on label stack
      #
      pop(@{ $current{'label_stack'} });
      push(@{ $current{'label_stack'} }, $current{'label'});

      #-------------------------------------------------------
      # P2: 8.27.9 - Store label in data structure
      #
      my $name = $current{'name'};
      my $num  = $count{$name}{'total'};
      $data{$name}{$num}{'label'} = $current{'label'};
      $data{$name}{$num}{'order'} = $count{'division'};

      #-------------------------------------------------------
      # P2: 8.27.10 - Print detailed debugging message
      #
      if ($DEBUGGING) {
	print "DEBUG: pass 2 found label $label\n";
	print "       current name:        $name\n";
	print "       current num:         $num\n";
	print "       label:               $current{'label'}\n";
	print "\n";
	print "       structure name type: $structure{$name}{'type'}\n";
	print "       current toptype:     $current{'toptype'}\n";
	print "       current topnum:      $current{'topnum'}\n";
	print "       current secnum:      $current{'secnum'}\n";
	print "       current sectype:     $current{'sectype'}\n";
	print "       current title:       $current{'title'}\n";
	print "       current number:      $current{'number'}\n";
      }

      #-------------------------------------------------------
      # P2: 8.27.11 - Store data in label data structure
      #
      $label{$label}{'name'}    = $current{'name'};          # Table
      $label{$label}{'type'}    = $structure{$name}{'type'}; # Section
      $label{$label}{'toptype'} = $current{'toptype'};       # Chapter
      $label{$label}{'topnum'}  = $current{'topnum'};        # 2
      $label{$label}{'secnum'}  = $current{'secnum'};        # 2.4.14
      $label{$label}{'sectype'} = $current{'sectype'};       # section
      $label{$label}{'title'}   = $current{'title'};         # My Title
      $label{$label}{'number'}  = $current{'number'};        # 2-6
      $label{$label}{'order'}   = $count{'division'};        # 142

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.28 - IF element is a title
    #
    elsif (/^title::\s*(.*?)(\s+\#\s*(.*))?$/) {

      #-------------------------------------------------------
      # P2: 8.28.1 - Parse title
      #
      my $title = $1;

      #-------------------------------------------------------
      # P2: 8.28.2 - Print debugging message
      #
      printdebug("P2 begin title") if $DEBUGGING;

      #---------------------------------------------------------------
      # P2: 8.28.3 - End any data element
      #
      end_any_data_element();

      #-------------------------------------------------------
      # P2: 8.28.4 - Set current title
      #
      $current{'title'} = $title;

      #---------------------------------------------------------------
      # P2: 8.28.5 - Set state: in title = 1
      #
      $in{'title'} = 1;

      #---------------------------------------------------------------
      # P2: 8.28.6 - Increment count: title total
      #
      ++ $count{'title'}{'total'};

      #-------------------------------------------------------
      # P2: 8.28.7 - Replace top title on title stack
      #
      pop(@{ $current{'title_stack'} });
      push(@{ $current{'title_stack'} }, $title);

      #-------------------------------------------------------
      # P2: 8.28.8 - Store title in data structure
      #
      my $name = $current{'name'};
      my $num  = $count{$name}{'total'};
      $data{$name}{$num}{'title'} = $title;

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.29 - ELSIF line begins 'date' element
    #
    elsif ( /^date::\s*(.*?)(\s+\#\s*(.*))?$/ ) {

      #-----------------------------------------------------------------
      # P2: 8.29.1 - Parse date
      #
      my $date = $1;

      #-------------------------------------------------------
      # P2: 8.29.2 - Print debugging message
      #
      printdebug("P2 begin date") if $DEBUGGING;

      #-----------------------------------------------------------------
      # P2: 8.29.3 - End any data element
      #
      end_any_data_element();

      #-----------------------------------------------------------------
      # P2: 8.29.4 - Strip any change control keywords
      #
      $date =~ s/\$Date:(.*)\$/$1/;

      #-----------------------------------------------------------------
      # P2: 8.29.5 - Set state: in date = 1
      #
      $in{'date'} = 1;

      #---------------------------------------------------------------
      # P2: 8.29.6 - Increment count: date total
      #
      ++ $count{'date'}{'total'};

      #-------------------------------------------------------
      # P2: 8.29.7 - Store date in data structure
      #
      my $name = $current{'name'};
      my $num  = $count{$name}{'total'};
      $data{$name}{$num}{'date'} = $date;

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.30 - ELSIF line begins 'revision' element
    #
    elsif ( /^revision::\s*(.*?)(\s+\#\s*(.*))?$/ ) {

      #-----------------------------------------------------------------
      # P2: 8.30.1 - Parse revision
      #
      my $revision = $1;

      #-------------------------------------------------------
      # P2: 8.30.2 - Print debugging message
      #
      printdebug("P2 begin revision") if $DEBUGGING;

      #-----------------------------------------------------------------
      # P2: 8.30.3 - End any data element
      #
      end_any_data_element();

      #-----------------------------------------------------------------
      # P2: 8.30.4 - Strip any change control keywords
      #
      $revision =~ s/\$Revision:(.*)\$/$1/;

      #-----------------------------------------------------------------
      # P2: 8.30.5 - Set state: in revision = 1
      #
      $in{'revision'} = 1;

      #---------------------------------------------------------------
      # P2: 8.30.6 - Increment count: revision total
      #
      ++ $count{'revision'}{'total'};

      #-------------------------------------------------------
      # P2: 8.30.7 - Store revision in data structure
      #
      my $name = $current{'name'};
      my $num  = $count{$name}{'total'};
      $data{$name}{$num}{'revision'} = $revision;

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.31 - ELSIF line begins 'author' element
    #
    elsif ( /^author::\s*(.*?)(\s+\#\s*(.*))?$/ ) {

      #-----------------------------------------------------------------
      # P2: 8.31.1 - Parse author
      #
      my $author = $1;

      #-------------------------------------------------------
      # P2: 8.31.2 - Print debugging message
      #
      printdebug("P2 begin author") if $DEBUGGING;

      #-----------------------------------------------------------------
      # P2: 8.31.3 - End any data element
      #
      end_any_data_element();

      #-----------------------------------------------------------------
      # P2: 8.31.4 - Strip any change control keywords
      #
      $author =~ s/\$Author:(.*)\$/$1/;

      #-----------------------------------------------------------------
      # P2: 8.31.5 - Set state: in author = 1
      #
      $in{'author'} = 1;

      #---------------------------------------------------------------
      # P2: 8.31.6 - Increment count: author total
      #
      ++ $count{'author'}{'total'};

      my $name = $current{'name'};
      my $num  = $count{$name}{'total'};

      #---------------------------------------------------------------
      # P2: 8.31.7 - IF element may be multivalued
      #
      if ( $structure{$name}{'elements'}{'author'}{'multivalued'} ) {
	push @{ $data{$name}{$num}{'author'} }, $author;
      }

      #-------------------------------------------------------
      # P2: 8.31.8 - ELSE element must be a scalar
      #
      else {
	$data{$name}{$num}{'author'} = $author;
      }

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.32 - ELSIF line begins 'type' element
    #
    #     For some blocks type is multivalued and for others it is
    #     not.
    #
    elsif ( /^type::\s*(.*?)(\s+\#\s*(.*))?$/ ) {

      #-----------------------------------------------------------------
      # P2: 8.32.1 - Parse type
      #
      my $type = $1;

      #-------------------------------------------------------
      # P2: 8.32.2 - Print debugging message
      #
      printdebug("P2 begin type $type") if $DEBUGGING;

      #-----------------------------------------------------------------
      # P2: 8.32.3 - End any data element
      #
      end_any_data_element();

      #-----------------------------------------------------------------
      # P2: 8.32.4 - Set state: in type = 1
      #
      $in{'type'} = 1;

      #---------------------------------------------------------------
      # P2: 8.32.5 - Increment count: type total
      #
      ++ $count{'type'}{'total'};

      my $name = $current{'name'};
      my $num  = $count{$name}{'total'};

      #---------------------------------------------------------------
      # P2: 8.32.6 - IF element may be multivalued
      #
      if ( $structure{$name}{'elements'}{'type'}{'multivalued'} ) {
	push @{ $data{$name}{$num}{'type'} }, $type;
      }

      #-------------------------------------------------------
      # P2: 8.32.7 - ELSE element must be a scalar
      #
      else {
	$data{$name}{$num}{'type'} = $type;
      }

      #-------------------------------------------------------
      # P2: 8.32.8 - IF in section
      #
      #
      if ( in_section() ) {
	my $label = $current{'label'};
	$label{$label}{'sectype'} = $type;
      }

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.33 - ELSIF line begins 'use_formal_status' element
    #
    #     For some blocks use_formal_status is multivalued and for others it is
    #     not.
    #
    elsif ( /^use_formal_status::\s*(.*?)(\s+\#\s*(.*))?$/ ) {

      #-----------------------------------------------------------------
      # P2: 8.33.1 - Parse use_formal_status
      #
      my $use_formal_status = $1;

      #-------------------------------------------------------
      # P2: 8.33.2 - Print debugging message
      #
      printdebug("P2 begin use_formal_status") if $DEBUGGING;

      #-----------------------------------------------------------------
      # P2: 8.33.3 - End any data element
      #
      end_any_data_element();

      #-----------------------------------------------------------------
      # P2: 8.33.4 - Set state: in use_formal_status = 1
      #
      $in{'use_formal_status'} = 1;

      #---------------------------------------------------------------
      # P2: 8.33.5 - Increment count: use_formal_status total
      #
      ++ $count{'use_formal_status'}{'total'};

      #-------------------------------------------------------
      # P2: 8.33.6 - IF use_formal_status value is 1
      #
      if ($use_formal_status == 1) {
	$document{'use_formal_status'} = 1;
	$option{'use_formal_status'}   = 1;
      }

      #-------------------------------------------------------
      # P2: 8.33.7 - ELSIF use_formal_status value is 0
      #
      elsif ($use_formal_status == 0) {
	$document{'use_formal_status'} = 0;
	$option{'use_formal_status'}   = 0;
      }

      #-----------------------------------------------------------------
      # P2: 8.33.8 - ELSE value is neither 1 or 0
      #
      else {
	printerror("use_formal_status must be either 1 or 0");
      }

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.34 - ELSIF line begins 'effort_units' element
    #
    #     For some blocks effort_units is multivalued and for others it is
    #     not.
    #
    elsif ( /^effort_units::\s*(.*?)(\s+\#\s*(.*))?$/ ) {

      #-----------------------------------------------------------------
      # P2: 8.34.1 - Parse effort_units
      #
      my $effort_units = $1;

      #-------------------------------------------------------
      # P2: 8.34.2 - Print debugging message
      #
      printdebug("P2 begin effort_units") if $DEBUGGING;

      #-----------------------------------------------------------------
      # P2: 8.34.3 - End any data element
      #
      end_any_data_element();

      #-----------------------------------------------------------------
      # P2: 8.34.4 - Set state: in effort_units = 1
      #
      $in{'effort_units'} = 1;

      #---------------------------------------------------------------
      # P2: 8.34.5 - Increment count: effort_units total
      #
      ++ $count{'effort_units'}{'total'};

      #-------------------------------------------------------
      # P2: 8.34.6 - Store value in document data structure
      #
      $document{'effort_units'} = $effort_units;

      #-------------------------------------------------------
      # P2: 8.34.7 - Store value in option data structure
      #
      $option{'effort_units'} = $effort_units;

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.35 - ELSIF line begins 'column' data element
    #
    #     Authors are allowed to specify certain table column
    #     parameters:
    #
    #       - head
    #       - width
    #       - background
    #
    elsif ( /^column::(\S+:)?\s*(.*?)(\s+\#\s*(.*))?$/ ) {

      #---------------------------------------------------------------
      # P2: 8.35.1 - Parse attributes and value
      #
      my $attrs = $1;
      my $value = $2;

      #-------------------------------------------------------
      # P2: 8.35.2 - Print debugging message
      #
      printdebug("P2 begin column parameter") if $DEBUGGING;

      #---------------------------------------------------------------
      # P2: 8.35.3 - End any data element
      #
      end_any_data_element();

      #---------------------------------------------------------------
      # P2: 8.35.4 - Set state: in column = 1
      #
      $in{'column'} = 1;

      #---------------------------------------------------------------
      # P2: 8.35.5 - IF not in a table
      #
      if ( not $in{'table'}{'environment'} ) {
	printerror("column parameter found outside table");
	push @outtext, [$nest,$nesting_level,$current{'line'},$_];
	next LINE;
      }

      #---------------------------------------------------------------
      # P2: 8.35.6 - Initialize column and param values
      #
      my $column = '';
      my $param  = '';

      #---------------------------------------------------------------
      # P2: 8.35.7 - IF attributes have correct syntax
      #
      if ( $attrs =~ /(\d+):(width|head|background):/ ) {
	$column = $1;
	$param  = $2;
      }

      #---------------------------------------------------------------
      # P2: 8.35.8 - ELSE attributes do not have correct syntax
      #
      else {
	printerror("column parameter syntax error");
	push @outtext, [$nest,$nesting_level,$current{'line'},$_];
	next LINE;
      }

      #---------------------------------------------------------------
      # P2: 8.35.9 - Get current table number
      #
      #     TABLES MUST BE COUNTED SEPARATE FROM BARETABLES.
      #
      my $num = $count{'table'}{'total'};

      #---------------------------------------------------------------
      # P2: 8.35.10 - IF parameter is column 'width'
      #
      #     The widths of table columns must be expressed in terms of
      #     percentage of overall table width like this:
      #
      #       column:1:width: 50
      #       column:2:width: 50
      #
      #     The sum of all column widths DON'T have to equal 100.
      #     Widths of all columns must be specified.
      #
      if ($param eq 'width') {

	#-------------------------------------------------------------
	# P2: 8.35.10.1 - Value is column width
	#
	my $width = $value;

	#-------------------------------------------------------------
	# P2: 8.35.10.2 - IF width is not an integer between 1 and 100
	#
	if (not $width =~ /\d+/
	    or
	    not ($width >= 1 and $width <= 100)) {
	  printerror("column width ($width) )must be an integer between 1 and 100");
	}

	#-------------------------------------------------------------
	# P2: 8.35.10.3 - ELSE width is an integer between 1 and 100
	#
	else {
	  $data{'table'}{$num}{$column}{'width'} = $width;
	}
      }

      #---------------------------------------------------------------
      # P2: 8.35.11 - ELSIF param is column 'head'
      #
      #     The headers of table columns can be defined like this:
      #
      #       column:1:head: column 1 head
      #       column:2:head: column 2 head
      #
      #     The 'head' value must fit on a single line.
      #     Column heads defined this way will be repeated at
      #     the top of each page in the PDF rendition.
      #
      elsif ($param eq 'head') {
	$data{'table'}{$num}{$column}{'head'} = $value;
      }

      #---------------------------------------------------------------
      # P2: 8.35.12 - IF param is column 'background'
      #
      #     The colors of table columns must be expressed as one of
      #     the allowed colors:
      #
      #       column:1:background: red
      #
      elsif ($param eq 'background') {
	$data{'table'}{$num}{$column}{'background'} = $value;
      }

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.?? - ELSIF line begins with 'csvfile' element
    #
    elsif ( /^csvfile::\s+(.*?)\s*$/ )
      {
	read_csvfile($1);
      }

    #-----------------------------------------------------------------
    # P2: 8.36 - FOREACH element in list of header/footer elements
    #
    foreach my $element (@header_footer_elements) {

      #-----------------------------------------------------------------
      # P2: 8.36.1 - IF line begins this header/footer element AND in
      #              doc preamble
      #
      if (/^${element}::([^\s]*:)?\s*(.*?)(\s+\#\s*(.*))?$/
	  and $in{'preamble'}{'text'}) {

	#---------------------------------------------------------------
	# P2: 8.36.1.1 - Parse attributes and text
	#
	my $attrs   = $1;
	my $text    = $2;
	my $comment = $4;

	#-------------------------------------------------------
	# P2: 8.36.1.2 - Print debugging message
	#
	printdebug("P2 begin header/footer element $element")
	  if $DEBUGGING;

	#---------------------------------------------------------------
	# P2: 8.36.1.3 - End any data element
	#
	end_any_data_element();

	#-------------------------------------------------------
	# P2: 8.36.1.4 - Set state: in this element = 1
	#
	$in{$element} = 1;

	#-------------------------------------------------------
	# P2: 8.36.1.5 - Initialize anonymous struct hash
	#
	my $struct = {};

	#---------------------------------------------------------------
	# P2: 8.36.1.6 - Store text in anonymous struct hash
	#
	${$struct}{'text'} = $text;

	#-------------------------------------------------------
	# P2: 8.36.1.7 - IF attributes present
	#
	if ($attrs) {

	  #-------------------------------------------------------
	  # P2: 8.36.1.7.1 - Split attributes into list
	  #
	  my @attr = split(':', $attrs);

	  #-------------------------------------------------------
	  # P2: 8.36.1.7.2 - FOREACH attribute in list
	  #
	  foreach my $attr (@attr) {

	    #-----------------------------------------------------
	    # P2: 8.36.1.7.2.1 - FOREACH allowable font size
	    #
	    foreach my $size (@font_sizes) {
	      if ($attr eq $size) {
		${$struct}{'size'} = $size;
	      }
	    }

	    #-----------------------------------------------------
	    # P2: 8.36.1.7.2.2 - FOREACH allowable font weight
	    #
	    foreach my $weight (@font_weights) {
	      if ($attr eq $weight) {
		${$struct}{'weight'} = $weight;
	      }
	    }

	    #-----------------------------------------------------
	    # P2: 8.36.1.7.2.3 - FOREACH allowable font shape
	    #
	    foreach my $shape (@font_shapes) {
	      if ($attr eq $shape) {
		${$struct}{'shape'} = $shape;
	      }
	    }

	    #-----------------------------------------------------
	    # P2: 8.36.1.7.2.4 - FOREACH allowable font family
	    #
	    foreach my $family (@font_families) {
	      if ($attr eq $family) {
		${$struct}{'family'} = $family;
	      }
	    }
	  }
	}

	#-------------------------------------------------------
	# P2: 8.36.1.8 - Store struct in document data
	#
	push @{ $document{$element} }, $struct;

	push @outtext, [$nest,$nesting_level,$current{'line'},$_];
	next LINE;
      }

    }

    #---------------------------------------------------------------
    # P2: 8.37 - IF in this name/type and line not blank
    #
    #     Are we in one? Only look for relevant data elements.
    #
    #     !!! Bug Here !!!
    #
    #     I think I've made an assumption you can only be in one
    #     name/type at one time.  Is this true?  What about
    #     universal/text?  You can't be in preamble/text and
    #     universal/text at the same time.
    #
    if ( $in{$name}{$type} ) {

      my $num  = $count{$name}{'total'};

      #---------------------------------------------------------------
      # P2: 8.37.1 - Make list of allowed data elements
      #
      #     Make a list of data elements allowed in this environment
      #     or region.  Each environment and region defined in the
      #     %structure data structure includes an 'elements' list
      #     that defines the allowed elements.
      #
      my @allowed_elements = keys %{ $structure{$name}{'elements'} };

      #---------------------------------------------------------------
      # P2: 8.37.2 - FOREACH element in allowed elements
      #
      #     Check for each allowed data element.  Look for each data
      #     element allowed for this text, environment, or region.
      #
      foreach my $element (@allowed_elements) {

	#-------------------------------------------------------------
	# P2: 8.37.2.1 - IF this line begins this data element
	#
	#     Test to see if this line begins with the name of this
	#     data element.
	#
	if ( /^${element}::(\S*:)?\s*(.*?)(\s+\#\s*(.*))?$/ ) {

	  #-----------------------------------------------------------
	  # P2: 8.37.2.1.1 - Parse attributes from line
	  #
	  my $attrs   = $1;
	  my $value   = $2;
	  my $comment = $4;

	  if ($element eq 'image')
	    {
	      my $current_file = $current{'file'};
	      my $tier         = $nesting_level + 1;

	      $files{$current_file}{'resources'}{$value} = 1;
	      $files{$value}{'tier'}                     = $tier;
	    }

	  if ($element eq 'file')
	    {
	      my $current_file = $current{'file'};
	      my $tier         = $nesting_level + 1;

	      $files{$current_file}{'resources'}{$value} = 1;
	      $files{$value}{'tier'}                     = $tier;
	    }

	  #-----------------------------------------------------------
	  # P2: 8.37.2.1.2 - Print debugging message
	  #
	  printdebug("P2 begin $element data element $name $type $num is \"$value\"")
	    if $DEBUGGING;

	  #-----------------------------------------------------------
	  # P2: 8.37.2.1.3 - End any data element
	  #
	  #     Since we've found the beginning of a data element, it
	  #     means we're no longer in any other data element.
	  #
	  #     !!! BUG HERE !!!
	  #
	  #     Now here's an odd thing.  You'd think that I could
	  #     simply call the end_any_data_element() subroutine to
	  #     perform this function.  But, when I do, I only get
	  #     the first line of text from each data element.  I
	  #     don't know why.  I *do* know that the following
	  #     block of code works fine so I'll keep it for now.
	  #
	  end_any_data_element();

	  #---------------------------------------------------------
	  # P2: 8.37.2.1.4 - Remember we're in this element
	  #
	  $in{$name}{$element} = 1;

	  #-------------------------------------------------------------
	  # P2: 8.37.2.1.5 - IF this element may be multivalued
	  #
	  if ( $structure{$name}{'elements'}{$element}{'multivalued'} ) {
	    push(@{$data{$name}{$num}{$element}}, $value);
	  }

	  #-----------------------------------------------------------
	  # P2: 8.37.2.1.6 - ELSE element may not be multivalued
	  #
	  #     If you've made it this far then this must be a plain
	  #     old-fashioned data element.  Stuff it into the data
	  #     structure as a plain old scalar.
	  #
	  else {
	    $data{$name}{$num}{$element} = $value;

	    # if this is a document preamble element also put it in
	    # the document datastructure (for example, capture
	    # $document{'doctype'})
	    #
	    if ($name eq 'preamble' and $num == 1) {
	      $document{$element} = $value;
	    }
	  }

	  push @outtext, [$nest,$nesting_level,$current{'line'},$_];
	  next LINE;

	}
      }
    }

    ##################################################################
    ##################################################################
    ##################################################################
    ###                                                            ###
    ###                  Ending of Data Elements                   ###
    ###                                                            ###
    ##################################################################
    ##################################################################
    ##################################################################

    #-----------------------------------------------------------------
    # P2: 8.38 - ELSIF in file and line blank
    #
    #     Look for a file continuation line.
    #
    if ( $in{'file'} and /^\s*$/ ) {
      $in{'file'} = 0;
      printdebug("P2 end file") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.39 - ELSIF in 'generate' and line blank
    #
    elsif ( $in{'generate'} and /^\s*$/ ) {
      $in{'generate'} = 0;
      printdebug("P2 end generate") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.40 - ELSIF in 'insert' and line blank
    #
    elsif ( $in{'insert'} and /^\s*$/ ) {
      $in{'insert'} = 0;
      printdebug("P2 end insert") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.41 - ELSIF in 'script' and line blank
    #
    elsif ( $in{'script'} and /^\s*$/ ) {
      $in{'script'} = 0;
      printdebug("P2 end script") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.42 - ELSIF in 'insert_gen_content' and line blank
    #
    elsif ( $in{'insert_gen_content'} and /^\s*$/ ) {
      $in{'insert_gen_content'} = 0;
      printdebug("P2 end insert_gen_content") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.43 - ELSIF in 'insert_ins_content' and line blank
    #
    elsif ( $in{'insert_ins_content'} and /^\s*$/ ) {
      $in{'insert_ins_content'} = 0;
      printdebug("P2 end insert_ins_content") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.44 - ELSIF in 'image' and line blank
    #
    elsif ( $in{'image'} and /^\s*$/ ) {
      $in{'image'} = 0;
      printdebug("P2 end image") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.45 - ELSIF in 'footnote' and line blank
    #
    elsif ( $in{'footnote'} and /^\s*$/ ) {
      $in{'footnote'} = 0;
      printdebug("P2 end footnote") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.46 - ELSIF in 'glossary' and line blank
    #
    elsif ( $in{'glossary'} and /^\s*$/ ) {
      $in{'glossary'}           = 0;
      $current{'glossary_term'} = [];
      printdebug("P2 end glossary entry") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.47 - ELSIF in 'var' and line blank
    #
    elsif ( $in{'var'} and /^\s*$/ ) {
      $in{'var'} = 0;
      $current{'var_name'} = '';
      printdebug("P2 end var") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #---------------------------------------------------------------
    # P2: 8.48 - ELSIF in 'acronym' and line blank
    #
    elsif ( $in{'acronym'} and /^\s*$/ ) {
      $in{'acronym'} = 0;
      $current{'acronym'} = '';
      printdebug("P2 end acronym") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.49 - ELSIF in 'index' and line blank
    #
    elsif ( $in{'index'} and /^\s*$/ ) {
      $in{'index'} = 0;
      printdebug("P2 end index entry") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #---------------------------------------------------------------
    # P2: 8.50 - ELSIF in 'outcome' and line blank
    #
    elsif ( $in{'outcome'} and /^\s*$/ ) {
      $in{'outcome'} = 0;
      $current{'outcome'}{'item'} = '';
      $current{'outcome'}{'date'} = '';
      printdebug("P2 end outcome") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-------------------------------------------------------------
    # P2: 8.51 - ELSIF in 'review' and line blank
    #
    elsif ( $in{'review'} and /^\s*$/ ) {
      $in{'review'} = 0;
      $current{'review'}{'item'} = '';
      $current{'review'}{'date'} = '';
      printdebug("P2 end review") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.52 - ELSIF in 'step' and line blank
    #
    elsif ( $in{'step'} and /^\s*$/ ) {
      $in{'step'} = 0;
      printdebug("P2 end step") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }


    #-----------------------------------------------------------------
    # P2: 8.53 - ELSIF in label and line blank
    #
    elsif ( $in{'label'} and /^\s*$/ ) {
      $in{'label'} = 0;
      printdebug("P2 end label") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.54 - ELSIF in title and line blank
    #
    elsif ( $in{'title'} and /^\s*$/ ) {
      $in{'title'} = 0;
      printdebug("P2 end title") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.55 - ELSIF in date and line blank
    #
    elsif ( $in{'date'} and /^\s*$/ ) {
      $in{'date'} = 0;
      printdebug("P2 end date") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.56 - ELSIF in revision and line blank
    #
    elsif ( $in{'revision'} and /^\s*$/ ) {
      $in{'revision'} = 0;
      printdebug("P2 end revision") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.57 - ELSIF in author and line blank
    #
    elsif ( $in{'author'} and /^\s*$/ ) {
      $in{'author'} = 0;
      printdebug("P2 end author") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.58 - ELSIF in type and line blank
    #
    elsif ( $in{'type'} and /^\s*$/ ) {
      $in{'type'} = 0;
      printdebug("P2 end type") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.59 - ELSIF in use_formal_status and line blank
    #
    elsif ( $in{'use_formal_status'} and /^\s*$/ ) {
      $in{'use_formal_status'} = 0;
      printdebug("P2 end use_formal_status") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.60 - ELSIF in effort_units and line blank
    #
    elsif ( $in{'effort_units'} and /^\s*$/ ) {
      $in{'effort_units'} = 0;
      printdebug("P2 end effort_units") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.61 - ELSIF in 'column' and line blank
    #
    elsif ($in{'column'} and /^\s*$/ ) {
      $in{'column'} = 0;
      printdebug("P2 end column") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.62 - FOREACH element in list of header/footer elements
    #
    foreach my $element (@header_footer_elements) {

      #-----------------------------------------------------------------
      # P2: IF in this header/footer element and line blank
      #
      if ( $in{$element} and /^\s*$/ ) {
	$in{$element} = 0;
	printdebug("P2 end header/footer element $element")
	  if $DEBUGGING;
	push @outtext, [$nest,$nesting_level,$current{'line'},$_];
	next LINE;
      }
    }

    ##################################################################
    ##################################################################
    ##################################################################
    ###                                                            ###
    ###                Continuation of Data Elements               ###
    ###                                                            ###
    ##################################################################
    ##################################################################
    ##################################################################

    #-----------------------------------------------------------------
    # P2: 8.63 - IF in file and line not blank
    #
    #     Look for a file continuation line.
    #
    if ( $in{'file'} and /\S+/ ) {
      printdebug("P2 continue file") if $DEBUGGING;
      printerror("filename must be contained on one line\n");
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.64 - ELSIF line is a 'generate' continuation line
    #
    elsif ( $in{'generate'} and /\S+/ ) {
      printdebug("P2 continue generate") if $DEBUGGING;
      printerror("generate directive must be contained on one line\n");
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.65 - ELSIF line is an 'insert' continuation line
    #
    elsif ( $in{'insert'} and /\S+/ ) {
      printdebug("P2 continue insert") if $DEBUGGING;
      printerror("insert directive must be contained on one line\n");
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.66 - ELSIF in 'script' and line not blank
    #
    elsif ( $in{'script'} and /\S+/ ) {
      printdebug("P2 continue script") if $DEBUGGING;
      printerror("script must be contained on one line\n");
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;

    }

    #-----------------------------------------------------------------
    # P2: 8.67 - ELSIF in 'insert_gen_content' and line not blank
    #
    elsif ( $in{'insert_gen_content'} and /\S+/ ) {
      printdebug("P2 continue insert_gen_content") if $DEBUGGING;
      printerror("insert_gen_content must be contained on one line\n");
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;

    }

    #-----------------------------------------------------------------
    # P2: 8.68 - ELSIF in 'insert_ins_content' and line not blank
    #
    elsif ( $in{'insert_ins_content'} and /\S+/ ) {
      printdebug("P2 continue insert_ins_content") if $DEBUGGING;
      printerror("insert_ins_content must be contained on one line\n");
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;

    }

    #-----------------------------------------------------------------
    # P2: 8.69 - ELSIF in 'image' and line not blank
    #
    elsif ( $in{'image'} and /\S+/ ) {
      printdebug("P2 continue image") if $DEBUGGING;
      printerror("image must be contained on one line\n");
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.70 - ELSIF in 'footnote' and line not blank
    #
    elsif ( $in{'footnote'} and /^\s*(.+)\s*$/ ) {
      my $text = $1;
      my $label = $current{'label'};
      my $tag   = $current{'footnote-tag'};
      $footnote{$label}{$tag} .= " $text";
      printdebug("P2 continue footnote $label $tag") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.71 - ELSIF in 'glossary' and line not blank
    #
    elsif ( $in{'glossary'} and /^\s*(.+)\s*$/ ) {
      my $text = $1;
      my ($term,$alt) = @{ $current{'glossary_term'} };
      $data{'glossary'}{$term}{$alt} .= " $text";
      if ( $term =~ /&/ ) {
	$term =~ s/&/ and /g;
	$data{'glossary'}{$term}{$alt} .= " $text";
      }
      printdebug("P2 continue glossary term $term") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.72 - ELSIF in 'var' and line not blank
    #
    elsif ( $in{'var'} and /^\s*(.+)\s*$/ ) {
      my $value = $1;
      my $varname  = $current{'var_name'};
      $data{'var'}{$varname} .= " $value";
      printdebug("P2 continue var $varname") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #---------------------------------------------------------------
    # P2: 8.73 - ELSIF in 'acronym' and line not blank
    #
    elsif ( $in{'acronym'} and /^\s*(.+)\s*$/ ) {
      my $text = $1;
      my $acronym = $current{'acronym'};
      $data{'acronym'}{$acronym} .= " $text";
      printdebug("P2 continue acronym $term") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.74 - ELSIF in 'index' and line not blank
    #
    #     !!! Bug Here !!!
    #
    #     What if a multi-word index entry breaks across a newline?
    #
    elsif ( $in{'index'} and /^\s*(.+)\s*$/ ) {
      my $text = $1;
      my @entries = split(/\s*\;\s*/, $text);
      foreach my $entry (@entries) { ++ $data{'index'}{$entry} };
      printdebug("P2 continue index entry") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #---------------------------------------------------------------
    # P2: 8.75 - ELSIF in 'outcome' and line not blank
    #
    elsif ( $in{'outcome'} and /^\s*(.+)\s*$/ ) {
      my $text = $1;
      my $item = $current{'outcome'}{'item'};
      my $date = $current{'outcome'}{'date'};
      $outcomes{$item}{$date}{'description'} .= " $text";
      printdebug("P2 continue outcome") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-------------------------------------------------------------
    # P2: 8.76 - ELSIF in 'review' and line not blank
    #
    elsif ( $in{'review'} and /^\s*(.+)\s*$/ ) {
      my $text = $1;
      my $item = $current{'review'}{'item'};
      my $date = $current{'review'}{'date'};
      $reviews{$item}{$date}{'description'} .= " $text";
      printdebug("P2 continue review") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.77 - ELSIF in 'step' and line not blank
    #
    elsif ( $in{'step'} and /\S+/ ) {
      printdebug("P2 continue step") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.78 - ELSIF in label and line not blank
    #
    elsif ( $in{'label'} and /\S+/ ) {
      printdebug("P2 continue label") if $DEBUGGING;
      printerror("label must be on one line");
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.79 - ELSIF in title and line not blank
    #
    elsif ( $in{'title'} and /^\s*(.+)\s*$/ ) {
      my $text = $1;
      $current{'title'} .= " $text";
      pop(@{ $current{'title_stack'} });
      push(@{ $current{'title_stack'} }, $current{'title'});
      my $name = $current{'name'};
      my $num  = $count{$name}{'total'};
      $data{$name}{$num}{'title'} = $current{'title'};
      printdebug("P2 continue title") if $DEBUGGING;
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.80 - ELSIF in date and line not blank
    #
    elsif ( $in{'date'} and /\S+/ ) {
      printdebug("P2 continue date") if $DEBUGGING;
      printerror("date must be on one line");
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.81 - ELSIF in revision and line not blank
    #
    elsif ( $in{'revision'} and /\S+/ ) {
      printdebug("P2 continue revision") if $DEBUGGING;
      printerror("revision must be on one line");
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.82 - ELSIF in author and line not blank
    #
    elsif ( $in{'author'} and /\S+/ ) {
      printdebug("P2 continue author") if $DEBUGGING;
      printerror("author must be on one line");
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.83 - ELSIF in type and line not blank
    #
    elsif ( $in{'type'} and /\S+/ ) {
      printdebug("P2 continue type") if $DEBUGGING;
      printerror("type must be on one line");
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.84 - ELSIF in use_formal_status and line not blank
    #
    elsif ( $in{'use_formal_status'} and /\S+/ ) {
      printdebug("P2 continue use_formal_status") if $DEBUGGING;
      printerror("use_formal_status must be on one line");
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.85 - ELSIF in effort_units and line not blank
    #
    elsif ( $in{'effort_units'} and /\S+/ ) {
      printdebug("P2 continue effort_units") if $DEBUGGING;
      printerror("effort_units must be on one line");
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.86 - ELSIF in column and line not blank
    #
    elsif ( $in{'column'} and /\S+/ ) {
      printdebug("P2 continue column") if $DEBUGGING;
      printerror("column must be on one line");
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.87 - FOREACH header/footer element
    #
    foreach my $element (@header_footer_elements) {

      #-----------------------------------------------------------------
      # P2: 8.87.1 - IF in this element and line not blank
      #
      if ( $in{$element} and /^\s*(.+)\s*$/ ) {
	my $line = $1;
	my $struct = ${ $document{$element} }[-1];
	${$struct}{'text'} .= " $line";
	printdebug("P2 continue $element") if $DEBUGGING;
	push @outtext, [$nest,$nesting_level,$current{'line'},$_];
	next LINE;
      }
    }

    #---------------------------------------------------------------
    # P2: 8.88 - IF in this name/type and line not blank
    #
    #     Are we in one? Only look for relevant data elements.
    #
    #     !!! Bug Here !!!
    #
    #     I think I've made an assumption you can only be in one
    #     name/type at one time.  Is this true?  What about
    #     universal/text?  You can't be in preamble/text and
    #     universal/text at the same time.
    #
    if ( $in{$name}{$type} ) {

      #---------------------------------------------------------------
      # P2: 8.88.1 - Get current num
      #
      my $num = $count{$name}{'total'};

      #---------------------------------------------------------------
      # P2: 8.88.2 - Make list of allowed data elements
      #
      #     Make a list of data elements allowed in this environment
      #     or region.  Each environment and region defined in the
      #     %structure data structure includes an 'elements' list
      #     that defines the allowed elements.
      #
      my @allowed_elements = keys %{ $structure{$name}{'elements'} };

      #-------------------------------------------------------------
      # P2: 8.88.3 - FOREACH element in allowed elements
      #
      #     If this line ISN'T blank, and we're in a data element,
      #     it must be a continuation of the data element.  Look for
      #     CONTINUATION DATA for each data element allowed in this
      #     environment or region.
      #
      foreach my $element ( @allowed_elements ) {

	#-----------------------------------------------------------
	# P2: 8.88.3.1 - IF in name/element and line not blank
	#
	#     If we're already in the data element, append this line
	#     of text to the data structure.
	#
	if ( $in{$name}{$element} and /^\s*(.+)\s*$/ ) {

	  #---------------------------------------------------------
	  # P2: 8.88.3.1.1 - Parse line
	  #
	  my $line = $1;

	  #-----------------------------------------------------------
	  # P2: 8.88.3.1.2 - Print debugging message
	  #
	  printdebug("P2 continue $element data element $name $type $num")
	    if $DEBUGGING;

	  #---------------------------------------------------------
	  # P2: 8.88.3.1.3 - IF this element may be multivalued
	  #
	  #     If this data element is multivalued, add this line
	  #     to the most recent element on an anonymous array,
	  #     otherwise just assign the value as a scalar to the
	  #     data structure.
	  #
	  if ( $structure{$name}{'elements'}{$element}{'multivalued'} ) {
	    ${$data{$name}{$num}{$element}}[-1] .= " $line";
	  }

	  #---------------------------------------------------------
	  # P2: 8.88.3.1.4 - ELSE element is single-valued
	  #
	  #     Otherwise we're in the continuation of a plain old
	  #     fashioned data element.
	  #
	  else {
	    $data{$name}{$num}{$element} .= " $line";
	  }

	  push @outtext, [$nest,$nesting_level,$current{'line'},$_];
	  next LINE;

        }
      }
    }

    ##################################################################
    ##################################################################
    ##
    ## Look for narrative document content
    ##
    ##################################################################
    ##################################################################

    #-----------------------------------------------------------------
    # P2: 8.89 - ELSIF line is blank
    #
    if ( /^\s*$/ ) {

      #---------------------------------------------------------------
      # P2: 8.89.1 - Print debugging message
      #
      printdebug("P2 BLANK LINE") if $DEBUGGING;

      my $name = $current{'name'};
      my $num  = $count{$name}{'total'};

      #---------------------------------------------------------------
      # P2: 8.89.2 - IF in any region and not in region preamble
      #
      #     If we're in any region and we're not in the region
      #     preamble, put this blank line into the narrative data.
      #
      if ( in_any_region() and not $in{'region'}{'preamble'} ) {
	$data{$name}{$num}{'narrative'} .= $_;
      }

      #---------------------------------------------------------------
      # P2: 8.89.3 - End any data element
      #
      end_any_data_element();

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.90 - End region preamble
    #
    #     If you've gotten this far without matching a line, you must
    #     be in narrative content.
    #
    end_region_preamble() if $in{'region'}{'preamble'};

    #-----------------------------------------------------------------
    # P2: 8.91 - Append narrative line in data structure
    #
    my $name = $current{'name'};
    my $num  = $count{$name}{'total'};
    $data{$name}{$num}{'narrative'} .= $_;

    #-----------------------------------------------------------------
    # P2: 8.92 - IF line is a section heading
    #
    #     Look for a section heading.  Section headings are lines that
    #     begin with one or more asterisks in the first column.  There
    #     MUST be space between the asterisks and the section title.
    #
    #     In the regular expression that follows, the whitespace after
    #     the asterisks is critical to distinguish a section heading
    #     from bolded text at the beginning of the line.
    #
    if (/^(\*+)\s+(.*?)\s*$/) {

      #---------------------------------------------------------------
      # P2: 8.92.1 - Parse section heading
      #
      #     Get the section title from the regex pattern match.  Note
      #     that the entire section title must occur on one line.
      #
      #     !!! Bug Here !!!
      #
      #     Section headings should be multi-line if necessary.  This
      #     hasn't been a problem so far because I use Emacs
      #     outline-mode to edit structured text files and that mode
      #     forces all section headings (lines beginning with
      #     asterisks) to be on one line no matter how long they are.
      #
      my $asterisks = $1;
      my $text      = $2;

      #---------------------------------------------------------------
      # P2: 8.92.2 - Print debugging message
      #
      printdebug("P2 begin $asterisks section heading $text")
	if $DEBUGGING;

      #---------------------------------------------------------------
      # P2: 8.92.3 - Set current title to section heading
      #
      $current{'title'} = $text;

      #---------------------------------------------------------------
      # P2: 8.92.4 - Clear the title stack
      #
      #     Manage the title stack. Since we've found a section
      #     heading, we need to empty the title stack and push this
      #     title onto it as the sole item on the stack.
      #
      @{ $current{'title_stack'} } = ();

      #---------------------------------------------------------------
      # P2: 8.92.5 - Push section heading onto title stack
      #
      push(@{ $current{'title_stack'} }, $text);

      #---------------------------------------------------------------
      # P2: 8.92.6 - Increment count: section total
      #
      #     Sections are defined in the %structure hash and must be
      #     treated similar to data elements.  Each section in a
      #     document is given a unique one-up number just like tables
      #     and figures.  This enables us to refer to that section
      #     even if it doesn't have a label.
      #
      #     !!! Bug Here !!!
      #
      #     Just like tables and figures, shouldn't we generate a fake
      #     label for this section until the real one is discovered?
      #
      ++ $count{'section'}{'total'};

      #---------------------------------------------------------------
      # P2: 8.92.7 - Set current name = 'section'
      #
      $current{'name'} = 'section';

      #---------------------------------------------------------------
      # P2: 8.92.8 - Replace top name on name stack
      #
      pop(@{ $current{'name_stack'} });
      push(@{ $current{'name_stack'} }, $current{'name'});

      #-------------------------------------------------------------
      # P2: 8.92.9 - Create temporary fake section label
      #
      #     Make up a fake label to use until we find the real one.
      #
      my $num = $count{'section'}{'total'};
      $current{'label'} = "section-$num";

      #-------------------------------------------------------------
      # P2: 8.92.10 - Replace top label on label stack
      #
      pop(@{ $current{'label_stack'} });
      push(@{ $current{'label_stack'} }, $current{'label'});

      #-------------------------------------------------------------
      # P2: 8.92.11 - Store section type in data structure
      #
      #     Assume this is a simple section until we discover
      #     otherwise.
      #
      #     !!! BUG HERE !!!
      #
      #     Does this overwrite other section types like chapter and
      #     appendix?  What about sectype?
      #
      if ( $document{'doctype'} eq 'book' and length($asterisks) == 1 ) {
	$data{'section'}{$num}{'type'} = 'chapter';
      } else {
	$data{'section'}{$num}{'type'} = 'section';
      }

      #---------------------------------------------------------------
      # P2: 8.92.12 - Store section heading in data structure
      #
      #     Remember the section title in the %data datastructure so
      #     it will also be refactored into the %lookup datastructure
      #     and made available for lookup by label.
      #
      #     !!! BUG HERE !!!
      #
      #     Section headings must occur on a single line.
      #
      $data{'section'}{$num}{'title'} = $text;

      #---------------------------------------------------------------
      # P2: 8.92.13 - Set state: no longer in preamble text
      #
      $in{'preamble'}{'text'} = 0;

      #---------------------------------------------------------------
      # P2: 8.92.14 - End any data element
      #
      #     In the unlikely event we were parsing a data element, end
      #     it.
      #
      end_any_data_element();

      #---------------------------------------------------------------
      # P2: 8.92.15 - Remember previous section depth
      #
      #     We keep track of the current section heading depth as we
      #     go through the text.  The depth of a section heading is
      #     indicated by the number of asterisks.  We use 'length $1'
      #     to discover the number of asterisks and therefore the
      #     depth of this section heading.
      #
      $previous{'depth'} = $current{'depth'};

      #---------------------------------------------------------------
      # P2: 8.92.16 - Set current section depth
      #
      $current{'depth'} = length $1;

      #---------------------------------------------------------------
      # P2: Section Counter Housekeeping
      #
      #     We maintain a datastructure called $scounter to remember
      #     things about the section structure of the text and to
      #     generate section numbers like '2.5.11.6'.
      #
      #     If the the section depth *before* this section heading was
      #     greater than this one, then we need to do a little
      #     housekeeping in the $scounter datastructure.  Namely, we
      #     need to set the count to zero for section levels between
      #     the previous one and this one.  For instance, if the
      #     previous section was:
      #
      #       2.5.11.6
      #
      #     and this new heading has a depth of 2, then it's section
      #     number should be:
      #
      #       2.6
      #
      #     and the counters for the three and four level counters (11
      #     and 6) need to be reset to zero.
      #
      #     !!! Bug Here !!!
      #
      #     Why do we care about section numbers at all in pass 2?
      #
      #---------------------------------------------------------------

      #---------------------------------------------------------------
      # P2: 8.92.17 - Get current section type and depth
      #
      my $sectype = $current{'sectype'};
      my $depth   = $current{'depth'};

      #---------------------------------------------------------------
      # P2: 8.92.18 - IF previous depth was greater than current depth
      #
      if ($previous{'depth'} > $depth) {
        my $temp_depth = $previous{'depth'};
        while ($temp_depth > $depth) {
          $scounter{$temp_depth} = 0;
          -- $temp_depth;
        }
      }

      #---------------------------------------------------------------
      # P2: 8.92.19 - Increment section counter for current depth
      #
      #     Now we need to increment the counter for the current depth
      #     to assign it the right number.  This is the part that
      #     changes the 5 to a 6 in our 2.5.11.6 -> 2.6 example.
      #
      ++$scounter{$depth};

      #---------------------------------------------------------------
      # P2: 8.92.20 - Initialize current type to ''
      #
      $current{'type'} = $EMPTY_STRING;

      #---------------------------------------------------------------
      # P2: 8.92.21 - Remember previous section number
      #
      my $previous_secnum = $current{'secnum'};

      #---------------------------------------------------------------
      # P2: Determine Current Section Number
      #
      #     Now we want to construct the section number string
      #     (i.e. 2.6) by joining the value of the count from each
      #     level with a dot.
      #
      #---------------------------------------------------------------

      #---------------------------------------------------------------
      # P2: 8.92.22 - Set temp_depth = 1
      #
      my $temp_depth = 1;

      #---------------------------------------------------------------
      # P2: 8.92.23 - Set current secnum to section counter for temp_depth
      #
      $current{'secnum'} = $scounter{$temp_depth};

      #---------------------------------------------------------------
      # P2: 8.92.24 - WHILE temp_depth is less than current depth
      #
      while ($temp_depth < $depth) {
        ++$temp_depth;
        $current{'secnum'} .= '.' . $scounter{$temp_depth};
      }

      #---------------------------------------------------------------
      # P2: 8.92.25 - Initialize section array in html data structure
      #
      my $secnum = $current{'secnum'};
      $html{'body'}{$secnum} = [];

      #---------------------------------------------------------------
      # P2: 8.92.26 - Store data in section datastructure
      #
      #     Populate the type, depth, previous, and next elements of
      #     the %section datastructure.
      #
      $section{$secnum}{'type'}          = $sectype;
      $section{$secnum}{'depth'}         = $depth;
      $section{$secnum}{'previous'}      = $previous_secnum;
      $section{$previous_secnum}{'next'} = $secnum;

      #---------------------------------------------------------------
      # P2: 8.92.27 - Set level = current depth
      #
      #     We don't want to allow section depths greater than
      #     $MAX_SEC_DEPTH.  So, if the current section depth is
      #     deeper than this, just set it to the maximum section
      #     depth.
      #
      my $level = $depth;

      #---------------------------------------------------------------
      # P2: 8.92.28 - Truncate level at MAX_SEC_DEPTH
      #
      $level = $MAX_SEC_DEPTH if $level > $MAX_SEC_DEPTH;

      #---------------------------------------------------------------
      # P2: 8.92.29 - IF this is a toplevel section
      #
      #     If this is a toplevel heading then all section level
      #     counters need to be reset to zero.
      #
      if ($level == 1) {
        $current{'topnum'} = $scounter{1};
        foreach my $name (keys %structure) {
          $count{$name}{'section'} = 0;
        }
      }

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;

    }

    #-----------------------------------------------------------------
    # P2: 8.93 - IF line is end of table row
    #
    #     Look for the end of a table row indicated by three or more
    #     hyphens beginning in column 1, and nothing else on the line.
    #
    if (/^-{3,}\s*$/) {
      printdebug("P2 end table row") if $DEBUGGING;
      $current{'column'} = 0;
      end_any_data_element();
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: Table Headers And Cells
    #
    #     Here in pass 2, we need to find out the following
    #     information about each table in the document:
    #
    #       - number of columns
    #
    #       - number of characters in the largest cell of each column
    #         this will be used to calculate how wide each column
    #         should be in the LaTeX rendition
    #
    #       - whether or not the table uses colored cells
    #
    #     !!! Bug Here !!!
    #
    #     Column and row spanning is not currently supported.  I plan
    #     to add support in some future version.
    #
    #     The standard method of doing row spanning in LaTeX is to use
    #     the \multicolumn command which, according to the
    #     documentation, can't be used inside of a tabularx
    #     region, the region I use for tables.  Doh!
    #
    #     The following variables are used to track this information
    #     during P2:
    #
    #       $count{'table'}{'total'}
    #       $current{'column'}
    #       $size (number of characters)
    #
    #     As information is collected in these variables, the
    #     following data structure is populated.  This data structure
    #     will later be used during PASS 3 to calculate column widths
    #     for the LaTeX rendition:
    #
    #       $num = $count{'table'}{'total'};
    #       $data{'table'}{$num}{'column_count'}   = 4;
    #       $data{'table'}{$num}{'column_size'}{1} = 213;
    #       $data{'table'}{$num}{'column_size'}{2} = 412;
    #       $data{'table'}{$num}{'column_size'}{3} = 52;
    #       $data{'table'}{$num}{'column_size'}{4} = 1123;
    #       $data{'table'}{$num}{'table_size'}     = 1804;
    #       $data{'table'}{$num}{'uses_color'}     = 1;
    #
    #     For the purpose of PASS 2, we don't differentiate between
    #     table headers (that start with '::') and table cells (that
    #     start with ':').  We're only really interested in how much
    #     content is in each column (headers and cells) so we can
    #     calculate column widths
    #
    #-----------------------------------------------------------------

    #-----------------------------------------------------------------
    # P2: 8.94 - IF line is beginning of table header or cell
    #
    if (/^::?(\S+:)?\s+(.*)/) {

      #---------------------------------------------------------------
      # P2: 8.94.1 - Parse header or cell attributes and text
      #
      #     Get the attributes and opening text of this table cell (or
      #     header) from the regex pattern match.
      #
      my $attrs = resolve_references($1);
      my $text  = $2;

      #---------------------------------------------------------------
      # P2: 8.94.2 - Print debugging message
      #
      printdebug("P2 begin table cell") if $DEBUGGING;

      #---------------------------------------------------------------
      # P2: 8.94.3 - End any data element
      #
      #     In the unlikely event we were parsing a data element, end
      #     it.
      #
      end_any_data_element();

      #---------------------------------------------------------------
      # P2: 8.94.4 - Convert to plain text for column width calculation
      #
      $text = plain_text($text);

      #---------------------------------------------------------------
      # P2: 8.94.5 - Set size = length of plain text
      #
      #     Minimize size is 1.
      #
      my $size = length($text) || 1;

      #---------------------------------------------------------------
      # P2: 8.94.6 - IF current column is 0
      #
      #     If the current column is 0, you've found a new row and
      #     need to increment the row counter.
      #
      if ( $current{'column'} == 0 ) {
	++ $current{'row'};
      }

      #---------------------------------------------------------------
      # P2: 8.94.7 - Increment current column
      #
      #     The column count gets incremented here because we've found
      #     a new column.  The column count gets reset to zero when we
      #     find the end of a table row (indicated by a line with
      #     three or more hyphens (---).
      #
      ++ $current{'column'};

      #---------------------------------------------------------------
      # Are you paying attention?
      #
      #     If anyone reading this code is paying REALLY close
      #     attention, you'll realize the width of the text in a cell
      #     in the RAW text (i.e. the structured text input file)
      #     might not exactly correspond to the width of the text in
      #     typeset text.  If the input file was wordwrapped at column
      #     70, for instance, you'll have a maximum cell size of about
      #     70.  Only one line (the biggest for the table cell) is
      #     used to estimate it's width.
      #
      #     In practice, this seems to work out about right, but it is
      #     far from an exact calculation.
      #
      #---------------------------------------------------------------

      #---------------------------------------------------------------
      # P2: 8.94.8 - IF not in table and not in baretable
      #
      #     We've just found a line that begins a table cell. If we're
      #     not already in a table or in a baretable, then this must
      #     be the start of a new baretable.
      #
      if (
	  (not $in{'table'}{'environment'})
	  and
	  (not $in{'baretable'} == 1)
	 ) {

        #-------------------------------------------------------------
	# P2: Begin new baretable
	#
        #     You've found the start of a table cell here. If neither
        #     $in{'table'}{'environment'} or $in{'baretable'} are
        #     true, it means this is a 'bare' table; one not delimited
        #     by table region markers.  Baretables are OK -- they just
        #     don't have titles or labels.  This program typsets all
        #     baretables as longtables in LaTeX so they don't float
        #     and can break across pages between rows.
	#
	#     NOTE: While it may be tempting to call 'begin_baretable'
	#     here, remember that the 'begin_baretable' is reserved
	#     for use in pass_three.
        #
        #-------------------------------------------------------------

        #-------------------------------------------------------------
	# P2: 8.94.8.1 - Set state: in baretable = 1
	#
        $in{'baretable'} = 1;

        #-------------------------------------------------------------
	# P2: 8.94.8.2 - Increment count: baretable total
	#
        ++ $count{'baretable'}{'total'};

        #-------------------------------------------------------------
	# P2: 8.94.8.3 - Reset current column and row to 1
	#
        my $col = $current{'column'} = 1;
	my $row = $current{'row'}    = 1;

        #-------------------------------------------------------------
	# P2: 8.94.8.4 - Add to baretable size in data structure
	#
        #     We track the overall number of characters in the table
        #     (table_size) so we can later decide if this table (for
        #     LaTeX, PDF) should float or have page breaks between
        #     rows.
        #
        #     Add the size of this line to the overall table size
        #     (number of characters)
        #
        my $num = $count{'baretable'}{'total'};
        $data{'baretable'}{$num}{'table_size'} += $size;

        #-------------------------------------------------------------
	# P2: 8.94.8.5 - Increment column count in data structure
	#
	#     Count the number of columns in each row so we can warn
	#     the user if not every row in the table contains the same
	#     number of columns.
	#
	++ $data{'baretable'}{$num}{'row'}{$row}{'column_count'};

        #-------------------------------------------------------------
	# P2: 8.94.8.6 - Remember the size of this line
	#
        #     If the size of this line (number of characters) is
        #     bigger than any other line in this column, set this as
        #     the biggest size of the current column.
        #
	$data{'baretable'}{$num}{'column_size'}{$col} = $size;

        #-------------------------------------------------------------
	# P2: 8.94.8.7 - Print debugging message
	#
        printdebug("P2 begin baretable $num column $col size $size")
	  if $DEBUGGING;

        #-------------------------------------------------------------
	# P2: 8.94.8.8 - FOREACH color in allowed background colors
	#
        #     Determine whether the attributes (if any) define a table
        #     cell background
        #
        foreach my $color (@background_colors) {
	  if ($attrs =~ /$color/) {
	    $data{'baretable'}{$num}{'uses_color'} = 1;
	  }
        }

      }

      #---------------------------------------------------------------
      # P2: 8.94.9 - ELSIF already in table environment
      #
      #     Otherwise we were ALREADY in either a table or baretable.
      #
      elsif ($in{'table'}{'environment'}) {

        #-------------------------------------------------------------
	# P2: 8.94.9.1 - Get table number
	#
	my $num = $count{'table'}{'total'};

	#-------------------------------------------------------------
	# P2: 8.94.9.2 - Add to overall table size
	#
        #     Add the size of this line to the overall table size
        #     (number of characters) used later to decide if this
        #     table should float or be a long_table that can include
        #     page breaks.
        #
	$data{'table'}{$num}{'table_size'} += $size;

	#-------------------------------------------------------------
	# P2: 8.94.9.3 - Get current column
	#
	my $column = $current{'column'};

	#---------------------------------------------------------------
	# P2: 8.94.9.4 - IF this is the biggest line seen for this column
	#
        #     If the size of this line (number of characters) is
        #     bigger than any other line in this column, set this as
        #     the biggest size of the current column.
        #
	if ($size > $data{'table'}{$num}{'column_size'}{$column}) {
	  $data{'table'}{$num}{'column_size'}{$column} = $size;
	}

	#---------------------------------------------------------------
	# P2: 8.94.9.5 - Print debugging message
	#
	printdebug("P2 begin table $num column $column size $size")
	  if $DEBUGGING;

	#---------------------------------------------------------------
	# P2: 8.94.9.6 - FOREACH allowable background color
	#
        #     Determine whether the attributes (if any) define a table
        #     cell background
        #
	foreach my $color (@background_colors) {
	  if ($attrs =~ /$color/) {
	    $data{'table'}{$num}{'uses_color'} = 1;
	  }
	}

      }

      #---------------------------------------------------------------
      # P2: 8.94.10 - ELSE already in baretable
      #
      #     Otherwise we were ALREADY in either a table or baretable.
      #
      else {

	#---------------------------------------------------------------
	# P2: 8.94.10.1 - Get baretable number
	#
	my $num = $count{'baretable'}{'total'};

	#---------------------------------------------------------------
	# P2: 8.94.10.2 - Add to overall baretable size
	#
	$data{'baretable'}{$num}{'table_size'} += $size;

	#---------------------------------------------------------------
	# P2: 8.94.10.3 - Get current column number
	#
	my $column = $current{'column'};

	#---------------------------------------------------------------
	# P2: 8.94.10.4 - IF this is the biggest line seen for this column
	#
	if ($size > $data{'baretable'}{$num}{'column_size'}{$column}) {
	  $data{'baretable'}{$num}{'column_size'}{$column} = $size;
	}

	#---------------------------------------------------------------
	# P2: 8.94.10.5 - Print debugging message
	#
	printdebug("P2 begin baretable $num column $column size $size")
	  if $DEBUGGING;

	#---------------------------------------------------------------
	# P2: 8.94.10.6 - FOREACH allowable background color
	#
	foreach my $color (@background_colors) {
	  if ($attrs =~ /$color/) {
	    $data{'baretable'}{$num}{'uses_color'} = 1;
	  }
	}
      }

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;

    }

    #-----------------------------------------------------------------
    # P2: 8.95 - IF this line ends a baretable
    #
    #     Look for the end of a baretable. If we're currently in a
    #     baretable, and the current column is zero (meaning we just
    #     saw the end of a row), and this line doesn't begin with a
    #     ':' and it's not a blank line, and it's not the end of a
    #     table row (---), then this must be the end of the baretable.
    #
    if ($in{'baretable'} == 1
        and $current{'column'} == 0
        and not /^:/
        and not /^-{3,}\s*$/
        and not /^\s*$/) {

      $in{'baretable'} = 0;
      $current{'column'} = 0;
      $current{'row'}    = 0;
      printdebug("P2 end baretable") if $DEBUGGING;
      end_any_data_element();
      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # P2: 8.96 - IF this line is baretable content
    #
    #     Look for the contents of a baretable
    #
    if ($in{'baretable'} == 1
        and not /^(table:|label:)/
        and not /[><]{3,}table/) {

      #---------------------------------------------------------------
      # P2: 8.96.1 - Get current baretable number
      #
      #     Which baretable are we in? Get the number of this
      #     baretable and the number of the current column.
      #
      my $num = $count{'baretable'}{'total'};

      #---------------------------------------------------------------
      # P2: 8.96.2 - Get current column and row
      #
      my $col = $current{'column'};
      my $row = $current{'row'};

      #---------------------------------------------------------------
      # P2: 8.96.3 - Compute size of plain text
      #
      #     Determine the size of the 'plain' text (that is, the
      #     content with all substitutions performed and without any
      #     of the special markup characters).
      #
      #     Add the size of this line to the overall table size
      #     (number of characters)
      #
      #     !!! BUG HERE !!!
      #
      #     What's the difference between the 'strip_format_markup'
      #     and 'plain_text' subroutines?  They seem to do the same
      #     function.
      #
      #     !!! POSSIBLE RESOLUTION !!!
      #
      #     The 'plain_text' subroutine performs various substitutions
      #     (title, description, lookup, glossary, command, url, and
      #     cross reference) in addition to stripping formatting
      #     characters.  It gets these from the lookup data structure
      #     which is intentionally NOT initialized at the beginning of
      #     pass_two.
      #
      my $text      = $_;
      my $plaintext = plain_text($text);
      my $size      = length($plaintext);

      #---------------------------------------------------------------
      # P2: 8.96.4 - Add to baretable size in data structure
      #
      $data{'baretable'}{$num}{'table_size'} += $size;

      #---------------------------------------------------------------
      # P2: 8.96.5 - IF biggest line seen for this column
      #
      #     If the size of this line (number of characters) is bigger
      #     than any other line in this column, set this as the
      #     biggest size of the current column.
      #
      if ($size > $data{'baretable'}{$num}{'column_size'}{$col}) {
        $data{'baretable'}{$num}{'column_size'}{$col} = $size;
      }

      #---------------------------------------------------------------
      # P2: 8.96.6 - Print debugging message
      #
      printdebug("P2 continue baretable $num column $col size $size")
	if $DEBUGGING;

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;

    }

    #-----------------------------------------------------------------
    # P2: 8.97 - IF this line is table content
    #
    #     Look for table content.
    #
    if ($in{'table'}{'environment'}
        and not /^(table:|label:)/
        and not /[><]{3,}table/) {

      #---------------------------------------------------------------
      # P2: 8.97.1 - Get current table number
      #
      #     Get the number of this table and the number of the current
      #     column.
      #
      my $num = $count{'table'}{'total'};

      #---------------------------------------------------------------
      # P2: 8.97.2 - Get current column and row
      #
      my $col = $current{'column'};
      my $row = $current{'row'};

      #---------------------------------------------------------------
      # P2: 8.97.3 - Compute size of plain text
      #
      my $text      = $_;
      my $plaintext = plain_text($text);
      my $size      = length($plaintext);

      #---------------------------------------------------------------
      # P2: 8.97.4 - Add to table size in data structure
      #
      $data{'table'}{$num}{'table_size'} += $size;

      #---------------------------------------------------------------
      # P2: 8.97.5 - IF biggest line seen for this column
      #
      #     If the size of this line (number of characters) is bigger
      #     than any other line in this column, set this as the
      #     biggest size of the current column.
      #
      if ($size > $data{'table'}{$num}{'column_size'}{$col}) {
        $data{'table'}{$num}{'column_size'}{$col} = $size;
      }

      #---------------------------------------------------------------
      # P2: 8.97.6 - Print debugging message
      #
      printdebug("P2 continue table $num column $col size $size")
	if $DEBUGGING;

      push @outtext, [$nest,$nesting_level,$current{'line'},$_];
      next LINE;

    }

    push @outtext, [$nest,$nesting_level,$current{'line'},$_];
    next LINE;

  }

  #-------------------------------------------------------------------
  # P2: 9 - IF debugging
  #
  #     If we're debugging, tell the user we've just finished pass 2.
  #
  if ($DEBUGGING) {
    my $text = <<"END_OF_TEXT";
------------------------------------------------------------
END PASS 2
------------------------------------------------------------

END_OF_TEXT

    printdebug($text);
  }

  #-------------------------------------------------------------------
  # P2: 10 - Copy outtext to intext
  #
  #     Put the @outtext back in to @intext in preparation for the
  #     next pass.
  #
  @intext = @outtext;

}

######################################################################

sub text_contains_requests {

  #-------------------------------------------------------------------
  # This is a test to see if the text contains requests to generate
  # other text via either the 'generate:' or 'script:' mechanisms.  If
  # so, return 1 and if not return 0.
  #
  # !!! Bug Here !!!
  #
  #     Generate requests within comment blocks (###comment) are not
  #     ignored by this subroutine.
  #-------------------------------------------------------------------

  printstatus("checking whether text contains requests");

  my @testtext = @intext;

  my $in_comment = 0;

 LINE:
  foreach (@testtext) {

    #-----------------------------------------------------------------
    # Break the line out into its four elements
    #
    my $nest          = @{$_}[0]; # filename nest
    my $nesting_level = @{$_}[1]; # current nesting level
    my $linenum       = @{$_}[2]; # current line number
    $_                = @{$_}[3]; # current line

    # skip comment divisions...
    if (/^(#){3,}comment\s*$/) {
      if ($in_comment) {
	$in_comment = 0;
      } else {
	$in_comment = 1;
      }
      next LINE;
    } elsif (/^#/ or $in_comment ) {
      next LINE;
    }

    #-----------------------------------------------------------------
    # If this line indicates a request then return a 1 indicating the
    # text still contains requests for generated content.
    #
    if (   /^(\*+\s+)?include::/
	or /^(\.){3,}include/
	or /^(-){3,}include/
	or /^generate::/
	or /^script::/
	or /^insert::/
	or /^insert_gen_content::/
	or /^insert_ins_content::/) {

      # printmessage("text_contains_requests: found $nest $linenum: $_");
      return 1;
    }
  }

  #-------------------------------------------------------------------
  # If you've gotten this far it means you went through the entire
  # document without finding a request to generate content.  Return 0.
  #
  return 0;

}

######################################################################

sub generate_content {

  printstatus("generating content");

  #-------------------------------------------------------------------
  # If there is content to be generated, do it now.
  #
  #    This subroutine gets called during runs of pass 2, meaning that
  #    the lookup data structure has not yet been created.  DO NOT try
  #    to use the lookup data structure to generate requested
  #    content. You'll have to rely on the 'data' data structure.
  #
  #    !!! Bug Here !!!
  #
  #    When I first designed the generated content mechanism I assumed
  #    there would only be one instance of each type of generated
  #    content in a document.  For example, I didn't imaging generating
  #    more than one problem domain listing in the same document.
  #
  #    But now I find myself with the requirement to have multiple
  #    intances of certain blocks of generated content.  For example,
  #    I want the script to be able to generate a listing of
  #    associated problems for any label.  There could be many of
  #    these.  The script needs to maintain a sense of context
  #    (i.e. the current label) for each request to generate a list of
  #    associated problems.
  #
  foreach my $name (keys %to_be_generated) {

    #-----------------------------------------------------------------
    # Generate problem-domain-listing
    #
    #     The problem-domain-listing is NOT context sensitive.
    #     Therefore, no matter how many times one was requested in the
    #     document, we only have to generate it ONCE.
    #
    if ($name eq 'problem-domain-listing'
        and $to_be_generated{'problem-domain-listing'}) {

      # generate the content
      #
      $generated_content{'problem-domain-listing'}
        = sml_domain_traceability_matrix('problem');

      # delete the request from the to_be_generated hash
      #
      delete $to_be_generated{'problem-domain-listing'};

    }

    #-----------------------------------------------------------------
    # Generate solution-domain-listing
    #
    #     The solution-domain-listing is NOT context sensitive.
    #     Therefore, no matter how many times one was requested in the
    #     document, we only have to generate it ONCE.
    #
    if ($name eq 'solution-domain-listing'
        and $to_be_generated{'solution-domain-listing'}) {

      # generate the content
      #
      $generated_content{'solution-domain-listing'}
        = sml_domain_traceability_matrix('solution');

      # delete the request from the to_be_generated hash
      #
      delete $to_be_generated{'solution-domain-listing'};

    }

    #-----------------------------------------------------------------
    # Generate prioritized-problem-listing
    #
    #     The prioritized-problem-listing is NOT context sensitive.
    #     Therefore, no matter how many times one was requested in the
    #     document, we only have to generate it ONCE.
    #
    if ($name eq 'prioritized-problem-listing'
        and $to_be_generated{'prioritized-problem-listing'}) {

      # generate the content
      #
      $generated_content{'prioritized-problem-listing'}
        = generate_prioritized_problem_listing();

      # delete the request from the to_be_generated hash
      #
      delete $to_be_generated{'prioritized-problem-listing'};
    }

    #-----------------------------------------------------------------
    # Generate prioritized-solution-listing
    #
    #     The prioritized-solution-listing is NOT context sensitive.
    #     Therefore, no matter how many times one was requested in the
    #     document, we only have to generate it ONCE.
    #
    if ($name eq 'prioritized-solution-listing'
        and $to_be_generated{'prioritized-solution-listing'}) {

      # generate the content
      #
      $generated_content{'prioritized-solution-listing'}
        = generate_prioritized_solution_listing();

      # delete the request from the to_be_generated hash
      #
      delete $to_be_generated{'prioritized-solution-listing'};
    }

    #-----------------------------------------------------------------
    # Generate associated problem listing
    #
    #     The associated-problem-listing IS context sensitive.
    #     Therefore, generate the associated-problem-listing for each
    #     relevant label.
    #
    if ($name eq 'associated-problem-listing'
        and $to_be_generated{'associated-problem-listing'}) {

      my @labels = keys %{$to_be_generated{'associated-problem-listing'}};
      foreach my $label (@labels) {

	# generate the content
	#
	$generated_content{'associated-problem-listing'}{$label}
	  = generate_associated_problem_listing($label);

	# delete the request from the to_be_generated hash
	#
	delete $to_be_generated{'associated-solution-listing'}{$label};

      }

    }

    #-----------------------------------------------------------------
    # Generate associated solution listing
    #
    #     The associated-solution-listing IS context sensitive.
    #     Therefore, generate the associated-solution-listing for each
    #     relevant label.
    #
    if ($name eq 'associated-solution-listing'
        and $to_be_generated{'associated-solution-listing'}) {

      my @labels = keys %{$to_be_generated{'associated-solution-listing'}};
      foreach my $label (@labels) {

	# generate the content
	#
	$generated_content{'associated-solution-listing'}{$label}
	  = generate_associated_solution_listing($label);

	# delete the request from the to_be_generated hash
	#
	delete $to_be_generated{'associated-solution-listing'}{$label};

      }

    }
  }
}

######################################################################

sub sml_domain_traceability_matrix {

  # Generate and return the structured manuscript language (SML) text
  # for a complete domain traceability matrix.  Domains include: (1)
  # problem, (2) solution, (3) allocation, (4) assignment, (5) task,
  # (6) test, (7) result, and (8) role.
  #
  # Items are listed in sets.  Each set consists of a "parent" item
  # and its immediate children. Each set is rendered as a table.  The
  # first set consists of the top level problems, followed by the
  # immediate children of the top level problems, followed by their
  # children, and so on.
  #
  # Each table has five columns: (1) item title and description, (2)
  # number of parts (i.e. children), (3) item priority, (4) item
  # status, and (5) traceability.

  my $name = shift;

  printstatus("generating $name domain traceability matrix");

  my $text = $EMPTY_STRING;

  $text .= <<"END_OF_TEXT";
:grey: !!Top Level!!

:grey:

:grey:

:grey:

:grey:

---

:grey: ~~$name~~

:grey: ~~parts~~

:grey: ~~priority~~

:grey: ~~status~~

:grey: ~~traceability~~

---

END_OF_TEXT

  #-------------------------------------------------------------------
  # Make a queue of items to be added to the item domain listing and
  # add all of the toplevel items.  A toplevel item is simply any item
  # that doesn't have a parent.
  #
  my @queue         = ();
  my @toplevelitems = ();

  foreach my $item ( list_by_name($name) ) {
    if (not $lookup{$item}{'parent'}) {
      push @toplevelitems, $item;
    }
  }

  #-------------------------------------------------------------------
  # Add each toplevel item to the domain traceability matrix.
  #
  foreach my $item (@toplevelitems) {

    #---------------------------------------------------------------
    # If this problem has children, add it to the list of problems in
    # the queue
    #
    if (@{$lookup{$item}{'children'}}) {
      push @queue, $item;
    }

    #---------------------------------------------------------------
    # Look up values that need to go into the domain traceability
    # matrix for this item.
    #
    my $title        = $lookup{$item}{'title'};
    my $description  = $lookup{$item}{'description'};
    my @type         = @{ $lookup{$item}{'type'} };
    my $type         = join(', ', @type);
    my $priority     = $lookup{$item}{'priority'};
    my $status       = status_of($item) if label_exists($item);
    my $childcount   = @{$lookup{$item}{'children'}};
    my $days_old     = $days_old{$item}{'num'} || 0;
    my $last_changed = $days_old{$item}{'date'} || 0;

    #-----------------------------------------------------------------
    # stakeholders
    #
    my @stakeholders = @{$lookup{$item}{'stakeholder'}};
    my $stakeholders = $EMPTY_STRING;
    if (@stakeholders) {
      $stakeholders = join(', ', @stakeholders);
    }

    #-----------------------------------------------------------------
    # requests
    #
    my @requests     = @{$lookup{$item}{'request'}};
    my $requests     = '';
    if (@requests) {
      $requests = join(', ', @requests);
    }

    #-----------------------------------------------------------------
    # info
    #
    my @info = ();
    push @info, $type                if $type;
    push @info, $item                if $item;
    push @info, $stakeholders        if $stakeholders;
    push @info, $requests            if $requests;
    push @info, "last changed $last_changed" if $last_changed;
    push @info, "[ref:$item]"    if $item;
    my $info = join(', ', @info);

    #-----------------------------------------------------------------
    # status color
    #
    my $status_color = 'white';
    $status_color = 'red'    if $status eq 'red';
    $status_color = 'yellow' if $status eq 'yellow';
    $status_color = 'green'  if $status eq 'green';
    $status_color = 'grey'   if $status eq 'grey';
    $status_color = 'grey'   if $status eq 'gray';

    #-----------------------------------------------------------------
    # priority color
    #
    my $priority_color = 'grey';
    $priority_color = 'red'    if $priority eq 'critical';
    $priority_color = 'orange' if $priority eq 'high';
    $priority_color = 'yellow' if $priority eq 'routine';
    $priority_color = 'grey'   if $priority eq 'low';

    #-----------------------------------------------------------------
    # title, description, and other info
    #
    my $title_description_info = wrap("!!$title:!! $description ~~$info~~");

    #---------------------------------------------------------------
    # Put this toplevel item into the domain traceability matrix.
    #
    $text .= <<"END_OF_TEXT";
: $title_description_info

: $childcount

:$priority_color: $priority

:$status_color: $status

:

END_OF_TEXT

    #-----------------------------------------------------------------
    # traceable directed_by
    #
    my @directed_by = @{$lookup{$item}{'directed_by'}};
    foreach my $directed_by (@directed_by) {
      my $string = wrap("- $directed_by");
      $text .= "$string\n\n";
    }

    #-----------------------------------------------------------------
    # traceable problems
    #
    my @problems = @{$lookup{$item}{'problem'}};
    foreach my $problem (@problems) {
      my $title  = $lookup{$problem}{'title'};
      my $tier   = $lookup{$problem}{'tier'};
      my $string = wrap("- problem $problem ($tier) $title");
      $text .= "$string\n\n";
    }

    #-----------------------------------------------------------------
    # traceable solutions
    #
    my @solutions = @{$lookup{$item}{'solution'}};
    foreach my $solution (@solutions) {
      my $title  = $lookup{$solution}{'title'};
      my $tier   = $lookup{$solution}{'tier'};
      my $string = wrap("- solution $solution ($tier) $title");
      $text .= "$string\n\n";
    }

    #-----------------------------------------------------------------
    # traceable allocations
    #
    my @allocations = @{$lookup{$item}{'allocation'}};
    foreach my $allocation (@allocations) {
      my $title  = $lookup{$allocation}{'title'};
      my $tier   = $lookup{$allocation}{'tier'};
      my $string = wrap("- allocation $allocation ($tier) $title");
      $text .= "$string\n\n";
    }

    #-----------------------------------------------------------------
    # traceable assignments
    #
    my @assignments = @{$lookup{$item}{'assignment'}};
    foreach my $assignment (@assignments) {
      my $title  = $lookup{$assignment}{'title'};
      my $tier   = $lookup{$assignment}{'tier'};
      my $string = wrap("- assignment $assignment ($tier) $title");
      $text .= "$string\n\n";
    }

    #-----------------------------------------------------------------
    # traceable tasks
    #
    my @tasks = @{$lookup{$item}{'task'}};
    foreach my $task (@tasks) {
      my $title  = $lookup{$task}{'title'};
      my $tier   = $lookup{$task}{'tier'};
      my $string = wrap("- task $task ($tier) $title");
      $text .= "$string\n\n";
    }

    #-----------------------------------------------------------------
    # traceable tests
    #
    my @tests = @{$lookup{$item}{'test'}};
    foreach my $test (@tests) {
      my $title  = $lookup{$test}{'title'};
      my $tier   = $lookup{$test}{'tier'};
      my $string = wrap("- test $test ($tier) $title");
      $text .= "$string\n\n";
    }

    #-----------------------------------------------------------------
    # traceable results
    #
    my @results = @{$lookup{$item}{'result'}};
    foreach my $result (@results) {
      my $title  = $lookup{$result}{'title'};
      my $tier   = $lookup{$result}{'tier'};
      my $string = wrap("- result $result ($tier) $title");
      $text .= "$string\n\n";
    }

    #-----------------------------------------------------------------
    # traceable roles
    #
    my @roles = @{$lookup{$item}{'role'}};
    foreach my $role (@roles) {
      my $title  = $lookup{$role}{'title'};
      my $tier   = $lookup{$role}{'tier'};
      my $string = wrap("- role $role ($tier) $title");
      $text .= "$string\n\n";
    }

    #-----------------------------------------------------------------
    # End the row
    #
    $text .= <<"END_OF_TEXT";
---

END_OF_TEXT

  }

  #-----------------------------------------------------------------
  # Now process each item on the queue, adding new items to the back
  # of the queue as you find ones that have children.
  #
  foreach my $item (@queue) {

    #---------------------------------------------------------------
    # title
    #
    my $title    = $lookup{$item}{'title'};
    my $parent   = $lookup{$item}{'parent'};
    my @children = @{$lookup{$item}{'children'}};

    $title = wrap("$title");

    #---------------------------------------------------------------
    # Insert the header row for this item.
    #
    $text .= <<"END_OF_TEXT";
:grey: !!$title!!

:grey:

:grey:

:grey:

:grey:

---

:grey: ~~$name~~

:grey: ~~parts~~

:grey: ~~priority~~

:grey: ~~status~~

:grey: ~~traceability~~

---

END_OF_TEXT

    #---------------------------------------------------------------
    # Insert the children of this item.
    #
    foreach my $child (@children) {

      #-------------------------------------------------------------
      # If this child has children, add them to the queue.
      #
      if (@{$lookup{$child}{'children'}}) {
        push @queue, $child;
      }

      #-------------------------------------------------------------
      # Look up the values that need to go into the traceability
      # matrix for this child
      #
      my $title        = $lookup{$child}{'title'};
      my $description  = $lookup{$child}{'description'};
      my @type         = @{ $lookup{$child}{'type'} };
      my $type         = join(', ', @type);
      my $priority     = $lookup{$child}{'priority'};
      my $status       = status_of($child) if label_exists($child);
      my $days_old     = $days_old{$child}{'num'} || 0;
      my $last_changed = $days_old{$child}{'date'} || 0;
      my $childcount   = @{$lookup{$child}{'children'}};

      #---------------------------------------------------------------
      # stakeholders
      #
      my @stakeholders = @{$lookup{$child}{'stakeholder'}};
      my $stakeholders = $EMPTY_STRING;
      if (@stakeholders) {
	$stakeholders = join(', ', @stakeholders);
      }

      #---------------------------------------------------------------
      # requests
      #
      my @requests     = @{$lookup{$child}{'request'}};
      my $requests     = $EMPTY_STRING;
      if (@requests) {
	$requests = join(', ', @requests);
      }

      #---------------------------------------------------------------
      # info
      #
      my @info = ();
      push @info, $type                if $type;
      push @info, $child               if $child;
      push @info, $stakeholders        if $stakeholders;
      push @info, $requests            if $requests;
      push @info, "last changed $last_changed" if $last_changed;
      push @info, "[ref:$item]" if $item;
      my $info = join(', ', @info);

      #---------------------------------------------------------------
      # status color
      #
      my $status_color = 'white';
      $status_color = 'red'    if $status eq 'red';
      $status_color = 'yellow' if $status eq 'yellow';
      $status_color = 'green'  if $status eq 'green';
      $status_color = 'grey'   if $status eq 'grey';
      $status_color = 'grey'   if $status eq 'gray';

      #---------------------------------------------------------------
      # priority color
      #
      my $priority_color = 'grey';
      $priority_color = 'red'    if $priority eq 'critical';
      $priority_color = 'orange' if $priority eq 'high';
      $priority_color = 'yellow' if $priority eq 'routine';
      $priority_color = 'grey'   if $priority eq 'low';

      my $title_description_info = wrap("!!$title:!! $description ~~$info~~");

      #-------------------------------------------------------------
      # Add this item to the traceability matrix.
      #
      $text .= <<"END_OF_TEXT";
: $title_description_info

: $childcount

:$priority_color: $priority

:$status_color: $status

:

END_OF_TEXT

      #---------------------------------------------------------------
      # traceable directed_by
      #
      my @directed_by = @{$lookup{$child}{'directed_by'}};
      foreach my $directed_by (@directed_by) {
	my $string = wrap("- $directed_by");
	$text .= "$string\n\n";
      }

      #---------------------------------------------------------------
      # traceable problems
      #
      my @problems = @{$lookup{$child}{'problem'}};
      foreach my $problem (@problems) {
        my $title  = $lookup{$problem}{'title'};
        my $tier   = $lookup{$problem}{'tier'};
        my $string = wrap("- problem $problem ($tier) $title");
        $text .= "$string\n\n";
      }

      #---------------------------------------------------------------
      # traceable solutions
      #
      my @solutions = @{$lookup{$child}{'solution'}};
      foreach my $solution (@solutions) {
        my $title  = $lookup{$solution}{'title'};
        my $tier   = $lookup{$solution}{'tier'};
        my $string = wrap("- solution $solution ($tier) $title");
        $text .= "$string\n\n";
      }

      #---------------------------------------------------------------
      # traceable allocations
      #
      my @allocations = @{$lookup{$child}{'allocation'}};
      foreach my $allocation (@allocations) {
        my $title  = $lookup{$allocation}{'title'};
        my $tier   = $lookup{$allocation}{'tier'};
        my $string = wrap("- allocation $allocation ($tier) $title");
        $text .= "$string\n\n";
      }

      #---------------------------------------------------------------
      # traceable assignments
      #
      my @assignments = @{$lookup{$child}{'assignment'}};
      foreach my $assignment (@assignments) {
        my $title  = $lookup{$assignment}{'title'};
        my $tier   = $lookup{$assignment}{'tier'};
        my $string = wrap("- assignment $assignment ($tier) $title");
        $text .= "$string\n\n";
      }

      #---------------------------------------------------------------
      # traceable tasks
      #
      my @tasks = @{$lookup{$child}{'task'}};
      foreach my $task (@tasks) {
	my $title  = $lookup{$task}{'title'};
	my $tier   = $lookup{$task}{'tier'};
	my $string = wrap("- task $task ($tier) $title");
	$text .= "$string\n\n";
      }

      #---------------------------------------------------------------
      # traceable tests
      #
      my @tests = @{$lookup{$child}{'test'}};
      foreach my $test (@tests) {
	my $title  = $lookup{$test}{'title'};
	my $tier   = $lookup{$test}{'tier'};
	my $string = wrap("- test $test ($tier) $title");
	$text .= "$string\n\n";
      }

      #---------------------------------------------------------------
      # traceable results
      #
      my @results = @{$lookup{$child}{'result'}};
      foreach my $result (@results) {
	my $title  = $lookup{$result}{'title'};
	my $tier   = $lookup{$result}{'tier'};
	my $string = wrap("- result $result ($tier) $title");
	$text .= "$string\n\n";
      }

      #---------------------------------------------------------------
      # traceable roles
      #
      my @roles = @{$lookup{$child}{'role'}};
      foreach my $role (@roles) {
	my $title  = $lookup{$role}{'title'};
	my $tier   = $lookup{$role}{'tier'};
	my $string = wrap("- role $role ($tier) $title");
	$text .= "$string\n\n";
      }

      #---------------------------------------------------------------
      # End the row
      #
      $text .= <<"END_OF_TEXT";
---

END_OF_TEXT

    }

  }

  return $text;
}

######################################################################

sub generate_prioritized_problem_listing {

  #-------------------------------------------------------------------
  #
  #    Generate and return the structured text for a prioritized
  #    listing (table) of problems.
  #
  #    This subroutine gets called during pass 2 runs, meaning that
  #    the lookup data structure has not yet been created.  DO NOT try
  #    to use the lookup data structure to generate requested
  #    content. You'll have to rely on the 'data' data structure.
  #
  #    This subroutine generates structured text.
  #
  #-------------------------------------------------------------------

  printstatus("generating prioritized problem listing");

  my $text = $EMPTY_STRING;

  #-------------------------------------------------------------------
  # Assign ranking number to each problem in the problem domain.
  #
  my %problems  = ();
  foreach my $problem ( list_by_name('problem') ) {
    my $priority = $lookup{$problem}{'priority'};
    my $status   = status_of($problem) if label_exists($problem);
    my $rank     = rank_for($priority,$status);
    push @{$problems{$rank}}, $problem;
    ++ $count{'priority'}{'total'} if $rank >= 1 and $rank <= 8;
  }

  #-----------------------------------------------------------------
  # Begin the problem priorities table
  #
  $text .= <<"END_OF_TEXT";
:grey: !!Prioritized List of Problems To Be Solved!!

:grey:

:grey:

:grey:

:grey:

---

:grey: ~~problem~~

:grey: ~~rank~~

:grey: ~~importance~~

:grey: ~~priority~~

:grey: ~~status~~

---

END_OF_TEXT

  #-----------------------------------------------------------------
  # Output a row for each problem priority
  #
  foreach my $rank (1..8) {
    foreach my $problem (@{$problems{$rank}}) {

      my $title        = $lookup{$problem}{'title'};
      my $description  = $lookup{$problem}{'description'};
      my $priority     = $lookup{$problem}{'priority'};
      my $status       = status_of($problem) if label_exists($problem);

      # stakeholders...
      #
      my @stakeholders = @{$lookup{$problem}{'stakeholder'}};
      my $stakeholders = $EMPTY_STRING;
      if (@stakeholders) {
	$stakeholders = join(', ', @stakeholders);
      }

      # requests...
      #
      my @requests     = @{$lookup{$problem}{'request'}};
      my $requests     = $EMPTY_STRING;
      if (@requests) {
	$requests = join(', ', @requests);
      }

      # determine importance...
      #
      my $importance   = 'routine';
      $importance      = 'urgent' if $rank <= 4;

      my $info = $EMPTY_STRING;
      $info .= $problem;
      $info .= ", $stakeholders"  if $stakeholders;
      $info .= ", $requests"      if $requests;
      $info .= ", [ref:$problem]" if $problem;

      my $status_color = 'white';
      $status_color = 'red'    if $status eq 'red';
      $status_color = 'yellow' if $status eq 'yellow';
      $status_color = 'green'  if $status eq 'green';
      $status_color = 'grey'   if $status eq 'grey';
      $status_color = 'grey'   if $status eq 'gray';

      my $priority_color = 'grey';
      $priority_color = 'red'    if $priority eq 'critical';
      $priority_color = 'orange' if $priority eq 'high';
      $priority_color = 'yellow' if $priority eq 'routine';
      $priority_color = 'grey'   if $priority eq 'low';

      my $title_description_info = wrap("!!$title:!! $description ~~$info~~");

      $text .= <<"END_OF_TEXT";
: $title_description_info

: $rank

: $importance

:$priority_color: $priority

:$status_color: $status

---

END_OF_TEXT
    }
  }

  return $text;
}

######################################################################

sub generate_prioritized_solution_listing {

  #-------------------------------------------------------------------
  #
  #    Generate and return the structured text for a prioritized
  #    listing (table) of solutions requiring attention.
  #
  #    This subroutine gets called during pass 2 runs, meaning that
  #    the lookup data structure has not yet been created.  DO NOT try
  #    to use the lookup data structure to generate requested
  #    content. You'll have to rely on the 'data' data structure.
  #
  #    This subroutine generates structured text.
  #
  #-------------------------------------------------------------------

  printstatus("generating prioritized solution listing");

  my $text = $EMPTY_STRING;

  #-------------------------------------------------------------------
  # Assign ranking number to each solution in the solution domain.
  #
  my %solutions  = ();
  foreach my $solution ( list_by_name('solution') ) {
    my $priority = $lookup{$solution}{'priority'};
    my $status   = status_of($solution) if label_exists($solution);
    my $rank     = rank_for($priority,$status);
    push @{$solutions{$rank}}, $solution;
    ++ $count{'priority'}{'total'} if $rank >= 1 and $rank <= 8;
  }

  #-----------------------------------------------------------------
  # Begin the solution priorities table
  #
  $text .= <<"END_OF_TEXT";
:grey: !!Prioritized List of Solutions To Be Improved!!

:grey:

:grey:

:grey:

:grey:

---

:grey: ~~solution~~

:grey: ~~rank~~

:grey: ~~importance~~

:grey: ~~priority~~

:grey: ~~status~~

---

END_OF_TEXT

  #-----------------------------------------------------------------
  # Output a row for each solution priority
  #
  foreach my $rank (1..8) {
    foreach my $solution (@{$solutions{$rank}}) {

      my $title        = $lookup{$solution}{'title'};
      my $description  = $lookup{$solution}{'description'};
      my $priority     = $lookup{$solution}{'priority'};
      my $status       = status_of($solution) if label_exists($solution);

      # stakeholders...
      #
      my @stakeholders = @{$lookup{$solution}{'stakeholder'}};
      my $stakeholders = $EMPTY_STRING;
      if (@stakeholders) {
	$stakeholders = join(', ', @stakeholders);
      }

      # requests...
      #
      my @requests     = @{$lookup{$solution}{'request'}};
      my $requests     = $EMPTY_STRING;
      if (@requests) {
	$requests = join(', ', @requests);
      }

      # determine importance...
      #
      my $importance   = 'routine';
      $importance      = 'urgent' if $rank <= 4;

      my $info = $EMPTY_STRING;
      $info .= $solution;
      $info .= ", $stakeholders"   if $stakeholders;
      $info .= ", $requests"       if $requests;
      $info .= ", [ref:$solution]" if $solution;

      my $status_color = 'white';
      $status_color   = 'red'    if $status   eq 'red';
      $status_color   = 'yellow' if $status   eq 'yellow';
      $status_color   = 'green'  if $status   eq 'green';
      $status_color   = 'grey'   if $status   eq 'grey';
      $status_color   = 'grey'   if $status   eq 'gray';

      my $priority_color = 'grey';
      $priority_color = 'red'    if $priority eq 'critical';
      $priority_color = 'orange' if $priority eq 'high';
      $priority_color = 'yellow' if $priority eq 'routine';
      $priority_color = 'grey'   if $priority eq 'low';

      my $title_description_info = wrap("!!$title:!! $description ~~$info~~");

      $text .= <<"END_OF_TEXT";
: $title_description_info

: $rank

: $importance

:$priority_color: $priority

:$status_color: $status

---

END_OF_TEXT
    }
  }

  return $text;
}

######################################################################

sub generate_associated_problem_listing {

  #-------------------------------------------------------------------
  #
  #    Generate and return the structured text for a listing of
  #    problems associated with the specified label.
  #
  #-------------------------------------------------------------------

  my $label = shift;
  my $text = $EMPTY_STRING;

  printstatus("generating associated problem listing: $label");

  #-------------------------------------------------------------------
  # make a list of everything associated with this label.
  #
  my @associates = @{ $lookup{$label}{'associated'} };

  #-------------------------------------------------------------------
  # go through the list of associates and pick out the problems
  #
  my @problems = ();
  foreach my $associate (@associates) {
    my $associate_name = name_for($associate);
    if ($associate_name eq 'problem') {
      push @problems, $associate;
    }
  }

  #-------------------------------------------------------------------
  # If there were no problems, insert a statement that no problems
  # have been identified.
  #
  if (not @problems) {
    $text .= <<"END_OF_TEXT";
(U) No problems have been identified.

END_OF_TEXT

    return $text;
  }

  #-------------------------------------------------------------------
  # build the listing
  #
  foreach my $problem (@problems) {

    my $title =    $lookup{$problem}{'title'};
    my @type  = @{ $lookup{$problem}{'type'} };
    my $type  = join(', ', @type);

    printstatus("  $problem: $type: $title");

    $text .= <<"END_OF_TEXT";
- $title ([ref:$problem])

END_OF_TEXT

  }

  return $text;
}

######################################################################

sub generate_associated_solution_listing {

  #-------------------------------------------------------------------
  #
  #    Generate and return the structured text for a listing of
  #    solutions associated with the specified label.
  #
  #-------------------------------------------------------------------

  my $label = shift;
  my $text = $EMPTY_STRING;

  printstatus("generating associated solution listing: $label");

  #-------------------------------------------------------------------
  # make a list of everything associated with this label.
  #
  my @associates = @{ $lookup{$label}{'associated'} };

  #-------------------------------------------------------------------
  # go through the list of associates and pick out the solutions
  #
  my @solutions = ();
  foreach my $associate (@associates) {
    my $associate_name = name_for($associate);
    if ($associate_name eq 'solution') {
      push @solutions, $associate;
    }
  }

  #-------------------------------------------------------------------
  # If there were no solutions, insert a statement that no solutions
  # have been identified.
  #
  if (not @solutions) {
    $text .= <<"END_OF_TEXT";
(U) No solutions have been identified.

END_OF_TEXT

    return $text;
  }

  #-------------------------------------------------------------------
  # build the listing
  #
  foreach my $solution (@solutions) {

    my $title =    $lookup{$solution}{'title'};
    my @type  = @{ $lookup{$solution}{'type'} };
    my $type  = join(', ', @type);

    $text .= <<"END_OF_TEXT";
- $title ([ref:$solution])

END_OF_TEXT

  }

  return $text;
}

######################################################################

sub generate_item_summary {

  my $item   = shift;
  my $string = "[status:$item] [id:$item] [t:$item] -- [d:$item] ([pg:$item])";

  return $string;
}

######################################################################

sub pass_three {

  ####################################################################
  ####################################################################
  #
  # P3: render documents
  #
  ####################################################################
  ####################################################################
  #
  #     - perform error checking
  #
  #     - assemble the text output for selected renditions
  #
  #-------------------------------------------------------------------
  # PARSING ORDER
  #
  #     As the file is parsed line-by-line, each line must be checked
  #     for the following things in order:
  #
  #         1  Comment block marker
  #         2  Conditional block marker
  #         3  Begin region marker
  #         4  End region marker
  #         5  Environment marker
  #         6  Begin any data element
  #         7  Blank line ending any data element
  #         8  Continuation of any data element
  #
  #-------------------------------------------------------------------
  # SUBROUTINE OUTLINE
  #
  # 2  1  IF debugging
  # 4     1  Print debugging message "begin pass 3 of 3"
  # 2  2  Print progress message

  my $in_resources_div = 0;

  #-------------------------------------------------------------------
  # P3: 1 - Debugging
  #
  #     If we're debugging, tell the user we're starting pass 3.
  #
  if ($DEBUGGING) {
    my $text = <<"END_OF_TEXT";
------------------------------------------------------------
BEGIN PASS 3 of 3
------------------------------------------------------------

END_OF_TEXT

    printdebug($text);
  }

  #-------------------------------------------------------------------
  # P3: 2 - Print progress message
  #
  #     Announce the beginning of pass three.
  #
  # print "\n" if not $option{'gui'} and not $option{'verbose'};
  printmessage("[$text_file->$renditions] Pass 3 of 3 rendering document");

  #-------------------------------------------------------------------
  # P3: 3 - Datastructure Housekeeping (scounter, in, current)
  #
  %scounter           = ();        # Reset the 'scounter' hash
  %dcounter           = ();        # Reset the 'dcounter' hash
  %in                 = ();        # Reset the 'in' hashes
  %current            = ();
  $current{'column'}  = 0;         # Reset table column counter
  $current{'sectype'} = 'section';
  $current{'secnum'}  = 'DEFAULT';
  $current{'name'}    = 'preamble';
  $current{'label'}   = 'preamble';
  $current{'title'}   = 'no title';

  #-------------------------------------------------------------------
  # P3: 3a - Push current name, label, and title on stacks
  #
  push(@{$current{'name_stack'}},$current{'name'});
  push(@{$current{'label_stack'}},$current{'label'});
  push(@{$current{'title_stack'}},$current{'title'});

  #-------------------------------------------------------------------
  # P3: 4 - Reset counts
  #
  #     Reset all the region, environment, and other misc counters.
  #
  foreach my $name ( keys %structure ) {
    $count{$name}{'total'} = 0;
  }

  $count{'quotesource'}{'total'} = 0; # reset the quotesource counter
  $count{'baretable'}{'total'}   = 0; # reset the baretable counter
  $count{'baretable'}{'section'} = 0; # reset the baretable counter
  $count{'footnote'}{'total'}    = 0; # reset the footnote counter
  $count{'footnote'}{'section'}  = 0; # reset the footnote counter

  #-------------------------------------------------------------------
  # P3: 5 - Begin Preamble
  #
  #     Begin the preamble.
  #
  begin_preamble();

  #-------------------------------------------------------------------
  # P3: 6 - Main Loop
  #
  #     process the intext array line by line...
  #
 LINE: for ( @intext ) {

    #-----------------------------------------------------------------
    # P3: Split Line
    #
    #     Break the line out into its four elements
    #
    my $nest          = @{$_}[0]; # current nest of filenames
    my $nesting_level = @{$_}[1]; # current nesting level
    $current{'line'}  = @{$_}[2]; # line in current file
    $_                = @{$_}[3]; # current line

    #-----------------------------------------------------------------
    # P3: Plain Text Output
    #
    #     Write this line to a text version of the output for
    #     debugging purposes.  It let's me know what the text looked
    #     like that actually made it to pass 3.  This text version is
    #     accumulated in an array named @text.
    #
    push @text, $_;

    #-----------------------------------------------------------------
    # P3: Current file
    #
    #     Figure out the name of the current file by splitting up the
    #     "file nest."
    #
    my @files = split(/\s*>\s*/,$nest);
    $current{'file'} = $files[-1];

    #-----------------------------------------------------------------
    # P3: Debugging
    #
    #     Print the current line (if we're debugging).
    #
    if ($DEBUGGING) {
      printmessage("P3---- $_");
    }

    ##################################################################
    ##################################################################
    ##################################################################
    ###                                                            ###
    ###                                                            ###
    ###   Each of the following processing actions are applied to  ###
    ###   EVERY line...                                            ###
    ###                                                            ###
    ###                                                            ###
    ##################################################################
    ##################################################################
    ##################################################################

    #-----------------------------------------------------------------
    # P3: 'Hide' Block
    #
    #     Look for the begin or end a hide block (###hide)
    #
    if (/^(#){3,}hide\s*$/) {
      process_hide_block_marker();
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Begin or end 'Comment' Block
    #
    #     Look for the begin or end a comment block (###comment)
    #
    if (/^(#){3,}comment\s*$/) {
      process_comment_block_marker();
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Continuation of 'Comment' Block Content
    #
    #    If we're in a comment block, process this line as a comment
    #    line.
    #
    if ( $in{'comment'}{'block'} ) {
      process_comment_line($_);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Ignore RESOURCES divisions
    #
    if (/^>>>RESOURCES$/) {
      $in_resources_div = 1;
      next LINE;
    } elsif (/^<<<RESOURCES$/) {
      $in_resources_div = 0;
      next LINE;
    } elsif ($in_resources_div) {
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Begin or end Conditional Block
    #

    #-----------------------------------------------------------------
    # P3: Continuation of Conditional Block
    #

    #-----------------------------------------------------------------
    # P3: Label Block
    #
    if (/^(id|label)::\s*(\S+)\s*$/) {
      $current{'label'} = $2;
      pop(@{ $current{'label_stack'} });
      push(@{ $current{'label_stack'} }, $current{'label'});
    }

    #-----------------------------------------------------------------
    # P3: Footnote References
    #
    #    There may be multiple footnote references on the same line.
    #
    #    A footnote reference is a "[f:label:1]".
    #
    #    Is it OK to put footnotes in a 'preformatted' region?  The
    #    'preformatted' region is designed to be fancier than the
    #    'pre' region. For now, I'm going to say yes, you can put
    #    footnotes in a 'preformatted' region.
    #
    my $temp = $_;
    while ($temp =~ /\S.*?\[f:(\S+?):(\S+?)\]/
           and not /\[lit:\[f:(\S+?):(\S+?)\]/
           and not $in{'comment'}{'block'}
           and not $in{'hide'}{'block'}
           and not /^\s*#/
           and not $in{'pre'}
           and not $in{'listing'}{'environment'}
	  ) {

      # !!! Bug Here !!!
      #
      # The footnote count can't be incremented here.  It breaks
      # multiple footnote references on the same line.  The footnote
      # count must be incremented in the escape_latex or escape_html
      # subroutines.  This, however, creates a bug if multiple
      # revisions are being rendered at the same time.  What to do?
      #
      # ++ $count{'footnote'}{'total'};

      $temp =~ s/\[f:(\S+?):(\S+?)\]//;

      printdebug("found footnote marker [f]") if $DEBUGGING;
    }

    #-----------------------------------------------------------------
    # P3: Preformatted Text
    #
    #    Look for the beginning of preformatted text.  An indented
    #    line indicates the beginning of a pre-formatted text region
    #    EXCEPT when:
    #
    #    (1) You are already in a preformatted text region
    #
    #    (2) The line starts with '-' or '+' and you are already in an
    #        unordered or enumerated list
    #
    #    (3) You are in a comment block
    #
    #    (4) You are in an 'item' (either unordered or enumerated, the
    #        second and subsequent lines of which can be indented)
    #
    #    (5) You are in a todo item (the second and subsequent lines
    #        of which can be indented)
    #
    #    The following condition looks for one of two regular
    #    expressions:
    #
    #     1. /^\s+[^-+=\s]/
    #
    #        Beginning of a line followed by one or more spaces,
    #        followed by any character that's not a '-', '+', '=', or
    #        space.
    #
    #     2. /^\s+[-+=]\S/
    #
    #        Beginning of line followed by one or more spaces,
    #        followed by '-', '+', or '=' IMMEDIATELY (a space
    #        character is NOT allowed immediately after the '-' or
    #        '+') followed by a non-space character.
    #
    if (
        (
	 (/^(\s+)[^-+=\s]/ or /^(\s+)[-+=]\S/)
         and not $in{'pre'}
         and not $in{'preformatted'}{'environment'}
         and not $in{'todo'}
         and not $in{'comment'}{'block'}
         and not $in{'hide'}{'block'}
         and not $in{'listing'}{'environment'}
         and not $in{'item'}
	)
        or
        (/^(\s+)[-+=]/
         and not ($in{'ulist'} or $in{'olist'} or $in{'dlist'})
         and not $in{'pre'}
         and not $in{'preformatted'}{'environment'}
         and not $in{'todo'}
         and not $in{'comment'}{'block'}
         and not $in{'hide'}{'block'}
         and not $in{'listing'}{'environment'}
         and not $in{'item'}
	)
       ) {

      #---------------------------------------------------------------
      # P3: Preformatted: Text Within Slides
      #
      #     !!! Bug Here !!!
      #
      #     This block of code should NOT be necessary.
      #
      #     Skip this line if we're in a slide region and we're not
      #     rendering slide content
      #
      if ( $in{'slide'}{'region'} and not $option{'slide'} ) {
	next LINE;
      }

      #---------------------------------------------------------------
      # P3: Preformatted: Data Elements
      #
      #     Only start a pre-formatted block if we're NOT in a data
      #     element.
      #
      #     For instance, imagine the current line is the second
      #     (indented) line of a source's title.  We don't want to
      #     treat this line as pre-formatted text and stick it in the
      #     document.  We need to recognize when this is the case.
      #
      my @names = keys %structure;
      foreach my $name (@names) {
        my $type = $structure{$name}{'type'};
        if ($in{$name}{$type}) {
	  my @elements = keys %{ $structure{$name}{'elements'} };
          foreach my $element (@elements) {
            if ($in{$name}{$element}) {
              next LINE;
            }
          }
        }
      }

      printdebug(" begin pass 3 block pre DETECTION") if $DEBUGGING;

      #---------------------------------------------------------------
      # P3: Preformatted: Current Initial Indent
      #
      #     Set the value of the current initial indent to the indent
      #     of this line.  If this block of preformatted text occurs
      #     inside a table cell we'll need to strip the initial indent
      #     off the beginning of each line of the block to get rid of
      #     unwanted whitespace in the table.
      #
      my $indent = $1;

      $current{'initial_indent'} = $indent;

      #---------------------------------------------------------------
      # P3: Preformatted: Begin Block
      #
      begin_pre($_);

      #---------------------------------------------------------------
      # P3: Next line
      #
      #     Skip to the next line because the "begin_pre" subroutine
      #     takes care of all necessary processing for this line.
      #
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Preformatted Blank Line
    #
    if (/^\s*$/
	and ( $in{'pre'} or $in{'preformatted'}{'environment'} )
       ) {

      process_line($_);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Emacs Mode Variable
    #
    #     Ignore Emacs mode variable declarations like:
    #
    #         -*-outline-*-
    #
    if (/^-\*-/
	and not $in{'pre'}
        and not $in{'preformatted'}{'environment'}
        and not $in{'listing'}{'environment'}
       ) {

      printdebug("ignoring Emacs mode indicator") if $DEBUGGING;
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Blank Line
    #
    #    A data element is key value pair in the source text.  The key
    #    is a single word followed by a colon at the beginning of a
    #    line (no space is allowed between the key word and the
    #    colon).  The value is the paragraph of text that follows the
    #    key word.
    #
    #    The end of a data element is indicated by (1) a blank line,
    #    (2) another data element, (3) the end of the region, or (4)
    #    the end of the environment
    #
    if (/^\s*$/
	or /^<{3,}/
	or /^-{3,}/
       ) {

      end_current_context();
    }

    ##################################################################
    ##################################################################
    ##################################################################
    ###                                                            ###
    ###                                                            ###
    ###   ONLY ONE OF THE FOLLOWING CONDITIONS WILL APPLY TO THE   ###
    ###   LINE...                                                  ###
    ###                                                            ###
    ###                                                            ###
    ##################################################################
    ##################################################################
    ##################################################################

    #-----------------------------------------------------------------
    # P3: Conditional Blocks
    #
    #     Look for the begin or end a conditional block
    #     (i.e. ???rh9,knoppix)
    #
    if (/^(\?){3,}(.*)\s*$/) {
      process_conditional_block_marker($2);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Region Markers
    #
    #     Look for a begin region marker.  Three or more greater-than
    #     signs and a region name begins a region (i.e. >>>problem).
    #
    if (/^(>){3,}(\w+)/) {
      process_begin_region_marker($2);
      next LINE;
    }

    #     Look for an end region marker.  Three or more less-than
    #     signs and a region name ends a region (i.e. <<<problem).
    #
    if (/^(<){3,}(\w+)/) {
      process_end_region_marker($2);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Environment Markers
    #
    #     Three or more hyphens and an environment name begin and end
    #     an environment (depending on whether you were already in the
    #     environment to begin with) (i.e. ---table).
    #
    if (/^(-){3,}(\w+)/) {
      process_environment_marker($2);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Pagebreaks
    #
    #     A pagebreak is indicated by [pagebreak] on a line by itself
    #     beginning in column one.
    #
    if (/^\[pagebreak\]$/) {
      process_pagebreak();
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Clearpage
    #
    #     A clearpage is indicated by [clearpage] on a line by itself
    #     beginning in column one.
    #
    if (/^\[clearpage\]$/) {
      process_clearpage();
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Region Data Elements
    #
    #     Skip region data elements because the data in these were
    #     gathered in pass 2.  These will be used by either the begin
    #     or end rendering subroutine for whatever region or
    #     environment they are part of.
    #
    #     "Names" include: preamble, figure, attachment, listing,
    #     preformatted, sidebar, source, table, video, demo, exercise,
    #     keypoints, module, quotation, problem, slide, solution,
    #     allocation, assignment, task, result, role, and test.
    #
    #     "Types" include: text, environment, and region
    #
    my @names = list_of_region_names();
    foreach my $name (@names) {
      my $type = $structure{$name}{'type'};
      if ( $in{$name}{$type} ) {
	my @elements = keys %{ $structure{$name}{'elements'} };
        foreach my $element (@elements) {

	  # Start of a data element?
	  #
          if (/^${element}::\s*(\S*)/) {
	    printdebug("found $name $type $element") if $DEBUGGING;
	    my @others = keys %{ $structure{$name}{'elements'} };
            foreach my $other (@others) {
              if ($other eq $element) {
                $in{$name}{$other} = 1;
              }
              else {
                $in{$name}{$other} = 0;
              }
            }
            next LINE;
          }

	  # Continuation of a data element?
	  #
	  elsif ( $in{$name}{$element} ) {
	    printdebug("in $name $element, skipping line") if $DEBUGGING;
            next LINE;
	  }

        }
      }
    }

    #-----------------------------------------------------------------
    # P3: Environment Data Elements
    #
    #     Skip environment data elements because the data in these
    #     were gathered in pass 2.  These will be used by either the
    #     begin or end rendering subroutine for whatever region or
    #     environment they are part of.
    #
    #     "Names" include: preamble, figure, attachment, listing,
    #     preformatted, sidebar, source, table, video, demo, exercise,
    #     keypoints, module, quotation, problem, slide, solution,
    #     allocation, assignment, task, result, role, and test.
    #
    #     "Types" include: text, environment, and region
    #
    my @names = list_of_environment_names();
    foreach my $name (@names) {
      my $type = $structure{$name}{'type'};
      if ( $in{$name}{$type} ) {
	my @elements = keys %{ $structure{$name}{'elements'} };
        foreach my $element (@elements) {

	  # Start of a data element?
	  #
          if (/^${element}::\s*(\S*)/) {
	    printdebug("found $name $type $element") if $DEBUGGING;
	    my @others = keys %{ $structure{$name}{'elements'} };
            foreach my $other (@others) {
              if ($other eq $element) {
                $in{$name}{$other} = 1;
              }
              else {
                $in{$name}{$other} = 0;
              }
            }
            next LINE;
          }

	  # Continuation of a data element?
	  #
	  elsif ( $in{$name}{$element} ) {
	    printdebug("in $name $element, skipping line") if $DEBUGGING;
            next LINE;
	  }

        }
      }
    }

    #-----------------------------------------------------------------
    # P3: Any other Data Elements
    #
    #     Skip any other (non region or element) data elements because
    #     the data in these were gathered in pass 2.  These will be
    #     used by either the begin or end rendering subroutine for
    #     whatever region or environment they are part of.
    #
    #     "Names" include: preamble, figure, attachment, listing,
    #     preformatted, sidebar, source, table, video, demo, exercise,
    #     keypoints, module, quotation, problem, slide, solution,
    #     allocation, assignment, task, result, role, and test.
    #
    #     "Types" include: text, environment, and region
    #
    my @names = keys %structure;
    foreach my $name (@names) {
      my $type = $structure{$name}{'type'};
      if ( $in{$name}{$type} ) {
	my @elements = keys %{ $structure{$name}{'elements'} };
        foreach my $element (@elements) {

	  # Start of a data element?
	  #
          if (/^${element}::\s*(\S*)/) {
	    printdebug("found $name $type $element") if $DEBUGGING;
	    my @others = keys %{ $structure{$name}{'elements'} };
            foreach my $other (@others) {
              if ($other eq $element) {
                $in{$name}{$other} = 1;
              }
              else {
                $in{$name}{$other} = 0;
              }
            }
            next LINE;
          }

	  # Continuation of a data element?
	  #
	  elsif ( $in{$name}{$element} ) {
	    printdebug("in $name $element, skipping line") if $DEBUGGING;
            next LINE;
	  }

        }
      }
    }

    #-----------------------------------------------------------------
    # P3: Comment Lines
    #
    #     Comment lines begin with '#'.
    #
    if (/^#/
	and not $in{'pre'}
        and not $in{'preformatted'}{'environment'}
        and not $in{'listing'}{'environment'}
       ) {

      process_comment_line($_);
      next LINE;
    }

    if (/^#/ and $in{'pre'}) {
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Section Headings
    #
    #     Section headings are lines beginning with one or more *'s
    #
    #     NOTE: Lines could start with two asterisks that indicate a
    #     **bold** word.  These shouldn't be mistaken for a section
    #     heading.  The whitespace following the asterisks in the
    #     following regular expression, therefore, is critical!
    #
    if (/^(\*+)\s+(.*?)\s*$/) {
      my $asterisks = $1;
      my $text      = $2;
      process_heading($asterisks,$text);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Footnotes
    #
    #     Look for the beginning of a footnote. Footnote text begins
    #     with "footnote::<tag>" where the "<tag>" is any string of
    #     the author's choosing that does not contain spaces.  The
    #     "<tag>" is typically a single number or letter.
    #
    #     Don't confuse the footnote text with the footnote reference
    #     indicator doohickey [f:label:1] that appears in the text.
    #
    if (/^footnote::([^\s\:]+):\s*(.*)/) {
      begin_footnote($1,$2);
      next LINE;
    }

    # Footnote Continuation
    #
    #     Look for footnote text.
    #
    elsif ( $in{'footnote'} ) {
      process_footnote_text($_);
      next LINE;
    }

    # End Footnote
    #
    #     Look for the end of a footnote.
    #
    elsif ( /^\s*$/ and $in{'footnote'} ) {
      end_footnote();
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Glossary Entries
    #
    #     Look for the beginning of a glossary entry.  Glossary
    #     entries begin with "glossary:".  Don't confuse the glossary
    #     entry with the inline glossary term indicator [g:term] that
    #     appears in the text.
    #
    if (/^glossary::\s*(.*?)\s*(\[.*?\])?\s*=\s*(.*)/
	and not $in{'footnote'}
	and not $in{'preformatted'}{'environment'}
	and not ($in{'pre'} and $in{'listing'}{'environment'})
       ) {

      my $term = $1;
      my $alt  = $2 || '';
      my $text = $3;

      ++ $count{'glossary'}{'total'};

      begin_glossary_entry($term,$alt,$text);
      next LINE;
    }

    # End Glossary
    #
    #     Look for the end of a glossary entry
    #
    elsif ( /^\s*$/ and $in{'glossary'} ) {
      end_glossary_entry();
      next LINE;
    }

    # Glossary Continuation
    #
    #     Look for glossary entry text
    #
    elsif ( $in{'glossary'} ) {
      process_glossary_entry_text($_);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Variable Definitions
    #
    #     Look for the beginning of a variable definition.  Variable
    #     definitions begin with "var:".  Pass three only needs to
    #     ignore variable definitions.
    #
    if (/^var::(.*?)=(.*)/
	and not $in{'preformatted'}{'environment'}
	and not ($in{'pre'} and $in{'listing'}{'environment'})
       ) {

      my $name  = trim_whitespace($1);
      my $value = trim_whitespace($2);

      ++ $count{'variable'}{'total'};

      begin_variable_entry($name,$value);
      next LINE;
    }


    # End Variable
    #
    #     Look for the end of a variable entry
    #
    elsif ( /^\s*$/ and $in{'variable'} ) {
      end_variable_entry();
      next LINE;
    }

    # Variable Continuation
    #
    #     Look for variable entry text
    #
    elsif ( $in{'variable'} ) {
      process_variable_entry_text($_);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Acronym Definitions
    #
    #     Look for the beginning of an acronym definition.  Acronym
    #     definitions begin with "acronym:".  Don't confuse the
    #     acronym definition with the inline acronym [ac:term] that
    #     appears in the text.
    #
    if (/^acronym::(.*?)=(.*)/
	and not $in{'footnote'}
	and not $in{'preformatted'}{'environment'}
	and not ($in{'pre'} and $in{'listing'}{'environment'})
       ) {

      my $term = trim_whitespace($1);
      my $text = trim_whitespace($2);

      ++ $count{'acronym'}{'total'};

      begin_acronym_definition($term,$text);
      next LINE;
    }

    # End Acronym Definition
    #
    #     Look for the end of an acronym definition
    #
    elsif ( /^\s*$/ and $in{'acronym'} ) {
      end_acronym_definition();
      next LINE;
    }

    # Acronym Definition Continuation
    #
    #     Look for acronym definition text
    #
    elsif ( $in{'acronym'} ) {
      process_acronym_text($_);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Outcomes
    #
    #     Look for the beginning of an outcome.  Outcomes entries
    #     begin with "outcome:".
    #
    if (/^outcome::(\S+:)?\s*(.*)\s*$/) {

      my $attr = trim_whitespace($1);
      my $text = trim_whitespace($2);

      ++ $count{'outcome'}{'total'};

      begin_outcome_text($attr,$text);

      next LINE;

    }

    # End Outcome
    #
    #     Look for the end of an outcome
    #
    elsif ( /^\s*$/ and $in{'outcome'} ) {
      end_outcome_text();
      next LINE;
    }

    # Outcome Continuation
    #
    #     Look for outcome text
    #
    elsif ( $in{'outcome'} ) {
      my $text = trim_whitespace($_);
      process_outcome_text($text);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Reviews
    #
    #     Look for the beginning of an review.  Reviews entries begin
    #     with "review:".
    #
    if (/^review::(\S+:)?\s*(.*)\s*$/) {

      my $attr = trim_whitespace($1);
      my $text = trim_whitespace($2);

      ++ $count{'review'}{'total'};

      begin_review_text($attr,$text);

      next LINE;

    }

    # End Review
    #
    #     Look for the end of an review
    #
    elsif ( /^\s*$/ and $in{'review'} ) {
      end_review_text();
      next LINE;
    }

    # Review Continuation
    #
    #     Look for review text
    #
    elsif ( $in{'review'} ) {
      my $text = trim_whitespace($_);
      process_review_text($text);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Index Entries
    #
    #     Look for the beginning of a block of index text.  Index
    #     entries can be grouped in a block by separating individual
    #     entries with semicolons.
    #
    if (/^index::(\S+:)?\s*(.*)\s*$/) {

      my $attr = trim_whitespace($1);
      my $text = trim_whitespace($2);

      ++ $count{'index'}{'total'};

      begin_index_text($attr,$text);

      next LINE;

    }

    # End Index
    #
    elsif (/^\s*$/ and $in{'index'}) {
      end_index_text();
      next LINE;
    }

    # Index Continuation
    #
    elsif ( /\S/ and $in{'index'}) {
      my $text = trim_whitespace($_);
      process_index_text($text);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: To-Do Items
    #
    #     A todo indicator is one of:
    #
    #     [ ] work hasn't started                         regular
    #     [!] this todo is urgent!                        urgent
    #     [.] work has started                            started
    #     [-] todo has been cancelled                     cancelled
    #     [x] todo is completed                           completed
    #     [?] (Don) indicates Don has a question          question
    #     [ ] (12 Sep 2002) means todo has a              deadline
    #         12 Sep 2002 deadline
    #     [ ] (12 Sep 2002, Don) means Don has a          deadline
    #         12 Sep 2002 deadline
    #
    #     Look for the beginning of a to-do item.
    #
    if (/^\[([ \.\?\-!x])\]\s*(.*)/) {
      my $indicator = $1;
      my $text      = $2;
      begin_todo_item($indicator,$text);
      next LINE;
    }

    # End To-Do Item
    #
    elsif ( /^\s*$/ and $in{'todo'} ) {
      end_todo_item();
      next LINE;
    }

    # To-Do Item Continuation
    #
    elsif ( $in{'todo'} ) {
      process_todo_text($_);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Table Header Cells
    #
    #     Look for lines beginning with "::" or even "::c:blue:"
    #
    if (/^::(\S+:)?\s+(.*)$/) {

      my $attrs = trim_whitespace($1);
      my $text  = trim_whitespace($2);

      if (not $in{'table'}{'environment'}
          and not $in{'baretable'} == 1
	 ) {

        begin_baretable();

      }

      if ( $in{'header'} or $in{'cell'} ) {
        insert_cell_boundary();
      }

      begin_table_header($attrs,$text);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Table Cells
    #
    #     Look for lines beginning with ":"
    #
    if (/^:(\S+:)?\s+(.*)?/) {

      my $attrs = trim_whitespace(resolve_references($1));
      my $text  = trim_whitespace($2);

      if (
	  not $in{'table'}{'environment'}
	  and not $in{'baretable'} == 1
	 ) {

        begin_baretable();

      }

      if ( $in{'header'} or $in{'cell'} ) {
	insert_cell_boundary();
      }

      begin_table_cell($attrs,$text);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: End of Table Row
    #
    #     Look for the end of a table row indicated by lines
    #     containing (only) three or more hyphens '---'
    #
    if (
	/^-{3,}\s*$/
        and (
	     $in{'table'}{'environment'}
	     or $in{'baretable'} == 1
	    )
       ) {

      end_table_row();
      next LINE;

    }

    #-----------------------------------------------------------------
    # P3: Un-Ordered List Item
    #
    #     Lines beginning with a "-" indicate the beginning of an
    #     un-ordered list item.  But NOT if:
    #
    #       (1) You are in footnote text
    #
    #       (2) You are in preformatted text within a listing
    #
    #     If this line is indented but we're NOT already in a ulist,
    #     it should be treated as preformatted text
    #
    if (/^(\s*)-\s+(.*)$/
        and not ($1 and not $in{'ulist'})
        and not $in{'footnote'}
        and not ($in{'pre'} and $in{'listing'}{'environment'})) {
      my $indent = $1;
      my $text   = $2;

      begin_ulist_item($indent,$text);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Ordered List Item
    #
    #     Lines beginning with a "+" indicate the beginning of an
    #     ordered list item.  But NOT if...
    #
    #       (1) You are in footnote text
    #
    #       (2) You are in preformatted text within a listing
    #
    if (/^(\s*)[\+]\s+(.*)$/
        and not ($1 and not $in{'olist'} and not $in{'dlist'})
        and not $in{'footnote'}
        and not ($in{'pre'} and $in{'listing'}{'environment'})) {
      my $indent = $1;
      my $text   = $2;
      begin_olist_item($indent,$text);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Definition List Item
    #
    #     Lines beginning with a "=" indicate the beginning of a
    #     definition list item.  The "term" being defined is placed
    #     between two equals signs like this:
    #
    #       = Perl = Practical Extraction and Reporting Language
    #
    #     A line beginning with an equal sign does NOT begin a
    #     definition list item if:
    #
    #       (1) You are in footnote text
    #
    #       (2) You are in preformatted text within a listing
    #
    #     Limitations:
    #
    #       - Definition lists cannot be nested one within another.
    #
    #       - The "term" being defined must fit on the first line of
    #         the definition list item.
    #
    if (/^=(.*?)=(.*)/
	and not $in{'footnote'}
	and not $in{'preformatted'}{'environment'}
	and not ($in{'pre'} and $in{'listing'}{'environment'})
       ) {

      my $term = trim_whitespace($1);
      my $text = trim_whitespace($2);

      begin_dlist_item($term,$text);
      next LINE;

    }

    #-----------------------------------------------------------------
    # P3: Blank Lines In Pre-Formatted Text
    #
    if (/^\s*$/
        and
        ($in{'pre'}) or $in{'preformatted'}{'environment'}) {
      process_pre($_);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Pre-Formatted Text
    #
    #     Indented lines (as long as we're not in some other context
    #     that might have indented text).
    #
    #     !!! Bug Here !!!
    #
    #     I don't think this code block is necessary.  All recognition
    #     of preformatted text blocks occured earlier.
    #
    if (/^(\s){1,}\S/
        and not $in{'todo'}
        and not $in{'listing'}{'environment'}
        and not $in{'item'}) {
      my $text = $_;
      process_pre($text);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Images
    #
    #     Look for images, i.e. image: image_file.png (the filename
    #     cannot contain any spaces)
    #
    if (/^image::\s*(.*?)\s*$/) {
      my $image_spec = $1;
      process_image($image_spec);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Files
    #
    #     This block of code is *not* executed for 'file:' data
    #     elements within environments like listings and source
    #     environments.  Those files are handled by the end_listing()
    #     and end_source() functions.
    #
    if (/^file::\s*(.*)\s*/
	and not $in{'attachment'}
	and not $in{'listing'}
	and not $in{'audio'}
	and not $in{'video'}
	and not $in{'source'} ) {

      my $filename = $1;
      process_file($filename);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Step Indicators
    #
    #     Look for step indicators.
    #
    #     Increment the step counter if this line starts with "step:".
    #
    #     Note that 'step:' is not considered a data element
    #     indicator. The escape_html and escape_latex routines will
    #     replace it with a check box.
    #
    if (/^step::/) {

      ++ $count{'step'}{'section'};
      ++ $count{'step'}{'total'};
      my $step = $count{'step'}{'total'};
      printdebug("step indicator $step") if $DEBUGGING;

      if ( not $in{'item'} ) {
        process_para_text($_);
      }

      else {
        process_line($_);
      }
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Unknown Data Indicators
    #
    #     Unknown data indicators (like 'titl:') might indicate the
    #     user misspelled something.
    #
    if (/^([a-z]+)::\s+\S+/) {

      my $indicator = $1;

      # determine current name and type
      #
      my $current_name = '';
      my $current_type = '';

      my @names = keys %structure;
      foreach my $name (@names) {
        my $type = $structure{$name}{'type'};
        if ($in{$name}{$type}) {
	  $current_name = $name;
	  $current_type = $type;
        }
      }

      if (not $in{'item'} and not $in{'cell'}) {
	printwarning("P3 unknown $current_name $current_type data element: $indicator");
        process_para_text($_);
      }

      else {
	printwarning("P3 unknown $current_name $current_type data element: $indicator");
        process_line($_);
      }

      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Listing Text
    #
    if ( $in{'listing'}{'environment'} ) {
      next if /^(id|label)::/;
      printdebug("in listing: $in{'listing'}{'environment'}") if $DEBUGGING;

      # skip blank lines at the beginning of the listing
      #
      if ( /^\s*$/ and not $seen{'first_nonblank_line'} ) {
	next LINE;
      }

      else {
	$seen{'first_nonblank_line'} = 1;
	process_line($_);
	next LINE;
      }

    }

    #-----------------------------------------------------------------
    # P3: Item Text
    #
    if ($in{'item'} and not /^\s*$/) {
      process_item_text($_);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Paragraph Text
    #
    if (/^\S/
        and not $in{'item'}
        and not $in{'celltext'}
       ) {

      process_para_text($_);
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Blank Line
    #
    #     Look for blank lines which indicate the end of certain
    #     contexts: para, item, table cell, table row.  A blank line
    #     does NOT indicate the end of a list (unordered or ordered),
    #     and does NOT indicate the end of preformatted text.
    #
    if (/^\s*$/
	and not $in{'pre'}
        and not $in{'preformatted'}{'environment'}
        and not $in{'listing'}{'environment'}
       ) {

      end_current_context();
      next LINE;
    }

    #-----------------------------------------------------------------
    # P3: Process Line
    #
    #     If you've made it this far, process the line as is.
    #
    else {
      printdebug("NO OTHER MATCH, PROCESS LINE") if $DEBUGGING;
      process_line($_);
    }
  }

  #-------------------------------------------------------------------
  # P3: Close Remaining Open Contexts
  #
  #    You've reached the end of the document.  If there happen to be
  #    any open contexts like lists or tables, close them.
  #
  #    !!! Bug Here !!!
  #
  #    If you've reached the end of the document and any of these are
  #    still open, the user should get an error (not a warning?).
  #
  end_pre()               if $in{'pre'};
  end_current_context();
  end_ulist_context()     if $in{'ulist'};
  end_olist_context()     if $in{'olist'};
  end_dlist()             if $in{'dlist'};
  end_baretable()         if $in{'baretable'} == 1;
  end_listing()           if $in{'listing'}{'environment'};

  if ( $in{'table'}{'environment'} ) {
    printwarning("document ended while in table");
    end_table();
  }

  if ( $in{'figure'}{'environment'} ) {
    printwarning("document ended while in figure");
    end_figure();
  }

  if ( $in{'attachment'}{'environment'} ) {
    printwarning("document ended while in attachment");
    end_attachment();
  }

  if ( $in{'preformatted'}{'environment'} ) {
    printwarning("document ended while in preformatted environment");
    end_preformatted();
  }

  if ( $in{'sidebar'}{'environment'} ) {
    printwarning("document ended while in sidebar");
    end_sidebar();
  }

  if ( $in{'source'}{'environment'} ) {
    printwarning("document ended while in source");
    end_source();
  }

  #-------------------------------------------------------------------
  # P3: Debugging
  #
  #     If debugging, notifiy the user we're done with pass 3
  #
  if ($DEBUGGING) {
    my $text = <<"END_OF_TEXT";
------------------------------------------------------------
END PASS 3
------------------------------------------------------------

END_OF_TEXT

    printdebug($text);
  }
}

######################################################################

sub launch_browser {

  my $file = shift;

  if ($^O eq 'MSWin32') {
    my $filename = basename($file);
    chdir($output_dir);
    system("start $filename");
    chdir($startdir);
  }

  else {
    system("mozilla $file &");
  }

}

######################################################################

sub assemble_latex_head_array {

  printdebug("assemble_latex_head_array") if $DEBUGGING;

  $fontfam   = $option{'pdf_fontfam'}    if not $fontfam;
  $fontsize  = $option{'pdf_fontsize'}   if not $fontsize;
  $linkcolor = $option{'pdf_link_color'} if not $linkcolor;

  my $begin_comment = <<"END_OF_TEXT";
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%    NOTICE: THIS FILE WAS GENERATED AUTOMATICALLY
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%    This LaTeX document was published using the publish.pl
%%    Perl script that takes text in Structured Manuscript Language
%%    (SML) and converts it to a LaTeX file.
%%
%%    For more information write to me:
%%
%%         Don Johnson
%%         drj826\@acm.org
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

END_OF_TEXT

  #-------------------------------------------------------------------
  # if this is a book, we want to use "chapter" in certain places, if
  # this is an "article" we want to use "section" in those places.
  #
  my $sectype = 'section';

  if ($document{'doctype'} eq 'book') {
    $sectype = 'chapter';
  }

  elsif ($document{'doctype'} eq 'article') {
    $sectype = 'section';
  }

  #-------------------------------------------------------------------
  # Retrieve the document type (doctype) from the %document data
  # structure.
  #
  my $doctype = $document{'doctype'} || 'article';

  #-------------------------------------------------------------------
  # Begin assembling the preamble.
  #
  my $preamble = <<"END_OF_TEXT";
%% this is a $doctype
\\documentclass[twoside,letterpaper,${fontsize}]{$doctype}

END_OF_TEXT

  #-------------------------------------------------------------------
  # listings package
  #
  $preamble .= <<"END_OF_TEXT";
%% listings package
\\usepackage{listings}
\\lstset{numberstyle=\\tiny,xleftmargin=16pt}

END_OF_TEXT

  #-------------------------------------------------------------------
  # times font
  #
  if ($fontfam eq 'times') {
    $preamble .= <<"END_OF_TEXT";
%% times font
\\usepackage{times}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # bookman font
  #
  elsif ($fontfam eq 'bookman') {
    $preamble .= <<"END_OF_TEXT";
%% bookman font
\\usepackage{bookman}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # chancery font
  #
  elsif ($fontfam eq 'chancery') {
    $preamble .= <<"END_OF_TEXT";
%% chancery font
\\usepackage{chancery}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # charter font
  #
  elsif ($fontfam eq 'charter') {
    $preamble .= <<"END_OF_TEXT";
%% charter font
\\usepackage{charter}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # new century font
  #
  elsif ($fontfam eq 'new_century') {
    $preamble .= <<"END_OF_TEXT";
%% new century font
\\usepackage{newcent}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # palatino font
  #
  elsif ($fontfam eq 'palatino') {
    $preamble .= <<"END_OF_TEXT";
%% palatino font
\\usepackage{palatino}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # makeidx package
  #
  #     Use the makeidx package to make an index if the user requested
  #     one and there were index terms found in the document
  #
  if ($option{'index'} and $count{'index'}{'total'} > 0) {
    $preamble .= <<"END_OF_TEXT";
%% make an index
\\usepackage{makeidx}
\\makeindex

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # framed package
  #
  #     The framed package is used to create boxes or shaded regions
  #     that can break across pages.  Use the framed package if there
  #     are any exercises, demonstrations, or listings.  These are all
  #     rendered using a shaded region.
  #
  #     I'm also trying this out for demarking tasks
  #
  if (
      (   $option{'exercise'} and $count{'exercise'}{'total'} > 0)
      or ($option{'demo'}     and $count{'demo'}{'total'} > 0)
      or ($count{'listing'}{'total'} > 0)
     ) {

    $preamble .= <<"END_OF_TEXT";
%% framed package to create boxes
\\usepackage{framed}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # fancyhdr package
  #
  #     Always use fancy headers and footers.
  #
  $preamble .= <<"END_OF_TEXT";
%% fancyhdr package for headers and footers
\\usepackage{fancyhdr}

END_OF_TEXT

  #-------------------------------------------------------------------
  # anysize package
  #
  #     Use the anysize package to set margin sizes.  The anysize
  #     package lets you adjust the paper size and the margins like
  #     this:
  #
  #       \papersize{width}{height}
  #
  #       \marginsize{left}{right}{top}{bottom}
  #
  my $left   = $margin{'left'}   . 'in';
  my $right  = $margin{'right'}  . 'in';
  my $top    = $margin{'top'}    . 'in';
  my $bottom = $margin{'bottom'} . 'in';
  $preamble .= <<"END_OF_TEXT";
%% anysize package for setting margin sizes
\\usepackage{anysize}
\\marginsize{$left}{$right}{$top}{$bottom}

END_OF_TEXT

  #-------------------------------------------------------------------
  # superscript and subscript
  #
  $preamble .= <<"END_OF_TEXT";
%% subscript
\\newcommand{\\subscript}[1]{\\ensuremath{_{\\scriptsize{\\textrm{#1}}}}}

END_OF_TEXT

  #-------------------------------------------------------------------
  # tabularx, longtable, array, supertabular, and colortbl packages
  #
  #     Use table rendering environments.  Tables are used to render
  #     title page images, the revisions summary, and the metadata for
  #     problems, solutions, allocations, assignments, and tests.
  #
  $preamble .= <<"END_OF_TEXT";
%% table rendering environments
\\usepackage{tabularx}
\\usepackage{longtable}
\\usepackage{array,supertabular}
\\usepackage{colortbl}
\\newlength{\\tablewidth}
\\setlength\\arrayrulewidth{0.5pt}
\\newcolumntype{G}{!{\\color{shadecolor}\\vline}}
\\newcommand\\ghline{\\arrayrulecolor{shadecolor}\\hline\\arrayrulecolor{black}}

END_OF_TEXT

  #-------------------------------------------------------------------
  # fancybox package
  #
  #     The fancybox environment's Ovalbox command is used to create
  #     keystroke descriptions when the user puts something like
  #     [[Enter]] in a document.  See the definition of the
  #     'keystroke' command later in the script.
  #
  #     Only use the fancybox environment if there are keystrokes or
  #     keypoints regions in the document.
  #
  if (   $count{'keystroke'}{'total'} > 0
      or $count{'keypoints'}{'total'} > 0
      or $count{'slide'}{'total'}     > 0
     ) {
    $preamble .= <<"END_OF_TEXT";
%% fancybox environment for keystrokes and slides
\\usepackage{fancybox}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # varioref package
  #
  #     The varioref package supplies flexible cross referencing
  #     features.  I use the vref command out of this package to
  #     reference content items by number and page.
  #
  #     Only use the varioref package if there are cross references in
  #     the document.
  #
  if ($count{'ref'}{'total'} > 0) {
    $preamble .= <<"END_OF_TEXT";
%% varioref package for flexible cross referencing
\\usepackage{varioref}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # amssymb package
  #
  #     I use the following math mode symbols from the amssymb
  #     package:
  #
  #        \backslash
  #        \rightarrow
  #        \leftarrow
  #        \Box
  #
  if (    $count{'mathsymbol'}{'total'} > 0
       or $count{'step'}{'total'}       > 0
       or $count{'todo'}{'total'}       > 0
       or $count{'problem'}{'total'}    > 0
       or $count{'solution'}{'total'}   > 0
       or $count{'allocation'}{'total'} > 0
       or $count{'assignment'}{'total'} > 0
     ) {
    $preamble .= <<"END_OF_TEXT";
%% amssymb and wasysym packages for special symbols
\\usepackage{amssymb}
\\usepackage{wasysym}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # boxedminipage and wrapfig packages
  #
  #     I use boxedminipage and wrapfig environments to display
  #     sidebars.  Only use these environments if there are sidebars
  #     in the document.
  #
  if ($option{'sidebar'} and $count{'sidebar'}{'total'} > 0) {
    $preamble .= <<"END_OF_TEXT";
%% boxedminipage and wrapfig packages to display sidebars
\\usepackage{boxedminipage}
\\usepackage{wrapfig}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # graphicx package
  #
  #     I use the pdftex version of the graphicx package to display
  #     images.  Only include this package if there are images in the
  #     document.
  #
  #     !!! Bug Here !!!
  #
  #     Find out why the conditional doesn't work.
  #
  if ( $count{'image'}{'total'} > 0
       or
       $document{'logo_image_small'}
       or
       $document{'logo_image_left'}
       or
       $document{'logo_image_center'}
       or
       $document{'logo_image_right'}
     ) {
    $preamble .= <<"END_OF_TEXT";
%% graphicx package (PDF version) to display images
\\usepackage[pdftex]{graphicx}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # marvosym package
  #
  #     I use the following symbols from the marvosym package:
  #
  #        \Writinghand   (take note symbol)
  #        \Smiley
  #        \Frowny
  #
  if (
         $count{'take_note'}{'total'} > 0
      or $count{'smiley'}{'total'}    > 0
      or $count{'frowny'}{'total'}    > 0
     ) {

    $preamble .= <<"END_OF_TEXT";
%% marvosym package for special symbols
\\usepackage{marvosym}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # acronym package
  #
  #     Handle acronyms using the latex acronym package if the user
  #     requested it.
  #
  #
  if ($option{'acronym'} and $count{'acronym'}{'total'} > 0) {
    $preamble .= <<"END_OF_TEXT";
%% acronym package
\\usepackage[printonlyused,withpage]{acronym}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # epigraph package
  #
  #     If the document contains any epigraphs (a quotation at the
  #     beginning of a major section), use the epigraph package.
  #
  if ($option{'epigraph'} and $count{'epigraph'}{'total'} > 0) {
    $preamble .= <<"END_OF_TEXT";
%% epigraph package
\\usepackage{epigraph}
\\setlength{\\epigraphwidth}{0.6\\textwidth}
\\setlength{\\epigraphrule}{0pt}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # lscape package
  #
  $preamble .= <<"END_OF_TEXT";
%% lscape package
\\usepackage{lscape}

END_OF_TEXT

  #-------------------------------------------------------------------
  # xcolor package
  #
  #     Use the xcolor package for shaded backgrounds for exercises,
  #     demos, listings, and colored table cell backgrounds.
  #
  #     Define colors to use for shaded areas and table cell
  #     background colors.
  #
  if (
         ($option{'exercise'} and $count{'exercise'}{'total'} > 0)
      or ($option{'demo'}     and $count{'demo'}{'total'}     > 0)
      or ($count{'listing'}{'total'}   > 0)
      or ($count{'table'}{'total'}     > 0)
      or ($count{'baretable'}{'total'} > 0)
      or ($count{'glossary'}{'total'}  > 0)
     ) {

    $preamble .= <<"END_OF_TEXT";
%% xcolor package for shaded backgrounds
\\usepackage[table,override,pdftex]{xcolor}
\\definecolor{shadecolor}{rgb}{0.9,0.9,0.9}
\\definecolor{bg-red}{rgb}{1.0,0.4,0.4}
\\definecolor{bg-green}{rgb}{0.4,1.0,0.4}
\\definecolor{bg-blue}{rgb}{0.4,0.4,1.0}
\\definecolor{bg-yellow}{rgb}{1.0,1.0,0.4}
\\definecolor{bg-orange}{rgb}{1.0,0.8,0.4}
\\definecolor{bg-purple}{rgb}{1.0,0.4,1.0}
\\definecolor{bg-litegrey}{rgb}{0.95,0.95,0.95}
\\definecolor{bg-grey}{rgb}{0.85,0.85,0.85}
\\definecolor{bg-darkgrey}{rgb}{0.75,0.75,0.75}
\\definecolor{bg-white}{rgb}{1.0,1.0,1.0}
\\definecolor{fg-grey}{rgb}{0.70,0.70,0.70}
\\definecolor{fg-green}{rgb}{0.3,0.9,0.3}
\\definecolor{fg-darkgreen}{rgb}{0.0,0.5,0.0}
\\definecolor{fg-darkred}{rgb}{0.5,0.0,0.0}
\\definecolor{fg-yellow}{rgb}{1.0,0.9,0.3}
\\definecolor{fg-blue}{rgb}{0.0,0.0,0.8}
\\definecolor{fg-orange}{rgb}{1.0,0.6,0.0}
\\definecolor{fg-red}{rgb}{0.9,0.3,0.3}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # url and hyperref packages
  #
  #     Use the url and hyperref packages for typesetting URLs and
  #     long path/filename expressions.
  #
  #     Since paths can contain spaces, use the [obeyspaces] package
  #     option for the url package.
  #
  #     !!! bug here !!!
  #
  #     The following block of code includes the url and hyperref
  #     packages ONLY if urls are present in the text.  The problem
  #     with this is that these packages are used for more than just
  #     URLs.  They are also used for typesetting:
  #
  #       paths (url)
  #       files (url)
  #       commands (url)
  #       colored links (hyperref)
  #
  #     For now, I've commented out the conditional statement so these
  #     packages are ALWAYS included.  In the future, I need to
  #     tighten up this code so they are only included if necessary.
  #
  $preamble .= <<"END_OF_TEXT";
%% url and hyperref packages for hyperlinks
\\usepackage[obeyspaces]{url}
\\usepackage[
  colorlinks=true,
  linkcolor=$linkcolor,
  urlcolor=$linkcolor,
  bookmarksopen=true,
  bookmarksnumbered=true,
  backref=section
]{hyperref}

END_OF_TEXT

  #-------------------------------------------------------------------
  # glossaries package
  #
  #     Make a glossary if the user requested one and there were
  #     glossary terms found in the document
  #
  if ($option{'glossary'} and $count{'glossary'}{'total'} > 0) {
    $preamble .= <<"END_OF_TEXT";
%% glossaries package
\\usepackage{glossaries}
\\glstoctrue
\\makeglossaries

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # attachfile package
  #
  #     Use the attachfile package to attach files to PDF renditions
  #     if the user wants attachments and the document contains
  #     attachments.
  #
  if ($option{'attachment'} and $count{'attachment'}{'total'} > 0) {
    $preamble .= <<"END_OF_TEXT";
%% attachfile package for PDF file attachments
\\usepackage{attachfile}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # changebar package
  #
  #     Use the changebar package to place a bar in the margin to
  #     indicate the beginning and ending of: problems, solutions,
  #     allocations, assignments, tests, tasks, results, and roles.
  #
  #     I know, this is not the intended use of the changebar package,
  #     but I think it does a nice job of signifying the beginning and
  #     ending of these environments.
  #
  #     !!! bug here !!!
  #
  #     I'd really, really like to use the changebar package to demark
  #     the start and end of problems, solutions, allocations,
  #     assignments, tests, tasks, results, and roles.  However, the
  #     LaTeX changebar package interferes with listings.
  #     Specifically, in the RELAX document, it derails the
  #     \listofsolutions.  Just using the package causes the problem,
  #     even when there are no changebars in the document.  So, I've
  #     got it commented out for now.
  #
  #     I wonder if the defect is in the way I define my custom
  #     listings?
  #
  $preamble .= <<"END_OF_TEXT";
%% changebar package to show what changed since the previous version
%% \\usepackage[leftbars]{changebar}
%% \\setlength\\changebarsep{6pt}
 
END_OF_TEXT

  #-------------------------------------------------------------------
  # paragraph indent
  #
  #     Set the paragraph indent to zero, we want block paragraphs
  #     with no initial indent.
  #
  $preamble .= <<"END_OF_TEXT";
%% no paragraph indent, use block paragraphs
\\setlength{\\parindent}{0pt}

END_OF_TEXT

  #-------------------------------------------------------------------
  # exercise region
  #
  #     If there are exercises in this document and we're including
  #     them, define an exercise region.
  #
  if ($count{'exercise'}{'total'} > 0 and $option{'exercise'})  {

    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% exercise region
%%
\\makeatletter
\\newcounter{exercise}[$sectype]
\\newcommand{\\listofexercises}{
\\${sectype}*{List of Exercises
\\\@mkboth{\\MakeUppercase{List of Exercises}}{\\MakeUppercase{List of Exercises}}}%
\\\@starttoc{exr}}
\\newenvironment{exercise}[1]{%
  \\begin{shaded}
  \\refstepcounter{exercise}
  \\addcontentsline{exr}{section}{\\protect\\numberline{\\theexercise} \\hspace{0.1in} #1}
  \\par\\noindent\\textbf{Exercise \\theexercise -- #1}\\par
}{%
  \\end{shaded}
}
\\renewcommand{\\theexercise}{\\the${sectype}.\\arabic{exercise}}
\\makeatother

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # demo region
  #
  #     If there are demonstrations in this document and we're
  #     including them, define a demonstration region.
  #
  if ($count{'demo'}{'total'} > 0 and $option{'demo'})  {

    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% demonstration region
%%
\\makeatletter
\\newcounter{demonstration}[$sectype]
\\newcommand{\\listofdemos}{
\\${sectype}*{List of Demonstrations
\\\@mkboth{\\MakeUppercase{List of Demonstrations}}{\\MakeUppercase{List of Demonstrations}}}%
\\\@starttoc{dem}}
\\newenvironment{demonstration}[1]{%
  \\begin{shaded}
  \\refstepcounter{demonstration}
  \\addcontentsline{dem}{section}{\\protect\\numberline{\\thedemonstration} \\hspace{0.1in} #1}
  \\par\\noindent\\textbf{Demonstration \\thedemonstration -- #1}\\par
}{%
  \\end{shaded}
}
\\renewcommand{\\thedemonstration}{\\the${sectype}.\\arabic{demonstration}}
\\makeatother

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # listing region
  #
  #     If there are listings in this document and we're including
  #     them, define a listing region.
  #
  if ($count{'listing'}{'total'} > 0)  {

    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% listing region
%%
\\makeatletter
\\newcounter{listing}[$sectype]
\\newcommand{\\listoflistings}{
\\${sectype}*{List of Listings
\\\@mkboth{\\MakeUppercase{List of Listings}}{\\MakeUppercase{List of Listings}}}%
\\\@starttoc{lis}}
\\newenvironment{listing}[1]{%
  \\begin{shaded}
  \\refstepcounter{listing}
  \\addcontentsline{lis}{table}{\\protect\\numberline{\\thelisting} \\hspace{0.1in} #1}
  \\par\\noindent\\textbf{Listing \\thelisting -- #1}\\par
}{%
  \\end{shaded}
}
\\renewcommand{\\thelisting}{\\the${sectype}.\\arabic{listing}}
\\makeatother

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # problem region
  #
  #     If there are problems in this document and we're including
  #     them, define a problem region.
  #
  if ($count{'problem'}{'total'} > 0 and $option{'problem'})  {

    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% problem region
%%
\\makeatletter
\\newcounter{problem}[$sectype]
\\newcommand{\\listofproblems}{
\\${sectype}*{List of Problems
\\\@mkboth{\\MakeUppercase{List of Problems}}{\\MakeUppercase{List of Problems}}}%
\\\@starttoc{req}}
\\newenvironment{problem}[1]{%
  \\refstepcounter{problem}
  \\addcontentsline{req}{figure}{\\protect\\numberline{\\theproblem} \\hspace{0.1in} #1}
}{%
}
\\renewcommand{\\theproblem}{\\the${sectype}.\\arabic{problem}}
\\makeatother

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # solution region
  #
  #     If there are solutions in this document and we're including
  #     them, define a solution region.
  #
  if ($count{'solution'}{'total'} > 0 and $option{'solution'})  {

    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% solution region
%%
\\makeatletter
\\newcounter{solution}[$sectype]
\\newcommand{\\listofsolutions}{
\\${sectype}*{List of Solutions
\\\@mkboth{\\MakeUppercase{List of Solutions}}{\\MakeUppercase{List of Solutions}}}%
\\\@starttoc{sol}}
\\newenvironment{solution}[1]{%
  \\refstepcounter{solution}
  \\addcontentsline{sol}{figure}{\\protect\\numberline{\\thesolution} \\hspace{0.1in} #1}
}{%
}
\\renewcommand{\\thesolution}{\\the${sectype}.\\arabic{solution}}
\\makeatother

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # allocation region
  #
  #     If there are allocations in this document and we're including
  #     them, define a allocation region.
  #
  if ($count{'allocation'}{'total'} > 0 and $option{'allocation'})  {

    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% allocation region
%%
\\makeatletter
\\newcounter{allocation}[$sectype]
\\newcommand{\\listofallocations}{
\\${sectype}*{List of Allocations
\\\@mkboth{\\MakeUppercase{List of Allocations}}{\\MakeUppercase{List of Allocations}}}%
\\\@starttoc{alo}}
\\newenvironment{allocation}[1]{%
  \\refstepcounter{allocation}
  \\addcontentsline{alo}{figure}{\\protect\\numberline{\\theallocation} \\hspace{0.1in} #1}
}{%
}
\\renewcommand{\\theallocation}{\\the${sectype}.\\arabic{allocation}}
\\makeatother

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # assignment region
  #
  #     If there are assignments in this document and we're including
  #     them, define a assignment region.
  #
  if ($count{'assignment'}{'total'} > 0 and $option{'assignment'})  {

    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% assignment region
%%
\\makeatletter
\\newcounter{assignment}[$sectype]
\\newcommand{\\listofassignments}{
\\${sectype}*{List of Assignments
\\\@mkboth{\\MakeUppercase{List of Assignments}}{\\MakeUppercase{List of Assignments}}}%
\\\@starttoc{asn}}
\\newenvironment{assignment}[1]{%
  \\refstepcounter{assignment}
  \\addcontentsline{asn}{figure}{\\protect\\numberline{\\theassignment} \\hspace{0.1in} #1}
}{%
}
\\renewcommand{\\theassignment}{\\the${sectype}.\\arabic{assignment}}
\\makeatother

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # test region
  #
  #     If there are tests in this document and we're including them,
  #     define a test region.
  #
  if ($count{'test'}{'total'} > 0 and $option{'test'})  {

    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% test region
%%
\\makeatletter
\\newcounter{test}[$sectype]
\\newcommand{\\listoftests}{
\\${sectype}*{List of Tests
\\\@mkboth{\\MakeUppercase{List of Tests}}{\\MakeUppercase{List of Tests}}}%
\\\@starttoc{tst}}
\\newenvironment{test}[1]{%
  \\refstepcounter{test}
  \\addcontentsline{tst}{figure}{\\protect\\numberline{\\thetest} \\hspace{0.1in} #1}
}{%
}
\\renewcommand{\\thetest}{\\the${sectype}.\\arabic{test}}
\\makeatother

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # task region
  #
  #     If there are tasks in this document and we're including them,
  #     define a task region.
  #
  if ($count{'task'}{'total'} > 0 and $option{'task'})  {

    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% task region
%%
\\makeatletter
\\newcounter{task}[$sectype]
\\newcommand{\\listoftasks}{
\\${sectype}*{List of Tasks
\\\@mkboth{\\MakeUppercase{List of Tasks}}{\\MakeUppercase{List of Tasks}}}%
\\\@starttoc{tsk}}
\\newenvironment{task}[1]{%
  \\refstepcounter{task}
  \\addcontentsline{tsk}{figure}{\\protect\\numberline{\\thetask} \\hspace{0.1in} #1}
}{%
}
\\renewcommand{\\thetask}{\\the${sectype}.\\arabic{task}}
\\makeatother

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # result region
  #
  #     If there are results in this document and we're including them,
  #     define a result region.
  #
  if ($count{'result'}{'total'} > 0 and $option{'result'})  {

    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% result region
%%
\\makeatletter
\\newcounter{result}[$sectype]
\\newcommand{\\listofresults}{
\\${sectype}*{List of Results
\\\@mkboth{\\MakeUppercase{List of Results}}{\\MakeUppercase{List of Results}}}%
\\\@starttoc{res}}
\\newenvironment{result}[1]{%
  \\refstepcounter{result}
  \\addcontentsline{res}{figure}{\\protect\\numberline{\\theresult} \\hspace{0.1in} #1}
}{%
}
\\renewcommand{\\theresult}{\\the${sectype}.\\arabic{result}}
\\makeatother

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # role region
  #
  #     If there are roles in this document and we're including them,
  #     define a role region.
  #
  if ($count{'role'}{'total'} > 0 and $option{'role'})  {

    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% role region
%%
\\makeatletter
\\newcounter{role}[$sectype]
\\newcommand{\\listofroles}{
\\${sectype}*{List of Roles
\\\@mkboth{\\MakeUppercase{List of Roles}}{\\MakeUppercase{List of Roles}}}%
\\\@starttoc{rol}}
\\newenvironment{role}[1]{%
  \\refstepcounter{role}
  \\addcontentsline{rol}{figure}{\\protect\\numberline{\\therole} \\hspace{0.1in} #1}
}{%
}
\\renewcommand{\\therole}{\\the${sectype}.\\arabic{role}}
\\makeatother

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # attachment region
  #
  #     If there are attachments in this document and we're including
  #     them, define a attachment region.
  #
  if ($count{'attachment'}{'total'} > 0 and $option{'attachment'})  {

    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% attachment region
%%
\\makeatletter
\\newcounter{attachment}[$sectype]
\\newcommand{\\listofattachments}{
\\${sectype}*{List of Attachments
\\\@mkboth{\\MakeUppercase{List of Attachments}}{\\MakeUppercase{List of Attachments}}}%
\\\@starttoc{att}}
\\newenvironment{attachment}[1]{%
  \\refstepcounter{attachment}
  \\addcontentsline{att}{figure}{\\protect\\numberline{\\theattachment} \\hspace{0.1in} #1}
}{%
}
\\renewcommand{\\theattachment}{\\the${sectype}.\\arabic{attachment}}
\\makeatother

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # Future expansion... nothing to see here... move along...
  #
#   $preamble .= <<"END_OF_TEXT";

# %%--------------------------------------------------------------------
# %% define a chapter-like section called "lab"
# %%
# %% \\newcommand{\\labname}{Hands-On Lab}
# %% \\newcounter{lab}[part]
# %% \\newcommand{\\lab}[2][?]{%
# %%   \\newpage\\thispagestyle{plain}%
# %%   \\refstepcounter{lab}%
# %%   \\addcontentsline{toc}{lab}%
# %%      {\\protect\\numberline{\\labname~\\thelab} #1}%
# %%   {\\flushleft\\LARGE\\bfseries\\labname\\ \\thelab\\par\\nohyphens#2\\par}%
# %%   \\sectionmark{#1}\\vspace{\\baselineskip}}
# END_OF_TEXT

  #-------------------------------------------------------------------
  # table cell list environment
  #
  #     Define a special environment for lists inside of table cells.
  #
  if ($count{'table'}{'total'} > 0 or $count{'baretable'}{'total'} > 0) {

    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% define an itemize region for use in table cells
%%
\\newenvironment{tablecellitemize}{%
  \\begin{list}{\$\\bullet\$}{%
      \\setlength{\\topsep}{0pt}
      \\setlength{\\parskip}{0pt}
      \\setlength{\\leftmargin}{10pt}
      \\setlength{\\rightmargin}{10pt}
      \\setlength{\\parsep}{4pt}
      \\setlength{\\itemsep}{0pt}
    }}
    {\\end{list}}%

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # fancy header and footer
  #
  #     Always use a fancy header and footer.
  #
  $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% fancy header and footer
%%
\\pagestyle{fancy}
\\addtolength{\\headheight}{\\baselineskip}
\\addtolength{\\footskip}{\\baselineskip}

END_OF_TEXT

  #-------------------------------------------------------------------
  # Surpress section numbering if requested by the user.
  #
  if (not $option{'secnums'}) {

    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% This line surpresses all section numbering both in section headings
%% and in the table of contents.
%%
\\setcounter{secnumdepth}{-2}

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # headers and footers
  #
  #     Scold the user if their document contains *both* security
  #     markings *and* specified headers and footers.
  #
  #     There are three possible header/footer styles:
  #
  #     1. plain
  #
  #        title page header left   -> blank
  #        title page header center -> blank
  #        title page header right  -> blank
  #
  #        title page footer left   -> blank
  #        title page footer center -> blank
  #        title page footer right  -> blank
  #
  #        header left              -> [thepage]      horizontal rule
  #        header center            ->                horizontal rule
  #        header right             -> [thesection]   horizontal rule
  #
  #        footer left              -> Revision [revision]
  #        footer center            -> blank
  #        footer right             -> Version [version], [date]
  #
  #     2. classified
  #
  #        title page header left   -> blank
  #        title page header center -> $document{'classification'} + $document{'handling_caveat'}
  #        title page header right  -> blank
  #
  #        title page footer left   -> blank
  #        title page footer center -> $document{'classification'} + $document{'handling_caveat'}
  #        title page footer right  -> blank
  #
  #        header left              -> blank
  #        header center            -> $document{'classification'} + $document{'handling_caveat'}
  #        header right             -> blank
  #
  #        footer left              -> blank
  #        footer center            -> [thepage] + $document{'classification'} + $document{'handling_caveat'}
  #        footer right             -> [date]
  #
  #     3. custom
  #
  #        title page header left   ->
  #        title page header center -> @{ $document{'header_center'} }
  #        title page header right  ->
  #
  #        title page footer left   ->
  #        title page footer center -> @{ $document{'footer_center'} }
  #        title page footer right  ->
  #
  #        header left              -> @{ $document{'header_left'} }
  #        header center            -> @{ $document{'header_center'} }
  #        header right             -> @{ $document{'header_right'} }
  #
  #        footer left              -> @{ $document{'footer_left'} }
  #        footer center            -> @{ $document{'footer_center'} }
  #        footer right             -> @{ $document{'footer_right'} }
  #
  #     If the document is classified, the classification and handling
  #     markings go in the center of both the header and footer.
  #

  #-------------------------------------------------------------------
  # Determine whether custom header/footer information is present.
  #
  my $custom_headfoot = '';
  my @custom_headfoot_elements = (
        'header_left',   'header_left_odd',   'header_left_even',
        'header_center', 'header_center_odd', 'header_center_even',
	'header_right',  'header_right_odd',  'header_right_even',
        'footer_left',   'footer_left_odd',   'footer_left_even',
        'footer_center', 'footer_center_odd', 'footer_center_even',
	'footer_right',  'footer_right_odd',  'footer_right_even',
  );

  foreach my $element (@custom_headfoot_elements) {
    if ($document{$element}) {
      $custom_headfoot = 1;
    }
  }

  #-------------------------------------------------------------------
  # Scold user if *both* custom headers and classification markings
  # are present.
  #
  if ( ($document{'classification'}
	or $document{'handling_caveat'})
       and $custom_headfoot) {
    printwarning("Document contains BOTH classification markings and custom header/footer information.  Using classification markings");
  }

  #-------------------------------------------------------------------
  # Renew the chaptermark command if this is a book.
  #
  if ($document{'doctype'} eq 'book') {

    $preamble .= <<"END_OF_TEXT";
%% this document is a book, use chapters
\\renewcommand{\\chaptermark}[1]{\\markboth{#1}{}}

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # not classified and not custom headers/footers
  #
  #     If the document is not classified, render `normal' headers and
  #     footers...
  #
  if (not $document{'classification'} and not $custom_headfoot) {

    #-----------------------------------------------------------------
    # Set up the header to include running headers and page numbers.
    #
    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% default headers and footers
%%
\\renewcommand{\\sectionmark}[1]{\\markright{\\thesection\\ #1}}
\\lhead[\\fancyplain{}{\\bfseries\\thepage}]{\\fancyplain{}{\\bfseries\\rightmark}}
\\rhead[\\fancyplain{}{\\bfseries\\leftmark}]{\\fancyplain{}{\\bfseries\\thepage}}
%% \\fancyhead[CE,CO]{\\sf\\bfseries{}}
\\fancyfoot[CE,CO]{\\sf\\bfseries{}}
%% \\fancyhead[LE,RO]{}
%% \\fancyhead[RE,LO]{}

END_OF_TEXT

    #-----------------------------------------------------------------
    # footer (copyright and revision + date)
    #
    #     !!! Bug Here !!!
    #
    #     I don't think I like having the copyright show up on every
    #     single page.  Perhaps this should be a publish-time option.
    #
    my $copyright       = '';
    my $revision        = '';
    my $date            = '';
    my $revision_number = '';
    my $modified_date   = '';
    my $modified        = $document{'modified'} || 0;

    if ($modified) {
      $modified = 'CHANGES';
    } else {
      $modified = '';
    }

    if ( $document{'copyright'} ) {
      $copyright = '\\footnotesize Copyright~\\copyright~' . $document{'copyright'};
    }

    if ( $document{'date'} ) {
      my $original_date = $document{'date'};
      if ( $original_date =~ /\((\w+,\s+\d+\s+\w+\s+\d+)\)/ ) {
	$modified_date = $1;
      }
      else {
	$modified_date = $original_date;
      }
    }

    if ( $document{'version'} and $document{'revision'} ) {
      my $version           = $document{'version'};
      my $original_revision = $document{'revision'};

      if ($original_revision =~ /\$Revision:\s*(.*?)\s*\$/) {
	$revision_number = $1;
      } else {
	$revision_number = $original_revision;
      }

      $revision_number = trim_whitespace($revision_number);

      $revision = "\\footnotesize $modified_date - v${version}.$revision_number $modified";
    }

    elsif ( $document{'version'} ) {
      my $version = $document{'version'};
      $revision = "\\footnotesize $modified_date - v${version} $modified";
    }

    elsif ( $document{'revision'} ) {
      my $original_revision = $document{'revision'};
      if ($original_revision =~ /\$Revision:\s*(.*?)\s*\$/) {
	$revision_number = $1;
      }
      else {
	$revision_number = $original_revision;
      }

      $revision_number = trim_whitespace($revision_number);

      $revision = "\\footnotesize $modified_date - r${revision_number} $modified";
    }

    $preamble .= <<"END_OF_TEXT";
\\fancyfoot[LE]{$copyright}
\\fancyfoot[RO]{$revision}
\\fancyfoot[LO]{$copyright}
\\fancyfoot[RE]{$revision}

END_OF_TEXT

    #-----------------------------------------------------------------
    # head and foot rules
    #
    #     Set up the rule under the header, and make the footer rule
    #     disappear.
    #
    $preamble .= <<"END_OF_TEXT";
\\renewcommand{\\headrulewidth}{0.4pt}
\\renewcommand{\\footrulewidth}{0pt}
\\raggedbottom
\\setlength{\\voffset}{-0.25in}
\\setlength{\\fboxsep}{10pt}

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # classified
  #
  #     Otherwise, the document is classified and should be rendered
  #     with security headers and footers
  #
  elsif ($document{'classification'}) {

    #-------------------------------------------------------------------
    # Fancy Header and Footer for classified documents
    #
    #     This is a fancy header/footer I developed for classified
    #     documents.  I include it here so I can eventually automate
    #     the headers and footers for classified documents.
    #
    my $classification = escape_latex( $document{'classification'} );
    my $handling       = escape_latex( join('/', @{$document{'handling_caveat'}}) );

    my $markings = $EMPTY_STRING;
    if ($classification and $handling) {
      $markings = "$classification//$handling";
    }
    elsif ($classification) {
      $markings = "$classification";
    }

    my $draft_copy = $EMPTY_STRING;
    if ($option{'draft'}) {
      $draft_copy = 'DRAFT COPY';
    }

    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% Header and footer for classified documents...
%%
\\renewcommand{\\chaptermark}[1]{\\markboth{#1}{}}
\\renewcommand{\\sectionmark}[1]{\\markright{\\thesection\\ #1}}
\\lhead[\\fancyplain{}{\\sf{$draft_copy}}]{\\fancyplain{}{\\sf{}}}
\\rhead[\\fancyplain{}{\\sf{}}]{\\fancyplain{}{\\sf{$draft_copy}}}
\\fancyhead[CE,CO]{\\sf\\bfseries\\large{$markings}}
\\fancyfoot[CE,CO]{\\normalfont\\thepage \\\\ \\sf\\bfseries\\large{$markings}}
%% \\fancyhead[LE,RO]{}
%% \\fancyhead[RE,LO]{}
\\fancyfoot[LE]{}
\\fancyfoot[RO]{\\sf\\footnotesize\\today}
\\fancyfoot[LO]{}
\\fancyfoot[RE]{\\sf\\footnotesize\\today}
\\renewcommand{\\headrulewidth}{0pt}
\\renewcommand{\\footrulewidth}{0pt}
\\raggedbottom
\\setlength{\\voffset}{-0.25in}
\\setlength{\\fboxsep}{10pt}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # custom headers and footers
  #
  #     Otherwise, the document has custom headers and footers.
  #
  #     The header and footer are both divided into three blocks:
  #     left, center, and right.
  #
  #     Each block can contain multiple components separated by line
  #     breaks.  For instance, the footer might contain the page
  #     number with a short statement underneath.  Each component can
  #     be independently formatted with: font-size, font-weight,
  #     justification.
  #
  elsif ($custom_headfoot) {

    #-----------------------------------------------------------------
    # List possible header/footer elements
    #
    my @custom_headfoot_elements = (
        'header_left',   'header_left_odd',   'header_left_even',
        'header_center', 'header_center_odd', 'header_center_even',
	'header_right',  'header_right_odd',  'header_right_even',
        'footer_left',   'footer_left_odd',   'footer_left_even',
        'footer_center', 'footer_center_odd', 'footer_center_even',
	'footer_right',  'footer_right_odd',  'footer_right_even',
    );

    #-----------------------------------------------------------------
    # Construct a hash of header/footer strings.
    #
    my %headfoot = ();
    foreach my $element (@custom_headfoot_elements) {
      my @components = ();
      foreach my $struct (@{ $document{$element} }) {
	my $text = $struct->{'text'};    # arbitrary text
	$text = escape_latex($text);

	next if not $text;

	my $size   = $struct->{'size'};    # see @font_sizes
	my $weight = $struct->{'weight'};  # see @font_weights
	my $shape  = $struct->{'shape'};   # see @font_shapes
	my $family = $struct->{'family'};  # see @font_families
	my $string = "{" . $text . "}";

	$string = "\\$size"      . $string if $size;
	$string = "\\normalfont" . $string if $shape  eq 'normal';
	$string = "\\itshape"    . $string if $shape  eq 'italic';
	$string = "\\slshape"    . $string if $shape  eq 'slanted';
	$string = "\\scshape"    . $string if $shape  eq 'smallcaps';
	$string = "\\bfseries"   . $string if $weight eq 'bold';
	$string = "\\bfseries"   . $string if $weight eq 'bold_extended';
	$string = "\\mdseries"   . $string if $weight eq 'medium';
	$string = "\\rmfamily"   . $string if $family eq 'roman';
	$string = "\\sffamily"   . $string if $family eq 'serif';
	$string = "\\ttfamily"   . $string if $family eq 'typewriter';

	push @components, $string;

      }
      $headfoot{$element} = join(' \\\\ ', @components);
    }

    my $hlo = $headfoot{'header_left_odd'}    || $headfoot{'header_left'};
    my $hco = $headfoot{'header_center_odd'}  || $headfoot{'header_center'};
    my $hro = $headfoot{'header_right_odd'}   || $headfoot{'header_right'};
    my $hle = $headfoot{'header_left_even'}   || $headfoot{'header_left'};
    my $hce = $headfoot{'header_center_even'} || $headfoot{'header_center'};
    my $hre = $headfoot{'header_right_even'}  || $headfoot{'header_right'};
    my $flo = $headfoot{'footer_left_odd'}    || $headfoot{'footer_left'};
    my $fco = $headfoot{'footer_center_odd'}  || $headfoot{'footer_center'};
    my $fro = $headfoot{'footer_right_odd'}   || $headfoot{'footer_right'};
    my $fle = $headfoot{'footer_left_even'}   || $headfoot{'footer_left'};
    my $fce = $headfoot{'footer_center_even'} || $headfoot{'footer_center'};
    my $fre = $headfoot{'footer_right_even'}  || $headfoot{'footer_right'};

    my $hlo_block = wrap("\\fancyhead[LO]{$hlo}");
    my $hco_block = wrap("\\fancyhead[CO]{$hco}");
    my $hro_block = wrap("\\fancyhead[RO]{$hro}");
    my $hle_block = wrap("\\fancyhead[LE]{$hle}");
    my $hce_block = wrap("\\fancyhead[CE]{$hce}");
    my $hre_block = wrap("\\fancyhead[RE]{$hre}");
    my $flo_block = wrap("\\fancyfoot[LO]{$flo}");
    my $fco_block = wrap("\\fancyfoot[CO]{$fco}");
    my $fro_block = wrap("\\fancyfoot[RO]{$fro}");
    my $fle_block = wrap("\\fancyfoot[LE]{$fle}");
    my $fce_block = wrap("\\fancyfoot[CE]{$fce}");
    my $fre_block = wrap("\\fancyfoot[RE]{$fre}");

    #-----------------------------------------------------------------
    # Fancy Header and Footer for custom documents
    #
    #     This is a fancy header/footer I developed for classified
    #     documents.  I include it here so I can eventually automate
    #     the headers and footers for classified documents.
    #
    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% Custom Headers/Footers
%%
END_OF_TEXT

    if ( $document{'doctype'} eq 'book' ) {
      $preamble .= <<"END_OF_TEXT";
\\renewcommand{\\chaptermark}[1]{\\markboth{#1}{}}
END_OF_TEXT
    }

    $preamble .= <<"END_OF_TEXT";
\\renewcommand{\\sectionmark}[1]{\\markright{\\thesection\\ #1}}
\\lhead[\\fancyplain{}{\\sf{}}]{\\fancyplain{}{\\sf{}}}
\\rhead[\\fancyplain{}{\\sf{}}]{\\fancyplain{}{\\sf{}}}
$hlo_block
$hco_block
$hro_block
$hle_block
$hce_block
$hre_block
$flo_block
$fco_block
$fro_block
$fle_block
$fce_block
$fre_block
\\renewcommand{\\headrulewidth}{0pt}
\\renewcommand{\\footrulewidth}{0pt}
\\raggedbottom
\\setlength{\\voffset}{-0.25in}
\\setlength{\\fboxsep}{10pt}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # keystrokes
  #
  #     If there were any keystrokes in the document, define a special
  #     command for displaying them.
  #
  if ($count{'keystroke'}{'total'} > 0) {

    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% "keystroke" command
%%
\\newcommand{\\keystroke}[1]{\\setlength{\\fboxsep}{2pt}\\Ovalbox{\\scriptsize{#1}}\\setlength{\\fboxsep}{10pt}}

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # steps
  #
  #     If there were any steps in the document, define a special
  #     command for displaying them.
  #
  if ( $count{'step'}{'total'} > 0 ) {

    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% "step" command
%%
\\newcommand{\\step}[1]{\\Large\\Square\\normalsize \\hspace{4pt} {\\sc \\textbf{Step #1}} -- }

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # todo
  #
  #     If there were any todo items in the document, define a special
  #     command for displaying them.
  #
  if ( $count{'todo'}{'total'} > 0 ) {

    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% "todo" and "done" commands
%%
%% \\newcommand{\\todo}{\\Large\$\\Box\$\\normalsize \\hspace{0.1in}}
\\newcommand{\\todo}{\\Large\\Square\\normalsize \\hspace{4pt}}
\\newcommand{\\done}{\\Large\\XBox\\normalsize \\hspace{4pt}}

END_OF_TEXT

  }

  #-----------------------------------------------------------------
  # myheadings security header and footer
  #
  #     The 'myheadings' style of headers and footers is used for the
  #     titlepage.
  #
  my $classification = escape_latex( $document{'classification'} );
  my $handling       = escape_latex( join('/', @{$document{'handling_caveat'}}) );

  # documents with classified markings...
  #
  if ($classification) {

    my $markings = $EMPTY_STRING;
    if ($classification and $handling) {
      $markings = "$classification//$handling";
    }
    else {
      $markings = "$classification";
    }

    my $draft_copy = $EMPTY_STRING;
    if ($option{'draft'}) {
      $draft_copy = 'DRAFT COPY';
    }

    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% myheadings security header and footer
%%
\\makeatletter
\\renewcommand\\ps\@myheadings\{\%
  \\renewcommand\\\@oddhead{{\\sf{$draft_copy}} \\hfil {\\sf\\bfseries\\large{$markings}} \\hfil {\\sf{}}}\%
  \\renewcommand\\\@oddfoot{\\hfil {\\sf\\bfseries\\large{$markings}} \\hfil}\%
\}
\\makeatother

END_OF_TEXT
  }

  # documents with custom headers and footers...
  #
  elsif ($custom_headfoot) {

    #-----------------------------------------------------------------
    # List possible header/footer elements
    #
    my @custom_headfoot_elements = (
        'header_center', 'header_center_odd', 'header_center_even',
        'footer_center', 'footer_center_odd', 'footer_center_even',
    );

    #-----------------------------------------------------------------
    # Construct a hash of header/footer strings.
    #
    my %headfoot = ();
    foreach my $element (@custom_headfoot_elements) {
      my @components = ();
      foreach my $struct (@{ $document{$element} }) {
	my $text = $struct->{'text'};    # arbitrary text
	$text = escape_latex($text);

	next if not $text;

	my $size   = $struct->{'size'};    # see @font_sizes
	my $weight = $struct->{'weight'};  # see @font_weights
	my $shape  = $struct->{'shape'};   # see @font_shapes
	my $family = $struct->{'family'};  # see @font_families
	my $string = "{" . $text . "}";

	$string = "\\$size"      . $string if $size;
	$string = "\\normalfont" . $string if $shape  eq 'normal';
	$string = "\\itshape"    . $string if $shape  eq 'italic';
	$string = "\\slshape"    . $string if $shape  eq 'slanted';
	$string = "\\scshape"    . $string if $shape  eq 'smallcaps';
	$string = "\\bfseries"   . $string if $weight eq 'bold';
	$string = "\\bfseries"   . $string if $weight eq 'bold_extended';
	$string = "\\mdseries"   . $string if $weight eq 'medium';
	$string = "\\rmfamily"   . $string if $family eq 'roman';
	$string = "\\sffamily"   . $string if $family eq 'serif';
	$string = "\\ttfamily"   . $string if $family eq 'typewriter';

	push @components, $string;

      }
      $headfoot{$element} = join(' \\\\ ', @components);
    }

    my $hc = $headfoot{'header_center_odd'} || $headfoot{'header_center_even'} || $headfoot{'header_center'};

    my $hc_head_block = wrap("\\renewcommand\\\@oddhead{\\sf{} \\hfil $hc \\hfil \\sf{}}\%");
    my $hc_foot_block = wrap("\\renewcommand\\\@oddfoot{\\sf{} \\hfil $hc \\hfil \\sf{}}\%");

    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% header and footer
%%
\\makeatletter
\\renewcommand\\ps\@myheadings\{\%
$hc_head_block
$hc_foot_block
\}
\\makeatother

END_OF_TEXT
  }

  #-----------------------------------------------------------------
  # chapter header and footer
  #
  #     If this is a book, the normal header and footer need to appear
  #     on the first page of each chapter.  Normally, the first page
  #     has a 'plain' pagestyle.  Here we redefine it to by
  #     'myheadings.'
  #
  if ($document{'doctype'} eq 'book') {
    $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% chapter header and footer
%%
\\makeatletter
\\renewcommand\\chapter{\\if\@openright\\cleardoublepage\\else\\clearpage\\fi
                    \\thispagestyle{fancy}\%
                    \\global\\\@topnum\\z\@
                    \\\@afterindentfalse
                    \\secdef\\\@chapter\\\@schapter}
\\makeatother

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # Assemble latex glossary entries
  #
  $preamble .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% glossary entries
%%
END_OF_TEXT

  foreach my $term ( sort keys %{ $data{'glossary'} } ) {

    foreach my $alt ( sort keys %{ $data{'glossary'}{$term} } ) {

      my $entry       = $data{'glossary'}{$term}{$alt};
      my $latex_term  = $term;
      # my $latex_term  = escape_latex($term);
      my $latex_entry = escape_latex($entry);
      my $text        = <<"END_OF_TEXT";
\\newglossaryentry{$latex_term:$alt}{name={$latex_term},description={$latex_entry}}
END_OF_TEXT

      $preamble .= wrap($text) . "\n";

    }

  }

  #-------------------------------------------------------------------
  # Begin the document
  #
  my $begin_document = <<"END_OF_TEXT";
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                  %%
%%                      BEGINNING OF DOCUMENT                       %%
%%                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\\begin{document}

END_OF_TEXT

  #-------------------------------------------------------------------
  # graphics file extensions
  #
  #     If this document includes image, declare available graphics
  #     extensions.
  #
  if ($count{'image'}{'total'} > 0) {

    $begin_document .= <<"END_OF_TEXT";
\\DeclareGraphicsExtensions{.jpg,.pdf,.mps,.png,.gif}

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # frontmatter
  #
  #     If this is a book, add a 'frontmatter' declaration.
  #
  if ($document{'doctype'} eq 'book') {

    $begin_document .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% frontmatter
%%
\\frontmatter

END_OF_TEXT

  }

  push @latex_head, $begin_comment, $preamble, $begin_document;
}

######################################################################

sub assemble_html_head_array {

  printdebug("assemble_html_head_array") if $DEBUGGING;

  my $headstart = <<"END_OF_TEXT";
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/1999/xhtml" xml:lang="en">

<!-- ============================================================= -->
<!--                                                               -->
<!--   This HTML document was pulished using the publish.pl        -->
<!--   Perl script that takes plain (but structured) text and      -->
<!--   converts it to a set of HTML files.  publish.pl together    -->
<!--   with PDFLaTeX can produce PDF output for nicely formatted   -->
<!--   printed pages.                                              -->
<!--                                                               -->
<!--   For more information write to me:                           -->
<!--                                                               -->
<!--     Don Johnson                                               -->
<!--     drj826\@acm.org                                            -->
<!--                                                               -->
<!-- ============================================================= -->

<html>
<head>

END_OF_TEXT

  my $title = <<"END_OF_TEXT";
<title>$document{'title'}</title>

END_OF_TEXT

  my $script = <<"END_OF_TEXT";
<script type="text/javascript" src="popimage.js"></script>
<script type="text/javascript" src="treetable.js"></script>

<script type="text/javascript">
<!--
function goToA(target) {window.location.hash=target}
//-->
</script>

END_OF_TEXT

  #-------------------------------------------------------------------
  #     !!! BUG HERE !!!
  #
  #     In the absence of header/footer information, headers/footers
  #     should NOT be rendered (but they are).  Certain style
  #     parameters like header and footer height must be conditional
  #     on the presence/absence of header/footer/ info.
  #
  my $head_height = '0px';
  if (
      $document{'header_left'}
      or
      $document{'header_center'}
      or
      $document{'header_right'}
     )
    {
      $head_height = '16px';
    }

  my $foot_height = '0';
  if (
      $document{'footer_left'}
      or
      $document{'footer_center'}
      or
      $document{'footer_right'}
     )
    {
      $foot_height = '64px';
    }

  my $content_height = 100 - $head_height - $foot_height;

  my $left_width     = '110px';
  my $body_width     = '86%';
  my $scroll_width   = '4%';

  my $style = <<"END_OF_TEXT";
<style type="text/css">
html { height: 100%; max-height: 100%; padding: 0; margin: 0; border: 0; /* hide overflow: hidden from IE5/Mac */ /* \*/ overflow: hidden; /* */ }
body { height: 100%; max-height: 100%; overflow: hidden; margin: 0; border: 0; padding: 0; font-size: 10pt; font-family: verdana, sans-serif; }
#content { display: block; top: $head_height; bottom: -$foot_height; max-height: 100%; overflow: auto; padding-top: 20px; padding-bottom: 0; padding-left: 100px; margin-left: 20px; padding-right: 20px; position: relative; z-index: 3; }
#head { position: fixed; top: 0; right: 18px; display: block; width: 100%; height: $head_height; background-color: #DDDDDD; color: #888888; z-index: 4; }
#foot { position: fixed; bottom: -1px; right: 18px; display: block; width: 100%; height: $foot_height; background-color: #DDDDDD; color: #888888; z-index: 4; }
#left { position: fixed; left: 0; top: 0; height: 100%; width: $left_width; background-color: #DDDDDD; z-index: 5; }
* html #head, * html #foot, * html #left { position: absolute; }
#pad1 { display: block; width: 118px; height: 20px; float: left; }
#pad3 { display: block; width: 118px; height: 60px; float: left; }
.pad2 { display: block; width: 100px; height: 20px; }
.pad4 { display: block; width: 100px; height: 10px; }
H1 { font-size: 16pt; }
H2 { font-size: 14pt; }
H3 { font-size: 12pt; }
H4 { font-size: 12pt; }
H5 { font-size: 12pt; }
H6 { font-size: 12pt; }
TD { font-size: 8pt; font-family: verdana, sans-serif; vertical-align: top; }
P.title { font-weight: bold; text-align: center; }
P.source { font-style: italic; margin-left: 30pt; }
PRE { margin-left: 20pt; margin-right: 20pt; }
A { text-decoration: none; }
TT { font-size: 11pt; }
UL { margin-left: 20pt; }
UL UL { margin-left: 10pt; }
UL UL UL { margin-left: 10pt; }
OL { margin-left: 20pt; }
OL OL { margin-left: 10pt; }
OL OL OL { margin-left: 10pt; }
LI { padding: 3px; }
DIV.trace { font-size: 8pt; padding-bottom: 4pt;}
.even { background-color: #ffffff; color: #000000; font-size: 8pt;}
.odd { background-color: #f0f0f0; color: #000000; font-size: 8pt;}
.header { background-color: #cccccc; color: #000000; font-size: 8pt;}
.critical { font-size: 8pt; background-color: #ff6666; padding: 4px;}
.high { font-size: 8pt; background-color: #ffaa66; padding: 4px;}
.routine { font-size: 8pt; background-color: #ffff66; padding: 4px;}
.low { font-size: 8pt; background-color: #dddddd; padding: 4px;}
.green { font-size: 8pt; background-color: #66ff66; padding: 4px;}
.yellow { font-size: 8pt; background-color: #ffff66; padding: 4px;}
.orange { font-size: 8pt; background-color: #ffaa66; padding: 4px;}
.red { font-size: 8pt; background-color: #ff6666; padding: 4px;}
.grey { font-size: 8pt; background-color: #dddddd; padding: 4px;}
.req_label { font-size: 8pt; padding: 0px;}
.req_info { font-size: 8pt; padding: 0px; color: #888888;}
.info { font-size: 8pt; padding: 0px; color: #888888;}
.req_header { font-size: 8pt; color: #666666;}
.req_solution { font-size: 8pt;}
.req_allocation { font-size: 8pt;}
.req_assignment { font-size: 8pt;}
.req_individual { font-size: 8pt;}
.req_parent { font-size: 8pt;}
.req_child { font-size: 8pt;}
.req_title { font-weight: bold; }
.req_critical { font-size: 8pt; background-color: #ff6666; padding: 4px;}
.req_high { font-size: 8pt; background-color: #ffaa66; padding: 4px;}
.req_routine { font-size: 8pt; background-color: #ffff66; padding: 4px;}
.req_low { font-size: 8pt; background-color: #dddddd; padding: 4px;}
.req_grey { font-size: 8pt; background-color: #dddddd; padding: 4px;}
.req_gray { font-size: 8pt; background-color: #dddddd; padding: 4px;}
.req_green { font-size: 8pt; background-color: #66ff66; padding: 4px;}
.req_yellow { font-size: 8pt; background-color: #ffff66; padding: 4px;}
.req_red { font-size: 8pt; background-color: #ff6666; padding: 4px;}
.req_header { background-color: #dddddd; color: #000000;}
.req_even { background-color: #ffffff; color: #000000;}
.req_odd { background-color: #f6f6f6; color: #000000;}
.sol_label { font-size: 8pt; padding: 0px;}
.sol_info { font-size: 8pt; padding: 0px; color: #888888;}
.sol_header { font-size: 8pt; color: #666666;}
.sol_solution { font-size: 8pt;}
.sol_allocation { font-size: 8pt;}
.sol_assignment { font-size: 8pt;}
.sol_individual { font-size: 8pt;}
.sol_parent { font-size: 8pt;}
.sol_child { font-size: 8pt;}
.sol_version { font-size: 8pt;}
.sol_cost { font-size: 8pt;}
.sol_problem { font-size: 8pt;}
.sol_test { font-size: 8pt;}
.sol_title { font-weight: bold; }
.sol_critical { font-size: 8pt; background-color: #ff6666; padding: 4px;}
.sol_high { font-size: 8pt; background-color: #ffaa66; padding: 4px;}
.sol_routine { font-size: 8pt; background-color: #ffff66; padding: 4px;}
.sol_low { font-size: 8pt; background-color: #dddddd; padding: 4px;}
.sol_grey { font-size: 8pt; background-color: #dddddd; padding: 4px;}
.sol_gray { font-size: 8pt; background-color: #dddddd; padding: 4px;}
.sol_green { font-size: 8pt; background-color: #66ff66; padding: 4px;}
.sol_yellow { font-size: 8pt; background-color: #ffff66; padding: 4px;}
.sol_red { font-size: 8pt; background-color: #ff6666; padding: 4px;}
.sol_header { background-color: #dddddd; color: #000000;}
.sol_even { background-color: #ffffff; color: #000000;}
.sol_odd { background-color: #f6f6f6; color: #000000;}
DIV.title { font-size: 22pt; font-weight: bold; text-align: center; margin-top: 10px; margin-bottom: 10px; }
DIV.subtitle { font-size: 12pt; text-align: center; margin-top: 10px; margin-bottom: 10px; }
DIV.preamble { font-size: 8pt; background-color: #ffffff; margin: 10pt 20pt 10pt 20pt; padding: 10pt; border-style: solid; border-width: 1px; border-color: #cccccc; }
DIV.copyright { font-size: 10pt; text-align: center; margin-bottom: 10px; }
DIV.slide { background-color: #fdfdaa; margin: 10pt 20pt 10pt 20pt; padding: 10pt; border-style: solid; border-width: 1px; border-color: #cccccc; }
DIV.sidebar { float: right; width: 40%; font-size: 8pt; background-color: #eeeeee; margin: 10pt 20pt 10pt 20pt; padding: 5pt; border-style: solid; border-width: 1px; border-color: #cccccc; margin-left: 0pt; margin-right: 0pt; }
DIV.quotation { margin-left: 20pt; margin-right: 20pt; }
DIV.problem { background-color: #ffffff; }
DIV.solution { background-color: #ffffff; }
DIV.allocation { background-color: #ffffff; }
DIV.assignment { background-color: #ffffff; }
DIV.test { background-color: #ffffff; }
DIV.task { background-color: #ffffff; }
DIV.result { background-color: #ffffff; }
DIV.role { background-color: #ffffff; }
DIV.demo { background-color: #ddddff; margin: 10pt 20pt 10pt 20pt; padding: 10pt; border-style: solid; border-width: 1px; border-color: #cccccc; }
DIV.exercise { background-color: #ffffff; margin: 10pt 20pt 10pt 20pt; padding: 10pt; border-style: solid; border-width: 1px; border-color: #cccccc; }
DIV.listing { background-color: #ddffdd; margin: 10pt 20pt 10pt 20pt; padding: 10pt; border-style: solid; border-width: 1px; border-color: #cccccc; }
DIV.todo { background-color: #ffcccc; margin: 10pt 20pt 10pt 20pt; padding: 10pt; border-style: solid; border-width: 1px; border-color: #cccccc; font-size: 8pt; }
DIV.keypoints { background-color: #eeeeee; margin: 10pt 20pt 10pt 20pt; padding: 10pt; border-style: solid; border-width: 1px; border-color: #cccccc; }
SPAN.indent { margin-left: 40pt; font-size: 8pt; }
SPAN.keystroke { border-style: outset; border-color: #666666; border-width: 1px; background-color: #eeeeee; color: #444444; padding-top: 0px; padding-bottom: 0px; padding-left: 2px; padding-right: 2px; font-family: courier; font-size: 8pt; }
SPAN.recent { border-style: outset; border-color: #666666; border-width: 1px; background-color: #eeee00; color: #444444; padding-top: 0px; padding-bottom: 0px; padding-left: 2px; padding-right: 2px; }
.footnote { background-color: #eeeeee; padding: 5pt; font-size: 8pt; border-style: solid; border-width: 1px; border-color: #cccccc; }
.metadata { background-color: #ffffff; padding: 5pt; font-size: 8pt; border-style: solid; border-width: 1px; border-color: #cccccc; }
.attachment { background-color: #FFFFFF; padding: 4px; font-size: 8pt; }
P.num { color: #aaaaaa; text-align: right; font-size: 8pt; margin-left: 0pt; margin-right: 0pt; margin-top: 0pt; margin-bottom: 0pt; }
TABLE.treetable { padding: 4px; }
.treetable { font-family: verdana, sans-serif; font-size: 8pt; }
.treetable th { background:#ddd; margin:1px; padding: 0 5px; font-weight:normal; }
.treetable td { margin:1px; padding: 0 5px; border-bottom: #dddddd solid 1px; border-top: none; border-left: none; border-right: none; }
.treetable td.number { text-align:center; }
.treetable a { text-decoration: none; }
.button { border: none; margin: 0 4px 0 0 ; }
</style>

END_OF_TEXT

  my $headend = <<"END_OF_TEXT";
</head>
<body>

END_OF_TEXT

  push @{ $html{'head'} }, $headstart, $title, $script, $style, $headend;

}

######################################################################

sub assemble_html_nav_array {

  printdebug("assemble_html_nav_array") if $DEBUGGING;

  #-------------------------------------------------------------------
  # Determine HTML header and footer components
  #
  #     !!! BUG HERE !!!
  #
  #     In the absence of header/footer information, no header/footer
  #     should be rendered.
  #
  my $logo_image_small = $document{'logo_image_small'} || $EMPTY_STRING;
  my %headfoot = ();
  my @headfoot_blocks = (
        'header_left',  'header_center', 'header_right',
        'footer_left',  'footer_center', 'footer_right',
  );

  foreach my $headfoot_block (@headfoot_blocks) {

    my $normal_block = $headfoot_block;
    my $odd_block    = $headfoot_block . "_odd";
    my $even_block   = $headfoot_block . "_even";

    if ( $document{$normal_block} ) {
      foreach my $hashref (@{ $document{$normal_block} }) {
	my $string = $hashref->{'text'};
	$string = escape_html($string);
	$headfoot{$headfoot_block} .= $string;
      }
    }

    elsif ( $document{$odd_block}) {
      foreach my $hashref (@{ $document{$odd_block} }) {
	my $string = $hashref->{'text'};
	$string = escape_html($string);
	$headfoot{$headfoot_block} .= $string;
      }
    }

    elsif ( $document{$even_block} ) {
      foreach my $hashref (@{ $document{$even_block} }) {
	my $string = $hashref->{'text'};
	$string = escape_html($string);
	$headfoot{$headfoot_block} .= $string;
      }
    }

  }

  my $left_head   = wrap("<td align=\"left\">$headfoot{'header_left'}</td>");
  my $center_head = wrap("<td align=\"center\"><b>$headfoot{'header_center'}</b></td>");
  my $right_head  = wrap("<td align=\"right\">$headfoot{'header_right'}</td>");

  my $header = <<"END_OF_TEXT";
<!-- header -->
<div id="head">
<div id="pad1"></div>
<div align="center">
<table width="80%" border="0" cellpadding="0" cellspacing="0">
<tr>
$left_head
$center_head
$right_head
</tr>
</table>
</div>
</div>

END_OF_TEXT

  my $left_foot   = wrap("<td align=\"left\">$headfoot{'footer_left'}</td>");
  my $center_foot = wrap("<td align=\"center\">$headfoot{'footer_center'}</td>");
  my $right_foot  = wrap("<td align=\"right\">$headfoot{'footer_right'}</td>");

  my $footer = <<"END_OF_TEXT";
<!-- footer -->
<div id="foot">
<div id="pad3"></div>
<div align="center">
<table width="80%" border="0" cellpadding="0" cellspacing="0">
<tr>
$left_foot
$center_foot
$right_foot
</tr>
</table>
</div>
</div>

END_OF_TEXT

  my $navstart = <<"END_OF_TEXT";
<!-- navigation -->
<div id="left">
<div class="pad4"></div>
END_OF_TEXT

  if ($logo_image_small) {
    publish_image($logo_image_small);
    my $image_file = basename($logo_image_small);
    $navstart .= <<"END_OF_TEXT";
<div align="center">
<a href="../index.html">
<img src="images/$image_file" style="border:0px">
</a>
</div>
END_OF_TEXT
  }

  $navstart .= <<"END_OF_TEXT";
<table border="0" cellpadding="4" cellspacing="4">

END_OF_TEXT

  #-------------------------------------------------------------------
  # Front Matter Navigation
  #
  #     - Contents
  #     - Tables
  #     - Figures
  #     - Attachments
  #     - Listings
  #     - Exercises
  #     - Demos
  #     - Slides
  #     - Sidebars
  #     - Quotations
  #     - Footnotes
  #     - To Do
  #     - Glossary
  #     - Acronyms
  #     - Sources
  #     - Changelog
  #
  my $front_nav = <<"END_OF_TEXT";
<tr>
<td>
END_OF_TEXT

  my $document_page = '';
  if (defined $html{'body'}{'1'}) {
    $document_page = "$output_file-1.html";
  } else {
    $document_page = "$output_file-DEFAULT.html";
  }

  if (    $count{'section'}{'total'}    > 0
       or $count{'update'}{'total'}     > 0
       or $count{'revenv'}{'total'}     > 0
       or $count{'table'}{'total'}      > 0
       or $count{'figure'}{'total'}     > 0
       or $count{'attachment'}{'total'} > 0
       or $count{'listing'}{'total'}    > 0
       or $count{'exercise'}{'total'}   > 0
       or $count{'demo'}{'total'}       > 0
       or $count{'slide'}{'total'}      > 0
       or $count{'sidebar'}{'total'}    > 0
       or $count{'quotation'}{'total'}  > 0
       or $count{'footnote'}{'total'}   > 0
       or $count{'todo'}{'total'}       > 0
       or $count{'acronym'}{'total'}    > 0
       or $count{'glossary'}{'total'}   > 0
       or $count{'source'}{'total'}     > 0
       or $count{'changelog'}{'total'}  > 0
       or $count{'problem'}{'total'}    > 0
       or $count{'solution'}{'total'}   > 0
       or $count{'test'}{'total'}       > 0
       or $count{'task'}{'total'}       > 0
       or $count{'result'}{'total'}     > 0
       or $count{'allocation'}{'total'} > 0
       or $count{'assignment'}{'total'} > 0
     ) {
    $front_nav .= <<"END_OF_TEXT";
<a href="$document_page"><b>Document</b></a><br/>
END_OF_TEXT
  }

  if ( $count{'section'}{'total'} > 0 ) {
    $front_nav .= <<"END_OF_TEXT";
- <a href="$html_toc_file">Contents</a><br/>
END_OF_TEXT
  }

  if ( $count{'update'}{'total'} > 0 and $option{'use_svn'} ) {
    $front_nav .= <<"END_OF_TEXT";
- <a href="$html_updates_file">Updates</a><br/>
END_OF_TEXT
  }

  if ( $count{'revenv'}{'total'} > 0 ) {
    $front_nav .= <<"END_OF_TEXT";
- <a href="$html_revisions_file">Revisions</a><br/>
END_OF_TEXT
  }

  if ( $count{'table'}{'total'} > 0 ) {
    $front_nav .= <<"END_OF_TEXT";
- <a href="$html_table_index_file">Tables</a><br/>
END_OF_TEXT
  }

  if ( $count{'figure'}{'total'} > 0 ) {
    $front_nav .= <<"END_OF_TEXT";
- <a href="$html_figure_index_file">Figures</a><br/>
END_OF_TEXT
  }

  if ( $count{'attachment'}{'total'} > 0 ) {
    $front_nav .= <<"END_OF_TEXT";
- <a href="$html_attachment_index_file">Attachments</a><br/>
END_OF_TEXT
  }

  if ( $count{'listing'}{'total'} > 0 ) {
    $front_nav .= <<"END_OF_TEXT";
- <a href="$html_listing_index_file">Listings</a><br/>
END_OF_TEXT
  }

  if ( $count{'exercise'}{'total'} > 0 ) {
    $front_nav .= <<"END_OF_TEXT";
- <a href="$html_exercise_index_file">Exercises</a><br/>
END_OF_TEXT
  }

  if ( $count{'demo'}{'total'} > 0 ) {
    $front_nav .= <<"END_OF_TEXT";
- <a href="$html_demo_index_file">Demos</a><br/>
END_OF_TEXT
  }

  if ( $count{'slide'}{'total'} > 0 ) {
    $front_nav .= <<"END_OF_TEXT";
- <a href="$html_slide_index_file">Slides</a><br/>
END_OF_TEXT
  }

  if ( $count{'sidebar'}{'total'} > 0 ) {
    $front_nav .= <<"END_OF_TEXT";
- <a href="$html_sidebar_index_file">Sidebars</a><br/>
END_OF_TEXT
  }

  if ( $count{'quotation'}{'total'} > 0 ) {
    $front_nav .= <<"END_OF_TEXT";
- <a href="$html_quotation_index_file">Quotations</a><br/>
END_OF_TEXT
  }

  if ( $count{'footnote'}{'total'} > 0 ) {
    $front_nav .= <<"END_OF_TEXT";
- <a href="$html_footnote_index_file">Footnotes</a><br/>
END_OF_TEXT
  }

  if ( $count{'todo'}{'total'} > 0 ) {
    $front_nav .= <<"END_OF_TEXT";
- <a href="$html_todo_index_file">To Do</a><br/>
END_OF_TEXT
  }

  if ( $count{'acronym'}{'total'} > 0 ) {
    $front_nav .= <<"END_OF_TEXT";
- <a href="$html_acronym_file">Acronyms</a><br/>
END_OF_TEXT
  }

  if ( $count{'glossary'}{'total'} > 0 ) {
    $front_nav .= <<"END_OF_TEXT";
- <a href="$html_glossary_file">Glossary</a><br/>
END_OF_TEXT
  }

  if ( $count{'source'}{'total'} > 0 ) {
    $front_nav .= <<"END_OF_TEXT";
- <a href="$html_source_index_file">References</a><br/>
END_OF_TEXT
  }

  if ( $option{'changelog'} ) {
    $front_nav .= <<"END_OF_TEXT";
- <a href="$html_changelog_file">Changelog</a><br/>
END_OF_TEXT
  }

  if ( -e "$output_dir/$output_file.pdf" or $rendering{ pdf } ) {
    $front_nav .= <<"END_OF_TEXT";
- <a href="$output_file.pdf">PDF</a><br/>
END_OF_TEXT
  }

  $front_nav .= <<"END_OF_TEXT";
</td>
</tr>

END_OF_TEXT

  #-------------------------------------------------------------------
  # Problem Navigation
  #
  #     - Tree (small)
  #     - Tree (big)
  #     - Spreadsheet
  #     - Priorities
  #
  my $problem_nav = <<"END_OF_TEXT";
<tr>
<td>
<a href="$html_problem_index_file"><b>Requirements</b></a><br/>
<!--
<span style="font-size: 8pt;">
- <a href="$html_problem_tree_small_file">Tree</a> (<a href="$html_problem_tree_big_file">big</a>)<br/>
- <a href="$html_problem_spreadsheet_file">Spreadsheet</a><br/>
- <a href="$html_problem_priorities_file">Priorities</a><br/>
</span>
-->
</td>
</tr>

END_OF_TEXT

  #-------------------------------------------------------------------
  # Solution Navigation
  #
  #     - Tree (small)
  #     - Tree (big)
  #     - Spreadsheet
  #     - Priorities
  #
  my $solution_nav = <<"END_OF_TEXT";
<tr>
<td>
<a href="$html_solution_index_file"><b>Solutions</b></a><br/>
<!--
<span style="font-size: 8pt;">
- <a href="$html_solution_tree_small_file">Tree</a> (<a href="$html_solution_tree_big_file">big</a>)</a><br/>
- <a href="$html_solution_spreadsheet_file">Spreadsheet</a><br/>
- <a href="$html_solution_priorities_file">Priorities</a><br/>
</span>
-->
</td>
</tr>

END_OF_TEXT

  #-------------------------------------------------------------------
  # Allocation Navigation
  #
  #     - Tree (small)
  #     - Tree (big)
  #     - Spreadsheet
  #     - Priorities
  #
  my $allocation_nav = <<"END_OF_TEXT";
<tr>
<td>
<a href="$html_allocation_index_file"><b>Allocations</b></a><br/>
<!--
<span style="font-size: 8pt;">
- <a href="$html_allocation_tree_small_file">Tree</a> (<a href="$html_allocation_tree_big_file">big</a>)</a><br/>
- <a href="$html_allocation_spreadsheet_file">Spreadsheet</a><br/>
- <a href="$html_allocation_priorities_file">Priorities</a><br/>
</span>
-->
</td>
</tr>

END_OF_TEXT

  #-------------------------------------------------------------------
  # Assignment Navigation
  #
  #     - Tree (small)
  #     - Tree (big)
  #     - Spreadsheet
  #     - Priorities
  #
  my $assignment_nav = <<"END_OF_TEXT";
<tr>
<td>
<a href="$html_assignment_index_file"><b>Assignments</b></a><br/>
<!--
<span style="font-size: 8pt;">
- <a href="$html_assignment_tree_small_file">Tree</a> (<a href="$html_assignment_tree_big_file">big</a>)</a><br/>
- <a href="$html_assignment_spreadsheet_file">Spreadsheet</a><br/>
- <a href="$html_assignment_priorities_file">Priorities</a><br/>
</span>
-->
</td>
</tr>

END_OF_TEXT

  #-------------------------------------------------------------------
  # Role Navigation
  #
  #     - Tree (small)
  #     - Tree (big)
  #     - Spreadsheet
  #     - Priorities
  #
  my $role_nav = <<"END_OF_TEXT";
<tr>
<td>
<a href="$html_role_index_file"><b>Roles</b></a><br/>
<!--
<span style="font-size: 8pt;">
- <a href="$html_role_tree_small_file">Tree</a> (<a href="$html_role_tree_big_file">big</a>)</a><br/>
- <a href="$html_role_spreadsheet_file">Spreadsheet</a><br/>
- <a href="$html_role_priorities_file">Priorities</a><br/>
</span>
-->
</td>
</tr>

END_OF_TEXT

  #-------------------------------------------------------------------
  # Test Navigation
  #
  #     - Tree (small)
  #     - Tree (big)
  #     - Spreadsheet
  #     - Priorities
  #
  my $test_nav = <<"END_OF_TEXT";
<tr>
<td>
<a href="$html_test_index_file"><b>Tests</b></a><br/>
<!--
<span style="font-size: 8pt;">
- <a href="$html_test_tree_small_file">Tree</a> (<a href="$html_test_tree_big_file">big</a>)</a><br/>
- <a href="$html_test_spreadsheet_file">Spreadsheet</a><br/>
- <a href="$html_test_priorities_file">Priorities</a><br/>
</span>
-->
</td>
</tr>

END_OF_TEXT

  #-------------------------------------------------------------------
  # Task Navigation
  #
  #     - Tree (small)
  #     - Tree (big)
  #     - Spreadsheet
  #     - Priorities
  #
  my $task_nav = <<"END_OF_TEXT";
<tr>
<td>
<a href="$html_task_index_file"><b>Tasks</b></a><br/>
<!--
<span style="font-size: 8pt;">
- <a href="$html_task_tree_small_file">Tree</a> (<a href="$html_task_tree_big_file">big</a>)</a><br/>
- <a href="$html_task_spreadsheet_file">Spreadsheet</a><br/>
- <a href="$html_task_priorities_file">Priorities</a><br/>
</span>
-->
</td>
</tr>

END_OF_TEXT

  #-------------------------------------------------------------------
  # Result Navigation
  #
  #     - Tree (small)
  #     - Tree (big)
  #     - Spreadsheet
  #     - Priorities
  #
  my $result_nav = <<"END_OF_TEXT";
<tr>
<td>
<a href="$html_result_index_file"><b>Results</b></a><br/>
<!--
<span style="font-size: 8pt;">
- <a href="$html_result_tree_small_file">Tree</a> (<a href="$html_result_tree_big_file">big</a>)</a><br/>
- <a href="$html_result_spreadsheet_file">Spreadsheet</a><br/>
- <a href="$html_result_priorities_file">Priorities</a><br/>
</span>
-->
</td>
</tr>

END_OF_TEXT

  #-------------------------------------------------------------------
  # Version Info
  #
  my $version  = trim_whitespace($document{'version'});
  my $revision = trim_whitespace($document{'revision'});
  my $date     = trim_whitespace($document{'date'});
  my $modified = trim_whitespace($document{'modified'});

  my $errors   = 1 if scalar @LOG_ERRORS_FILE;
  my $warnings = 1 if scalar @LOG_WARNINGS_FILE;

  $version  = '<font color="#888888">v' . $version . '</font>';
  $revision = '<font color="#888888">r' . $revision . '</font>';
  $modified = '<a href="publish.changes.txt"><font color="red">CHANGES</font></a>'  if $modified;
  $errors   = '<a href="publish.errors.txt"><font color="red">ERRORS</font></a>'    if $errors;
  $warnings = '<a href="publish.warnings.txt"><font color="red">WARNINGS</font></a>' if $warnings;
  $date     = $1 if $date =~ /\((\w+,\s+\d+\s+\w+\s+\d+)\)/;
  $date     = '<font color="#888888">' . $date . '</font>';

  my $version_nav = <<"END_OF_TEXT";
<!-- begin version nav -->
<tr>
<td>
<div style="font-size: 8pt;" align="center">
END_OF_TEXT

  if ($document{'version'}) {
    $version_nav .= <<"END_OF_TEXT";
$version
</br>
END_OF_TEXT
  }

  if ($document{'revision'}) {
    $version_nav .= <<"END_OF_TEXT";
$revision
</br>
END_OF_TEXT
  }

  if ($document{'date'}) {
    $version_nav .= <<"END_OF_TEXT";
$date
</br></br>
END_OF_TEXT
  }

  if ($document{'modified'}) {
    $version_nav .= <<"END_OF_TEXT";
$modified
</br>
END_OF_TEXT
  }

  if (scalar @LOG_ERRORS_FILE) {
    $version_nav .= <<"END_OF_TEXT";
$errors
</br>
END_OF_TEXT
  }

  if (scalar @LOG_WARNINGS_FILE) {
    $version_nav .= <<"END_OF_TEXT";
$warnings
END_OF_TEXT
  }

$version_nav .= <<"END_OF_TEXT";
</div>
</td>
</tr>
<!-- end version nav -->

END_OF_TEXT

  #-------------------------------------------------------------------
  # End of Navigation Stuff
  #
  my $navend = <<"END_OF_TEXT";
</table>
</div>

END_OF_TEXT

  my $aref = $html{'nav'};

  push @{ $aref }, $header;
  push @{ $aref }, $footer;
  push @{ $aref }, $navstart;
  push @{ $aref }, $front_nav;
  push @{ $aref }, $problem_nav    if $count{'problem'}{'total'}    > 0;
  push @{ $aref }, $solution_nav   if $count{'solution'}{'total'}   > 0;
  push @{ $aref }, $allocation_nav if $count{'allocation'}{'total'} > 0;
  push @{ $aref }, $assignment_nav if $count{'assignment'}{'total'} > 0;
  push @{ $aref }, $role_nav       if $count{'role'}{'total'}       > 0;
  push @{ $aref }, $task_nav       if $count{'task'}{'total'}       > 0;
  push @{ $aref }, $test_nav       if $count{'test'}{'total'}       > 0;
  push @{ $aref }, $result_nav     if $count{'result'}{'total'}     > 0;
  push @{ $aref }, $version_nav;
  push @{ $aref }, $navend;

}

######################################################################

sub assemble_latex_nav_array {

  printdebug("assemble_latex_nav_array") if $DEBUGGING;

  push @latex_nav, <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% tables and lists
%%

END_OF_TEXT

  #-------------------------------------------------------------------
  # table of contents
  #
  if ($count{'section'}{'total'} > 0 and $option{'toc'}) {
    push @latex_nav, <<"END_OF_TEXT";
%% table of contents
\\tableofcontents

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # list of figures
  #
  if ($count{'figure'}{'total'} > 0 and $option{'lof'}) {
    push @latex_nav, <<"END_OF_TEXT";
%% list of figures
\\listoffigures

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # list of tables
  #
  if ($count{'table'}{'total'} > 0 and $option{'lot'}) {
    push @latex_nav, <<"END_OF_TEXT";
%% list of tables
\\listoftables

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # list of attachments
  #
  if ($count{'attachment'}{'total'} > 0 and $option{'loa'}) {
    push @latex_nav, <<"END_OF_TEXT";
%% list of attachements
\\listofattachments

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # list of listings
  #
  if ($count{'listing'}{'total'} > 0 and $option{'lolistings'}) {
    push @latex_nav, <<"END_OF_TEXT";
%% list of listings
\\listoflistings

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # list of exercises
  #
  if ($count{'exercise'}{'total'} > 0 and $option{'loexercises'}) {
    push @latex_nav, <<"END_OF_TEXT";
%% list of exercises
\\listofexercises

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # list of demonstrations
  #
  if ($count{'demo'}{'total'} > 0 and $option{'lodemos'}) {
    push @latex_nav, <<"END_OF_TEXT";
%% list of demonstrations
\\listofdemos

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # list of problems
  #
  if ($count{'problem'}{'total'} > 0 and $option{'loproblems'}) {
    push @latex_nav, <<"END_OF_TEXT";
%% list of problems
\\listofproblems

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # list of solutions
  #
  if ($count{'solution'}{'total'} > 0 and $option{'losolutions'}) {
    push @latex_nav, <<"END_OF_TEXT";
%% list of solutions
\\listofsolutions

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # list of allocations
  #
  if ($count{'allocation'}{'total'} > 0 and $option{'loallocations'}) {
    push @latex_nav, <<"END_OF_TEXT";
%% list of allocations
\\listofallocations

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # list of assignments
  #
  if ($count{'assignment'}{'total'} > 0 and $option{'loassignments'}) {
    push @latex_nav, <<"END_OF_TEXT";
%% list of assignments
\\listofassignments

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # list of roles
  #
  if ($count{'role'}{'total'} > 0 and $option{'loroles'}) {
    push @latex_nav, <<"END_OF_TEXT";
%% list of roles
\\listofroles

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # list of tasks
  #
  if ($count{'task'}{'total'} > 0 and $option{'lotasks'}) {
    push @latex_nav, <<"END_OF_TEXT";
%% list of tasks
\\listoftasks

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # list of tests
  #
  if ($count{'test'}{'total'} > 0 and $option{'lotests'}) {
    push @latex_nav, <<"END_OF_TEXT";
%% list of tests
\\listoftests

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # list of results
  #
  if ($count{'result'}{'total'} > 0 and $option{'loresults'}) {
    push @latex_nav, <<"END_OF_TEXT";
%% list of results
\\listofresults

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # 8pt skip between block paragraphs
  #
  push @latex_nav, <<"END_OF_TEXT";
\\setlength{\\parskip}{8pt}

END_OF_TEXT

  #-------------------------------------------------------------------
  # if this is a book, add a 'mainmatter' declaration
  #
  if ($document{'doctype'} eq 'book') {
    push @latex_nav, <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% book mainmatter
%%
\\mainmatter

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # if this is an article, put a pagebreak here to separate the table
  # of contents, and other lists from the main content
  #
  if ($document{'doctype'} eq 'article') {
    push @latex_nav, <<"END_OF_TEXT";
%% page break between frontmatter and main content
\\pagebreak

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # set the pagestyle back to "fancy" to get running headers and page
  # numbering at the top of the page
  #
  push @latex_nav, <<"END_OF_TEXT";
%% fancy pagestyle to get running headers and page numbering
\\pagestyle{fancy}

END_OF_TEXT

}

######################################################################

sub assemble_html_title_array {

  printdebug("assemble_html_title_array") if $DEBUGGING;

  my $title       = escape_html( $document{'title'} );
  my $subtitle    = escape_html( $document{'subtitle'} ) || $EMPTY_STRING;

  my $titlestring = <<"END_OF_TEXT";
<!-- title -->
<div id="content">
<div class="pad2"></div>
<div class="title">$title</div>
<div class="subtitle">$subtitle</div>

END_OF_TEXT

  push @{ $html{'title'} }, $titlestring;
}

######################################################################

sub assemble_latex_title_array {

  printdebug("assemble_latex_title_array") if $DEBUGGING;

  #-------------------------------------------------------------------
  # title page
  #
  #     Only render a title or title page if there is actually a
  #     document title and a title page has been requested (which
  #     happens to be the default).
  #
  if ($document{'title'} and $option{'titlepage'}) {

    my $title             = escape_latex( $document{'title'}          );
    my $organization      = escape_latex( $document{'organization'}   ) || $EMPTY_STRING;
    my $subtitle          = escape_latex( $document{'subtitle'}       ) || $EMPTY_STRING;
    my $version           = escape_latex( $document{'version'}        ) || $EMPTY_STRING;
    my $classification    = escape_latex( $document{'classification'} ) || $EMPTY_STRING;
    my $handling          = escape_latex( join('/', @{$document{'handling_caveat'}}) );
    my $classified_by     = escape_latex( $document{'classified_by'}  ) || $EMPTY_STRING;
    my $classif_reason    = escape_latex( $document{'classif_reason'} ) || $EMPTY_STRING;
    my $declassify_on     = escape_latex( $document{'declassify_on'}  ) || $EMPTY_STRING;
    my $logo_image_left   = $document{'logo_image_left'} || $EMPTY_STRING;
    my $logo_image_center = $document{'logo_image_center'} || $EMPTY_STRING;
    my $logo_image_right  = $document{'logo_image_right'} || $EMPTY_STRING;
    my $author            = $EMPTY_STRING;
    my @authors           = @{ $document{'author'} };
    my $author_count      = scalar(@authors);
    my $original_date     = $document{'date'} || '\today';
    my $modified_date     = '';
    my $original_revision = $document{'revision'} || $EMPTY_STRING;
    my $modified_revision = '';

    #-----------------------------------------------------------------
    # Determine whether document has custom headers/footers
    #
    my $custom_headfoot = '';
    my @custom_headfoot_elements = (
        'header_left',   'header_left_odd',   'header_left_even',
        'header_center', 'header_center_odd', 'header_center_even',
	'header_right',  'header_right_odd',  'header_right_even',
        'footer_left',   'footer_left_odd',   'footer_left_even',
        'footer_center', 'footer_center_odd', 'footer_center_even',
	'footer_right',  'footer_right_odd',  'footer_right_even',
    );

    foreach my $element (@custom_headfoot_elements) {
      if ($document{$element}) {
	$custom_headfoot = 1;
      }
    }

    #-----------------------------------------------------------------
    # date
    #
    if ( $original_date =~ /\((\w+,\s+\d+\s+\w+\s+\d+)\)/ ) {
      $modified_date = escape_latex( $1 );
    }
    else {
      $modified_date = escape_latex( $original_date );
    }

    #-----------------------------------------------------------------
    # revision
    #
    if ( $original_revision =~ /\$Revision:\s*(.*?)\s*\$/ ) {
      $modified_revision = "Revision $1";
    } else {
      $modified_revision = "Revision $original_revision";
    }

    #-----------------------------------------------------------------
    # single author
    #
    #     Larry
    #
    if ($author_count == 1) {
      $author = $authors[0];
      $author = escape_latex($author);
    }

    #-----------------------------------------------------------------
    # two authors
    #
    #     Larry and Curly
    #
    elsif ($author_count == 2) {
      $author = join(' and ', @authors);
      $author = escape_latex($author);
    }

    #-----------------------------------------------------------------
    # three or more authors
    #
    #     Larry, Curly and Mo
    #
    elsif ($author_count > 2) {
      my $last_author   = pop(@authors);
      my $first_authors = join(', ', @authors);
      $author = $first_authors . ' and ' . $last_author;
      $author = escape_latex($author);
    }

    #-----------------------------------------------------------------
    # pagestyle
    #
    #     If there are no security markings, the pagestyle should be
    #     empty.  Use the myheadings pagestyle to add security
    #     markings.
    #
    my $pagestyle = 'empty';
    if ($classification or $custom_headfoot) {
      $pagestyle = 'myheadings';
    }

    #-----------------------------------------------------------------
    # begin title page
    #
    push @latex_title, <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% title page
%%
\\newcommand\\HRule{\\noindent\\rule{\\linewidth}{1.5pt}}
\\begin{titlepage}
\\thispagestyle{$pagestyle}

END_OF_TEXT

    #-----------------------------------------------------------------
    # logo images
    #
    if ($logo_image_left or $logo_image_center or $logo_image_right) {

      my $left_cell   = '';
      my $center_cell = '';
      my $right_cell  = '';

      if ($logo_image_left) {
	if (not -f $logo_image_left) {
	  printwarning("left title page logo image file not found: $logo_image_left");
	} else {
	  publish_image($logo_image_left);
	  my $image_file = (split('/', $logo_image_left))[-1];
	  $left_cell = "\\includegraphics[height=1.25in]{images/$image_file}";
	}
      }

      if ($logo_image_center) {
	if (not -f $logo_image_center) {
	  printwarning("center title page logo image file not found: $logo_image_center");
	} else {
	  publish_image($logo_image_center);
	  my $image_file = (split('/', $logo_image_center))[-1];
	  $center_cell = "\\includegraphics[height=1.25in]{images/$image_file}";
	}
      }

      if ($logo_image_right) {
	if (not -f $logo_image_right) {
	  printwarning("right title page logo image file not found: $logo_image_right");
	} else {
	  publish_image($logo_image_right);
	  my $image_file = (split('/', $logo_image_right))[-1];
	  $right_cell = "\\includegraphics[height=1.25in]{images/$image_file}";
	}
      }

      if ($left_cell or $center_cell or $right_cell) {
	push @latex_title, <<"END_OF_TEXT";
\\vspace*{0.5in}

%% logo images
\\begin{tabularx}{\\linewidth}{l>{\\centering}Xr}
$left_cell
&
$center_cell
&
$right_cell
\\\\
\\end{tabularx}

END_OF_TEXT
      }
    }

    #-----------------------------------------------------------------
    # title
    #
    push @latex_title, <<"END_OF_TEXT";
%% title
\\vspace*{\\stretch{1}}
\\HRule
\\begin{flushright}
  \\Huge $title
\\end{flushright}
\\HRule
\\vspace*{\\stretch{1}}

END_OF_TEXT

    #-----------------------------------------------------------------
    # subtitle
    #
    if ($subtitle) {
      push @latex_title, <<"END_OF_TEXT";
%% subtitle
\\begin{flushright}
  \\LARGE $subtitle
\\end{flushright}

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # vertical space
    #
    push @latex_title, <<"END_OF_TEXT";
%% vertical space
\\vspace*{\\stretch{2}}

END_OF_TEXT

    #-----------------------------------------------------------------
    # version
    #
    if ($version) {
      push @latex_title, <<"END_OF_TEXT";
%% version
\\begin{center}
  \\normalsize Version $version
\\end{center}

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # author
    #
    if ($author) {
      push @latex_title, <<"END_OF_TEXT";
%% author
\\begin{center}
  \\normalsize By $author
\\end{center}

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # organization
    #
    if ($organization) {
      push @latex_title, <<"END_OF_TEXT";
%% organization
\\begin{center}
  \\normalsize $organization
\\end{center}

END_OF_TEXT

    #-----------------------------------------------------------------
    # revision
    #
    if ($modified_revision and not $version) {
      push @latex_title, <<"END_OF_TEXT";
%% revision
\\begin{center}
  \\normalsize $modified_revision
\\end{center}

END_OF_TEXT

    }

    #-----------------------------------------------------------------
    # date
    #
    push @latex_title, <<"END_OF_TEXT";
%% date
\\begin{center}
  \\normalsize $modified_date
\\end{center}

END_OF_TEXT

    }

    #-----------------------------------------------------------------
    # classification instructions
    #
    if ($classification and ($classification !~ /unclassified/i)) {
      push @latex_title, <<"END_OF_TEXT";
%% classification instructions
{\\sf\\footnotesize{Classified By: $classified_by \\\\ Reason: $classif_reason \\\\ Declassify On: $declassify_on}}

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # end title page
    #
    push @latex_title, <<"END_OF_TEXT";
%% end of title page
\\end{titlepage}

END_OF_TEXT

  }
}

######################################################################

sub assemble_latex_glossary_array {

  printdebug("assemble_latex_glossary_array") if $DEBUGGING;

  push @latex_glossary, <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% glossary entries
%%
END_OF_TEXT

  foreach my $term ( sort keys %{ $data{'glossary'} } ) {

    foreach my $alt ( sort keys %{ $data{'glossary'}{$term} } ) {

      my $entry       = $data{'glossary'}{$term}{$alt};

      print "term:  $term:$alt\n";

      my $latex_term  = $term;
      # my $latex_term  = escape_latex($term);
      my $latex_entry = escape_latex($entry);
      my $text        = <<"END_OF_TEXT";
\\newglossaryentry{$latex_term:$alt}{name={$latex_term},description={$latex_entry}}
END_OF_TEXT

      push @latex_glossary, wrap($text) . "\n";

    }
  }

}

######################################################################

sub assemble_latex_changelog_array {

  printdebug("assemble_latex_changelog_array") if $DEBUGGING;

  push @latex_changelog, <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% changelog
%%

END_OF_TEXT

  push @latex_changelog, wrap($text) . "\n\n";

}

######################################################################

sub assemble_html_foot_array {

  printdebug("assemble_html_foot_array") if $DEBUGGING;

  my $ending_elements = <<"END_OF_TEXT";
<div class="pad2"></div>
<div class="pad2"></div>
<div class="pad2"></div>
<div class="pad2"></div>
<div class="pad2"></div>
</div>
</body>
</html>

END_OF_TEXT

  push @{ $html{'foot'} }, $ending_elements;

}

######################################################################

sub assemble_latex_foot_array {

  printdebug("assemble_latex_foot_array") if $DEBUGGING;

  my $ending_elements = $EMPTY_STRING;

  #-------------------------------------------------------------------
  # if this is a book, add a 'backmatter' declaration
  #
  if ($document{'doctype'} eq 'book') {
    $ending_elements .= <<"END_OF_TEXT";
%%--------------------------------------------------------------------
%% book backmatter
%%
\\backmatter

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # Include a glossary if the user wants one
  #
  if ($option{'glossary'} and keys %{$data{'glossary'}}) {
    $ending_elements .= <<"END_OF_TEXT";
%% glossary
\\printglossaries

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # If this document contains sources and the user wants to include a
  # list of sources (bibliography) then add it here.
  #
  if ($count{'source'}{'section'} > 0 and $option{'losources'}) {
    $ending_elements .= <<"END_OF_TEXT";
%% bibliography
\\bibliography{$output_file}
\\bibliographystyle{plain}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # Include an index if the user wants one
  #
  if ($option{'index'} and keys %{$data{'index'}}) {
    $ending_elements .= <<"END_OF_TEXT";
%% index
\\printindex

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # End the document
  #
  $ending_elements .= <<"END_OF_TEXT";
\\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

END_OF_TEXT

  push @latex_foot, $ending_elements;

}

######################################################################

sub assemble_xml_head_array {

  printdebug("assemble_xml_head_array") if $DEBUGGING;

  my $xml_decl = <<"END_OF_TEXT";
<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>

END_OF_TEXT

  my $xml_head_comment = <<"END_OF_TEXT";
<!-- ============================================================= -->
<!--                                                               -->
<!--   This XML document was pulished using the publish.pl         -->
<!--   Perl script that takes plain (but structured) text and      -->
<!--   converts it to an XML file.  publish.pl can also produce    -->
<!--   HTML files for viewing in a web browser and LaTeX output    -->
<!--   for nicely typeset printed pages.                           -->
<!--                                                               -->
<!--   For more information write to me:                           -->
<!--                                                               -->
<!--     Don Johnson                                               -->
<!--     drj826\@acm.org                                            -->
<!--     http://www.donjohnson.net/projects/publish/               -->
<!--                                                               -->
<!-- ============================================================= -->

END_OF_TEXT

  my $xml_stylesheet_decl = <<"END_OF_TEXT";
<?xml-stylesheet type="text/css" href="publish.css" ?>

END_OF_TEXT

  my $xml_begin_doc = <<"END_OF_TEXT";
<doc>

END_OF_TEXT

  my $xml_title = <<"END_OF_TEXT";
<title>$document{'title'}</title>

END_OF_TEXT

  push @xml_head,
    $xml_stylesheet_decl,
    $xml_head_comment,
    $xml_begin_doc,
    $xml_title;

}

######################################################################

sub assemble_xml_stylesheet {

  printdebug("assemble_xml_stylesheet") if $DEBUGGING;

  #-------------------------------------------------------------------
  #
  #   I've noticed that Internet Explorer does not support several
  #   parts of the CSS standard that I use below.  I recommend using
  #   Firefox to preview the XML output from this publish script.
  #
  #   - Preformatted text is jumbled up. IE does not seem to support
  #   "white-space: pre" feature resulting in preformatted regions
  #   being all run together.
  #
  #   - Exercise titles missing "EXERCISE: " IE does not seem to
  #   support the "exercise title:begin" feature resulting in the
  #   "EXERCISE: " string missing from the beginning of exercise
  #   titles.
  #
  #   - Tables jumbled up. IE does not seem to support the display
  #   features "table", "table-row", and "table-cell" resulting in
  #   table content being all jumbled up.
  #
  #   - style sheet attribute selectors like 'list[type="unordered"]'
  #   don't seem to work.
  #
  #-------------------------------------------------------------------

  my $xml_stylesheet = <<"END_OF_TEXT";
stylesheet {
  display:              none;
}

/* ================================================================ */
/* Format Element Styles                                            */
/* ================================================================ */

b {
  display:              inline;
  font-weight:          bold;
}
i {
  display:              inline;
  font-style:           italic;
}
tt {
  display:              inline;
}
u {
  display:              inline;
  text-decoration:      underline;
}
sub {
  display:              inline;
  vertical-align:       sub;
}
sup {
  display:              inline;
  vertical-align:       50%;
}
pre {
  display:              block;
  white-space:          pre;
  font-family:          courier;
  font-size:            10pt;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
hr {
  display:              block;
}
keystroke {
  display:              inline;
}
takenote {
  display:              inline;
}
smiley {
  display:              inline;
}
frowny {
  display:              inline;
}
fillinblank {
  display:              inline;
}

/* ================================================================ */
/* Structure Element Styles                                         */
/* ================================================================ */

title {
  display:              block;
  font-size:            11pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
doc title {
  display:              block;
  font-size:            24pt;
  font-weight:          bold;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
heading {
  display:              block;
  font-weight:          bold;
  font-size:            18pt;
  margin-top:           10pt;
  margin-bottom:        10pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
para {
  display:              block;
  margin-bottom:        8pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
heading {
  display:              block;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
list[type="unordered"] {
  display:              block;
  list-style-type:      disc;
  list-style-position:  inside;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
list[type="ordered"] {
  display:              block;
  list-style-position:  inside;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
list {
  display:              block;
  list-style-type:      disc;
  list-style-position:  inside;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
item {
  display:              list-item;
  margin-bottom:        4pt;
}
table {
  display:              table;
  table-layout:         auto;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
table title {
  display:              table-caption;
  caption-side:         top;
  font-size:            14pt;
  margin-bottom:        10pt;
}
tr {
  display:              table-row;
}
th {
  display:              table-cell;
  padding:              4pt 4pt 4pt 4pt;
  font-weight:          bold;
}
td {
  display:              table-cell;
  padding:              4pt 4pt 4pt 4pt;
}
figure {
  display:              block;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
figure title {
  font-size:            14pt;
  margin-bottom:        10pt;
}
image {
  display:              block;
  margin-left:          20pt;
  margin-right:         20pt;
}
footnote {
  display:              block;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
label {
  display:              none;
}
ref {
  display:              inline;
}
link {
  display:              inline;
}
bibsource {
  display:              none;
}
step {
  display:              block;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
step:before {
  content:              "STEP: ";
  font-weight:          bold;
  font-variant:         small-caps;
  display:              inline;
}
sidebar {
  display:              block;
}
sidebar title {
  display:              block;
  font-weight:          bold;
  margin-bottom:        4pt;
}
indexentry {
  display:              none;
}

/* ================================================================ */
/* Content Element Styles                                           */
/* ================================================================ */

exercise {
  display:              block;
  margin-top:           20pt;
  margin-bottom:        20pt;
  margin-left:          20pt;
  margin-right:         20pt;
  padding:              10pt 10pt 10pt 10pt;
  background:           #ffff99;
}
exercise title {
  display:              block;
  font-weight:          bold;
  font-size:            14pt;
  margin-bottom:        4pt;
}
exercise title:before {
  content:              "EXERCISE: ";
  font-variant:         small-caps;
  display:              inline;
}
listing {
  display:              block;
  margin-top:           20pt;
  margin-bottom:        20pt;
  margin-left:          20pt;
  margin-right:         20pt;
  padding:              10pt 10pt 10pt 10pt;
  background:           #eeeeee;
}
listing title {
  display:              block;
  font-weight:          bold;
  font-size:            14pt;
  margin-bottom:        4pt;
}
slide {
  display:              block;
  margin-top:           20pt;
  margin-bottom:        20pt;
  margin-left:          20pt;
  margin-right:         20pt;
  padding:              10pt 10pt 10pt 10pt;
  background:           #eeeeee;
}
slide title {
  display:              block;
  font-weight:          bold;
  font-size:            14pt;
  margin-bottom:        4pt;
}
quotation {
  display:              block;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
quotation title {
  display:              block;
  font-weight:          bold;
  font-size:            14pt;
  margin-bottom:        4pt;
}
quotesource {
  display:              block;
  align:                right;
  font-style:           italic;
  margin-bottom:        4pt;
}
demo {
  display:              block;
  margin-top:           20pt;
  margin-bottom:        20pt;
  margin-left:          20pt;
  margin-right:         20pt;
  padding:              10pt 10pt 10pt 10pt;
  background:           #9999ff;
}
demo title {
  display:              block;
  font-weight:          bold;
  font-size:            14pt;
  margin-bottom:        4pt;
}
keypoints {
  display:              block;
  margin-top:           20pt;
  margin-bottom:        20pt;
  margin-left:          20pt;
  margin-right:         20pt;
  padding:              10pt 10pt 10pt 10pt;
  background:           #eeeeee;
}
keypoints title {
  display:              block;
  font-size:            12pt;
  font-weight:          bold;
  font-size:            14pt;
  margin-bottom:        4pt;
}
todoitem {
  display:              block;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
note {
  display:              block;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
problem {
  display:              block;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
problem title {
  display:              block;
  font-weight:          bold;
  font-size:            14pt;
  margin-bottom:        4pt;
}
solution {
  display:              block;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
allocation {
  display:              block;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
assignment {
  display:              block;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
solution title {
  display:              block;
  font-weight:          bold;
  font-size:            14pt;
  margin-bottom:        4pt;
}
allocation title {
  display:              block;
  font-weight:          bold;
  font-size:            14pt;
  margin-bottom:        4pt;
}
assignment title {
  display:              block;
  font-weight:          bold;
  font-size:            14pt;
  margin-bottom:        4pt;
}
test {
  display:              block;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
test title {
  display:              block;
  font-weight:          bold;
  font-size:            14pt;
  margin-bottom:        4pt;
}
task {
  display:              block;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
task title {
  display:              block;
  font-weight:          bold;
  font-size:            14pt;
  margin-bottom:        4pt;
}
result {
  display:              block;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
role {
  display:              block;
  margin-bottom:        4pt;
  margin-left:          20pt;
  margin-right:         20pt;
}
result title {
  display:              block;
  font-weight:          bold;
  font-size:            14pt;
  margin-bottom:        4pt;
}

END_OF_TEXT

  push @xml_stylesheet, $xml_stylesheet;

}

######################################################################

sub assemble_xml_dtd {

  printdebug("assemble_xml_dtd") if $DEBUGGING;

  my $xml_dtd = <<"END_OF_TEXT";
<!ELEMENT doc                                                     ANY>
<!ATTLIST doc          type         CDATA                    #IMPLIED>
<!ELEMENT stylesheet                                              ANY>

<!-- ============================================================= -->
<!-- General Entities                                              -->
<!-- ============================================================= -->

<!ENTITY  lt           "&#060;"                                      >
<!ENTITY  gt           "&#062;"                                      >
<!ENTITY  amp          "&#038;"                                      >
<!ENTITY  tm           "&#153;"                                      >
<!ENTITY  reg          "&#174;"                                      >
<!ENTITY  copy         "&#169;"                                      >

<!-- ============================================================= -->
<!-- Format Elements                                               -->
<!-- ============================================================= -->

<!ELEMENT b                                                       ANY>
<!ELEMENT i                                                       ANY>
<!ELEMENT tt                                                      ANY>
<!ELEMENT u                                                       ANY>
<!ELEMENT sub                                                     ANY>
<!ELEMENT sup                                                     ANY>
<!ELEMENT hr                                                    EMPTY>
<!ELEMENT keystroke                                               ANY>
<!ELEMENT takenote                                              EMPTY>
<!ELEMENT smiley                                                EMPTY>
<!ELEMENT frowny                                                EMPTY>
<!ELEMENT fillinblank                                           EMPTY>
<!ATTLIST fillinblank  width        CDATA                    #IMPLIED>

<!-- ============================================================= -->
<!-- Structure Elements                                            -->
<!-- ============================================================= -->

<!ELEMENT title                                                   ANY>
<!ELEMENT para                                                    ANY>
<!ELEMENT heading                                                 ANY>
<!ATTLIST heading      type         CDATA                    #IMPLIED
                       level        CDATA                    #IMPLIED>
<!ELEMENT list                                                    ANY>
<!ATTLIST list         type         CDATA                    #IMPLIED>
<!ELEMENT item                                                    ANY>
<!ELEMENT table                                                   ANY>
<!ATTLIST table        border       CDATA                    #IMPLIED
                       cellpadding  CDATA                    #IMPLIED
                       cellspacing  CDATA                    #IMPLIED>
<!ELEMENT tr                                                      ANY>
<!ELEMENT th                                                      ANY>
<!ATTLIST th           bgcolor      CDATA                    #IMPLIED
                       cellpadding  CDATA                    #IMPLIED
                       cellspacing  CDATA                    #IMPLIED
                       align        CDATA                    #IMPLIED
                       valign       CDATA                    #IMPLIED>
<!ELEMENT td                                                      ANY>
<!ATTLIST td           bgcolor      CDATA                    #IMPLIED
                       cellpadding  CDATA                    #IMPLIED
                       cellspacing  CDATA                    #IMPLIED
                       align        CDATA                    #IMPLIED
                       valign       CDATA                    #IMPLIED>
<!ELEMENT figure                                                  ANY>
<!ATTLIST figure       width        CDATA                    #IMPLIED>
<!ELEMENT attachment                                              ANY>
<!ATTLIST attachment   width        CDATA                    #IMPLIED>
<!ELEMENT image                                                   ANY>
<!ATTLIST image        src          CDATA                    #IMPLIED>
<!ELEMENT pre                                                     ANY>
<!ELEMENT footnote                                                ANY>
<!ELEMENT label                                                 EMPTY>
<!ATTLIST label        id           CDATA                    #IMPLIED>
<!ELEMENT ref                                                   EMPTY>
<!ATTLIST ref          id           CDATA                    #IMPLIED>
<!ELEMENT a                                                       ANY>
<!ATTLIST a            href         CDATA                    #IMPLIED>
<!ELEMENT bibsource                                               ANY>
<!ELEMENT step                                                    ANY>
<!ELEMENT sidebar                                                 ANY>
<!ELEMENT indexentry                                              ANY>
<!ATTLIST indexentry   key          CDATA                    #IMPLIED
                       begin        CDATA                    #IMPLIED
                       end          CDATA                    #IMPLIED>

<!-- ============================================================= -->
<!-- Content Elements                                              -->
<!-- ============================================================= -->

<!ELEMENT exercise                                                ANY>
<!ELEMENT listing                                                 ANY>
<!ELEMENT slide                                                   ANY>
<!ELEMENT quotation                                               ANY>
<!ELEMENT quotesource                                             ANY>
<!ELEMENT demo                                                    ANY>
<!ELEMENT keypoints                                               ANY>
<!ELEMENT todoitem                                                ANY>
<!ELEMENT note                                                    ANY>
<!ELEMENT problem                                                 ANY>
<!ELEMENT solution                                                ANY>
<!ELEMENT allocation                                              ANY>
<!ELEMENT assignment                                              ANY>
<!ELEMENT test                                                    ANY>
<!ELEMENT task                                                    ANY>
<!ELEMENT result                                                  ANY>
<!ELEMENT role                                                    ANY>

<!-- ============================================================= -->
<!-- End of DTD                                                    -->
<!-- ============================================================= -->

END_OF_TEXT

  push @xml_dtd, $xml_dtd;

}

######################################################################

sub assemble_xml_foot_array {

  printdebug("assemble_xml_foot_array") if $DEBUGGING;

  my $ending_elements = <<"END_OF_TEXT";
</doc>
END_OF_TEXT

  push @xml_foot, $ending_elements;

}

######################################################################

sub end_cell_context {

  printdebug("end_cell_context") if $DEBUGGING;

  #-------------------------------------------------------------------
  # If we're in a cell, then it's OK to end the cell context.
  #
  if ($in{'cell'}) {

    $in{'cell'} = 0;
    my $secnum  = $current{'secnum'};
    my $aref    = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # Render HTML
    #
    if ($rendering{'html'} and not $in{'hide'}{'block'}) {
      push @{ $aref }, "</td>\n";
    }

    #-----------------------------------------------------------------
    # Render PDF
    #
    if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
      push @latex, "\n";
    }

    #-----------------------------------------------------------------
    # Render XML
    #
    if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
      push @xml, "</td>\n";
    }

  }

  #-------------------------------------------------------------------
  # ...otherwise, we shouldn't be ending a cell, warn the user
  #
  else {
    printwarning("end_cell_context called while not in cell");
  }
}

######################################################################

sub end_row_context {

  printdebug("end_row_context") if $DEBUGGING;

  #-------------------------------------------------------------------
  # If we're in a row, then it's OK to end the row context.
  #
  if ($in{'row'}) {
    end_cell_context() if $in{'cell'};

    $in{'row'} = 0;
    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # Render HTML
    #
    if ($rendering{'html'} and not $in{'hide'}{'block'}) {
      push @{ $aref }, "</tr>\n";
    }

    #-----------------------------------------------------------------
    # Render PDF
    #
    if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
      push @latex, "\n";
    }

    #-----------------------------------------------------------------
    # Render XML
    #
    if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
      push @xml, "</tr>\n";
    }

  }

  #-------------------------------------------------------------------
  # ...otherwise, we shouldn't be ending a row, warn the user
  #
  else {
    printwarning("end_row_context called while not in row");
  }
}

######################################################################

sub end_table_context {

  printdebug("end_table_context") if $DEBUGGING;

  #-------------------------------------------------------------------
  # If we're in a table environment then it's OK to end the table.
  #
  if ($in{'table'}{'environment'}) {
    end_table_item()  if $in{'item'};
    end_table_list()  if $in{'table_list'};
    end_row_context() if $in{'row'};
    $in{'table'}{'environment'} = 0;
    $current{'column'} = 0;

    #-----------------------------------------------------------------
    # Render HTML
    #
    if ($rendering{'html'} and not $in{'hide'}{'block'}) {
      my $secnum = $current{'secnum'};
      my $aref   = $html{'body'}{$secnum};
      push @{ $aref }, "</table>\n";
      push @{ $aref }, "</div>\n";
    }

    #-----------------------------------------------------------------
    # Render PDF
    #
    if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
      push @latex, <<"END_OF_TEXT";
%%
%% end table

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # Render XML
    #
    if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
      push @xml, "</table>\n";
    }

  }

  #-------------------------------------------------------------------
  # ...otherwise we're NOT in a table environment, and we shouldn't be
  # ending a table here.  Warn the user.
  #
  else {
    printwarning("end_table_context called while not in table");
  }
}

######################################################################

sub end_baretable_context {

  printdebug("end_baretable_context") if $DEBUGGING;

  #-------------------------------------------------------------------
  # If we're in a baretable, then it's OK to end the baretable here.
  #
  if ( $in{'baretable'} == 1 ) {
    end_table_item()  if $in{'item'};
    end_table_list()  if $in{'table_list'};
    end_row_context() if $in{'row'};
    $in{'baretable'} = 0;
    $current{'column'} = 0;

    #-----------------------------------------------------------------
    # Render HTML
    #
    if ($rendering{'html'} and not $in{'hide'}{'block'}) {
      my $secnum = $current{'secnum'};
      my $aref   = $html{'body'}{$secnum};
      push @{ $aref }, "</table>\n";
      push @{ $aref }, "</div>\n";
    }

    #-----------------------------------------------------------------
    # Render PDF
    #
    # !!! bug here !!!
    #
    #     Now this looks odd.  There is no actual LaTeX code for
    #     ending the table.  Normally this would include a string like
    #     \end{longtable} if we are using longtables.
    #
    if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
      push @latex, <<"END_OF_TEXT";
%%
%% end baretable

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # Render XML
    #
    if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
      push @xml, "</table>\n";
    }

  }

  #-------------------------------------------------------------------
  # ...otherwise we're NOT in a baretable, and we shouldn't be ending
  # a baretable here.  warn the user.
  #
  else {
    printwarning("end_baretable_context called while not in table");
  }
}

######################################################################

sub end_image_set_context {

  printdebug("end_image_set_context") if $DEBUGGING;

  #-------------------------------------------------------------------
  # If we're in an image set, then it's OK to end it here.
  #
  if ($in{'imageset'}) {

    $in{'imageset'}                = 0;
    $count{'image'}{'consecutive'} = 0;
    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # Render HTML
    #
    if ($rendering{'html'} and not $in{'hide'}{'block'}) {
      push @{ $aref }, "\n</p>\n";
    }

    #-----------------------------------------------------------------
    # Render PDF
    #
    if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
      push @latex, "\n";
    }

    #-----------------------------------------------------------------
    # Render XML
    #
    if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
      push @xml, "\n</imageset>\n";
    }

  }

  #-------------------------------------------------------------------
  # ...otherwise, we're NOT in an image set, and we shouldn't be
  # ending one here.  Warn the user.
  #
  else {
    printwarning("end_image_set_context called while not in imageset");
  }
}

######################################################################

sub begin_ulist {

  printdebug("begin_ulist") if $DEBUGGING;

  # ARG 0: indent whitespace

  my $indent                = shift;
  my $new_ulist_indent      = length($indent);
  $in{'ulist'}              = 1;
  $current{'ulist_indent'}  = $new_ulist_indent;
  ++$current{'ulist_depth'};
  my $depth                 = $current{'ulist_depth'};
  $ulist_indent_for{$depth} = $new_ulist_indent;

  #-------------------------------------------------------------------
  # We've been asked to begin a new *unordered* list. If we're already
  # in an *ordered* list, AND the new *unordered* list has the same
  # indent and depth as the current *ordered* list, end the current
  # ordered list before starting the new *unordered* list.
  #
  if ($in{'olist'}
      and $current{'olist_depth'} == $current{'ulist_depth'}
      and $olist_indent_for{$current{'olist_depth'}} == $ulist_indent_for{$current{'ulist_depth'}}) {
    end_olist($indent);
  }

  #-------------------------------------------------------------------
  # Render HTML.
  #
  if ( $rendering{'html'} and not $in{'hide'}{'block'} ) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    if ( $in{'table'}{'environment'} or $in{'baretable'} ) {
      push @{ $aref }, "<ul style=\"margin: 0em; padding-left: 1.5em\">\n\n";
    }

    else {
      push @{ $aref }, "<ul>\n\n";
    }
  }

  #-------------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'} ) {

    if ($in{'cell'} and $current{'ulist_depth'} == 1) {
      # DON'T ADD TRAILING NEWLINE!
      push @latex, <<"END_OF_TEXT";
\\vspace{-1\\baselineskip}
\\begin{tablecellitemize}
END_OF_TEXT
    }

    elsif ($in{'cell'}) {
      # DON'T ADD TRAILING NEWLINE!
      push @latex, <<"END_OF_TEXT";
\\begin{tablecellitemize}
END_OF_TEXT
    }

    else {
      # DON'T ADD TRAILING NEWLINE!
      push @latex, <<"END_OF_TEXT";
\\begin{itemize}
\\setlength\\itemsep{0pt}
END_OF_TEXT
    }
  }

  #-------------------------------------------------------------------
  # Render XML.
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'} ) {
    push @xml, "<list type=\"unordered\">\n\n";
  }

}

######################################################################

sub end_ulist {

  # ARG 0: indent whitespace

  printdebug("end_ulist") if $DEBUGGING;

  #-------------------------------------------------------------------
  # NOTE
  #
  # The 'begin_ulist_item' method calls *this* one when it needs to
  # begin a new ulist with a smaller indent than the previous one.
  # But what happens in the case where the new ulist is, say, a level
  # 1 ulist whereas the current one is a level 3?  This method uses
  # the *new* indent to determine how many list levels need to be
  # ended.
  #
  # Another problem to recognize is when users have inconsistently
  # indented their list items.  For instance, what if the user
  # indented level 2 list items 2 spaces, and level 3 list items 4
  # spaces, then followed with a list item indented 3 spaces?  There
  # is no previous list depth that corresponds to a 3 space indent. If
  # this is the case, this method generates an 'inconsistent item
  # indentation' warning and ends all list levels.
  # -------------------------------------------------------------------

  my $indent = shift;
  my $new_ulist_indent = length($indent);

  #-------------------------------------------------------------------
  # Look through all the indentations we've seen before to find out if
  # this new one has been seen before.
  #
  my $indent_seen_before = 0;
  foreach my $depth (keys %ulist_indent_for) {
    my $indent = $ulist_indent_for{$depth};
    if ($indent == $new_ulist_indent) {
      $indent_seen_before = 1;
      printdebug("end_ulist: indent_seen_before = 1 (depth: $depth)") if $DEBUGGING;
    }
  }

  #-------------------------------------------------------------------
  # If this new indentation *hasn't* been seen before it means the
  # user inconsistently indented the list items.  Warn the user and
  # end all list levels.
  #
  if (not $indent_seen_before) {
    my $file = $current{'file'};
    my $line = $current{'line'};
    printerror("$file:$line: inconsistent unordered list item indentation\n");
    end_ulist_context();
  }

  #-------------------------------------------------------------------
  # ...Otherwise, this indentation *has* been seen before, and we need
  # to end the correct number of lists to get back out to the list
  # depth that corresponds to that indentation.
  #
  else {

    #-----------------------------------------------------------------
    # If this is a top-level list (depth = 1) then there is no
    # out-denting to be done.
    #
    if ($current{'ulist_depth'} == 1) {

      #---------------------------------------------------------------
      # HTML
      #
      if ($rendering{'html'} and not $in{'hide'}{'block'}) {
	my $secnum = $current{'secnum'};
	my $aref   = $html{'body'}{$secnum};
        push @{ $aref }, "</ul>\n\n";
      }

      #---------------------------------------------------------------
      # PDF
      #
      if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

        if ($in{'cell'}) {
          push @latex, "\\end{tablecellitemize}\n";
        }

        else {
          push @latex, "\\end{itemize}\n\n";
        }
      }

      #---------------------------------------------------------------
      # XML
      #
      if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
        push @xml, "</list>\n\n";
      }

      -- $current{'ulist_depth'};
      $current{'ulist_indent'} = $ulist_indent_for{$current{'ulist_depth'}}
    }

    #-----------------------------------------------------------------
    # ...Otherwise this is *not* a top level list, and we need to work
    # our way out to the correct list level.
    #
    else {
      until ($current{'ulist_indent'} == $new_ulist_indent) {
        printdebug("end_ulist: outputting end of list") if $DEBUGGING;

        #-------------------------------------------------------------
        # HTML
        #
        if ($rendering{'html'} and not $in{'hide'}{'block'}) {
	  my $secnum = $current{'secnum'};
	  my $aref   = $html{'body'}{$secnum};
          push @{ $aref }, "</ul>\n\n";
        }

        #-------------------------------------------------------------
        # PDF
        #
        if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

          if ($in{'cell'}) {
            push @latex, "\\end{tablecellitemize}\n";
          }

          else {
            push @latex, "\\end{itemize}\n\n";
          }
        }

        #-------------------------------------------------------------
        # XML
        #
        if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
          push @xml, "</list>\n\n";
        }

        -- $current{'ulist_depth'};
        $current{'ulist_indent'} = $ulist_indent_for{$current{'ulist_depth'}}
      }
    }

    #-----------------------------------------------------------------
    # If we've decremented the list depth all the way out to 0 it
    # means we're no longer in a ulist.
    #
    $in{'ulist'} = 0 if $current{'ulist_depth'} == 0;
  }
}

######################################################################

sub begin_ulist_item {

  # ulist = unordered list

  # ARG 0: indent whitespace
  # ARG 1: item text

  printdebug("begin_ulist_item") if $DEBUGGING;

  my $indent           = shift;
  my $text             = shift;
  my $new_ulist_indent = length($indent);

  #-------------------------------------------------------------------
  # end previous context if necessary
  #
  end_pre()      if $in{'pre'};
  end_item()     if $in{'item'};
  end_preamble() if $in{'preamble'}{'text'};

  #-------------------------------------------------------------------
  # If we're not already in a unordered list, then start one.
  #
  if (not $in{'ulist'}) {
    begin_ulist($indent);
  }

  #-------------------------------------------------------------------
  # ...Otherwise, we might need to START a list WITHIN a list
  #
  elsif ($in{'ulist'} and ($new_ulist_indent > $current{'ulist_indent'})) {
    begin_ulist($indent);
  }

  #-------------------------------------------------------------------
  # ...Or, we might need to END a list WITHIN a list.
  #
  elsif ($in{'ulist'} and ($new_ulist_indent < $current{'ulist_indent'})) {
    end_ulist($indent);
  }

  #-------------------------------------------------------------------
  # We're now officially inside a list item.
  #
  $in{'item'} = 1;

  #-------------------------------------------------------------------
  # I'm changing the item rendering logic to render the item as a
  # block at the end of the item rather than line-by-line.  Accumulate
  # item text in $current{'item'}.
  # -------------------------------------------------------------------

  $text = trim_whitespace($text);
  $current{'item'} = "$text ";

}

######################################################################

sub begin_olist {

  printdebug("begin_olist") if $DEBUGGING;

  # ARG 0: indent whitespace

  my $indent = shift;
  my $new_olist_indent = length($indent);
  $in{'olist'} = 1;
  $current{'olist_indent'} = $new_olist_indent;
  ++$current{'olist_depth'};
  $olist_indent_for{$current{'olist_depth'}} = $new_olist_indent;

  #-------------------------------------------------------------------
  # We've been asked to begin a new *ordered* list. If we're already
  # in an *unordered* list, AND the new *ordered* list has the same
  # indent and depth as the current *unordered* list, end the current
  # *unordered* list before starting the new *unordered* list.
  #
  if ($in{'ulist'}
      and $current{'ulist_depth'} == $current{'olist_depth'}
      and $ulist_indent_for{$current{'ulist_depth'}} 
          == $olist_indent_for{ $current{'olist_depth'} }
     ) {
    end_ulist($indent);
  }

  #-------------------------------------------------------------------
  # HTML
  #
  if ( $rendering{'html'} and not $in{'hide'}{'block'} ) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    if ( $in{'table'}{'environment'} or $in{'baretable'} ) {
      push @{ $aref }, "<ol style=\"margin: 0em; padding-left: 1.5em\">\n";
    }

    else {
      push @{ $aref }, "<ol>\n";
    }
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    if ($in{'cell'} and $current{'olist_depth'} == 1) {
      push @latex, <<"END_OF_TEXT";
\\vspace{-1\\baselineskip}

END_OF_TEXT
    }

    push @latex, <<"END_OF_TEXT";
\\begin{enumerate}
\\setlength\\itemsep{0pt}

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, "<list type=\"ordered\">\n\n";
  }

}

######################################################################

sub begin_dlist {

  printdebug("begin_dlist") if $DEBUGGING;

  # ARG 0: term
  # ARG 1: text

  my $term = shift;
  my $text = shift;

  #-------------------------------------------------------------------
  # We are now officially inside a definition list (sometimes called a
  # description list).
  #
  $in{'dlist'} = 1;

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {
    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};
    push @{ $aref }, "<dl>\n\n";
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    push @latex, <<"END_OF_TEXT";
\\begin{description}
\\setlength\\itemsep{0pt}
END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, "<list type=\"definition\">\n\n";
  }

}

######################################################################

sub end_olist {

  # ARG 0: indent whitespace

  printdebug("end_olist") if $DEBUGGING;

  #-------------------------------------------------------------------
  # NOTE
  #
  # The 'begin_olist_item' method calls *this* one when it needs to
  # begin a new olist with a smaller indent than the previous one.
  # But what happens in the case where the new olist is, say, a level
  # 1 olist whereas the current one is a level 3?  This method uses
  # the *new* indent to determine how many list levels need to be
  # ended.
  #
  # Another potential problem to recognize is when users have
  # inconsistently indented their list items.  For instance, what if
  # the user indented level 2 list items 2 spaces, and level 3 list
  # items 4 spaces, then followed with a list item indented 3 spaces?
  # There is no previous list depth that corresponds to a 3 space
  # indent. If this is the case, this method generates an
  # 'inconsistent item indentation' warning and ends all list levels.
  # -------------------------------------------------------------------

  my $indent = shift;
  my $new_olist_indent = length($indent);

  #-------------------------------------------------------------------
  # Look through all the indentations we've seen before to find out if
  # this new one has been seen before.
  #
  my $indent_seen_before = 0;
  foreach my $depth (keys %olist_indent_for) {
    my $indent = $olist_indent_for{$depth};
    if ($indent == $new_olist_indent) {
      $indent_seen_before = 1;
    }
  }

  #-------------------------------------------------------------------
  # If this new indentation *hasn't* been seen before it means the
  # user inconsistently indented the list items.  Warn the user and
  # end all list levels.
  #
  if (not $indent_seen_before) {
    my $file = $current{'file'};
    my $line = $current{'line'};
    printerror("$file:$line: inconsistent ordered list item indentation\n");
    end_olist_context();
  }

  #-------------------------------------------------------------------
  # ...Otherwise, this indentation *has* been seen before, and we need
  # to end the correct number of lists to get back out to the list
  # depth that corresponds to that indentation.
  #
  else {

    #-----------------------------------------------------------------
    # If this is a top-level list (depth = 1) then there is no
    # out-denting to be done.
    #
    if ($current{'olist_depth'} == 1) {

      #---------------------------------------------------------------
      # HTML
      #
      if ($rendering{'html'} and not $in{'hide'}{'block'}) {
	my $secnum = $current{'secnum'};
	my $aref   = $html{'body'}{$secnum};
	push @{ $aref }, "</ol>\n";
      }

      #---------------------------------------------------------------
      # PDF
      #
      if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
	push @latex, "\\end{enumerate}\n";
      }

      #---------------------------------------------------------------
      # XML
      #
      if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
	push @xml, "</list>\n\n";
      }

      -- $current{'olist_depth'};
      $current{'olist_indent'} = $olist_indent_for{$current{'olist_depth'}}
    }

    #-----------------------------------------------------------------
    # ...Otherwise this is *not* a top level list, and we need to work
    # our way out to the correct list level.
    #
    else {
      until ($current{'olist_indent'} == $new_olist_indent) {
        printdebug("end_olist: outputting end of list") if $DEBUGGING;

        #-------------------------------------------------------------
        # HTML
        #
	if ($rendering{'html'} and not $in{'hide'}{'block'}) {
	  my $secnum = $current{'secnum'};
	  my $aref   = $html{'body'}{$secnum};
	  push @{ $aref }, "</ol>\n";
	}

        #-------------------------------------------------------------
        # PDF
        #
	if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
	  push @latex, "\\end{enumerate}\n";
	}

        #-------------------------------------------------------------
        # XML
        #
	if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
	  push @xml, "</list>\n\n";
	}

        -- $current{'olist_depth'};
        $current{'olist_indent'} = $olist_indent_for{$current{'olist_depth'}}
      }
    }

    #-----------------------------------------------------------------
    # If we've decremented the list depth all the way out to 0 it
    # means we're no longer in a ulist.
    #
    $in{'olist'} = 0 if $current{'olist_depth'} == 0;
  }
}

######################################################################

sub end_dlist {

  printdebug("end_dlist") if $DEBUGGING;

  #---------------------------------------------------------------
  # HTML
  #
  if ( $rendering{'html'} and not $in{'hide'}{'block'}) {
    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};
    push @{ $aref }, "</dl>\n\n";
  }

  #---------------------------------------------------------------
  # PDF
  #
  if ( $rendering{'pdf'} and not $in{'hide'}{'block'} ) {
    push @latex, "\\end{description}\n\n";
  }

  #---------------------------------------------------------------
  # XML
  #
  if ( $rendering{'xml'} and not $in{'hide'}{'block'} ) {
    push @xml, "</list>\n\n";
  }

  $in{'dlist'} = 0;
}

######################################################################

sub begin_olist_item {

  printdebug("begin_olist_item") if $DEBUGGING;

  # ARG 0: indent whitespace
  # ARG 1: item text

  my $indent = shift;
  my $text   = shift;
  my $new_olist_indent = length($indent);

  #-------------------------------------------------------------------
  # end previous context if necessary
  #
  end_pre()       if $in{'pre'};
  end_item()      if $in{'item'};
  end_preamble()  if $in{'preamble'}{'text'};

  #-------------------------------------------------------------------
  # If we're not already in an ordered list, then start one.
  #
  if (not $in{'olist'}) {
    begin_olist($indent);
  }

  #-------------------------------------------------------------------
  # ...Otherwise we might need to START a olist WITHIN a olist
  #
  elsif ($in{'olist'} and ($new_olist_indent > $current{'olist_indent'})) {
    begin_olist($indent);
  }

  #-------------------------------------------------------------------
  # ...Or, we might need to END a olist WITHIN a olist
  #
  elsif ($in{'olist'} and ($new_olist_indent < $current{'olist_indent'})) {
    end_olist($indent);
  }

  #-------------------------------------------------------------------
  # We're now officially inside a list item.
  #
  $in{'item'}   = 1;

  #-------------------------------------------------------------------
  # I'm changing the item rendering logic to render the item as a
  # block at the end of the item rather than line-by-line.  Accumulate
  # item text in $current{'item'}.
  # -------------------------------------------------------------------

  $text = trim_whitespace($text);
  $current{'item'} = "$text ";

}

######################################################################

sub begin_variable_entry {

  printdebug("begin_variable_entry") if $DEBUGGING;

  # ARG 0: name
  # ARG 1: value

  my $name  = shift;
  my $value = shift;

  #-------------------------------------------------------------------
  # end previous context if necessary
  #
  end_pre()           if $in{'pre'};
  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};
  end_preamble()      if $in{'preamble'}{'text'};
  end_item()          if $in{'item'};

  #-------------------------------------------------------------------
  # We're now officially inside a variable entry.
  #
  $in{'variable'} = 1;

}

######################################################################

sub process_variable_entry_text {

  printdebug("process_variable_entry_text") if $DEBUGGING;

  # All variable processing has moved to pass 2.

}

######################################################################

sub end_variable_entry {

  printdebug("end_variable_entry") if $DEBUGGING;

  #-------------------------------------------------------------------
  # We're now officially no longer inside a variable entry.
  #
  $in{'variable'} = 0;

}

######################################################################

sub begin_glossary_entry {

  printdebug("begin_glossary_entry") if $DEBUGGING;

  # ARG 0: term
  # ARG 1: alt
  # ARG 2: entry text

  my $term = shift;
  my $alt  = shift;
  my $text = shift;

  #-------------------------------------------------------------------
  # end previous context if necessary
  #
  end_pre()           if $in{'pre'};
  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};
  end_preamble()      if $in{'preamble'}{'text'};
  end_item()          if $in{'item'};

  #-------------------------------------------------------------------
  # We're now officially inside a glossary entry.
  #
  $in{'glossary'} = 1;

}

######################################################################

sub process_glossary_entry_text {

  printdebug("process_glossary_entry_text") if $DEBUGGING;

  # All glossary processing has moved to pass 2.

}

######################################################################

sub end_glossary_entry {

  printdebug("end_glossary_entry") if $DEBUGGING;

  #-------------------------------------------------------------------
  # We're now officially no longer inside a glossary entry.
  #
  $in{'glossary'} = 0;

}

######################################################################

sub begin_acronym_definition {

  printdebug("begin_acronym_definition") if $DEBUGGING;

  # ARG 0: term
  # ARG 1: entry text

  my $term = shift;
  my $text = shift;

  #-------------------------------------------------------------------
  # end previous context if necessary
  #
  end_pre()           if $in{'pre'};
  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};
  end_preamble()      if $in{'preamble'}{'text'};
  end_item()          if $in{'item'};

  #-------------------------------------------------------------------
  # We're now officially inside a acronym entry.
  #
  $in{'acronym'}      = 1;
  $current{'acronym'} = $term;

}

######################################################################

sub process_acronym_text {

  printdebug("process_acronym_text") if $DEBUGGING;

  # All acronym processing has moved to pass 2.

}

######################################################################

sub end_acronym_definition {

  printdebug("end_acronym_definition") if $DEBUGGING;

  #-------------------------------------------------------------------
  # We're now officially no longer inside a acronym definition.
  #
  $in{'acronym'}      = 0;
  $current{'acronym'} = '';

}

######################################################################

sub process_pagebreak {

  printdebug("process_pagebreak") if $DEBUGGING;

  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, "\\pagebreak\n\n";
  }

}

######################################################################

sub process_clearpage {

  printdebug("process_clearpage") if $DEBUGGING;

  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, "\\clearpage\n\n";
  }

}

######################################################################

sub begin_dlist_item {

  printdebug("begin_dlist_item") if $DEBUGGING;

  # dlist = definition list

  # ARG 0: term
  # ARG 1: item text

  my $term = shift;
  my $text = shift;

  #-------------------------------------------------------------------
  # end previous context if necessary
  #
  end_pre()       if $in{'pre'};
  end_item()      if $in{'item'};
  end_preamble()  if $in{'preamble'}{'text'};

  #-------------------------------------------------------------------
  # If we're not already in an definition list, then start one.
  #
  if (not $in{'dlist'}) {
    begin_dlist($term,$text);
  }

  #-------------------------------------------------------------------
  # We're now officially inside a list item.
  #
  $in{'item'} = 1;

  #-------------------------------------------------------------------
  # I'm changing the item rendering logic to render the item as a
  # block at the end of the item rather than line-by-line.  Accumulate
  # item text in $current{'item'}.
  # -------------------------------------------------------------------

  $text = trim_whitespace($text);
  $term = trim_whitespace($term);
  $current{'item'} = "$text ";
  $current{'term'} = $term;

}

######################################################################

sub end_item {

  printdebug("end_item") if $DEBUGGING;

  my $text   = trim_whitespace( $current{'item'} );
  $text      = compress_whitespace($text);
  my $secnum = $current{'secnum'};

  if ($in{'item'} and $in{'dlist'}) {

    my $term = $current{'term'};

    #-----------------------------------------------------------------
    # HTML
    #
    if ($rendering{'html'} and not $in{'hide'}{'block'}) {
      my $secnum     = $current{'secnum'};
      my $aref       = $html{'body'}{$secnum};
      my $html_term  = escape_html($term);
      my $html_text  = escape_html($text);
      my $string     = "<dt><b>$html_term</b></dt><dd>$html_text</dd>";
      my $block      = wrap($string) . "\n\n";
      push @{ $aref }, $block;
    }

    #-----------------------------------------------------------------
    # PDF
    #
    if ( $rendering{'pdf'} and not $in{'hide'}{'block'} ) {
      my $latex_term = escape_latex($term);
      my $latex_text = escape_latex($text);
      my $string     = "\\item[$latex_term] $latex_text";
      my $block      = wrap($string) . "\n";
      push @latex, $block;
    }

    #-----------------------------------------------------------------
    # XML
    #
    if ( $rendering{'xml'} and not $in{'hide'}{'block'} ) {
      my $xml_term = escape_xml($term);
      my $xml_text = escape_xml($text);
      my $string   = "<term>$xml_term</term><definition>$xml_text</definition>";
      my $block    = wrap($string) . "\n\n";
      push @xml, $block;
    }

  }

  elsif ( $in{'item'} ) {

    #-----------------------------------------------------------------
    # HTML
    #
    if ( $rendering{'html'} and not $in{'hide'}{'block'} ) {
      my $aref      = $html{'body'}{$secnum};
      my $html_text = "<li>" . escape_html($text) . "</li>";
      my $block     = wrap($html_text) . "\n\n";
      push @{ $aref }, $block;
    }

    #-----------------------------------------------------------------
    # PDF
    #
    if ( $rendering{'pdf'} and not $in{'hide'}{'block'} ) {
      my $latex_text = "\\item " . escape_latex($text);
      my $block      = wrap($latex_text) . "\n";
      push @latex, $block;
    }

    #-----------------------------------------------------------------
    # XML
    #
    if ( $rendering{'xml'} and not $in{'hide'}{'block'} ) {
      my $xml_text = "<item>" . escape_xml($text) . "</item>";
      my $block    = wrap($xml_text) . "\n\n";
      push @xml, $block;
    }

  }

  else {
    printerror("end_item called while NOT in an item!");
  }

  $in{'item'} = 0;

}

######################################################################

sub begin_para {
  printdebug("begin_para") if $DEBUGGING;
  end_footnote() if $in{'footnote'};
  $in{'para'} = 1;
}

######################################################################

sub end_para {

  printdebug("end_para") if $DEBUGGING;

  if ($in{'para'}) {

    my $text   = trim_whitespace( $current{'para'} );
    $text      = compress_whitespace($text);
    my $secnum = $current{'secnum'};

    $current{'para'} = '';

    #-----------------------------------------------------------------
    # HTML
    #
    if ( $rendering{'html'} and not $in{'hide'}{'block'} ) {
      my $aref      = $html{'body'}{$secnum};

      my $html_text = '';
      if ($in{'cell'}) {
	$html_text = "<p style=\"margin-top: 0;\">" . escape_html($text) . "</p>";
      } else {
	$html_text = "<p>" . escape_html($text) . "</p>";
      }
#      my $block     = wrap($html_text) . "\n\n";
      my $block     = $html_text . "\n\n";
      push @{ $aref }, $block;
    }

    #-----------------------------------------------------------------
    # PDF
    #
    if ( $rendering{'pdf'} and not $in{'hide'}{'block'} ) {
      my $latex_text = escape_latex($text);
      my $block = '';
      if ($in{'cell'}) {
	$block = wrap($latex_text) . '\linebreak ';
      } else {
	$block = wrap($latex_text) . "\n\n";
      }
      push @latex, $block;
    }

    #-----------------------------------------------------------------
    # XML
    #
    if ( $rendering{'xml'} and not $in{'hide'}{'block'} ) {
      my $xml_text = "<para>" . escape_xml($text) . "</para>";
      my $block    = wrap($xml_text) . "\n\n";
      push @xml, $block;
    }

    $in{'para'} = 0;

  }
}

######################################################################

sub begin_pre {

  printdebug("begin_pre") if $DEBUGGING;

  my $text = shift;

  #-------------------------------------------------------------------
  # Preformatted text is text that should be rendered verbatim.  In
  # the structured text syntax there are two ways of beginning a
  # structured text block: (1) indenting the text block, or (2)
  # beginning and ending the text  block with `---preformatted.'
  #
  # If preformatted text occurrs within a table, we need to strip off
  # an appropriate amount of leading (indented) whitespace.  The
  # appropriate amount is the amount of the initial indent of the
  # preformatted section of text (often two spaces).
  #
  # In order to know what this is, I've created a gloabal variable
  # named $current{'initial_indent'}.  Whenever the parser (PASS 3)
  # encounters the beginning of a preformatted text region, this
  # variable will be set to whatever that initial indent is.

    #-----------------------------------------------------------------
    # !!! BUG HERE !!!
    #
    # In some circumstances, we don't want to end the list, but make
    # an embedded list.

  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};

  $in{'pre'} = 1;

  #-----------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {
    my $html   = escape_html_pre($text);
    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};
    push @{ $aref }, "<pre>\n";
    push @{ $aref }, $html if $text;
  }

  #-----------------------------------------------------------------
  # PDF
  #
  #     If this preformatted text resides in a table cell, then remove
  #     2 baselineskip's worth of vertical space and remove the
  #     initial indent spaces.
  #
  if ($rendering{'pdf'} and $in{'cell'} and not $in{'hide'}{'block'}) {

    # strip off indented space
    #
    my $space = $current{'initial_indent'};
    $text =~ s/^$space(.*)/$1/;

    my $latex  = escape_latex_pre($text);
    push @latex, <<"END_OF_TEXT";
\\vspace{-2\\baselineskip}
\\begin{verbatim}
END_OF_TEXT

    push @latex, $latex if $latex;
  }

  elsif ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    my $latex  = escape_latex_pre($text);
    push @latex, <<"END_OF_TEXT";
\\begin{verbatim}
END_OF_TEXT
    push @latex, $latex if $latex;
  }

  #-----------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    my $xml = escape_xml_pre($text);
    push @xml, "<pre>\n";
    push @xml, $xml if $text;
  }
}

######################################################################

sub end_pre {

  printdebug("end_pre") if $DEBUGGING;

  if ($in{'pre'}) {

    $in{'pre'} = 0;

    #-----------------------------------------------------------------
    # HTML
    #
    if ($rendering{'html'} and not $in{'hide'}{'block'}) {
      my $secnum = $current{'secnum'};
      my $aref   = $html{'body'}{$secnum};
      push @{ $aref }, "</pre>\n";
    }

    #-----------------------------------------------------------------
    # PDF
    #
    if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

      #--------------------------------------------------------------
      # PDF: Pop the previous line off of the @latex stack.  Why is
      # this necessary?  Well, I'll just have to document that some
      # day...
      #
      my $previous = pop @latex;

      #--------------------------------------------------------------
      # PDF: if it's not empty, push it back on
      #
      if ($previous !~ /^\s*$/) {
        push @latex, $previous;
      }

      #---------------------------------------------------------------
      # PDF: End the LaTeX 'verbatim' region
      #
      push @latex, <<"END_OF_TEXT";
\\end{verbatim}

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # XML
    #
    if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
      push @xml, "</pre>\n";
    }
  }
}

######################################################################

sub begin_preformatted {

  printdebug("begin_preformatted") if $DEBUGGING;

  $in{'preformatted'}{'environment'} = 1;

  #-----------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {
    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};
    push @{ $aref }, "<pre>\n";
  }

  #-----------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, <<"END_OF_TEXT";
\\small
\\begin{verbatim}
END_OF_TEXT
  }

  #-----------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, "<pre>\n";
  }
}

######################################################################

sub end_preformatted {

  printdebug("end_preformatted") if $DEBUGGING;

  $in{'preformatted'}{'environment'} = 0;

  #-----------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {
    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};
    push @{ $aref }, "</pre>\n";
  }

  #-----------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #--------------------------------------------------------------
    # PDF: pop the previous line off of the @latex stack
    #
    my $previous = pop @latex;

    #--------------------------------------------------------------
    # PDF: if it's not empty, push it back on
    #
    if ($previous !~ /^\s*$/) {
      push @latex, $previous;
    }

    #---------------------------------------------------------------
    # PDF: End the LaTeX 'verbatim' region
    #
    push @latex, <<"END_OF_TEXT";
\\end{verbatim}
\\normalsize

END_OF_TEXT
  }

  #-----------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, "</pre>\n";
  }
}

######################################################################

sub end_ulist_context {

  printdebug("end_ulist_context") if $DEBUGGING;

  #-------------------------------------------------------------------
  # NOTE: there is another subroutine called "end_ulist" which ends
  # only the current level of a nested list.  This subroutine will end
  # all levels of a nested list.

  #-------------------------------------------------------------------
  # Before ending an unordered list, first check to make sure we're
  # already in one...
  #
  if ($in{'ulist'}) {

    #-----------------------------------------------------------------
    # If we're currently in an item, we need to close it before
    # closing the list.
    #
    end_item() if $in{'item'};

    #-----------------------------------------------------------------
    # As long as we haven't yet reached the top list level..
    #
    while ($current{'ulist_depth'} > 0) {

      #---------------------------------------------------------------
      # Decrement the current list level.
      #
      --$current{'ulist_depth'};

      #---------------------------------------------------------------
      # HTML
      #
      if ($rendering{'html'} and not $in{'hide'}{'block'}) {
	my $secnum = $current{'secnum'};
	my $aref   = $html{'body'}{$secnum};
        push @{ $aref }, "</ul>\n\n";
      }

      #---------------------------------------------------------------
      # PDF
      #
      if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

        #-------------------------------------------------------------
        # If we're inside a table cell, end the special
        # 'tablecellitemize' region.
        #
        if ($in{'cell'}) {
          push @latex, "\\end{tablecellitemize}\n";
        }

        #-------------------------------------------------------------
        # ..Otherwise end a normal 'itemize' region.
        #
        else {
          push @latex, "\\end{itemize}\n\n";
        }
      }

      #---------------------------------------------------------------
      # XML
      #
      if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
        push @xml, "</list>\n\n";
      }
    }

    #-----------------------------------------------------------------
    # We're no longer inside a ulist.
    #
    $in{'ulist'} = 0;
  }

  #-------------------------------------------------------------------
  # ...Otherwise, we've been asked to end an unordered list when we're
  # not even in one!  complain about this.
  #
  else {
    printwarning("asked to end a ulist when not in a ulist!\n");
  }
}

######################################################################

sub end_olist_context {

  printdebug("end_olist_context") if $DEBUGGING;

  #-------------------------------------------------------------------
  # NOTE: there is another subroutine called "end_olist" which ends
  # only the current level of a nested list.  This subroutine will end
  # all levels of a nested list.

  #-------------------------------------------------------------------
  # Before ending an ordered list, first check to make sure we're
  # already in one...
  #
  if ($in{'olist'}) {

    #-----------------------------------------------------------------
    # If we're currently in an item, we need to close it before
    # closing the list.
    #
    end_item() if $in{'item'};

    #-----------------------------------------------------------------
    # As long as we haven't yet reached the top list level..
    #
    while ($current{'olist_depth'} > 0) {

      #---------------------------------------------------------------
      # Decrement the current list level.
      #
      --$current{'olist_depth'};

      #---------------------------------------------------------------
      # HTML
      #
      if ($rendering{'html'} and not $in{'hide'}{'block'}) {
	my $secnum = $current{'secnum'};
	my $aref   = $html{'body'}{$secnum};
        push @{ $aref }, "</ol>\n";
      }

      #---------------------------------------------------------------
      # PDF
      #
      if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
        push @latex, "\\end{enumerate}\n";
      }

      #---------------------------------------------------------------
      # XML
      #
      if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
        push @xml, "</list>\n\n";
      }
    }

    #-----------------------------------------------------------------
    # We're no longer inside a olist.
    #
    $in{'olist'} = 0;
  }

  #-------------------------------------------------------------------
  # ...Otherwise, we've been asked to end an ordered list when we're
  # not even in one!  complain about this.
  #
  else {
    printwarning("asked to end an olist when not in an olist!\n");
  }
}

######################################################################

sub end_current_context {

  printdebug("end_current_context") if $DEBUGGING;

  # We're no longer in any environment or region data element
  #
  #     !!! Bug Here !!!
  #
  #     There is a potential here for a serious problem if the name of
  #     an element is the same as the name of a type since these two
  #     constructs are both used:
  #
  #       $in{$name}{$type}
  #
  #     and:
  #
  #       $in{$name}{$element}
  #
  #     Types are: text, environment, and region.
  #
  #     To avoid potential problems, I should convert all:
  #
  #       $in{$name}{$element}
  #
  #     to:
  #
  #       $in{$name}{$type}{$element}
  #
  foreach my $name (keys %structure) {
    my $type = $structure{$name}{'type'};
    foreach my $element (keys %{$structure{$name}{'elements'}}) {
      if ($in{$name}{$element}) {
        printdebug("no longer in $name $type $element") if $DEBUGGING;
        $in{$name}{$element} = 0;
      }
    }
  }

  #-------------------------------------------------------------------
  # Certain structures must end.
  #
  end_image_set_context()   if $in{'imageset'};
  end_celltext()            if $in{'celltext'};
  end_item()                if $in{'item'};
  end_para()                if $in{'para'};
  end_todo_item()           if $in{'todo'};
  end_table_title()         if $in{'table'}{'title'};
  end_file()                if $in{'file'};
  end_footnote()            if $in{'footnote'};
  end_glossary_entry()      if $in{'glossary'} == 1;
  end_acronym_definition()  if $in{'acronym'} == 1;
  end_index_text()          if $in{'index'};

  #-------------------------------------------------------------------
  # 'bold' markup can't span different blocks (like paragraphs)
  #
  if ($in{'b'}) {
    printerror("missing end-bold markup: ** or !!\n");

    #-----------------------------------------------------------------
    # HTML
    #
    if ($rendering{'html'} and not $in{'hide'}{'block'}) {
      my $secnum = $current{'secnum'};
      my $aref   = $html{'body'}{$secnum};
      push @{ $aref }, '</b>';
    }

    #-----------------------------------------------------------------
    # XML
    #
    if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
      push @xml, '</bold>';
    }

    $in{'b'} = 0;
  }

  #-------------------------------------------------------------------
  # latex 'bold' markup can't span different blocks (like paragraphs)
  #
  if ($in{'latex_b'}) {
    printerror("missing end-bold markup: ** or !!\n");

    #-----------------------------------------------------------------
    # PDF
    #
    if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
      push @latex, "}\n";
    }

    $in{'latex_b'} = 0;
  }

  #-------------------------------------------------------------------
  # 'tt' markup can't span different blocks (like paragraphs)
  #
  if ($in{'tt'}) {
    printerror("missing end-tt markup: ||\n");

    #-----------------------------------------------------------------
    # HTML
    #
    if ($rendering{'html'} and not $in{'hide'}{'block'}) {
      my $secnum = $current{'secnum'};
      my $aref   = $html{'body'}{$secnum};
      push @{ $aref }, '</tt>';
    }

    #-----------------------------------------------------------------
    # XML
    #
    if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
      push @xml, '</tt>';
    }

    $in{'tt'} = 0;
  }

  #-------------------------------------------------------------------
  # latex 'bold' markup can't span different blocks (like paragraphs)
  #
  if ($in{'latex_tt'}) {
    printerror("missing end-tt markup: ||\n");

    #-----------------------------------------------------------------
    # PDF
    #
    if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
      push @latex, "}\n";
    }

    $in{'latex_tt'} = 0;
  }

  #-------------------------------------------------------------------
  # 'italics' markup can't span different blocks (like paragraphs)
  #
  if ($in{'i'}) {
    printerror("missing end-italics markup: ~~\n");

    #-----------------------------------------------------------------
    # HTML
    #
    if ($rendering{'html'} and not $in{'hide'}{'block'}) {
      my $secnum = $current{'secnum'};
      my $aref   = $html{'body'}{$secnum};
      push @{ $aref }, '</i>';
    }

    #-----------------------------------------------------------------
    # XML
    #
    if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
      push @xml, '</italics>';
    }

    $in{'i'} = 0;
  }

  #-------------------------------------------------------------------
  # latex 'italics' markup can't span different blocks (like paragraphs)
  #
  if ($in{'latex_i'}) {
    printerror("missing end-italics markup: ~~\n");

    #-----------------------------------------------------------------
    # PDF
    #
    if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
      push @latex, "}\n";
    }

    $in{'latex_i'} = 0;
  }

  #-------------------------------------------------------------------
  # 'underline' markup can't span different blocks (like paragraphs)
  #
  if ($in{'u'}) {
    printerror("missing end-underline markup: __\n");

    #-----------------------------------------------------------------
    # HTML
    #
    if ($rendering{'html'} and not $in{'hide'}{'block'}) {
      my $secnum = $current{'secnum'};
      my $aref   = $html{'body'}{$secnum};
      push @{ $aref }, '</u>';
    }

    #-----------------------------------------------------------------
    # XML
    #
    if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
      push @xml, '</u>';
    }

    $in{'u'} = 0;
  }

  #-------------------------------------------------------------------
  # latex 'underline' markup can't span different blocks (like paragraphs)
  #
  if ($in{'latex_u'}) {
    printerror("missing end-underline markup: __\n");

    #-----------------------------------------------------------------
    # PDF
    #
    if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
      push @latex, "}\n";
    }

    $in{'latex_u'} = 0;
  }

  #-------------------------------------------------------------------
  # Should we really end 'pre' here?  Doesn't end_current_context get
  # called only when a blank line is encountered?
  #
  if ($in{'pre'}) {
    end_pre();
  }

  #-------------------------------------------------------------------
  # I have no idea what this is here...
  #
  elsif ($in{'slide'}{'region'}
         or $in{'sidebar'}{'environment'}
         or $in{'demo'}{'region'}) {

    #-----------------------------------------------------------------
    # HTML
    #
    if ($rendering{'html'} and not $in{'hide'}{'block'}) {
      my $html   = escape_html_pre($_);
      my $secnum = $current{'secnum'};
      my $aref   = $html{'body'}{$secnum};
      push @{ $aref }, $html;
    }

    #-----------------------------------------------------------------
    # XML
    #
    if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
      my $xml  = escape_xml_pre($_);
      push @xml, $xml;
    }

    #-----------------------------------------------------------------
    # PDF
    #
    if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
      my $latex = escape_latex_pre($_);
      push @latex, $latex;
    }
  }

  #-------------------------------------------------------------------
  # consider this the end of RCS info
  #
  elsif ($in{'rcsinfo'}) {
    $in{'rcsinfo'} = 0;

    #-----------------------------------------------------------------
    # HTML
    #
    if ($rendering{'html'} and not $in{'hide'}{'block'}) {
      push @{ $html{'preamble'} }, "</table>\n";
      push @{ $html{'preamble'} }, "</div>\n";
    }
  }
}

######################################################################

sub find_size {

  # Find the width and height (e.g. 600x450) of an image.

  printdebug("find_size") if $DEBUGGING;
  my $image_file  = shift;
  my ($x, $y)     = imgsize($image_file);
  my $size        = "600x450";
  if ($x and $y) {
    $size = $x . "x" . $y;
  }
  ;
  printdebug("  size: $size") if $DEBUGGING;
  return $size;
}

######################################################################

sub scale_image {

  printdebug("scale_image") if $DEBUGGING;

  my $image_spec = shift;
  my @parts      = split('/', $image_spec);
  my $image_file = pop @parts;

  my $orig       = "$image_spec";
  my $scaled     = "$output_dir/images-scaled/$image_file";

  # print an error and return if the file doesn't exist
  #
  if (not -f $orig) {
    printerror("can't scale non-existent $image_spec\n");
    return;
  }

  # if there is no scaled image or if it's stale, scale the image
  #
  if ((not -f "$scaled") or (file_is_stale("$orig","$scaled"))) {

    printstatus("    Scaling $orig");

    my $convert = $option{'convert'};

    if (not -e $convert) {
      printwarning("scaling image: convert program $convert is not executable");
      return;
    }

    systemnw("$convert -size ${scaled_size}x${scaled_size} $orig -resize ${scaled_size}x${scaled_size} +profile \"*\" $scaled");

    # if ($^O eq 'MSWin32' and -f ("$startdir/convert.exe")) {
    #   systemnw("$startdir\\convert.exe -size ${scaled_size}x${scaled_size} $orig -resize ${scaled_size}x${scaled_size} +profile \"*\" $scaled");
    # }

    # elsif ($^O eq 'MSWin32' and -f ("$startdir/publish/convert.exe")) {
    #   systemnw("$startdir\\publish\\convert.exe -size ${scaled_size}x${scaled_size} $orig -resize ${scaled_size}x${scaled_size} +profile \"*\" $scaled");
    # }

    # elsif ($^O eq 'MSWin32' and -f ("$startdir/app/ImageMagick-6.6.2-0/convert.exe")) {
    #   systemnw("$startdir\\app\\ImageMagick-6.6.2-0\\convert.exe -size ${scaled_size}x${scaled_size} $orig -resize ${scaled_size}x${scaled_size} +profile \"*\" $scaled");
    # }

    # else {
    #   systemnw("convert -size ${scaled_size}x${scaled_size} $orig -resize ${scaled_size}x${scaled_size} +profile \"*\" $scaled");
    # }

    utime undef, undef, "$scaled";

  }
}

######################################################################

sub publish_thumbnail {

  printdebug("publish_thumbnail") if $DEBUGGING;

  my $image_spec = shift;
  my @parts      = split('/', $image_spec);
  my $image_file = pop @parts;

  my $orig       = "$image_spec";
  my $thumbnail  = "$output_dir/images-thumbnails/$image_file";

  my $size = find_size($orig);
  my ($width,$height) = split(/x/, $size);

  # if the width of the original image is bigger than the thumbnail
  # size, then reduce it to thumbnail size.
  #
  if ($width > $thumbnail_size) {

    # create the thumbnail image if it doesn't already exist, or if
    # it's stale, make a thumbnail version of the original image --
    # this requires that ImageMagick be installed
    #
    if ((not -f "$thumbnail") or (file_is_stale("$orig","$thumbnail"))) {

      printstatus("    Thumbnailing $image_spec");

      my $convert = $option{'convert'};

      if (not -e $convert) {
	printwarning("thumbnailing image: convert program $convert is not executable");
	return;
      }

        systemnw("$convert -size ${thumbnail_size}x${thumbnail_size} $image_spec -resize ${thumbnail_size}x${thumbnail_size} +profile \"*\" $output_dir/images-thumbnails/$image_file");

      # if ($^O eq 'MSWin32') {
      #   systemnw("$startdir/convert.exe -size ${thumbnail_size}x${thumbnail_size} $image_spec -resize ${thumbnail_size}x${thumbnail_size} +profile \"*\" $output_dir/images-thumbnails/$image_file");
      # }

      # else {
      #   systemnw("convert -size ${thumbnail_size}x${thumbnail_size} $image_spec -resize ${thumbnail_size}x${thumbnail_size} +profile \"*\" $output_dir/images-thumbnails/$image_file");
      # }

      utime undef, undef, "$thumbnail";
    }
  }

  # else the image is already smaller than a thumbnail, copy it to
  # the thumbnails directory without resizing it.
  #
  else {
    if ((not -f $thumbnail) or (file_is_stale("$orig","$thumbnail"))) {

      printstatus("    Thumbnailing $orig");
      File::Copy::copy("$orig", "$thumbnail");
      utime undef, undef, "$thumbnail";
    }
  }
}

######################################################################

sub publish_image {

  my $image_spec = shift;
  my $image_file = (split('/', $image_spec))[-1];

  printdebug("publish_image $image_spec") if $DEBUGGING;

  #-------------------------------------------------------------------
  # Path
  #
  #     Define the path and filename for both the original and copy of
  #     the image file.
  #
  my $orig = "$docdir/$image_spec";
  my $copy = "$output_dir/images/$image_file";

  #-------------------------------------------------------------------
  # Readable?
  #
  #     If the original file is readable, try to make the copy.
  #
  if (-r $orig) {

    #-----------------------------------------------------------------
    # Make Copy
    #
    #     If the copy doesn't already exist, or if it is stale
    #     (i.e. the original is newer than the copy), then make the
    #     copy.
    #
    if ( (not -f "$copy") or (file_is_stale("$orig","$copy")) ) {
      printstatus("    Publishing $orig");
      File::Copy::copy("$orig", "$copy");
      utime undef, undef, "$copy";
    }

    #-----------------------------------------------------------------
    # Up-To-Date
    #
    #     Otherwise the file must be up-to-date (perhaps it was copied
    #     before) and doesn't need to be copied again.
    #
    else {
      printdebug("publish_image: copy of $orig is up-to-date") if $DEBUGGING;
    }
  }

  #-------------------------------------------------------------------
  # Error
  #
  #     Otherwise the original file doesn't exist, raise an error.
  #
  else {
    my $cwd = getcwd;
    printerror("$current{'file'}:$current{'line'}: image $orig not found!\n");
    printerror("  orig:   $orig\n");
    printerror("  copy:   $copy\n");
    printerror("  cwd:    $cwd\n");
    printerror("  docdir: $docdir\n");
  }
}

######################################################################

sub publish_file {

  # This subroutine places a copy of a file that is part of a document
  # into the "files" directory.

  printdebug("publish_file") if $DEBUGGING;

  my $file_spec = shift;
  my @parts     = split('/', $file_spec);
  my $file      = pop @parts;
  my $orig      = "$file_spec";
  my $copy      = "$output_dir/files/$file";

  # Create the files directory if it doesn't exist
  #
  if (not -d "$output_dir/files") {
    printstatus("creating output dir: $output_dir/files");
    mkdir "$output_dir/files", 0755;
  }

  # If the attached file exists...
  #
  if (-f $orig) {

    if ((not -f $copy) or (file_is_stale("$orig","$copy"))) {

      printstatus("    Publishing $orig");
      File::Copy::copy("$orig", "$copy");
      utime undef, undef, "$copy";
    }
  }

  # Else if the attached file DOES NOT exist...
  #
  else {
    printerror("file does not exist: $file_spec");
  }

  return $file;
}

######################################################################

sub file_is_stale {

  printdebug("checking if file_is_stale") if $DEBUGGING;

  my $file_orig = shift;
  my $file_copy = shift;

  return 1 if not -f $file_copy;

  my $time_orig = (stat $file_orig)[9];
  my $time_copy = (stat $file_copy)[9];

  if ($time_orig > $time_copy) {
    return 1;
  }

  else {
    return 0;
  }
}

######################################################################

sub init {

  printdebug("init") if $DEBUGGING;

  #-----------------------------------------------------------------
  # initialize variables

  # datastructure to hold HTML data
  #
  %html = (

    'head'  => [], 'foot'     => [], 'nav' => [],
    'title' => [], 'preamble' => [], 'toc' => [],

    'revisions' => [],
    'updates'   => [],

    'slide'      => { 'index' => [] }, 'sidebar'  => { 'index' => [] },
    'quotation'  => { 'index' => [] }, 'demo'     => { 'index' => [] },
    'exercise'   => { 'index' => [] }, 'listing'  => { 'index' => [] },
    'todo'       => { 'index' => [] }, 'footnote' => { 'index' => [] },
    'table'      => { 'index' => [] }, 'figure'   => { 'index' => [] },
    'attachment' => { 'index' => [] }, 'source'   => { 'index' => [] },

    'problem'    => {
      'index'       => [], 'tree_big'   => [], 'tree_small' => [],
      'spreadsheet' => [], 'priorities' => [],
    },

    'solution'   => {
      'index'       => [], 'tree_big'   => [], 'tree_small' => [],
      'spreadsheet' => [], 'priorities' => [],
    },

    'allocation'   => {
      'index'       => [], 'tree_big'   => [], 'tree_small' => [],
      'spreadsheet' => [], 'priorities' => [],
    },

    'assignment'   => {
      'index'       => [], 'tree_big'   => [], 'tree_small' => [],
      'spreadsheet' => [], 'priorities' => [],
    },

    'task'       => {
      'index'       => [], 'tree_big'   => [], 'tree_small' => [],
      'spreadsheet' => [], 'priorities' => [],
    },

    'test'       => {
      'index'       => [], 'tree_big'   => [], 'tree_small' => [],
      'spreadsheet' => [], 'priorities' => [],
    },

    'result'     => {
      'index'       => [], 'tree_big'   => [], 'tree_small' => [],
      'spreadsheet' => [], 'priorities' => [],
    },

    'role'       => {
      'index'       => [], 'tree_big'   => [], 'tree_small' => [],
      'spreadsheet' => [], 'priorities' => [],
    },

  );

  # datastructure to hold CSV data
  #
  my %csv = (
    'problem'  => [], 'solution' => [], 'allocation' => [], 'assignment' => [],
    'task'     => [], 'test'     => [], 'result'     => [], 'role'       => [],
  );

  # arrays to hold LaTeX data
  #
  @latex_head            = ();
  @latex_nav             = ();
  @latex_title           = ();
  @latex_cvsinfo         = ();
  @latex                 = ();
  @latex_glossary        = ();
  @latex_foot            = ();

  # array for accumulating XML data
  #
  @xml                   = ();
  @xml_head              = ();
  @xml_foot              = ();
  @xml_stylesheet        = ();
  @xml_dtd               = ();

  # array for accumulating raw text data
  #
  @text                  = ();

  # scalars for output file names
  #
  $html_toc_file                   = $EMPTY_STRING;
  $html_revisions_file             = $EMPTY_STRING;
  $html_updates_file               = $EMPTY_STRING;
  $html_slide_index_file           = $EMPTY_STRING;
  $html_sidebar_index_file         = $EMPTY_STRING;
  $html_quotation_index_file       = $EMPTY_STRING;
  $html_problem_index_file         = $EMPTY_STRING;
  $html_solution_index_file        = $EMPTY_STRING;
  $html_allocation_index_file      = $EMPTY_STRING;
  $html_assignment_index_file      = $EMPTY_STRING;
  $html_test_index_file            = $EMPTY_STRING;
  $html_task_index_file            = $EMPTY_STRING;
  $html_result_index_file          = $EMPTY_STRING;
  $html_role_index_file            = $EMPTY_STRING;
  $html_problem_tree_big_file      = $EMPTY_STRING;
  $html_solution_tree_big_file     = $EMPTY_STRING;
  $html_allocation_tree_big_file   = $EMPTY_STRING;
  $html_assignment_tree_big_file   = $EMPTY_STRING;
  $html_test_tree_big_file         = $EMPTY_STRING;
  $html_task_tree_big_file         = $EMPTY_STRING;
  $html_result_tree_big_file       = $EMPTY_STRING;
  $html_role_tree_big_file         = $EMPTY_STRING;
  $html_problem_tree_small_file    = $EMPTY_STRING;
  $html_solution_tree_small_file   = $EMPTY_STRING;
  $html_allocation_tree_small_file = $EMPTY_STRING;
  $html_assignment_tree_small_file = $EMPTY_STRING;
  $html_test_tree_small_file       = $EMPTY_STRING;
  $html_task_tree_small_file       = $EMPTY_STRING;
  $html_result_tree_small_file     = $EMPTY_STRING;
  $html_role_tree_small_file       = $EMPTY_STRING;
  $html_problem_spreadsheet_file   = $EMPTY_STRING;
  $html_solution_spreadsheet_file  = $EMPTY_STRING;
  $html_allocation_spreadsheet_file = $EMPTY_STRING;
  $html_assignment_spreadsheet_file = $EMPTY_STRING;
  $html_test_spreadsheet_file       = $EMPTY_STRING;
  $html_task_spreadsheet_file     = $EMPTY_STRING;
  $html_result_spreadsheet_file   = $EMPTY_STRING;
  $html_role_spreadsheet_file     = $EMPTY_STRING;
  $html_priority_index_file       = $EMPTY_STRING;
  $html_demo_index_file           = $EMPTY_STRING;
  $html_exercise_index_file       = $EMPTY_STRING;
  $html_listing_index_file        = $EMPTY_STRING;
  $html_todo_index_file           = $EMPTY_STRING;
  $html_footnote_index_file       = $EMPTY_STRING;
  $html_table_index_file          = $EMPTY_STRING;
  $html_figure_index_file         = $EMPTY_STRING;
  $html_attachment_index_file     = $EMPTY_STRING;
  $latex_file                     = $EMPTY_STRING;
  $bibliography_file              = $EMPTY_STRING;
  $index_file                     = $EMPTY_STRING;
  $xml_doc_file                   = $EMPTY_STRING;
  $xml_stylesheet_file            = $EMPTY_STRING;
  $xml_dtd_file                   = $EMPTY_STRING;
  $text_out_file                  = $EMPTY_STRING;

  # PASS 2 variables
  #
  # $current{'name'}          = 'section';
  $current{'sectype'}       = 'section';
  $current{'topnum'}        = $EMPTY_STRING;
  $current{'secnum'}        = $EMPTY_STRING;
  $current{'title'}         = $EMPTY_STRING;
  $current{'number'}        = $EMPTY_STRING;
  $current{'heading'}       = $EMPTY_STRING;
  $current{'top_heading'}   = $EMPTY_STRING;

  # variables for text regions
  #
  %in                    = ();  # in region hash
  %label                 = ();  # label hash
  @footnote              = ();  # hash of footnote text

  # counter variables
  #
  $count{'toplevel'}              = 0; # count top level sections
  $count{'image'}{'consecutive'}  = 0;
  $count{'table'}{'section'}      = 0;
  $count{'baretable'}{'section'}  = 0;
  $count{'figure'}{'section'}     = 0;
  $count{'attachment'}{'section'} = 0;
  $count{'listing'}{'section'}    = 0;
  $count{'exercise'}{'section'}   = 0;
  $count{'footnote'}{'total'}     = 0;
  $count{'step'}{'section'}       = 0;
  $count{'quotesource'}{'total'}  = 0;
  $count{'section'}{'total'}      = 0;
  $count{'slide'}{'total'}        = 0;
  $count{'sidebar'}{'total'}      = 0;
  $count{'quotation'}{'total'}    = 0;
  $count{'problem'}{'total'}      = 0;
  $count{'solution'}{'total'}     = 0;
  $count{'allocation'}{'total'}   = 0;
  $count{'assignment'}{'total'}   = 0;
  $count{'priority'}{'total'}     = 0;
  $count{'test'}{'total'}         = 0;
  $count{'task'}{'total'}         = 0;
  $count{'result'}{'total'}       = 0;
  $count{'role'}{'total'}         = 0;
  $count{'demo'}{'total'}         = 0;
  $count{'keypoints'}{'total'}    = 0;
  $count{'source'}{'total'}       = 0;
  $count{'table'}{'total'}        = 0;
  $count{'baretable'}{'total'}    = 0;
  $count{'figure'}{'total'}       = 0;
  $count{'attachment'}{'total'}   = 0;
  $count{'listing'}{'total'}      = 0;
  $count{'exercise'}{'total'}     = 0;
  $count{'todo'}{'total'}         = 0;
  $count{'note'}{'total'}         = 0;

  %scounter                       = (); # Section counter hash
  %dcounter                       = (); # Section counter hash (for display)

  $current{'column'}       = 0;
  $current{'sectype'}      = 'section';
  $count{'source'}{'section'}            = 0;
  $nesting_level           = 0;
  @nesting_stack           = ();
  %seen_title              = ();
  %env_type                = ();
  %env_marker              = ();
  $region_baton               = $EMPTY_STRING;
  $textfile                = $EMPTY_STRING;
  @current_line            = 0;
  %current_table           = (); # information about the current table

  # generated content
  #
  %generated_content       = ();

  # SVN information
  #
  %svninfo = ();

  # values of meta-data variables
  #
#  $copyright           = $EMPTY_STRING;    # copyright message
#  $bgcolor             = $EMPTY_STRING;    # table cell background color
#  $border              = $EMPTY_STRING;    # table border 0 or 1
#  $cellpadding         = $EMPTY_STRING;    # cell padding in pixels
#  $cellspacing         = $EMPTY_STRING;    # cell spacing in pixels
  $document{'doctype'} = 'article';        # article, report or book

  # font and fontsize are set using the GUI, don't reset them here
  #
  # $fontfam             = $EMPTY_STRING;        # times
  # $fontsize            = $EMPTY_STRING;        # 10pt, 11pt, or 12pt

#  $align               = $EMPTY_STRING;    # cell horizontal alignment
#  @author              = ();    # list of authors

  $heading_in_slide_index        = 0; #
  $heading_in_sidebar_index      = 0; #
  $heading_in_quotation_index    = 0; #
  $heading_in_problem_index      = 0; #
  $heading_in_solution_index     = 0; #
  $heading_in_allocation_index   = 0; #
  $heading_in_assignment_index   = 0; #
  $heading_in_priority_index     = 0; #
  $heading_in_test_index         = 0; #
  $heading_in_task_index         = 0; #
  $heading_in_result_index       = 0; #
  $heading_in_role_index         = 0; #
  $heading_in_demo_index         = 0; #
  $heading_in_exercise_index     = 0; #
  $heading_in_listing_index      = 0; #
  $heading_in_todo_index         = 0; #
  $heading_in_footnote_index     = 0; #
  $heading_in_table_index        = 0; #
  $heading_in_revisions_index    = 0; #
  $heading_in_updates_index      = 0; #
  $heading_in_figure_index       = 0; #
  $heading_in_attachment_index   = 0; #

  # default colors and sizes
  #
  $todo_bgcolor         = '#ffcccc'; # todo item background color
  $todo_regular_color   = '#009900'; # "regular" todo color
  $todo_started_color   = '#004400'; # "started" todo color
  $todo_cancelled_color = '#bbbbbb'; # "cancelled" todo color
  $todo_urgent_color    = '#ff0000'; # "urgent" todo color
  $todo_completed_color = '#000000'; # "completed" todo color
  $todo_question_color  = '#000000'; # "question" todo color

  $footnote_color       = '#000000'; # footnote color

  $num_color            = '#aaaaaa'; # color for slide count

  $slide_bgcolor        = '#fdfdaa'; # BG color of slides
  $slide_width          = '80%';     # width of slides
  $slide_border         = '1';       # width of slide border
  $slide_padding        = '10';      # padding around slides

  $sidebar_bgcolor      = '#eeeeee'; # BG color of sidebars
  $sidebar_width        = '80%';     # width of sidebars
  $sidebar_border       = '1';       # width of sidebar border
  $sidebar_padding      = '10';      # padding around sidebars

  $quotation_bgcolor    = '#eeeeee'; # BG color of quotations
  $quotation_width      = '80%';     # width of quotations
  $quotation_border     = '1';       # width of quotation border
  $quotation_padding    = '10';      # padding around quotations

  $problem_bgcolor      = '#eeeeee'; # BG color of problems
  $problem_width        = '80%';     # width of problems
  $problem_border       = '1';       # width of problem border
  $problem_padding      = '10';      # padding around problems

  $solution_bgcolor     = '#eeeeee'; # BG color of solutions
  $solution_width       = '80%';     # width of solutions
  $solution_border      = '1';       # width of solution border
  $solution_padding     = '10';      # padding around solutions

  $allocation_bgcolor     = '#eeeeee'; # BG color of allocations
  $allocation_width       = '80%';     # width of allocations
  $allocation_border      = '1';       # width of allocation border
  $allocation_padding     = '10';      # padding around allocations

  $assignment_bgcolor     = '#eeeeee'; # BG color of assignments
  $assignment_width       = '80%';     # width of assignments
  $assignment_border      = '1';       # width of assignment border
  $assignment_padding     = '10';      # padding around assignments

  $test_bgcolor         = '#eeeeee'; # BG color of tests
  $test_width           = '80%';     # width of tests
  $test_border          = '1';       # width of test border
  $test_padding         = '10';      # padding around tests

  $task_bgcolor         = '#eeeeee'; # BG color of tasks
  $task_width           = '80%';     # width of tasks
  $task_border          = '1';       # width of task border
  $task_padding         = '10';      # padding around tasks

  $result_bgcolor       = '#eeeeee'; # BG color of results
  $result_width         = '80%';     # width of results
  $result_border        = '1';       # width of result border
  $result_padding       = '10';      # padding around results

  $role_bgcolor         = '#eeeeee'; # BG color of roles
  $role_width           = '80%';     # width of roles
  $role_border          = '1';       # width of role border
  $role_padding         = '10';      # padding around roles

  $demo_bgcolor         = '#ddddff'; # BG color of demos
  $demo_width           = '80%';     # width of demos
  $demo_border          = '1';       # width of demo border
  $demo_padding         = '10';      # padding around demos

  $exercise_bgcolor     = '#ffffff'; # BG color of exercises
  $exercise_width       = '80%';     # width of exercises
  $exercise_border      = '1';       # width of exercise border
  $exercise_padding     = '10';      # padding around exercises

  $listing_bgcolor      = '#ddffdd'; # BG color of listings
  $listing_width        = '80%';     # width of listings
  $listing_border       = '1';       # width of listing border
  $listing_padding      = '20';      # padding around listings

  $keypoints_bgcolor    = '#eeeeee'; # BG color of keypointss
  $keypoints_width      = '80%';     # width of keypointss
  $keypoints_border     = '1';       # width of keypoints border
  $keypoints_padding    = '20';      # padding around keypointss

  $error_color          = '#ff0000'; # FG color of error text
  $thumbnail_size       = '160';     # size of slide thumbnails
  $scaled_size          = '605';     # width of scaled images
  $max_float_size       = 400;       # more than this? use longtable

  @intext              = ();

  #  $startdir;
  $docdir               = $EMPTY_STRING;
  $output_dir           = $EMPTY_STRING;
  $output_file          = $EMPTY_STRING;

  $main;
  $messages;

  $current_source_key   = $EMPTY_STRING;

  %data   = ();
  %lookup = ();
  %in     = ();

  #---------------------------------------------------------------------
  # Define variables that indicate the state of parsing.
  #
  $current{'file'}          = $EMPTY_STRING; # file currently being parsed
  $current{'line'}          = $EMPTY_STRING; # line number of current line
  # $current{'name'}          = $EMPTY_STRING;
  $current{'sectype'}       = 'section';
  $current{'topnum'}        = $EMPTY_STRING;
  $current{'secnum'}        = $EMPTY_STRING;
  $current{'title'}         = $EMPTY_STRING;
  $current{'number'}        = $EMPTY_STRING;

  %variable = ();

}

######################################################################
#
#     A todo indicator is one of:
#
#     [ ] work hasn't started                         regular
#     [!] this todo is urgent!                        urgent
#     [.] work has started                            started
#     [-] todo has been cancelled                     cancelled
#     [x] todo is completed                           completed
#     [?] (Don) indicates Don has a question          question
#     [ ] (12 Sep 2002) means todo has a              deadline
#         12 Sep 2002 deadline
#     [ ] (12 Sep 2002, Don) means Don has a          deadline
#         12 Sep 2002 deadline

sub begin_todo_item {

  printdebug("begin_todo_item") if $DEBUGGING;

  my $indicator = shift;
  my $text      = shift;

  $current{'todo'}           = trim_whitespace($text);
  $current{'todo-indicator'} = $indicator;

  # !!! can't put todo items in a table, baretable, list, or
  # preformatted

  end_pre()           if $in{'pre'};
  end_todo_item()     if $in{'todo'};
  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};
  end_preamble()      if $in{'preamble'}{'text'};

  $in{'todo'}   = 1;

}

######################################################################

sub end_todo_item {

  printdebug("end_todo_item") if $DEBUGGING;

  $in{'todo'} = 0;

  ++ $count{'todo'}{'total'};

  my $text      = $current{'todo'};
  my $indicator = $current{'todo-indicator'};
  my $secnum    = $current{'secnum'};
  my $num       = $count{'todo'}{'total'};
  my $sectype   = $current{'sectype'};
  my $heading   = $current{'heading'};
  my $block     = '';
  my $color     = $todo_regular_color;
  my $status    = 'To do item:';

  $count{'toplevel'} = $scounter{1};

  if ($indicator eq '.') {
    $color  = $todo_started_color;
    $status = 'Work has already started on this item:';
  }

  elsif ($indicator eq '-') {
    $color  = $todo_cancelled_color;
    $status = 'This item has been cancelled:';
  }

  elsif ($indicator eq '!') {
    $color  = $todo_urgent_color;
    $status = 'This item is URGENT!';
  }

  elsif ($indicator eq 'x') {
    $color  = $todo_completed_color;
    $status = 'This item has be completed:';
  }

  elsif ($indicator eq '?') {
    $color  = $todo_question_color;
    $status = 'Someone poses this question:';
  }

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $outfile      = html_outfile_for_secnum($secnum);
    my $html_heading = escape_html($heading);
    my $anchor       = "todo.$num";
    my $aref         = $html{'body'}{$secnum};
    my $html_text    = escape_html($text);

    #-----------------------------------------------------------------
    # to-do item in document
    #
    $block = wrap($html_text);

    push @{ $aref }, <<"END_OF_TEXT";
<!-- ========================= TODO ITEM ========================= -->
<a name="$anchor"/>
<div class="todo">
<font color="$color">$status</font><br>
$block
</div>

END_OF_TEXT

    #-----------------------------------------------------------------
    # current heading in todo item index
    #
    if (not $heading_in_todo_index) {
      $block = <<"END_OF_TEXT";
<h3>$sectype $html_heading</h3>
END_OF_TEXT
      $block = wrap($block);
      push @{ $html{'todo'}{'index'} }, $block;
      $heading_in_todo_index = 1;
    }

    #-----------------------------------------------------------------
    # Add this todo item to the todo item index.
    #
    $block = <<"END_OF_TEXT";
<p><font color="$color"><a href="$outfile#$anchor">
$sectype $count{'toplevel'}, To-Do item $num</a>
[$indicator] $html_text</font></p>
END_OF_TEXT
    $block = wrap($block);
    push @{ $html{'todo'}{'index'} }, $block;

  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    if ($indicator eq 'x') {

      my $latex_text = "\\done " . escape_latex($text);
      my $block      = wrap($latex_text);

      push @latex, <<"END_OF_TEXT";
%% todo item $num
%%
%% \\label{todo.$num}
%%
$block

END_OF_TEXT
    }

    else {

      my $latex_text = "\\todo " . escape_latex($text);
      my $block      = wrap($latex_text);

      push @latex, <<"END_OF_TEXT";
%% todo item $num
%%
%% \\label{todo.$num}
%%
$block

END_OF_TEXT
    }

  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    my $xml_text  = "<todoitem>" . escape_xml($text) . "</todoitem>";
    $block = wrap($xml_text);
    push @xml, $block;
  }

}

######################################################################

sub process_begin_region_marker {

  my $marker = shift;

  printdebug("process_begin_region_marker($marker)") if $DEBUGGING;

  #-------------------------------------------------------------------
  # Any region marker means the end of the document preamble.
  #
  end_preamble() if $in{'preamble'}{'text'};

  #-------------------------------------------------------------------
  # Ignore this region marker if we're in a comment block.
  #
  return if $in{'comment'}{'block'};

  #-------------------------------------------------------------------
  # make sure this is a known region
  #
  if (not exists $structure{$marker}) {
    printerror("beginning of unknown region: $marker\n");
    return;
  }

  #-------------------------------------------------------------------
  # take the some action based on the region
  #
  else {

    if (not $in{$marker}{'region'}) {
      begin_region($marker);
    }

    else {
      printerror("Can't nest $marker regions\n");
    }
  }

  #-------------------------------------------------------------------
  # reset the table column counter
  #
  $current{'column'} = 0;

  #-------------------------------------------------------------------
  # remember that we're in this region
  #
  $in{$marker}{'region'} = 1;

  #-------------------------------------------------------------------
  # temporary label
  #
  $current{'label'} = "temp-" . $marker . "-label";
  push(@{ $current{'label_stack'} }, $current{'label'});

}

######################################################################

sub process_end_region_marker {

  printdebug("process_end_region_marker") if $DEBUGGING;

  my $marker = shift;

  #-------------------------------------------------------------------
  # Any region marker means the end of the document preamble.
  #
  end_preamble() if $in{'preamble'}{'text'};

  #-------------------------------------------------------------------
  # make sure this is a known region
  #
  if (not exists $structure{$marker}) {
    printerror("end of unknown region: $marker\n");
    return;
  }

  #-------------------------------------------------------------------
  # take the some action based on the region
  #
  else {

    if (not $in{$marker}{'region'}) {
      printerror("not in a $marker region\n");
    }

    else {
      end_region($marker);
    }
  }

  #-------------------------------------------------------------------
  # reset the table column counter
  #
  $current{'column'} = 0;

  #-------------------------------------------------------------------
  # remember that we're no longer in this region
  #
  $in{$marker}{'region'} = 0;

  #-------------------------------------------------------------------
  # revert label
  #
  pop(@{ $current{'label_stack'} });
  $current{'label'} = (@{ $current{'label_stack'} })[-1];

}

######################################################################

sub process_environment_marker {

  my $marker = shift;

  printdebug("process_environment_marker($marker)") if $DEBUGGING;

  #-------------------------------------------------------------------
  # Ignore this environment marker if we're in a comment block.
  #
  return if $in{'comment'}{'block'};

  #-------------------------------------------------------------------
  # Since we've found an environment marker, we're no longer in the
  # document preamble.
  #
  end_preamble() if $in{'preamble'}{'text'};

  #-------------------------------------------------------------------
  # Make sure this is a known environment.
  #
  if (not exists $structure{$marker}) {
    printerror("unknown environment: $marker\n");
    return;
  }

  #-------------------------------------------------------------------
  # reset the table column counter
  #
  $current{'column'} = 0;

  #-------------------------------------------------------------------
  # begin or end the environment
  #
  if ($in{$marker}{'environment'}) {
    end_environment($marker);
  }

  else {
    begin_environment($marker);
  }

}

######################################################################

sub process_hide_block_marker {

  printdebug("process_hide_block_marker") if $DEBUGGING;

  #-------------------------------------------------------------------
  # track whether we're in or out of this environment
  #
  if ($in{'hide'}{'block'}) {
    printdebug("process_hide_block_marker: end hide block") if $DEBUGGING;
    $in{'hide'}{'block'} = 0;
  }

  else {
    printdebug("process_hide_block_marker: begin hide block") if $DEBUGGING;
    $in{'hide'}{'block'} = 1;
  }

}

######################################################################

sub process_comment_block_marker {

  printdebug("process_comment_block_marker") if $DEBUGGING;

  #-------------------------------------------------------------------
  # track whether we're in or out of this environment
  #
  if ($in{'comment'}{'block'}) {
    printdebug("end comment block") if $DEBUGGING;
    $in{'comment'}{'block'} = 0;
  }

  else {
    printdebug("begin comment block") if $DEBUGGING;
    $in{'comment'}{'block'} = 1;
  }

}

######################################################################

sub process_label {

  printdebug("process_label") if $DEBUGGING;

  my $label = shift;

  #-----------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, <<"END_OF_TEXT";
\\label{$label}

END_OF_TEXT
  }
}

######################################################################

# sub process_title_line {

#   printdebug("process_title_line") if $DEBUGGING;

#   my $text = shift;

#   $text =~ s/^\s*(.*)\s*$/$1/;
#   $document{'title'} .= $text;

# }

######################################################################

sub process_source_line {

  printdebug("process_source_line") if $DEBUGGING;

  my $text = shift;

  # don't do anything with this source line, PASS 2 took care of
  # processing all bibliography information
}

######################################################################

sub process_line {

  printdebug("process_line") if $DEBUGGING;

  my $text = shift;

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {
    my $html;

    if ($in{'pre'} or $in{'listing'}{'environment'}) {
      $html = escape_html_pre($text);
    }

    else {
      $html = escape_html($text);
    }

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};
    push @{ $aref }, $html;
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    my $latex;

    if ($in{'pre'} or $in{'listing'}{'environment'}) {
      $latex = escape_latex_pre($text);
    }

    else {
      $latex = escape_latex($text);
    }
    push @latex, $latex unless $in{'footnote'};
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    my $xml = escape_xml($text);
    push @xml, $xml;
  }

}

######################################################################

sub process_hide_line {

  printdebug("process_hide_line") if $DEBUGGING;

  my $text = shift;

  # Don't do anything with the text.  It is supposed to be hidden.

  return $EMPTY_STRING;

}

######################################################################

sub process_comment_line {

  printdebug("process_comment_line") if $DEBUGGING;

  my $text = shift;
  chomp($text);

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    # Within the comment line, convert double-dashes into
    # single-dashes.  Double-dashes interfere with HTML comment
    # markup.
    #
    $text =~ s/\b\-\-\b/-/g;

    my $html   = "<!-- $text -->\n";
    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};
    push @{ $aref }, $html;
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    my $latex = "%% $text\n";
    push @latex, $latex;
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    # my $xml  = "<!-- $text -->\n";
    my $xml  = "";
    push @xml, $xml;
  }

}

######################################################################

sub begin_index_text {

  printdebug("begin_index_text") if $DEBUGGING;

  # ARG 0: attr ('begin' or 'end')
  # ARG 1: text

  my $attr = shift;
  my $text = shift;
  my $num  = $count{'index'}{'total'};

  $data{'index'}{$num}{'attr'} = $attr;
  $data{'index'}{$num}{'text'} = $text;

  $in{'index'} = 1;

}

######################################################################

sub process_index_text {

  printdebug("process_index_text") if $DEBUGGING;

  # ARG 0: text

  my $text = shift;
  my $num  = $count{'index'}{'total'};

  $data{'index'}{$num}{'text'} .= " $text";

}

######################################################################

sub end_index_text {

  printdebug("end_index_text") if $DEBUGGING;

  $in{'index'} = 0;

  my $num  = $count{'index'}{'total'};
  my $attr = $data{'index'}{$num}{'attr'};
  my $text = $data{'index'}{$num}{'text'};

  # remove newlines from the text
  #
  $text = remove_newlines($text);

  # split out individual index entries
  #
  my @entries = split(/\s*\;\s*/, $text);

  # process individual index entries
  #
  foreach my $entry (@entries) {
    process_index_entry($entry,$attr);
  }

}

######################################################################

sub process_index_entry {

  # ARG 0: entry
  # ARG 1: attr ('begin' or 'end' indicator)

  my $entry = shift;
  my $attr  = shift;

  printdebug("process_index_entry $entry") if $DEBUGGING;

  end_pre()      if $in{'pre'};  # no index entries in pre
  end_preamble() if $in{'preamble'}{'text'}; # an index entry ends preamble

  #-------------------------------------------------------------------
  # The index entry might be marked up to be bold, underlined,
  # itaicized, or typewriter-type.  We need separate the index key
  # from the desired presentation so the term appears in the right
  # place alphabetically in the index.
  #
  my $key = $EMPTY_STRING;

  if ($entry =~ /^(\|\|)(.*?)(\|\|)(.*?)[\(\)]?/) {
    $key = $2 . $4;
  }

  if ($entry =~ /^(\*\*)(.*?)(\*\*)(.*?)[\(\)]?/) {
    $key = $2 . $4;
  }

  if ($entry =~ /^(\!\!)(.*?)(\!\!)(.*?)[\(\)]?/) {
    $key = $2 . $4;
  }

  if ($entry =~ /^(\~\~)(.*?)(\~\~)(.*?)[\(\)]?/) {
    $key = $2 . $4;
  }

  if ($entry =~ /^(\_\_)(.*?)(\_\_)(.*?)[\(\)]?/) {
    $key = $2 . $4;
  }

  #-------------------------------------------------------------------
  # HTML
  #
  #    Index processing is not yet implemented for the HTML rendition.

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    $entry = escape_xml($entry);

    push @xml, "<indexentry";
    push @xml, " key=\"$key\""  if $key;
    push @xml, " begin=\"yes\"" if $attr =~ /begin:/;
    push @xml, " end=\"yes\""   if $attr =~ /end:/;
    push @xml, ">$entry</indexentry>\n";

  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # PDF: This line that escapes the latex special character stuff
    # needs to go before the lines that insert pipes into the text if
    # this entry begins or ends an indexed region.  Otherwise, the
    # escape_latex routine would escape the inserted pipes and mess up
    # the index processing.
    #
    $entry = escape_latex($entry);

    #-----------------------------------------------------------------
    # PDF: If the index entry includes a 'begin:' or 'end:' indicator,
    # it means the entry begins or ends a *region* of text to be
    # indexed.  The LaTeX index entry must have a pipe (|) before an
    # open or close paren.
    #
    if ($attr =~ /begin:/) {
      $entry =~ s/^(.*?)\s*$/$1 |\(/; # begin index region
    }

    elsif ($attr =~ /end:/) {
      $entry =~ s/^(.*?)\s*$/$1 |\)/; # end index region
    }

    #-----------------------------------------------------------------
    # If there is a 'key' for this index entry (i.e. whenever the
    # index entry contains inline markup like bold, italics,
    # underline, etc.) then include both the 'key' and the 'text'
    # separated by an '@' sign.
    #
    my $latex = $EMPTY_STRING;

    if ($key) {
      $latex = $key . "@" . $entry;
    }

    else {
      $latex = $entry;
    }

    #-----------------------------------------------------------------
    # Insert the index entry into the LaTeX array.
    #
    push @latex, <<"END_OF_TEXT";
\\index{$latex}

END_OF_TEXT
  }
}

######################################################################

sub begin_outcome_text {

  printdebug("begin_outcome_text") if $DEBUGGING;

  # ARG 0: attr ('begin' or 'end')
  # ARG 1: text

  my $attr = shift;
  my $text = shift;
  my $num  = $count{'outcome'}{'total'};

  $data{'outcome'}{$num}{'attr'} = $attr;
  $data{'outcome'}{$num}{'text'} = $text;

  $in{'outcome'} = 1;

}

######################################################################

sub process_outcome_text {

  printdebug("process_outcome_text") if $DEBUGGING;

  # ARG 0: text

  my $text = shift;
  my $num  = $count{'outcome'}{'total'};

  $data{'outcome'}{$num}{'text'} .= " $text";

}

######################################################################

sub end_outcome_text {

  printdebug("end_outcome_text") if $DEBUGGING;

  $in{'outcome'} = 0;

  my $num  = $count{'outcome'}{'total'};
  my $attr = $data{'outcome'}{$num}{'attr'};
  my $text = $data{'outcome'}{$num}{'text'};

  # remove newlines from the text
  #
  $text = remove_newlines($text);

  process_outcome_entry($text,$attr);

}

######################################################################

sub process_outcome_entry {

  # ARG 0: text
  # ARG 1: attr (<date>:<item>:<status>)

  my $text    = shift;
  my $attr    = shift;
  my $secnum  = $current{'secnum'};
  my $name    = '';
  my $title   = '';
  my $bgcolor = '';

  printdebug("process_outcome_entry $attr") if $DEBUGGING;

  end_pre()      if $in{'pre'};              # no outcome entries in pre
  end_preamble() if $in{'preamble'}{'text'}; # an outcome entry ends preamble

  #-------------------------------------------------------------------
  # Split out attributes
  #
  my ($date,$item,$status) = split(/:/, $attr);

  #-------------------------------------------------------------------
  # Check that date value makes sense
  #
  if ($date !~ /\d\d\d\d-\d\d-\d\d/) {
    printwarning("date \"$date\" not in form yyyy-mm-dd");
  }

  #-------------------------------------------------------------------
  # Get name and title
  #
  if (label_exists($item)) {
    $name  = name_for($item);
    $title = $lookup{$item}{'title'};
  } else {
    printwarning("item \"$item\" does not exist");
  }

  #-------------------------------------------------------------------
  # Get status color
  #
  if ($status =~ /green|yellow|red|grey|gray/) {
    $bgcolor = html_cell_bgcolor_for($status);
  } else {
    printwarning("status \"$status\" should be one of: green, yellow, red, or grey");
  }

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $icon       = html_status_icon_for($status);
    my $aref       = $html{'body'}{$secnum};
    my $html_title = escape_html($title);

    # !!! BUG HERE !!!
    #
    # For some reason, submitting $text in the following line of code
    # to the escape_html() subroutine causes the application to hang
    # due to italics markup.  Therefore, I've temporarily left $text
    # un-escaped (2009-07-06).
    #
    # THEORY: Perhaps, $text is a multi-line scalar and escape_html()
    # only works on single-line scalars?

    my $html_text  = escape_html($text);
    my $outfile    = html_outfile_for_label($item);

    push @{ $aref }, <<"END_OF_TEXT";
<table width="100%" cellpadding="2" cellspacing="2">
<tr>
<td width="15%">$icon &nbsp; $status<br/>$date</td>
<td width="35%">$name <a href="$outfile#$item">$item</a> - $html_title</td>
<td width="50%">Outcome: $html_text</td>
</tr>
</table>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {

    # !!! BUG HERE !!!
    #
    # Write XML rendering code for outcomes.

  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    my $icon        = latex_status_icon_for($status);
    my $latex_title = escape_latex($title);
    my $latex_text  = escape_latex($text);
    my $latex_item  = escape_latex('[id:' . $item . ']');

    my $cell_1 = wrap("$icon $status $date");
    my $cell_2 = wrap("$name $latex_item - $latex_title");
    my $cell_3 = wrap("Outcome: $latex_text");

    #-----------------------------------------------------------------
    # outcome table
    #
    push @latex, <<"END_OF_TEXT";
%% begin outcome longtable
%%
\\begin{longtable}[l]{%
\@{}
>{\\small\\raggedright\\arraybackslash}p{0.10\\textwidth}
>{\\small\\raggedright\\arraybackslash}p{0.35\\textwidth}
>{\\small\\raggedright\\arraybackslash}p{0.55\\textwidth}
\@{}
}
\\tabularnewline
\\endfirsthead
\\tabularnewline
\\endhead
\\tabularnewline
\\endfoot
\\endlastfoot

%% outcome table row
%%
$cell_1
&
$cell_2
&
$cell_3
\\\\

\\end{longtable}
%%
%% end outcome table

END_OF_TEXT
  }

}

######################################################################

sub begin_review_text {

  printdebug("begin_review_text") if $DEBUGGING;

  # ARG 0: attr ('begin' or 'end')
  # ARG 1: text

  my $attr = shift;
  my $text = shift;
  my $num  = $count{'review'}{'total'};

  $data{'review'}{$num}{'attr'} = $attr;
  $data{'review'}{$num}{'text'} = $text;

  $in{'review'} = 1;

}

######################################################################

sub process_review_text {

  printdebug("process_review_text") if $DEBUGGING;

  # ARG 0: text

  my $text = shift;
  my $num  = $count{'review'}{'total'};

  $data{'review'}{$num}{'text'} .= " $text";

}

######################################################################

sub end_review_text {

  printdebug("end_review_text") if $DEBUGGING;

  $in{'review'} = 0;

  my $num  = $count{'review'}{'total'};
  my $attr = $data{'review'}{$num}{'attr'};
  my $text = $data{'review'}{$num}{'text'};

  # remove newlines from the text
  #
  $text = remove_newlines($text);

  process_review_entry($text,$attr);

}

######################################################################

sub process_review_entry {

  # ARG 0: text
  # ARG 1: attr (<date>:<item>:<status>)

  my $text    = shift;
  my $attr    = shift;
  my $secnum  = $current{'secnum'};
  my $name    = '';
  my $title   = '';
  my $bgcolor = '';

  printdebug("process_review_entry $attr") if $DEBUGGING;

  end_pre()      if $in{'pre'};              # no review entries in pre
  end_preamble() if $in{'preamble'}{'text'}; # an review entry ends preamble

  #-------------------------------------------------------------------
  # Split out attributes
  #
  my ($date,$item,$status) = split(/:/, $attr);

  #-------------------------------------------------------------------
  # Check that date value makes sense
  #
  if ($date !~ /\d\d\d\d-\d\d-\d\d/) {
    printwarning("date \"$date\" not in form yyyy-mm-dd");
  }

  #-------------------------------------------------------------------
  # Get name and title
  #
  if (label_exists($item)) {
    $name  = name_for($item);
    $title = $lookup{$item}{'title'};
  } else {
    printwarning("item \"$item\" does not exist");
  }

  #-------------------------------------------------------------------
  # Get status color
  #
  if ($status =~ /green|yellow|red|grey|gray/) {
    $bgcolor = html_cell_bgcolor_for($status);
  } else {
    printwarning("status \"$status\" should be one of: green, yellow, red, or grey");
  }

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $icon       = html_status_icon_for($status);
    my $aref       = $html{'body'}{$secnum};
    my $html_title = escape_html($title);

    # !!! BUG HERE !!!
    #
    # For some reason, submitting $text in the following line of code
    # to the escape_html() subroutine causes the application to hang
    # due to italics markup.  Therefore, I've temporarily left $text
    # un-escaped (2009-07-06).
    #
    # THEORY: Perhaps, $text is a multi-line scalar and escape_html()
    # only works on single-line scalars?

    my $html_text  = escape_html($text);
    my $outfile    = html_outfile_for_label($item);

    push @{ $aref }, <<"END_OF_TEXT";
<table width="100%" cellpadding="2" cellspacing="2">
<tr>
<td width="15%">$icon &nbsp; $status<br/>$date</td>
<td width="35%">$name <a href="$outfile#$item">$item</a> - $html_title</td>
<td width="50%">Review: $html_text</td>
</tr>
</table>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {

    # !!! BUG HERE !!!
    #
    # Write XML rendering code for reviews.

  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    my $icon        = latex_status_icon_for($status);
    my $latex_title = escape_latex($title);
    my $latex_text  = escape_latex($text);
    my $latex_item  = escape_latex('[id:' . $item . ']');

    my $cell_1 = wrap("$icon $status $date");
    my $cell_2 = wrap("$name $latex_item - $latex_title");
    my $cell_3 = wrap("Review: $latex_text");

    #-----------------------------------------------------------------
    # review table
    #
    push @latex, <<"END_OF_TEXT";
%% begin review longtable
%%
\\setlength\\LTpre{0pt}
\\setlength\\LTpost{0pt}
\\setlength\\LTleft{0pt}
\\setlength\\LTright{0pt}
\\begin{longtable}[l]{%
\@{}
>{\\small\\raggedright\\arraybackslash}p{0.10\\textwidth}
>{\\small\\raggedright\\arraybackslash}p{0.32\\textwidth}
>{\\small\\raggedright\\arraybackslash}p{0.52\\textwidth}
\@{}
}
\\tabularnewline
\\endfirsthead
\\tabularnewline
\\endhead
\\tabularnewline
\\endfoot
\\endlastfoot

%% review table row
%%
$cell_1
&
$cell_2
&
$cell_3
\\\\

\\end{longtable}
%%
%% end review table

END_OF_TEXT
  }

}

######################################################################

sub process_heading {

  # Process a heading line.  This subroutine should ONLY be called
  # during pass three processing.

  printdebug("process_heading") if $DEBUGGING;

  my $asterisks = shift;
  my $text      = shift;

  ++$count{'section'}{'total'};

  my $num  = $count{'section'}{'total'};
  my $prev = $num - 1;
  my $next = $num + 1;

  #-------------------------------------------------------------------
  # section label
  #
  #     Retrieve the section label cached during pass 2.  Also
  #     determine the previous and next labels.  This might come in
  #     handy for navigation purposes.
  #
  my $label      = $data{'section'}{$num}{'label'}  || $EMPTY_STRING;
  my $prev_label = $data{'section'}{$prev}{'label'} || $EMPTY_STRING;
  my $next_label = $data{'section'}{$next}{'label'} || $EMPTY_STRING;

  printdebug "rendering sec $num heading (label \"$label\")" if $DEBUGGING;

  #-------------------------------------------------------------------
  # end things
  #
  #     Since we've found a section heading, it means we've reached
  #     the end of certain other contexts.
  #
  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};
  end_preamble()      if $in{'preamble'}{'text'};
  end_current_context();

  #-------------------------------------------------------------------
  # section depth
  #
  #     Remember the previous section depth, and determine the current
  #     section depth.
  #
  $previous{'depth'} = $current{'depth'};
  $current{'depth'}  = length $asterisks;

  #-------------------------------------------------------------------
  # in section
  #
  #     Remember that we're in a section.
  #
  $in{'section'}{'text'} = 1;

  #-------------------------------------------------------------------
  # reset step count
  #
  #    For now, I'm going to reset the step counter whenever a heading
  #    is found.  This means that a series of steps will be numbered
  #    within a section but not across section boundaries.  I could
  #    also imagine it might be nice to have all the steps in an
  #    entire chapter (or hands-on lab) be numbered.  But, we'll
  #    figure that out later.
  #
  $count{'step'}{'section'} = 0;

  #-------------------------------------------------------------------
  # reset the table column counter
  #
  #     A series of table columns cannot cross a section boundary.
  #
  $current{'column'} = 0;

  #-------------------------------------------------------------------
  # section numbering
  #
  #     To understand the following section number logic imagine the
  #     previous section heading was a four level heading like:
  #
  #       **** Previous Section Heading
  #
  #     and that the current section heading is a level 2 heading
  #     like:
  #
  #       ** Current Section Heading
  #
  #     For the sake of illustration, let's assume the previous 4
  #     level section was "3.4.12.5" so that the new 2 level section
  #     should be numbered 3.5.
  #
  #     If the previous section heading was "deeper" than this section
  #     heading (i.e. 3.4.12.5 is "deeper" than 3.5) then reset the
  #     counters to zero for the deeper levels (in the example case
  #     levels 3 and 4 which have the values 12 and 5). In the example
  #     case from section 3.4.12.5 to 3.5, the level 4 (previously 5)
  #     and level three (previously 12) counters get reset to zero.
  #
  if ($previous{'depth'} > $current{'depth'}) {
    my $temp_depth = $previous{'depth'};
    while ($temp_depth > $current{'depth'}) {
      $scounter{$temp_depth} = 0;
      -- $temp_depth;
    }
  }

  if ($previous{'depth'} > $current{'depth'}) {
    my $temp_depth = $previous{'depth'};
    while ($temp_depth > $current{'depth'}) {
      $dcounter{$temp_depth} = 0;
      -- $temp_depth;
    }
  }

  #-------------------------------------------------------------------
  # increment current depth counter
  #
  #     Increment the value of the counter for the current depth.  The
  #     current depth is determined by the number of asterisks
  #     preceding the current section heading (in our example case,
  #     the current depth is 2, the previous value of the level two
  #     counter was 4, so this get incremented to 5 (remember 3.4.12.5
  #     -> 3.5)
  #
  ++ $scounter{$current{'depth'}};
  ++ $dcounter{$current{'depth'}};

  if ($current{'depth'} == 1
      and $dcounter{1} =~ /^\d+$/
      and $data{'section'}{$num}{'type'} eq 'appendix'
     ) {
    $dcounter{1} = 'A';
  }

  #-------------------------------------------------------------------
  # section number
  #
  #     Construct the current section number (i.e. 3.5).
  #
  my $depth = 1;
  $current{'secnum'} = $scounter{$depth};
  while ($depth < $current{'depth'}) {
    ++ $depth;
    $current{'secnum'} .= '.' . $scounter{$depth};
  }

  my $depth = 1;
  $current{'dsecnum'} = $dcounter{$depth};
  while ($depth < $current{'depth'}) {
    ++ $depth;
    $current{'dsecnum'} .= '.' . $dcounter{$depth};
  }

  my $level = $current{'depth'};
  $level = $MAX_SEC_DEPTH if $level > $MAX_SEC_DEPTH;
  my $toc_indent = $level * 30; # used for HTML only
  my $secnum  = $current{'secnum'};
  my $dsecnum = $current{'dsecnum'};

  #-------------------------------------------------------------------
  # special type of section?
  #
  #     Find out if this section has a special type assigned to it
  #     (preface, section, chapter, appendix, etc.) -- this would have
  #     been discovered in pass 2.
  #
  $current{'sectype'} = $data{'section'}{$num}{'type'} || 'section';
  my $sectype = $current{'sectype'};
  my $ucf_sectype = ucfirst($sectype);

  #-------------------------------------------------------------------
  # escape special characters
  #
  #     I'm not yet sure where these should go inside the rendition
  #     blocks...
  #
  my $html_text  = escape_html($text);
  my $xml_text   = escape_xml($text);
  my $latex_text = escape_latex($text);

  #-------------------------------------------------------------------
  # toplevel heading
  #
  if ($level == 1) {

    $heading_in_slide_index         = 0;
    $heading_in_sidebar_index       = 0;
    $heading_in_quotation_index     = 0;
    $heading_in_problem_index       = 0;
    $heading_in_solution_index      = 0;
    $heading_in_allocation_index    = 0;
    $heading_in_assignment_index    = 0;
    $heading_in_priority_index      = 0;
    $heading_in_test_index          = 0;
    $heading_in_task_index          = 0;
    $heading_in_result_index        = 0;
    $heading_in_role_index          = 0;
    $heading_in_demo_index          = 0;
    $heading_in_exercise_index      = 0;
    $heading_in_listing_index       = 0;
    $heading_in_todo_index          = 0;
    $heading_in_footnote_index      = 0;
    $heading_in_table_index         = 0;
    $heading_in_revisions_index     = 0;
    $heading_in_updates_index       = 0;
    $heading_in_figure_index        = 0;
    $heading_in_attachment_index    = 0;

    $count{'table'}{'section'}      = 0;
    $count{'figure'}{'section'}     = 0;
    $count{'attachment'}{'section'} = 0;
    $count{'listing'}{'section'}    = 0;
    $count{'exercise'}{'section'}   = 0;

    my $ucsectype = ucfirst($sectype);

    $current{'top_heading'} = "$ucsectype $dsecnum - $text";
    $current{'heading'} = "$ucsectype $dsecnum - $text";

    #-----------------------------------------------------------------
    # HTML
    #
    if ($rendering{'html'} and not $in{'hide'}{'block'}) {

      my $outfile = html_outfile_for_secnum($secnum);
      my $aref    = $html{'body'}{$secnum};

      #---------------------------------------------------------------
      # TOC Entry
      #
      push @{ $html{'toc'} }, <<"END_OF_TEXT";
<h4>$ucf_sectype $dsecnum &nbsp;&nbsp; <a href="$outfile#$sectype.$secnum">$html_text</a></h4>

END_OF_TEXT

      #---------------------------------------------------------------
      # Previous, Contents, and Next Links
      #
      my $prev_secnum    = $section{$secnum}{'previous'};
      my $prev_sectype   = ucfirst($lookup{$prev_label}{'type'});
      my $prev_title     = escape_html($lookup{$prev_label}{'title'});
      my $prev_outfile   = html_outfile_for_secnum($prev_secnum);
      my $prev_link      = '';
      my $next_secnum    = $section{$secnum}{'next'};
      my $next_sectype   = ucfirst($lookup{$next_label}{'type'});
      my $next_title     = escape_html($lookup{$next_label}{'title'});
      my $next_outfile   = html_outfile_for_secnum($next_secnum);
      my $next_link      = '';
      my $contents_title = $document{'title'};
      my $contents_link  = "<a href=\"$html_toc_file\">$contents_title</a>";

      if ($prev_secnum) {
	$prev_link = "<a href=\"$prev_outfile\">&lt; PREVIOUS $prev_sectype $prev_secnum</a>";
      }

      if ($next_secnum) {
	$next_link = "<a href=\"$next_outfile\">$next_sectype $next_secnum NEXT &gt;</a>";
      }

      push @{ $aref }, <<"END_OF_TEXT";
<!-- previous and next sections -->
<table width="100%">
<tr>
<td width="20%" align="left">$prev_link</td>
<td width="60%" align="center">$contents_link</td>
<td width="20%" align="right">$next_link</td>
</tr>
</table>

END_OF_TEXT

      #---------------------------------------------------------------
      # Label Anchor
      #
      if ($label) {
	push @{ $aref }, <<"END_OF_TEXT";
<a name="$label">

END_OF_TEXT
      }

      #---------------------------------------------------------------
      # Heading and Section Anchor
      #
      push @{ $aref }, <<"END_OF_TEXT";
<a name="$sectype.$secnum">
<h$level>$ucf_sectype $dsecnum<br/>$html_text</h$level>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # XML
    #
    if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
      push @xml, <<"END_OF_TEXT";
<heading level="$level" type="$sectype">$xml_text</heading>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # PDF
    #
    if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

      #---------------------------------------------------------------
      # PDF: Book Appendix.
      #
      #     If the section type has changed to appendix, and we're
      #     making a book, start rendering appendices.
      #
      if ($sectype =~ /Appendix/i
          and not $in{'appendix'}
          and $document{'doctype'} eq 'book') {
        $in{'appendix'} = 1;
        push @latex, <<"END_OF_TEXT";
%% begin appendix
%%
\\appendix
\\chapter{$latex_text}

END_OF_TEXT

        #---------------------------------------------------------------
        # PDF: Headings in Lists
        #
	insert_frontmatter_list_headings('thechapter',"$latex_text");

      }

      #---------------------------------------------------------------
      # PDF: Book or Report Preface.
      #
      #     Else if this is supposed to be a preface, and we're making
      #     a book, render it in the '*' form so it does not get a
      #     number like a normal chapter would
      #
      elsif ($sectype =~ /Preface/i
             and
             ($document{'doctype'} eq 'book'
              or
              $document{'doctype'} eq 'report')) {

        push @latex, <<"END_OF_TEXT";
%% begin preface
%%
\\chapter*{$latex_text}

END_OF_TEXT

        #---------------------------------------------------------------
        # PDF: Headings in Lists
        #
	insert_frontmatter_list_headings('thechapter',"$latex_text");

      }

      #---------------------------------------------------------------
      # PDF: Article Preface.
      #
      #     Else if this is supposed to be a preface, and we're making
      #     an article, render it in the '*' form so it does not get a
      #     number like a normal section would
      #
      elsif ($sectype =~ /Preface/i and $document{'doctype'} eq 'article') {

        push @latex, <<"END_OF_TEXT";
%% begin preface
%%
\\section*{$latex_text}

END_OF_TEXT

        #---------------------------------------------------------------
        # PDF: Headings in Lists
        #
	insert_frontmatter_list_headings('thesection',"$latex_text");

      }

      #---------------------------------------------------------------
      # PDF: Book or Report Chapter.
      #
      #     Else this is a normal old chapter, render it that way.
      #
      elsif ($document{'doctype'} eq 'book'
             or $document{'doctype'} eq 'report') {

        push @latex, <<"END_OF_TEXT";
%% begin chapter
%%
\\chapter{$latex_text}

END_OF_TEXT

        #---------------------------------------------------------------
        # PDF: Headings in Lists
        #
	insert_frontmatter_list_headings('thechapter',"$latex_text");

      }

      #---------------------------------------------------------------
      # PDF: Article Section.
      #
      #     If you've made it this far, we're not making a book or
      #     report, must be an article
      #
      else {

        push @latex, <<"END_OF_TEXT";
%% begin section
%%
\\section{$latex_text}

END_OF_TEXT

        #---------------------------------------------------------------
        # PDF: Headings in Lists
        #
	insert_frontmatter_list_headings('thesection',"$latex_text");

      }

      #---------------------------------------------------------------
      # PDF: Label.
      #
      #     Add the user-defined section label if there is one.
      #
      if ($label) {

        push @latex, <<"END_OF_TEXT";
\\label{$label}

END_OF_TEXT

	if ($DEBUGGING) {
	  printdebug("process_heading: inserting section label $label");
	}

      } elsif ($DEBUGGING) {
	printdebug("process_heading: label not defined for section $num");
      }

    }

    printstatus("$sectype $secnum - $current{'heading'}");
  }

  #-------------------------------------------------------------------
  # ...otherwise, this ISN'T a toplevel heading...
  #
  else {

    printstatus("$sectype $dsecnum - $text");
    $current{'heading'} = "$current{'dsecnum'} - $text";

    #-----------------------------------------------------------------
    # HTML
    #
    if ($rendering{'html'} and not $in{'hide'}{'block'}) {

      #---------------------------------------------------------------
      # TOC Entry
      #
      my $outfile = html_outfile_for_secnum($secnum);
      my $anchor  = "$sectype.$secnum";
      my $aref    = $html{'body'}{$secnum};

      push @{ $html{'toc'} }, <<"END_OF_TEXT";
<div style="text-indent: ${toc_indent}pt; font-size: 8pt;">$dsecnum &nbsp;&nbsp; <a href="$outfile#$anchor">$html_text</a></div>

END_OF_TEXT

      #---------------------------------------------------------------
      # Previous and Next Links
      #
      my $prev_secnum  = $section{$secnum}{'previous'};
      my $prev_sectype = ucfirst($lookup{$prev_label}{'type'});
      my $prev_title   = escape_html($lookup{$prev_label}{'title'});
      my $prev_outfile = html_outfile_for_secnum($prev_secnum);
      my $prev_link    = '';
      my $next_secnum  = $section{$secnum}{'next'};
      my $next_sectype = ucfirst($lookup{$next_label}{'type'});
      my $next_title   = escape_html($lookup{$next_label}{'title'});
      my $next_outfile = html_outfile_for_secnum($next_secnum);
      my $next_link    = '';
      my $contents_title    = $document{'title'};
      my $contents_link     = "<a href=\"$html_toc_file\">$contents_title</a>";

      if ($prev_secnum) {
	$prev_link = "<a href=\"$prev_outfile\">&lt; PREVIOUS $prev_sectype $prev_secnum</a>";
      }

      if ($next_secnum) {
	$next_link = "<a href=\"$next_outfile\">$next_sectype $next_secnum NEXT &gt;</a>";
      }

      push @{ $aref }, <<"END_OF_TEXT";
<!-- previous and next sections -->
<table width="100%">
<tr>
<td width="20%" align="left">$prev_link</td>
<td width="60%" align="center">$contents_link</td>
<td width="20%" align="right">$next_link</td>
</tr>
</table>

END_OF_TEXT

      #---------------------------------------------------------------
      # Label Anchor
      #
      if ($label) {
	push @{ $aref }, <<"END_OF_TEXT";
<a name="$label">

END_OF_TEXT
      }

      #---------------------------------------------------------------
      # Heading and Section Anchor
      #
      push @{ $aref }, <<"END_OF_TEXT";
<a name="$sectype.$secnum">
<h$level>$dsecnum &nbsp;&nbsp; $html_text</h$level>

END_OF_TEXT

    }

    #-----------------------------------------------------------------
    # XML
    #
    if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
      push @xml, <<"END_OF_TEXT";
<heading level="$level">$xml_text</heading>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # PDF
    #
    if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

      #---------------------------------------------------------------
      # PDF: Preface.
      #
      #     If the $current{'sectype'} is 'preface' then we want to
      #     use the * form of the sectioning commands to surpress
      #     section numbering.
      #
      if ($current{'sectype'} =~ /Preface/i) {

        if ($level == 2
	    and ($document{'doctype'} eq 'book'
		 or $document{'doctype'} eq 'report')) {

          push @latex, <<"END_OF_TEXT";
%% begin section
%%
\\section*{$latex_text}

END_OF_TEXT

          #---------------------------------------------------------------
          # PDF: Headings in Lists
          #
	  insert_frontmatter_list_headings('thesection',"$latex_text");

        }

        elsif ($level == 3
	       and ($document{'doctype'} eq 'book'
		    or $document{'doctype'} eq 'report')) {

          push @latex, <<"END_OF_TEXT";
%% begin subsection
%%
\\subsection*{$latex_text}

END_OF_TEXT

          #---------------------------------------------------------------
          # PDF: Headings in Lists
          #
	  insert_frontmatter_list_headings('thesubsection',"$latex_text");

        }

        elsif ($level == 4
	       and ($document{'doctype'} eq 'book'
		    or $document{'doctype'} eq 'report')) {

          push @latex, <<"END_OF_TEXT";
%% begin subsubsection
%%
\\subsubsection*{$latex_text}

END_OF_TEXT

          #---------------------------------------------------------------
          # PDF: Headings in Lists
          #
	  insert_frontmatter_list_headings('thesubsubsection',"$latex_text");

        }

        elsif ($level == 2) {
          push @latex, <<"END_OF_TEXT";
%% begin subsection
%%
\\subsection*{$latex_text}

END_OF_TEXT

          #---------------------------------------------------------------
          # PDF: Headings in Lists
          #
	  insert_frontmatter_list_headings('thesubsection',"$latex_text");

        }

        elsif ($level == 3) {
          push @latex, <<"END_OF_TEXT";
%% begin subsubsection
%%
\\subsubsection*{$latex_text}

END_OF_TEXT

          #---------------------------------------------------------------
          # PDF: Headings in Lists
          #
	  insert_frontmatter_list_headings('thesubsubsection',"$latex_text");

        }

        else {
          push @latex, "\n\\textbf{$latex_text}\n";
        }
      }

      #---------------------------------------------------------------
      # PDF: Ordinary Section.
      #
      #     If you've made it this far it means we're NOT in the
      #     preface and we're NOT rendering the heading of a toplevel
      #     section
      #
      else {

        if ($level == 2
	    and ($document{'doctype'} eq 'book'
		 or $document{'doctype'} eq 'report')) {

          push @latex, <<"END_OF_TEXT";
%% begin section
%%
\\section{$latex_text}

END_OF_TEXT

          #---------------------------------------------------------------
          # PDF: Headings in Lists
          #
	  insert_frontmatter_list_headings('thesection',"$latex_text");

        }

        elsif ($level == 3
	       and ($document{'doctype'} eq 'book'
		    or $document{'doctype'} eq 'report')) {

          push @latex, <<"END_OF_TEXT";
%% begin subsection
%%
\\subsection{$latex_text}

END_OF_TEXT

          #---------------------------------------------------------------
          # PDF: Headings in Lists
          #
	  insert_frontmatter_list_headings('thesubsection',"$latex_text");

        }

        elsif ($level == 4
	       and ($document{'doctype'} eq 'book'
		    or $document{'doctype'} eq 'report')) {

          push @latex, <<"END_OF_TEXT";
%% begin subsubsection
%%
\\subsubsection{$latex_text}

END_OF_TEXT

          #---------------------------------------------------------------
          # PDF: Headings in Lists
          #
	  insert_frontmatter_list_headings('thesubsubsection',"$latex_text");

        }

        elsif ($level == 2) {
          push @latex, <<"END_OF_TEXT";
%% begin subsection
%%
\\subsection{$latex_text}

END_OF_TEXT

          #---------------------------------------------------------------
          # PDF: Headings in Lists
          #
	  insert_frontmatter_list_headings('thesubsection',"$latex_text");

        }

        elsif ($level == 3) {
          push @latex, <<"END_OF_TEXT";
%% begin subsubsection
%%
\\subsubsection{$latex_text}

END_OF_TEXT

          #---------------------------------------------------------------
          # PDF: Headings in Lists
          #
	  insert_frontmatter_list_headings('thesubsubsection',"$latex_text");

        }

        else {
          push @latex, "\n\\textbf{$latex_text}\n";
        }
      }

      #---------------------------------------------------------------
      # PDF: Label.
      #
      #     Add the user-defined section label if there is one.
      #
      if ($label) {

        push @latex, <<"END_OF_TEXT";
\\label{$label}

END_OF_TEXT
      }
    }
  }
}

######################################################################

sub resolve_includes {

  # ARG 0: path/to/filename
  # ARG 1: array ref for variables

  #-------------------------------------------------------------------
  # RESOLVE INCLUDES
  #
  #     Parse a file and recursively resolve any "included" files.
  #
  #     The structured manuscript language (SML) allows you to include
  #     one file within another by putting the word 'include:' at the
  #     beginning of the line followed by the filename of the file you
  #     wish to include:
  #
  #       include: other-file.txt
  #
  #-------------------------------------------------------------------
  # INS AND OUTS
  #
  #     Inputs:
  #
  #         ARG 0 => path/to/filename
  #         ARG 1 => array ref for variables
  #
  #     Outputs:
  #
  #         updated "%svninfo"             global hash
  #         updated "$nesting_level"       global scalar
  #         updated "@nesting_stack"       global array
  #         updated "%current_line"        global hash
  #         updated "%in_preamble"         global hash
  #         updated "%seen_title"          global hash
  #         updated "%region_marker"       global hash
  #         updated "%region_type"         global hash
  #         updated "$region_baton"        global scalar
  #         updated "%begin_region"        global hash
  #         updated "%end_region"          global hash
  #         updated "%current"             global hash
  #         updated "%files"               global hash
  #         updated "%in"                  global hash
  #         updated "%include_as_section"  global hash
  #         updated "%hide_marker"         global hash
  #         updated "%raw_marker"          global hash
  #         updated "%data"                global hash
  #
  #-------------------------------------------------------------------
  # INCLUDE VARIATIONS
  #
  #     There are six variations on how a file can be included: (1)
  #     as-is, (2) flat, (3) section, (4) region, (5) hide, and (6)
  #     raw:
  #
  #     (1) as-is
  #
  #         The default behavior is to include a file ``as-is.''  That
  #         is, the program simply inserts the contents of the file
  #         into the containing file exactly as-is.
  #
  #         include: my-file.txt
  #
  #     (2) flat
  #
  #         On rare occasions, you may wish to convert all section
  #         headings in the included file to simple bold text to
  #         "flatten" the section structure.
  #
  #         include:flat: my-sectioned-file.txt
  #
  #     (3) section
  #
  #         Many files have titles.  Titles of included files become
  #         section headings in the containing document.  Section
  #         heading in included files become sub-section headings in
  #         the containing document.
  #
  #         In SML, section headings are indicated using one or more
  #         asterisks at the beginning of a line.  You can choose the
  #         section heading level of the included file title using the
  #         following syntax.
  #
  #         include:*: my-section.txt
  #
  #         include:**: my-subsection.txt
  #
  #         include:***: my-subsubsection.txt
  #
  #     (4) region
  #
  #         There are some special cases when you need to include a
  #         file as a document region such as an exercise, demo,
  #         problem, solution, allocation, or assignment.  For
  #         instance, if you want to include a file as an exercise,
  #         use the syntax:
  #
  #         include:exercise: my-exercise.txt
  #
  #         This 'resolve_includes' subroutine will insert the
  #         exercise begin and end region markings so you don't have
  #         to put them into the included file.
  #
  #     (5) hide
  #
  #         Occasionally you may need meta-data from included regions,
  #         (i.e. data elements such as titles and descriptions) even
  #         though you DON'T want the region to appear in the
  #         published document.  In other words, you want to include,
  #         but hide, the included file's content:
  #
  #         include:problem:hide: my-problem-for-reference.txt
  #
  #     (6) raw
  #
  #         If the included file contains an environment like a table
  #         or listing the author needs it included in it's 'raw'
  #         state.  In other words, don't convert the title to and
  #         section, and also don't convert the title to a bold
  #         string.
  #
  #         include:raw: my-table.txt
  #
  #-------------------------------------------------------------------
  # INLINE CURRENT REVISION OF INCLUDED FILE
  #
  #     In addition to the six variations on how you may include a
  #     file, the SML "include:" syntax provides a revision field
  #     feature.
  #
  #         include:$r45$: my-file.txt
  #
  #         include:problem:$r123$: my-problem.txt
  #
  #     This script automatically updates the number in the revision
  #     field ($r<num>$) to the current revision number of the
  #     included file.  Changes to included files thus trigger changes
  #     to containing files forcing version bumps of containing files.
  #
  #-------------------------------------------------------------------
  # PASSING VARIABLES
  #
  #     You may pass one or more variables to an included file.  The
  #     variables get substituted at the time the file is included.
  #     There are two ways to pass variables to an included file: (1)
  #     in a one-line "include" directive, and (2) in an "include
  #     region."  The following 2 examples are equivalent.
  #
  #     One-line "include" directive:
  #
  #         include:item=rq-000291: files/includes/item-summary.txt
  #
  #     Include region:
  #
  #         ---include
  #         file: files/includes/item-summary.txt
  #         var: item = rq-000291
  #         ---include
  #
  #-------------------------------------------------------------------
  # ITERATIVE INCLUDES
  #
  #     You may create iterative 'includes' that include the same file
  #     (template) iteratively, passing different variables to each
  #     iteration like this:
  #
  #         ...include
  #         file: template.txt
  #         1:var: id = ci-001
  #         2:var: id = ci-002
  #         3:var: id = ci-003
  #         ...include
  #
  #     Or this:
  #
  #         ...include
  #         file: template.txt
  #         values:id: ci-001,ci-002,ci-003
  #         ...include
  #
  #     The program (internally) will turn these into:
  #
  #         ---include
  #         file: template.txt
  #         var: id = ci-001
  #         ---include
  #
  #         ---include
  #         file: template.txt
  #         var: id = ci-002
  #         ---include
  #
  #         ---include
  #         file: template.txt
  #         var: id = ci-003
  #         ---include
  #
  #-------------------------------------------------------------------
  # SUBROUTINE OUTLINE
  #
  # 2  1  Get file and variables to be included
  # 2  2  Print debugging message
  # 2  3  DIE and throw error message IF file not readable
  # 2  4  Gather SVN meta-data for this file
  # 2  5  Increment nesting level
  # 2  6  Compute next level
  # 2  7  Build filename nest
  # 2  8  Initialize parsing state variables
  # 2  9  Remember previous state (previous file and line)
  # 2 10  Initialize current file and line
  # 2 11  Make list of allowed 'include' data elements
  # 2 12  IF the region baton is set
  # 4     1  Set region_type to the value of region_baton
  # 2 13  ELSE the region baton is NOT set
  # 4     1  Initialize region_type to EMPTY
  # 2 14  Initialize region_baton to EMPTY
  # 2 15  Provide user feedback
  # 2 16  Initialize array for file content
  # 2 17  Open the file to be included
  # 2 18  WHILE loop (each LINE):
  # 4     1  Update parsing state variables (current line)
  # 4     2  Remember this line in %files data structure
  # 4     3  Print debugging message
  # 4     4  FOREACH hash ref in vars array
  # 6        1  FOREACH key in hash
  # 8           1  Get value
  # 8           2  Substitute all instances of var on this line
  # 4     5  IF SVN inline version comment present
  # 6        1  Gather current SVN meta-data
  # 4     6  IF SVN inline date comment present
  # 6        1  Gather current SVN meta-data
  # 4     7  IF SVN inline author comment present
  # 6        1  Gather current SVN meta-data
  # 4     8  IF SVN revision in include directive present
  # 6        1  Gather current SVN meta-data
  # 4     9  IF not seen_title at this level
  # 6        1  FOREACH block name defined in %structure
  # 8          1  IF begin environment or region named block
  # 10            1  Set seen_title flag for this level
  #
  # Comment block
  #
  # 4    10  IF line is comment block marker
  # 6        1  IF in comment block
  # 8           1  Set state, no longer in comment block
  # 6        2  ELSE not in comment block
  # 8           1  Set state, in comment block
  # 8           2  End any data element
  # 6        3  Put line in outtext data structure
  # 6        4  Next LINE
  # 4    11  ELSIF comment line or in comment block
  # 6        1  Put line in outtext data structure
  # 6        2  Next LINE
  #
  # Found Include Statement
  #
  # 4    12  ELSIF line is a one-line include directive
  # 6        1  Parse one-line include directive
  # 6        2  Print debugging message
  # 6        3  FOREACH attr in list of include attributes
  # 8           1  Skip if this is a revision attribute
  # 8           2  Add this attr to the include_attrs hash
  # 6        4  Initialize the region marker
  # 6        5  Initialize the array for passing variables
  # 6        6  FOREACH attr in include_attrs hash
  # 8           1  FOREACH region name
  # 10             1  IF attr equals name
  # 12                1  set region marker for this level to name
  # 8           2  Initialize include_as_section for next level
  # 8           3  IF include attr is asterisks
  # 10             1  Remember section depth for next level
  # 10             2  Clear region_marker
  # 8           4  ELSIF include attr is 'hide'
  # 10             1  Set hide marker for this level to 1
  # 8           5  ELSIF include attr is 'raw'
  # 10             1  Set raw marker for next level to 1
  # 8           6  ELSIF include attr is a variable
  # 10             1  Parse variable name and value
  # 10             2  Push the name/value pair onto the array
  # 6        7  IF region_marker is set for this level
  # 8           1  Set region_baton to region_marker for this level
  # 6        8  IF included file is readable
  # 8           1  IF include as hidden
  # 10             1  Insert begin hide marker
  # 10             2  Print debugging message
  # 10             3  IF include as region
  # 12                1  Prepare region begin and end markers
  # 12                2  Insert begin region marker
  # 12                3  Print debugging message
  # 12                4  Recurse
  # 12                5  Insert end region marker
  # 12                6  Print debugging message
  # 10             4  ELSE not include as region
  # 12                1  Recurse
  # 10             5  Insert end hide marker
  # 8           2  ELSIF include as region
  # 10             1  Prepare region begin and end markers
  # 10             2  Add begin region marker
  # 10             3  Print debugging message
  # 10             4  recurse
  # 10             5  Add end region marker
  # 10             6  Print debugging message
  # 8           3  ELSE Include as a section
  # 10             1  Recurse
  # 6        9  ELSE included file is NOT readable, warn user
  # 8           1  Warn user
  # 8           2  Put line in outtext data structure
  #
  # Found Include Environment Marker
  #
  # 4    13  ELSIF line is include environment marker
  # 6        1  IF not in include environment
  # 8           1  Set in include environment flag
  # 8           2  Initialize data datastructure
  # 8           3  Print debugging message
  # 6        2  ELSE in include enviroment
  # 8           1  Set state in include environment = 0
  # 8           2  Print debugging message
  # 8           3  Get included file name
  # 8           4  Initialize anonymous variable passing array
  # 8           5  FOREACH variable to be passed
  # 10             1  IF variable is well formed
  # 12                1  Trim whitespace around key
  # 12                2  Trim whitespace around value
  # 12                3  Push key/value pair onto 'vars' array
  # 10             2  ELSE incorrect variable syntax
  # 12                1  Print error
  # 8           6  Initialize region variable
  # 8           7  IF region is true
  # 10             1  Set region marker for this nesting level
  # 8           8  Initialize 'include_as_section' for next level
  # 8           9  Get 'section' inclusion variable
  # 8          10  IF this file should be included as a section
  # 10             1  Set 'include_as_section' next level
  # 10             2  Initialize region_marker for this nesting level
  # 8          11  Get 'hide' inclusion variable
  # 8          12  IF this included file should be hidden
  # 10             1  Set hide marker for this nesting level = 1
  # 8          13  Get 'raw' inclusion variable
  # 8          14  IF this file should be included 'raw'
  # 10             1  Set raw marker for next level = 1
  # 8          15  IF region_marker is set for this level
  # 10             1  Set region_baton to that region marker
  # 8          16  IF included file is readable
  # 10             1  IF include as hidden
  # 12                1  Insert begin hide marker
  # 12                2  Print debugging message
  # 12                3  IF include as region
  # 14                   1  Prepare region begin and end markers
  # 14                   2  Insert begin region marker
  # 14                   3  Print debugging message
  # 14                   4  Recursively call resolve_includes()
  # 14                   5  Insert end region marker
  # 14                   6  Print debugging message
  # 12                4  ELSE not include as region
  # 14                   1  Recursively call resolve_includes()
  # 12                5  Insert end hide marker
  # 12                6  Print debugging message
  # 10             2  ELSIF include as region
  # 12                1  Prepare region begin and end markers
  # 12                2  Insert begin region marker
  # 12                3  Print debugging message
  # 12                4  Recursively call resolve_includes()
  # 12                5  Insert end region marker
  # 12                6  Print debugging message
  # 10             3  ELSE include as section
  # 8          17  ELSE included file is not readable
  # 10             1  Print warning "included file is not readable"
  # 10             2  Put line in outtext data structure
  #
  # Already In Include Environment
  #
  # 4    14  ELSIF in include environment
  # 6        1  FOREACH allowed data element
  # 8           1  Initialize is_multivalued to 0
  # 8           2  IF allowed data element may be multivalued
  # 10             1  Set is_multivalued to 1
  # 8           3  IF beginning of data element
  # 10              1  Parse first line of data element
  # 10              2  FOREACH other allowed element
  # 12                 1  No longer in this other element
  # 10              3  Remember that we're in current element
  # 10              4  IF is_multivalued
  # 12                 1  Push line onto array in data structure
  # 10              5  ELSE not multivalued
  # 12                 1  Place in scalar in data structure
  # 10              6  next LINE
  # 8           4  ELSIF already in data element and line not blank
  # 10              1  Prepare line
  # 10              2  IF is_multivalued
  # 12                 1  Push line onto array in data structure
  # 10              3  ELSE not multivalued
  # 12                 1  Place in scalar in data structure
  # 10              4  next LINE
  # 8           5  ELSIF already in data element and line IS blank
  # 10              1  FOREACH other allowed element
  # 12                 1  No longer in this other element
  #
  ###################################################################
  # BEGIN TO BE IMPLEMENTED
  ###################################################################
  #
  # Include Iterator
  #
  # 4    --  ELSIF line is 'include' iterator marker
  # 6        1  Set state: in preamble text = 0
  # 6        2  End any data element
  # 6        3  Set current table column and row to 0
  # 6        4  IF not currently in iterative include
  # 8           1  Print debugging message
  # 8           2  Set state in iterative_include = 1
  # 6        5  ELSE currently in iterative include
  # 8           1  Print debugging message
  # 8           2  Set state in iterative_include = 0
  # 8           3  INSERT INCLUDE ENVIRONMENTS
  # 4    --  ELSIF in 'include' iterator
  # 6        1  FOREACH allowed data element
  # 8           1  Initialize is_multivalued to 0
  # 8           2  IF allowed data element may be multivalued
  # 10             1  Set is_multivalued to 1
  # 8           3  IF beginning of data element
  # 10              1  Parse first line of data element
  # 10              2  FOREACH other allowed element
  # 12                 1  No longer in this other element
  # 10              3  Remember that we're in current element
  # 10              4  IF is_multivalued
  # 12                 1  Push line onto array in data structure
  # 10              5  ELSE not multivalued
  # 12                 1  Place in scalar in data structure
  # 10              6  next LINE
  # 8           4  ELSIF already in data element and line not blank
  # 10              1  Prepare line
  # 10              2  IF is_multivalued
  # 12                 1  Push line onto array in data structure
  # 10              3  ELSE not multivalued
  # 12                 1  Place in scalar in data structure
  # 10              4  next LINE
  # 8           5  ELSIF already in data element and line IS blank
  # 10              1  FOREACH other allowed element
  # 12                 1  No longer in this other element
  #
  ###################################################################
  # END TO BE IMPLEMENTED
  ###################################################################
  #
  # Not Include Line or Environment
  #
  # 4    15  ELSE this line is not an include directive, marker, or iterator
  # 6        1  IF 'title:' line (and level > 1, not region, not raw, not seen_title)
  # 8           1  Construct string of asterisks
  # 8           2  Replace title label with asterisks
  # 8           3  Set seen_title flag
  # 6        2  ELSIF section heading line (and level > 1)
  # 8           1  Construct string of asterisks
  # 8           2  Replace original asterisks with new asterisks
  # 8           3  Update state: no longer in preamble
  # 6        3  ELSIF this line is a preamble ending line
  # 8           1  Update state: no longer in preamble
  # 6        4  ELSIF 'step:' line
  # 8           1  Update state: no longer in preamble
  # 6        5  Put line in outtext data structure
  # 2 19  Pop the nesting stack
  # 2 20  Decrement the nesting level
  # 2 21  Close the included file
  # 2 22  Revert state of current file and current line

  #-------------------------------------------------------------------
  # 1 - Get file and variables to be included
  #
  #     Get the filename passed as the sole argument.
  #
  my $file = shift;
  my $vars = shift || [];

  #-------------------------------------------------------------------
  # 2 - Print debugging message
  #
  printdebug("resolve_includes: $file") if $DEBUGGING;

  #-------------------------------------------------------------------
  # 3 - IF file is not readable, DIE and throw error message
  #
  #     If the file isn't readable complain bitterly and die.
  #
  die "File \"$file\" isn't readable" if not -r $file;

  #-------------------------------------------------------------------
  # 4 - Gather SVN meta-data for this file
  #
  #     Note that, to avoid performance penalties, the
  #     "gather_svn_metadata()" subroutine exits immediately if the
  #     metadata for this file has already been gathered.
  #
  gather_svn_metadata($file);

  #-------------------------------------------------------------------
  # 5 - Increment Nesting Level
  #
  #     Increment the nesting level and establish what the next level
  #     is.  $level is a global variable that represents the current
  #     level of recursion of included files.
  #
  ++ $nesting_level;

  #-------------------------------------------------------------------
  # 6 - Compute Next Level
  #
  my $next_level = $nesting_level + 1;

  #-------------------------------------------------------------------
  # 7 - Build Filename Nest
  #
  #     Build a filename "nest" - a string of base filenames joined
  #     with a greater-than sign (>) that represents the nested set of
  #     included files.
  #
  #     This 'filename nest' is used to generate informative error
  #     messages.
  #
  # my $basefile = basename($file);
  # push @nesting_stack, $basefile;
  push @nesting_stack, $file;
  my $nest = join(' > ', @nesting_stack);

  #-------------------------------------------------------------------
  # 8 - Initialize Parsing State Variables
  #
  #     Set some state variables.
  #
  $current_line{$nesting_level}    = 0;
  $in_preamble{$nesting_level}     = 1;
  $seen_title{$nesting_level}      = 0;
  $region_marker{$nesting_level}   = $EMPTY_STRING;
  $begin_region{$nesting_level}    = $EMPTY_STRING;
  $end_region{$nesting_level}      = $EMPTY_STRING;

  #-------------------------------------------------------------------
  # 9 - Remember previous state (previous file and line)
  #
  #     Remember the previous file and line so we can restore the
  #     state of these parsing variables after including this file.
  #
  my $previous_file = $current{'file'};
  my $previous_line = $current{'line'};

  #-------------------------------------------------------------------
  # 10 - Initialize current file and line
  #
  #     Initialize values for current file and line to prepare to read
  #     the included file.
  #
  $current{'file'} = $basefile;
  $current{'line'} = $current_line{$nesting_level};

  #-------------------------------------------------------------------
  # 11 - Make List of Allowed Include Data Elements
  #
  #     Make a list of allowed data elements in 'include'
  #     environments.  This list will be used to parse 'include'
  #     environments.
  #
  my @allowed_elements = keys %{ $structure{'include'}{'elements'} };

  #-------------------------------------------------------------------
  # 12 - IF the region baton is set
  #
  #     What type of region are we including? If the $region_baton
  #     variable is set, it means this subroutine has been called
  #     recursively and that the calling subroutine is 'passing the
  #     baton' The baton tells this subroutine what type of region is
  #     being included.
  #
  if ($region_baton) {
    $region_type{$nesting_level} = $region_baton;
  }

  #-------------------------------------------------------------------
  # 13 - ELSE the region baton is NOT set
  #
  else {
    $region_type{$nesting_level} = $EMPTY_STRING;
  }

  #-------------------------------------------------------------------
  # 14 - Initialize region baton to empty
  #
  #     Clear the baton so it doesn't get passed to the next level of
  #     recursion.
  #
  $region_baton = $EMPTY_STRING;

  #-------------------------------------------------------------------
  # 15 - Provide User Feedback
  #
  #     Let the user know the script is including a file at the
  #     current nesting level and that the file is being included
  #     either as a type of region or simply as a section.
  #
  my $region_type = $region_type{$nesting_level} || 'section';

  #     Create a string containing the variables passed for
  #     substitution in this included file.
  #
  my @vars = ();
  foreach my $href ( @{$vars} ) {
    foreach my $key ( keys %{ $href } ) {
      my $value = $href->{$key};
      push(@vars,"$key=$value");
    }
  }
  my $var_string = join(',',@vars);

  if ($var_string) {
    printstatus("  ($nesting_level) including $region_type: $file ($var_string)");
  } else {
    printstatus("  ($nesting_level) including $region_type: $file");
  }

  #     Print a period for each included file.
  #
  #     This gives the command line user a warm fuzzy that something
  #     is happening especially for documents that include lots of
  #     external text files.
  #
  print '.' if not $option{'gui'} and not $option{'verbose'};

  #-------------------------------------------------------------------
  # 16 - Initialize array for file content
  #
  #     Initialize an array in the %files data structure to contain
  #     the lines from *this* file.
  #
  $files{$file}{'content'}   = []; # lines of this file
  $files{$file}{'resources'} = {}; # hash of files used by this one
  $files{$file}{'tier'}      = $nesting_level;

  #-------------------------------------------------------------------
  # 17 - Open File To Be Included
  #
  #     Open the file or complain bitterly and die.  Note that the
  #     filehandle is TEXT_1, TEXT_2, TEXT_3..., depending on the
  #     depth of the current nest.
  #
  #     !!! Bug Here !!!
  #
  #     This use of variables in filehandles prevents me from using
  #     the 'strict' pragma.  Someday I want to find a different
  #     approach so I can use strict.
  #
  my $fh = "TEXT_${nesting_level}";
  open $fh, "<$file" or die "Can't find $file";

  #-------------------------------------------------------------------
  # 18 - WHILE loop (each LINE)
  #
  #     Read the file line by line into the @outtext array.  Look for
  #     (1) one-line include directives, (2) include environments, and
  #     (3) iterative includes.  Recursively call this
  #     resolve_includes() subroutine to resolve those.
  #
 LINE:
  while (<$fh>) {

    #-----------------------------------------------------------------
    # 18.1 - Update Parsing State Variables (current line)
    #
    ++ $current_line{$nesting_level};
    ++ $current{'line'};

    #-----------------------------------------------------------------
    # 18.2 - Remember this line in %files data structure
    #
    #     Push this line onto the appropriate array in the %files data
    #     structure.  The purpose of remembering all file contents in
    #     the data structure is so this program can update the file
    #     contents and write them back out to storage.  This task is
    #     performed by the update_files() subroutine.
    #
    push @{ $files{$file}{'content'} }, $_;

    #-----------------------------------------------------------------
    # 18.3 - Print Debugging Message
    #
    #     Print this line if we're debugging.
    #
    printmessage("P1---- $_") if $DEBUGGING;

    #-----------------------------------------------------------------
    # 18.4 - FOREACH hash ref in vars array
    #
    #     Perform variable replacement.
    #
    foreach my $href ( @{$vars} ) {
      foreach my $key ( keys %{ $href } ) {
	my $value = $href->{$key};
	s/\[var:$key\]/$value/g;
      }
    }

    #-----------------------------------------------------------------
    # 18.5 - If SVN inline version comment present
    #
    if (/\[#v:(.*?):(.*?)\]/) {
      my $file    = $1;
      my $version = $2;
      gather_svn_metadata($file);
    }

    #-----------------------------------------------------------------
    # 18.6 - If SVN inline date comment present
    #
    if (/\[#d:(.*?):(.*?)\]/) {
      my $file    = $1;
      my $date    = $2;
      gather_svn_metadata($file);
    }

    #-----------------------------------------------------------------
    # 18.7 - If SVN inline author comment present
    #
    if (/\[#a:(.*?):(.*?)\]/) {
      my $file    = $1;
      my $author  = $2;
      gather_svn_metadata($file);
    }

    #-----------------------------------------------------------------
    # 18.8 - If SVN revision in include directive present
    #
    if (/^(\*+\s+)?include::(.*?:)?\$r(\w*?)\$:(.*?:)?\s+(.*?)\s*(#(.*))?$/) {
      my $file = $5;
      gather_svn_metadata($file);
    }

    #-----------------------------------------------------------
    # 18.8a - element is a label.  remember "days old"
    #
    if ( /^(id|label)::\s*(.*?)\s*$/ ) {

      my $label        = $2;
      my $modified     = $svninfo{$file}{'modified'} || '';
      my $days_old     = $svninfo{$file}{'days_old'} || '';
      my $last_changed = $svninfo{$file}{'date'}     || '';
      my $author       = $svninfo{$file}{'author'}   || '';
      my ($yr,$mo,$dy) = Date::Pcalc::Today();

      $mo = '0' . $mo until length $mo == 2;
      $dy = '0' . $dy until length $dy == 2;

      if ( $modified )
	{
	  $days_old{$label}{'file'}   = "$file"               || '';
	  $days_old{$label}{'num'}    = '0'                   || '';
	  $days_old{$label}{'date'}   = "$yr-$mo-$dy"         || '';
	  $days_old{$label}{'author'} = 'uncommitted changes' || '';
	}

      else
	{
	  $days_old{$label}{'file'}   = "$file"               || '';
	  $days_old{$label}{'num'}    = $days_old             || '';
	  $days_old{$label}{'date'}   = $last_changed         || '';
	  $days_old{$label}{'author'} = $author               || '';
	}
    }

    #-----------------------------------------------------------------
    # 18.9 - IF not seen_title at this level
    #
    #     Set seen_title for this nesting level to 1 if this line
    #     begins an environment or region.
    #
    #     Normally we want this subroutine to recognize the first
    #     title in the included file and use it as a section or
    #     subsection heading.  If, however, that title is inside an
    #     environment or region, (like a table) we DON'T want to use
    #     it as a section or subsection heading.
    #
    #     Not all included files have titles.
    #
    #     Therefore we must detect the beginning of any environments
    #     or regions and set the $seen_title flag to 1.
    #
    if ( not $seen_title{$nesting_level} ) {
      foreach my $block ( keys %structure ) {
	if ( /---$block/ or />>>$block/ ) {
	  $seen_title{$nesting_level} = 1;
	}
      }
    }

    ##################################################################
    ##################################################################
    ##################################################################
    ###                                                            ###
    ###                                                            ###
    ###   ONLY ONE OF THE FOLLOWING CONDITIONS WILL APPLY TO THE   ###
    ###   LINE...                                                  ###
    ###                                                            ###
    ###                                                            ###
    ##################################################################
    ##################################################################
    ##################################################################

    #-----------------------------------------------------------------
    # 18.10 - IF line is comment block marker
    #
    #     Look for the beginning or end of a comment block
    #     (###comment)
    #
    #     This MUST be the first condition tested when going
    #     line-by-line through pass one.
    #
    if (/^(#){3,}comment\s*$/) {

      #---------------------------------------------------------------
      # 18.10.1 - IF in comment block
      #
      if ($in{'comment'}{'block'}) {
        $in{'comment'}{'block'} = 0;
      }

      #---------------------------------------------------------------
      # 18.10.2 - ELSE not in comment block
      #
      else {
        $in{'comment'}{'block'} = 1;
        end_any_data_element();
      }

      push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # 18.11 - ELSIF comment line or in comment block
    #
    #     Look for comment lines or comment block content.
    #
    elsif (/^#/ or $in{'comment'}{'block'}) {
      push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},$_];
      next LINE;
    }

    #-----------------------------------------------------------------
    # 18.12 - ELSIF line is a one-line include directive
    #
    #     Look for included files.  Yes, that's right, while we're in
    #     the process of including lines from *this* file, look for
    #     the recursive inclusion of *other* files.
    #
    elsif (/^(\*+\s+)?include::(.*?:)?(\$r(\w*?)\$:)?(.*?:)?\s+(.*?)\s*(#(.*))?$/) {

      #---------------------------------------------------------------
      # 18.12.1 - Parse one-line include directive
      #
      my $attrs_2       = $2;
      my $attrs_3       = $3;
      my $attrs_5       = $5;
      my $included_file = $6;
      my $comment       = $8;
      my $include_attrs = $attrs_2 . $attrs_3 . $attrs_5;
      my @include_attrs = split(/:/,$include_attrs);
      my %include_attrs = ();

      $files{$file}{'resources'}{$included_file} = 1;
      $files{$included_file}{'tier'}             = $nesting_level + 1;

      #---------------------------------------------------------------
      # 18.12.2 - Print debugging message
      #
      if ($DEBUGGING) {
	printdebug("pass_one: include $included_file level $nesting_level");
      }

      #---------------------------------------------------------------
      # 18.12.3 - FOREACH attr in list of include attributes
      #
      foreach my $attr (@include_attrs) {
	next if $attr =~ /^\$r\w*\$$/;
	$include_attrs{$attr} = 1;
      }

      #---------------------------------------------------------------
      # 18.12.4 - Initialize the region marker
      #
      $region_marker{$nesting_level} = $EMPTY_STRING;

      #---------------------------------------------------------------
      # 18.12.5 - Initialize the array for passing variables
      #
      my $vars = [];

      #---------------------------------------------------------------
      # COMMENT
      #
      #     If the include indicator has a region attribute
      #     (i.e. 'include:exercise:') then the included file is meant
      #     to be included as the indicated region.
      #
      #     Recognizing the region indicator happens at *this* nesting
      #     level, but needs to be recognized both in *this* nesting
      #     level and the *next* nesting level.
      #
      #     The region indicator needs to be recognized at *this*
      #     nesting level in order to insert the region start and end
      #     markers:
      #
      #       >>>exercise
      #
      #       ...included file goes here...
      #
      #       <<<exercise
      #
      #     The region indicator also needs to be recognized at the
      #     *next* nesting level (i.e. while the included file is
      #     being inserted) to properly recognize 'title:' data
      #     indicators and to make the right decision on whether they
      #     should be converted to section markings (lines beginning
      #     with asterisks).
      #
      #     To achieve this trick, I'll pass a 'baton' between this
      #     nesting level and the next.
      #
      #     First, we need to determine (in *this* nesting level)
      #     whether region markers need to be placed around the
      #     included text.
      #
      #     What are all the possible environments and regions that
      #     can be included via external files?  We'll just use all of
      #     the environment and region names defined as keys in the
      #     %structure data structure.  That way we can define
      #     additional environments and regions without needing to
      #     change the code here.
      #
      #---------------------------------------------------------------

      #---------------------------------------------------------------
      # 18.12.6 - FOREACH attr in include_attrs hash
      #
      #     Determine what variation of include this is: (1) as-is,
      #     (2) flat, (3) hide, (4) section, or (5) region
      #
      foreach my $include_attr (keys %include_attrs) {

	#-----------------------------------------------------------
	# 18.12.6.1 - FOREACH region name
	#
	#     Include as $name region? If this is the name of a
	#     region, and the attributes contain this name, it means
	#     the author wants the file included as this type of
	#     region.
	#
        foreach my $name ( list_of_region_names() ) {
	  if ( $include_attr eq $name ) {
	    $region_marker{$nesting_level} = $name;
	  }
        }

	#-------------------------------------------------------------
	# 18.12.6.2 - Initialize include_as_section for next level
	#
	#     Look for a section attribute (i.e. *, **, ***...).
	#
	#     Since we're just now deciphering the "include:" line,
	#     the nesting level this pertains to will be the NEXT
	#     (subordinate) level.
	#
	# To begin with, assume this 'include:' line does *not*
	# indicate a section include.
	#
	$include_as_section{$next_level} = 0;

	#-------------------------------------------------------------
	# 18.12.6.3 - IF include attr is asterisks
	#
	if ($include_attr =~ /^(\*+)$/) {

          #-----------------------------------------------------------
	  # 18.12.6.3.1 - Remember section depth for next level
	  #
	  #     Remember the section depth at which to include the
	  #     contents of the file indicated on this 'include:'
	  #     line.
	  #
	  $include_as_section{$next_level} = length($1);

          #-----------------------------------------------------------
	  # 18.12.6.3.2 - Clear region marker
	  #
	  #     Blank out the region_type. We don't want to add region
	  #     start and end markers for a section.
	  #
	  $region_marker{$nesting_level} = $EMPTY_STRING;
	}

	#-------------------------------------------------------------
	# 18.12.6.4 - ELSIF include attr is 'hide'
	#
	#     Look for the 'hide' attribute.  If present, it means the
	#     author wants to use the data elements from the included
	#     file (perhaps to reference titles or descriptions) but
	#     does not want the text of the file to appear in the
	#     containing document.
	#
	#     The included document should be placed between '###hide'
	#     lines.
	#
	#     Nested includes should also be hidden.  So, if the
	#     included file itself contains include directives, those
	#     nested includes should also be hidden.
	#
	elsif ($include_attr eq 'hide') {
	  $hide_marker{$nesting_level} = 1;
	}

	#-------------------------------------------------------------
	# 18.12.6.5 - ELSIF include attr is 'raw'
	#
	#     Look for the 'raw' attribute.  If present, the included
	#     file contains an environment like a table or listing and
	#     the author needs it included in it's 'raw' state.  In
	#     other words, don't convert the title to a section
	#     heading, and also don't convert the title to a bold
	#     string.
	#
	elsif ($include_attr eq 'raw') {
	  $raw_marker{$nesting_level} = 1;
	}

	#-------------------------------------------------------------
	# 18.12.6.6 - ELSIF include attr is a variable
	#
	#     Look for the variables.  Any attribute containing an
	#     equals sign is a variable definition.  Left of the
	#     equals sign is the variable name; right of the equals
	#     sign is the variable value.
	#
	elsif ($include_attr =~ /(.*?)=(.*)/) {
	  my $name  = $1;
	  my $value = $2;
	  push(@{ $vars }, {$name,$value});
	}

      }

      #---------------------------------------------------------------
      # 18.12.7 - IF region_marker is set for this level
      #
      #     Get the baton ready. Now we need a way to communicate to
      #     the next nesting level that it is being included as a
      #     certain type of region.  This is where we'll 'pass the
      #     baton' so to speak.
      #
      if ($region_marker{$nesting_level}) {
        $region_baton = $region_marker{$nesting_level};
      }

      #---------------------------------------------------------------
      # 18.12.8 - IF Included File is Readable...
      #
      #     If the included file is readable, process it.
      #
      if (-r $included_file) {

        #-------------------------------------------------------------
	# 18.12.8.1 - IF Include As Hidden
	#
	#     Include file as a hidden block.  When a block of text is
	#     hidden, pass_two will gather data elements from it, but
	#     pass_three will not insert the content into the final
	#     rendition.
	#
	#     This enables authors to include files from which they
	#     only wish to reference data elements like titles and
	#     descriptions.
	#
	if ( $hide_marker{$nesting_level} ) {

          #-----------------------------------------------------------
	  # 18.12.8.1.1 - Insert begin hide marker
	  #
	  insert_hide_marker($nest,$nesting_level);

          #-----------------------------------------------------------
	  # 18.12.8.1.2 - Print debugging message
	  #
	  if ($DEBUGGING) {
	    printmessage("P1---- ");
	    printmessage("P1---- ");
	    printmessage("P1---- ###hide");
	    printmessage("P1---- ");
	    printmessage("P1---- ");
	  }

          #-----------------------------------------------------------
	  # 18.12.8.1.3 - IF include as region
	  #
	  if ($region_marker{$nesting_level}) {

	    #---------------------------------------------------------
	    # 18.12.8.1.3.1 - Prepare region begin and end markers
	    #
	    $begin_region{$nesting_level} = '>>>' . $region_marker{$nesting_level} . "\n\n";
	    $end_region{$nesting_level}   = '<<<' . $region_marker{$nesting_level} . "\n";

	    #---------------------------------------------------------
	    # 18.12.8.1.3.2 - Insert begin region marker
	    #
	    push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},$begin_region{$nesting_level}];

	    #---------------------------------------------------------
	    # 18.12.8.1.3.3 - Print debugging message
	    #
	    if ($DEBUGGING) {
	      printmessage("P1---- $begin_region{$nesting_level}");
	    }

	    #---------------------------------------------------------
	    # 18.12.8.1.3.4 - Recurse
	    #
	    resolve_includes($included_file,$vars);

	    #---------------------------------------------------------
	    # 18.12.8.1.3.5 - Insert end region marker
	    #
	    push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},"\n"];
	    push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},$end_region{$nesting_level}];

	    #---------------------------------------------------------
	    # 18.12.8.1.3.6 - Print debugging message
	    #
	    if ($DEBUGGING) {
	      printmessage("P1---- ");
	      printmessage("P1---- $end_region{$nesting_level}");
	    }

	  }

          #-----------------------------------------------------------
	  # 18.12.8.1.4 - ELSE not include as region
	  #
	  else {
	    resolve_includes($included_file,$vars);
	  }

          #-----------------------------------------------------------
	  # 18.12.8.1.5 - Insert end hide marker
	  #
	  insert_hide_marker($nest,$nesting_level);

          #-----------------------------------------------------------
	  # 18.12.8.1.6 - Print debugging message
	  #
	  if ($DEBUGGING) {
	    printmessage("P1---- ");
	    printmessage("P1---- ");
	    printmessage("P1---- ###hide");
	    printmessage("P1---- ");
	    printmessage("P1---- ");
	  }

	}

        #-------------------------------------------------------------
	# 18.12.8.2 - ELSIF include as region
	#
        #     Include file as a region. If there was a region
        #     indicator (like 'exercise' in the case of
        #     'index:exercise:', then insert begin/end region markers.
        #
        elsif ($region_marker{$nesting_level}) {

	  #-----------------------------------------------------------
	  # 18.12.8.2.1 - Prepare region begin and end markers
	  #
          $begin_region{$nesting_level} = '>>>' . $region_marker{$nesting_level} . "\n\n";
          $end_region{$nesting_level}   = '<<<' . $region_marker{$nesting_level} . "\n";

	  #-----------------------------------------------------------
	  # 18.12.8.2.2 - Insert begin region marker
	  #
          push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},$begin_region{$nesting_level}];

	  #---------------------------------------------------------
	  # 18.12.8.2.3 - Print debugging message
	  #
	  if ($DEBUGGING) {
	    printmessage("P1---- $begin_region{$nesting_level}");
	  }

	  #-----------------------------------------------------------
	  # 18.12.8.2.4 - Recurse
	  #
	  resolve_includes($included_file,$vars);

	  #-----------------------------------------------------------
	  # 18.12.8.2.5 - Insert end region marker
	  #
          push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},"\n"];
          push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},$end_region{$nesting_level}];

	  #---------------------------------------------------------
	  # 18.12.8.2.6 - Print debugging message
	  #
	  if ($DEBUGGING) {
	    printmessage("P1---- ");
	    printmessage("P1---- $end_region{$nesting_level}");
	  }

        }

        #-------------------------------------------------------------
	# 18.12.8.3 - ELSE Include As Section
	#
        #     Include file as a section. Simply resolve the includes
        #     as if they contain section content.
        #
        else {
	  resolve_includes($included_file,$vars);
        }

      }

      #---------------------------------------------------------------
      # 18.12.9 - ELSE included file is not readable, warn user
      #
      #     The file you're trying to include is not readable!  throw
      #     a warning.
      #
      #     But, assume this line begins with "include:" and the
      #     author intends it to be narrative text rather than an
      #     include directive.  Process the line as narrative text.
      #
      else {
        printwarning("included file \"$included_file\" is not readable!\n");
	push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},$_];
      }
    }

    #-----------------------------------------------------------------
    # 18.13 - ELSIF line is include environment marker
    #
    #     Check if this line begins with 3 or more hyphens followed by
    #     the word "include" -- if so, it indicates the begin or end
    #     of an include environment.
    #
    elsif (/^(-){3,}include\s*$/) {

      #---------------------------------------------------------------
      # 18.13.1 - IF not in include environment
      #
      if (not $in{'include'}{'environment'}) {
        $in{'include'}{'environment'} = 1;
	$data{'include'}{$nesting_level} = {};
	printdebug("pass_one: BEGIN environment marker: include")
	  if $DEBUGGING;
      }

      #---------------------------------------------------------------
      # 18.13.2 - ELSE in include enviroment
      #
      #     Here at the end of the include environment is where we
      #     actually resolve the include.
      #
      else {

        #-------------------------------------------------------------
	# 18.13.2.1 - Set state: in include environment = 0
	#
        $in{'include'}{'environment'} = 0;

        #-------------------------------------------------------------
	# 18.13.2.2 - Print debugging message
	#
	printdebug("pass_one: END environment marker: include")
	  if $DEBUGGING;

        #-------------------------------------------------------------
	# 18.13.2.3 - Get included file name
	#
	my $included_file = $data{'include'}{$nesting_level}{'file'} || '';

        #-------------------------------------------------------------
	# 18.13.2.4 - Initialize anonymous variable passing array
	#
	my $vars = [];

        #-------------------------------------------------------------
	# 18.13.2.5 - FOREACH variable to be passed
	#
	foreach my $var (@{$data{'include'}{$nesting_level}{'var'}}) {
	  if ($var =~ /(.*?)=(.*)/) {
	    my $key   = trim_whitespace($1);
	    my $value = trim_whitespace($2);
	    push(@{$vars},{$key,$value});
	  } else {
	    printerror("incorrect var syntax: $var");
	  }
	}

        #-------------------------------------------------------------
	# 18.13.2.6 - Initialize region variable
	#
	my $region = $data{'include'}{$nesting_level}{'region'} || '';

        #-------------------------------------------------------------
	# 18.13.2.7 - IF this file should be included as a region
	#
	if ($region) {
	  $region_marker{$nesting_level} = $region;
	}

        #-------------------------------------------------------------
	# 18.13.2.8 - Initialize section inclusion variables
	#
	$include_as_section{$next_level} = 0;

        #-------------------------------------------------------------
	# 18.13.2.9 - Get section inclusion variable
	#
	my $section = $data{'include'}{$nesting_level}{'section'} || '';

        #-------------------------------------------------------------
	# 18.13.2.10 - IF this file should be included as a section
	#
	if ($section) {
	  $include_as_section{$next_level} = length($section);
	  $region_marker{$nesting_level} = $EMPTY_STRING;
	}

        #-------------------------------------------------------------
	# 18.13.2.11 - Get 'hide' inclusion variable
	#
	my $hide = $data{'include'}{$nesting_level}{'hide'} || '';

        #-------------------------------------------------------------
	# 18.13.2.12 - IF this included file should be hidden
	#
	if ($hide) {
	  $hide_marker{$nesting_level} = 1;
	}

        #-------------------------------------------------------------
	# 18.13.2.13 - Get 'raw' inclusion variable
	#
	my $raw = $data{'include'}{$nesting_level}{'raw'} || '';

        #-------------------------------------------------------------
	# 18.13.2.14 - IF this file should be included 'raw'
	#
	if ($raw) {
	  $raw_marker{$nesting_level} = 1;
	}

	#---------------------------------------------------------------
	# 18.13.2.15 - IF region_marker is set for this level
	#
	#     Get the baton ready. Now we need a way to communicate to
	#     the next nesting level that it is being included as a
	#     certain type of region.  This is where we'll 'pass the
	#     baton' so to speak.
	#
	if ($region_marker{$nesting_level}) {
	  $region_baton = $region_marker{$nesting_level};
	}

	#---------------------------------------------------------------
	# 18.13.2.16 - IF Included File is Readable...
	#
	#     If the included file is readable, process it.
	#
	if (-r $included_file) {

	  #-------------------------------------------------------------
	  # 18.13.2.16.1 - IF Include As Hidden
	  #
	  #     Include file as a hidden block.  When a block of text is
	  #     hidden, pass_two will gather data elements from it, but
	  #     pass_three will not insert the content into the final
	  #     rendition.
	  #
	  #     This enables authors to include files from which they
	  #     only wish to reference data elements like titles and
	  #     descriptions.
	  #
	  if ( $hide_marker{$nesting_level} ) {

	    #-----------------------------------------------------------
	    # 18.13.2.16.1.1 - Insert begin hide marker
	    #
	    insert_hide_marker($nest,$nesting_level);

	    #-----------------------------------------------------------
	    # 18.13.2.16.1.2 - Print debugging message
	    #
	    if ($DEBUGGING) {
	      printmessage("P1---- ");
	      printmessage("P1---- ");
	      printmessage("P1---- ###hide");
	      printmessage("P1---- ");
	      printmessage("P1---- ");
	    }

	    #-----------------------------------------------------------
	    # 18.13.2.16.1.3 - IF include as region
	    #
	    if ($region_marker{$nesting_level}) {

	      #---------------------------------------------------------
	      # 18.13.2.16.1.3.1 - Prepare region begin and end markers
	      #
	      $begin_region{$nesting_level} = '>>>' . $region_marker{$nesting_level} . "\n\n";
	      $end_region{$nesting_level}   = '<<<' . $region_marker{$nesting_level} . "\n";

	      #---------------------------------------------------------
	      # 18.13.2.16.1.3.2 - Insert begin region marker
	      #
	      push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},$begin_region{$nesting_level}];

	      #---------------------------------------------------------
	      # 18.13.2.16.1.3.3 - Print debugging message
	      #
	      if ($DEBUGGING) {
		printmessage("P1---- $begin_region{$nesting_level}");
	      }

	      #---------------------------------------------------------
	      # 18.13.2.16.1.3.4 - Recurse
	      #
	      resolve_includes($included_file,$vars);

	      #---------------------------------------------------------
	      # 18.13.2.16.1.3.5 - Insert end region marker
	      #
	      push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},"\n"];
	      push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},$end_region{$nesting_level}];

	      #---------------------------------------------------------
	      # 18.13.2.16.1.3.6 - Print debugging message
	      #
	      if ($DEBUGGING) {
		printmessage("P1---- ");
		printmessage("P1---- $end_region{$nesting_level}");
	      }

	    }

	    #-----------------------------------------------------------
	    # 18.13.2.16.1.4 - ELSE not include as region
	    #
            else {
	      resolve_includes($included_file,$vars);
	    }

	    #-----------------------------------------------------------
	    # 18.13.2.16.1.5 - Insert end hide marker
	    #
	    insert_hide_marker($nest,$nesting_level);

	    #-----------------------------------------------------------
	    # 18.13.2.16.1.6 - Print debugging message
	    #
	    if ($DEBUGGING) {
	      printmessage("P1---- ");
	      printmessage("P1---- ");
	      printmessage("P1---- ###hide");
	      printmessage("P1---- ");
	      printmessage("P1---- ");
	    }

	  }

	  #-------------------------------------------------------------
	  # 18.13.2.16.2 - ELSIF include as region
	  #
	  #     Include file as a region. If there was a region
	  #     indicator (like 'exercise' in the case of
	  #     'index:exercise:', then insert begin/end region markers.
	  #
	  elsif ($region_marker{$nesting_level}) {

	    #-----------------------------------------------------------
	    # 18.13.2.16.2.1 - Prepare region begin and end markers
	    #
	    $begin_region{$nesting_level} = '>>>' . $region_marker{$nesting_level} . "\n\n";
	    $end_region{$nesting_level}   = '<<<' . $region_marker{$nesting_level} . "\n";

	    #-----------------------------------------------------------
	    # 18.13.2.16.2.2 - Insert begin region marker
	    #
	    push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},$begin_region{$nesting_level}];

	    #---------------------------------------------------------
	    # 18.13.2.16.2.3 - Print debugging message
	    #
	    if ($DEBUGGING) {
	      printmessage("P1---- $begin_region{$nesting_level}");
	    }

	    #-----------------------------------------------------------
	    # 18.13.2.16.2.4 - Recurse
	    #
	    resolve_includes($included_file,$vars);

	    #-----------------------------------------------------------
	    # 18.13.2.16.2.5 - Insert end region marker
	    #
	    push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},"\n"];
	    push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},$end_region{$nesting_level}];

	    #---------------------------------------------------------
	    # 18.13.2.16.2.6 - Print debugging message
	    #
	    if ($DEBUGGING) {
	      printmessage("P1---- ");
	      printmessage("P1---- $end_region{$nesting_level}");
	    }

	  }

	  #-------------------------------------------------------------
	  # 18.13.2.16.3 - ELSE Include As Section
	  #
	  #     Include file as a section. Simply resolve the includes
	  #     as if they contain section content.
	  #
	  else {
	    resolve_includes($included_file,$vars);
	  }

	}

	#---------------------------------------------------------------
	# 18.13.2.17 - ELSE included file is not readable, warn user
	#
	#     The file you're trying to include is not readable!  throw
	#     a warning.
	#
	#     But, assume this line begins with "include:" and the
	#     author intends it to be narrative text rather than an
	#     include directive.  Process the line as narrative text.
	#
	else {
	  printwarning("included file \"$included_file\" is not readable!\n");
	  push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},$_];
	}

      }

    }

    #-----------------------------------------------------------------
    # 18.14 - ELSIF in include environment
    #
    #     "include" environment data element names are listed in
    #     @allowed_elements.
    #
    elsif ($in{'include'}{'environment'}) {

      #---------------------------------------------------------------
      # 18.14.1 - FOREACH allowed data element
      #
      #     Check for each allowed data element.  Look for each data
      #     element allowed for this text, environment, or region.
      #
      foreach my $element (@allowed_elements) {

	#-------------------------------------------------------------
	# 18.14.1.1 - Initialize is_multivalued to 0
	#
	my $is_multivalued = 0;

        #-------------------------------------------------------------
        # 18.14.1.2 - IF allowed data element may be multivalued
	#
	#     Determine if this allowed data element can be
	#     multi-valued.
	#
	if ( $structure{'include'}{'elements'}{$element}{'multivalued'} ) {
	  $is_multivalued = 1;
	}

	#-------------------------------------------------------------
	# 18.14.1.3 - IF beginning of data element
	#
	#     Test to see if this line begins with the name of the
	#     allowed data element.
	#
	if ( /^${element}::([^\s]*:)?\s+(.*)/ ) {

	  #-----------------------------------------------------------
	  # 18.14.1.3.1 - Parse first line of data element
	  #
	  my $attrs = $1;
	  my $value = $2;

	  $value = trim_whitespace($value);

	  #-----------------------------------------------------------
	  # 18.14.1.3.2 - FOREACH other allowed element
	  #
	  foreach my $other (@allowed_elements) {
	    $in{'include'}{$other} = 0;
	  }

          #-----------------------------------------------------------
	  # 18.14.1.3.3 - Remember that we're in current element
	  #
	  #     Remember that we're 'in' this data element.  Also,
	  #     since we've found the beginning of an include
	  #     environment data element, it means we're no longer in
	  #     any other data element.
	  #
	  $in{'include'}{$element} = 1;

	  #-----------------------------------------------------------
	  # 18.14.1.3.4 - IF is_multivalued
	  #
	  #     If this data element is multi-valued, push this
	  #     value onto an anonymous array, otherwise assign it as
	  #     a scalar.
	  #
	  if ($is_multivalued) {
	    push(@{$data{'include'}{$nesting_level}{$element}}, $value);
	  }

	  #-----------------------------------------------------------
	  # 18.14.1.3.5 - ELSE not multivalued
	  #
	  else {
	    $data{'include'}{$nesting_level}{$element} = $value;
	  }

	  #---------------------------------------------------------
	  # 18.14.1.3.6 - Next Line
	  #
	  next LINE;

        }

	#-------------------------------------------------------------
	# 18.14.1.4 - ELSIF already in data element and line not blank
	#
	#     If we're already in the data element, append this line
	#     of text to the data structure.
	#
	elsif ( $in{'include'}{$element} and /\S+/) {

	  #-----------------------------------------------------------
	  # 18.14.1.4.1 - Prepare line
	  #
	  my $line = $_;
	  $line = trim_whitespace($line);

	  printdebug("pass_one: appending to 'include' $element") if $DEBUGGING;

	  #-----------------------------------------------------------
	  # 18.14.1.4.2 - IF is_multivalued
	  #
	  #     If this data element is multivalued, append this line
	  #     to the most recent element on an anonymous array.
	  #
	  if ($is_multivalued) {
	    ${$data{'include'}{$nesting_level}{$element}}[-1] .= " $line";
	  }

	  #-----------------------------------------------------------
	  # 18.14.1.4.3 - ELSE not multivalued
	  #
	  #     This data element is not multivalued, just append the
	  #     value as a scalar to the data structure.
	  #
	  else {
	    $data{'include'}{$nesting_level}{$element} .= " $line";
	  }

	  #---------------------------------------------------------
	  # 18.14.1.4.4 - Next Line
	  #
	  next LINE;

	}

        #-------------------------------------------------------------
	# 18.14.1.5 - ELSIF already in data element and line is blank
	#
	elsif ( $in{'include'}{$element} and /^\s*$/) {

	  #-----------------------------------------------------------
	  # 18.14.1.5.1 - FOREACH allowed element
	  #
	  foreach my $other (@allowed_elements) {
	    $in{'include'}{$other} = 0;
	  }
	}
      }
    }

    #-----------------------------------------------------------------
    # 18.15 - ELSE this line is not an include directive or include marker
    #
    else {

      #---------------------------------------------------------------
      # 18.15.1 - IF 'title:' line (and level > 1, not region, not raw, not seen_title)
      #
      #     If this line starts the title of the included file, AND
      #     the file is being included as a section, the title should
      #     be included as a section heading.
      #
      #     Replace "title:" with the proper number of asterisks.  For
      #     example:
      #
      #         title: My Included Section Title
      #
      #     becomes:
      #
      #         * My Included Section Title
      #
      #     If this line starts the title of the included file, AND
      #     the file is being included raw, the title should be
      #     included just as it appears in the included file.
      #
      #     Since included files can contain any number of title lines
      #     (for tables, figures, attachments, exercises, etc.), we
      #     need a way to distinguish if the title line represents the
      #     title of the included file or just some region within that
      #     file.  The title of a file is always near the top of the
      #     file and always comes before any of the following
      #     structures:
      #
      #     - a paragraph
      #     - a list
      #     - a table
      #
      #     We consider all text leading up to one of these structures
      #     to be "preamble."
      #
      #     Also, if we're including a file as a non-section region
      #     like an exercise or demo, then we should leave the title
      #     line alone.
      #
      if (/^title::\s/
          and $nesting_level > 1
          and not $region_type{$nesting_level}
          and not $raw_marker{$nesting_level}
          and not $seen_title{$nesting_level}) {

        #-------------------------------------------------------------
	# 18.15.1.1 - Construct string of asterisks
	#
        #     The number of asterisks to prefix the title is passed in
        #     '$include_as_section{$nesting_level}'
	#
	#     Don't allow sections deeper than $MAX_SEC_DEPTH.
        #
        my $asterisks = $EMPTY_STRING;
        until (length($asterisks) == $include_as_section{$nesting_level}
               or
               length($asterisks) == $MAX_SEC_DEPTH) {
          $asterisks .= '*';
        }

        #-------------------------------------------------------------
	# 18.15.1.2 - Replace title label with asterisks
	#
        s/^title::\s/$asterisks /;

	#-------------------------------------------------------------
	# 18.15.1.3 - Set seen_title flag
	#
	#     Remember that we've seen the title of this included
	#     file.
	#
        $seen_title{$nesting_level} = 1;
	printdebug("pass_one: set seen_title flag for level $nesting_level") if $DEBUGGING;

      }

      #---------------------------------------------------------------
      # 18.15.2 - ELSIF Section Heading line (and level > 1)
      #
      #     Look for section headings. If this line starts with one or
      #     more asterisks (indicating a section heading in the
      #     included file) then add the proper number of asterisks
      #     required by this nesting level.
      #
      elsif (/^(\*)+\s+/ and $nesting_level > 1) {

        #-------------------------------------------------------------
	# 18.15.2.1 - Construct String of Asterisks
	#
        #     Add the right number of asterisks.
        #
        my $asterisks = $1;
        my $add_asterisks = $EMPTY_STRING;

        until (length($add_asterisks) == $include_as_section{$nesting_level}
               or
               length($add_asterisks) == $MAX_SEC_DEPTH) {
          $add_asterisks .= '*';
        }

        $asterisks = $asterisks . $add_asterisks;

        #-------------------------------------------------------------
	# 18.15.2.2 - Replace original asterisks with new asterisks
	#
        s/^(\*)/$asterisks/;

        #-------------------------------------------------------------
	# 18.15.2.3 - Update state: no longer in preamble
	#
        #     Since we've just seen a heading, we must not be in the
        #     pre-amble anymore for this nesting level.
        #
        $in_preamble{$nesting_level} = 0;

      }

      #-----------------------------------------------------------------
      # 18.15.3 - ELSIF this line is a preamble ending line
      #
      #     Look for pre-amble ending lines. We need to detect when
      #     the preamble of an included file is over, so look for
      #     non-preamble lines.  Lines in the preamble include: (1)
      #     comments, (2) blank lines, and (3) data element lines
      #     (i.e. author: Mickey Mouse), (4) meta-data lines
      #     (i.e. ..type: Appendix).  If this line is NOT any of
      #     these, then end the preamble.
      #
      elsif (not /^#/
             and not $in{'comment'}{'block'}
             and not /^\s*$/
             and not /^\.\./
             and not /^\S+::/) {
        $in_preamble{$nesting_level} = 0;
      }

      #-----------------------------------------------------------------
      # 18.15.4 - ELSIF 'step:' line
      #
      #     If this is a 'step:' line it means the end of the preamble.
      #
      elsif (/^step::/) {
        $in_preamble{$nesting_level} = 0;
      }

      #---------------------------------------------------------------
      # 18.15.5 - Put line in outtext data structure
      #
      push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},$_];

    }
  }

  #-------------------------------------------------------------------
  # 19 - Pop the nesting stack
  #
  pop @nesting_stack;

  #-------------------------------------------------------------------
  # 20 - Decrement the nesting level
  #
  -- $nesting_level;

  #-------------------------------------------------------------------
  # 21 - Close the included file
  #
  close $fh;

  #-------------------------------------------------------------------
  # 22 - Revert state: file and line
  #
  $current{'file'} = $previous_file;
  $current{'line'} = $previous_line;

}

######################################################################

sub gather_svn_metadata {

  # This subroutine performs the function of gathering file meta-data
  # (version, author, date, and presence/absence of uncommitted
  # changes, number of days since last changed) from SVN.  This
  # meta-data is then stored in the %svninfo hash.
  #
  # The presence of uncommitted changes in the containing document or
  # any of its included files causes the document to be marked
  # 'CHANGES'.
  #
  # The structured manuscript language (SML) enables authors to add
  # inline comments that identify meta-data (version, author, date)
  # about external files.  For instance:
  #
  #     [#v:Solutions/ci-000001.txt:22]
  #
  #     include:$r22$: Solutions/ci-000001.txt
  #
  # is an inline comment that says the current version of the
  # Solutions/ci-000001.txt file is 22.
  #
  # This script automatically updates these inline comments to reflect
  # the current file meta-data.  It understands version, author, and
  # date as follows:
  #
  #     [#v:<path/to/filename>:<version>]
  #
  #     [#a:<path/to/filename>:<author>]
  #
  #     [#d:<path/to/filename>:<date>]
  #
  # This subroutine uses "svn info" and "svn status" to retrieve the
  # meta-data from the versioning system.  The text returned from the
  # "svn info" command looks like this:
  #
  #   g:/Engineering $ svn info Solutions/ci-000001.txt
  #   Path: Solutions\ci-000001.txt
  #   Name: ci-000001.txt
  #   URL: file:///G:/SVN%20Repository/Solutions/ci-000001.txt
  #   Repository Root: file:///G:/SVN%20Repository
  #   Repository UUID: 0169396a-9392-f34c-8026-a154977b8f00
  #   Revision: 21
  #   Node Kind: file
  #   Schedule: normal
  #   Last Changed Author: Don.Johnson
  #   Last Changed Rev: 19
  #   Last Changed Date: 2008-05-20 10:45:08 -0600 (Tue, 20 May 2008)
  #   Text Last Updated: 2008-05-20 11:45:52 -0600 (Tue, 20 May 2008)
  #   Checksum: 766ca7c11367ec7a8d9ee433d2de458c
  #
  #   g:/Engineering $
  #
  # When a file is in sync with the revision repository "svn status"
  # returns nothing.  When a file contains uncommitted changes, the
  # text returned from the "svn status" command looks like this (the
  # "M" is for modified):
  #
  #   M       publish-plan-semp.bat
  #
  #-------------------------------------------------------------------
  #   !!! bug here !!!
  #
  #   Sometimes I use the Perl packager (pp) to package this publish
  #   program into a windows executable.  But each time the program
  #   calls the "svn info" command, it launches a windows terminal
  #   window.  This slows down the program considerably and makes it
  #   unusable.  Look for another method for gathering SVN data about
  #   these files.
  #
  #-------------------------------------------------------------------
  #
  # The "revision" we want is the "Last Changed Rev:" 19 in the above
  # example.
  #
  # The "date" we want is the "Last Changed Date:" 2008-05-20 in the
  # above example.
  #
  # The "author" we want is the "Last Changed Author:" Don.Johnson in
  # the above example.
  #
  # The value of "modified" will be a boolean value of either 1 or 0.

  my $file    = shift;
  my $recheck = shift;

  if (not $option{'use_svn'})
    {
      return;
    }

  #-------------------------------------------------------------------
  # Ensure the file exists
  #
  if (not -f $file) {
    printerror("can't gather SVN metadata on non-existent file: \"$file\"");
    return;
  }

  #-------------------------------------------------------------------
  # Ensure the svn executable is executable
  #
  my $svn = $option{'svn'};
  if (not -e $svn) {
    printwarning("svn program $svn is not executable");
    return;
  }

  # return if we already know the revision of this file and this is
  # NOT a recheck
  #
  if ( $svninfo{$file}{'revision'} and not $recheck ) {
    return;
  }

  my $revision = 'unknown';
  my $date     = 'unknown';
  my $author   = 'unknown';
  my $days_old = 0;
  my $modified = 0;
  my $text     = '';

  #-------------------------------------------------------------------
  # Get SVN meta-data (revision, date, author)
  #
  my $info = `$svn info \"$file\"`;

  #-------------------------------------------------------------------
  # Get the revision
  #
  if ($info =~ /Last\s+Changed\s+Rev:\s+(\d+)/) {
    $revision = $1;
  }
  else {
    printwarning("unknown SVN revision: $file");
  }

  #-------------------------------------------------------------------
  # Get the date
  #
  if ($info =~ /Last\s+Changed\s+Date:\s+(\d\d\d\d-\d\d-\d\d)/) {
    $date = $1;
  }
  else {
    printwarning("unknown SVN date: $file");
  }

  #-------------------------------------------------------------------
  # Get the author
  #
  if ($info =~ /Last\s+Changed\s+Author:\s+(.*)/) {
    $author = $1;
  }
  else {
    printwarning("unknown SVN author: $file");
  }

  #-------------------------------------------------------------------
  # Get SVN status (modified or not modified)
  #
  my $status = eval { `$svn status \"$file\"` };
  $modified = 1 if $status =~ /^M/;

  #-------------------------------------------------------------------
  # Determine number of days since file last updated
  #
  if ( $date )
    {
      my $last_changed_year  = '';
      my $last_changed_month = '';
      my $last_changed_day   = '';

      if ( $date =~ /^(\d\d\d\d)-(\d\d)-(\d\d)$/ )
	{
	  $last_changed_year  = $1;
	  $last_changed_month = $2;
	  $last_changed_day   = $3;

	  my ($this_year,$this_month,$this_day) = Date::Pcalc::Today();

	  $days_old = Delta_Days
	    (
	     $last_changed_year,
	     $last_changed_month,
	     $last_changed_day,
	     $this_year,
	     $this_month,
	     $this_day
	    );
	}
      elsif ( $date eq 'unknown' )
	{
	  # do nothing
	}
      else
	{
	  warn("date \"$date\" not in expected format");
	}
    }

  #-------------------------------------------------------------------
  # Remember SVN information
  #
  $svninfo{$file}{'revision'} = $revision;
  $svninfo{$file}{'date'}     = $date;
  $svninfo{$file}{'author'}   = $author;
  $svninfo{$file}{'modified'} = $modified;
  $svninfo{$file}{'days_old'} = $days_old;

  return;

}

######################################################################

sub begin_preamble {

  printdebug("begin_preamble") if $DEBUGGING;

  $in{'preamble'}{'text'} = 1;

  #-------------------------------------------------------------------
  # HTML: begin preamble block
  #
  #     The order of items in the preamble are as follows:
  #
  #     (1) author(s)
  #     (2) editor(s)
  #     (3) organization
  #     (4) revision
  #     (5) copyright
  #     (6) date
  #
  push @{ $html{'preamble'} }, <<"END_OF_TEXT";
<!-- preamble -->
<div class="preamble">

END_OF_TEXT

  #-------------------------------------------------------------------
  # HTML: author
  #
  #     There may be several authors listed in the
  #     @{$document{'author'}} array.  They will be listed in the
  #     order they appear in the preamble of the document.  Here are
  #     some examples of how they should be listed:
  #
  #     A single author:
  #
  #       Mickey Mouse
  #
  #     Two authors:
  #
  #       Mickey Mouse and Donald Duck
  #
  #     Three or more authors:
  #
  #       Mickey Mouse, Donald Duck and Goofy
  #
  my $author       = $EMPTY_STRING;
  my @authors      = @{ $document{'author'} };
  my $author_count = scalar(@authors);

  if ($author_count == 1) {
    $author = $authors[0];
  }
  elsif ($author_count == 2) {
    $author = join(' and ', @authors);
  }
  elsif ($author_count > 2) {
    my $last_author   = pop(@authors);
    my $first_authors = join(', ', @authors);
    $author = $first_authors . ' and ' . $last_author;
  }

  if ($author) {
    push @{ $html{'preamble'} }, "<div align=\"center\">By $author</div>\n";
  }

  #-------------------------------------------------------------------
  # HTML: editor
  #
  #     There may be several editors listed in the
  #     @{$document{'editor'}} array.  They will be listed in the
  #     order they appear in the preamble of the document.  Here are
  #     some examples of how they should be listed:
  #
  #     A single editor:
  #
  #       Edited by Mickey Mouse
  #
  #     Two editors:
  #
  #       Edited by Mickey Mouse and Donald Duck
  #
  #     Three or more editors:
  #
  #       Edited by Mickey Mouse, Donald Duck and Goofy
  #
  my $editor       = $EMPTY_STRING;
  my @editors      = @{ $document{'editor'} };
  my $editor_count = scalar(@editors);

  if ($editor_count == 1) {
    $editor = $editors[0];
  }
  elsif ($editor_count == 2) {
    $editor = join(' and ', @editors);
  }
  elsif ($editor_count > 2) {
    my $last_editor   = pop(@editors);
    my $first_editors = join(', ', @editors);
    $editor = $first_editors . ' and ' . $last_editor;
  }

  if ($editor) {
    push @{ $html{'preamble'} }, "<div align=\"center\">Edited by $editor</div>\n";
  }

  #-------------------------------------------------------------------
  # HTML: organization
  #
  if ($document{'organization'}) {
    my $organization = escape_html( $document{'organization'} );
    push @{ $html{'preamble'} }, <<"END_OF_TEXT";
<div align="center">$organization</div>
END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # HTML: revision
  #
  if ($document{'revision'}) {

    my $version  = trim_whitespace($document{'version'});
    my $revision = trim_whitespace($document{'revision'});
    my $modified = trim_whitespace($document{'modified'});
    my $date     = trim_whitespace($document{'date'});

    $version  = '<font color="#888888">v' . $version . '</font>';
    $revision = '<font color="#888888">r' . $revision . '</font>';
    $date     = $1 if $date =~ /\((\w+,\s+\d+\s+\w+\s+\d+)\)/;
    $date     = '<font color="#888888">' . $date . '</font>';

    push @{ $html{'preamble'} }, <<"END_OF_TEXT";
<div align="center">$version $revision $date</div>
END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # HTML: copyright
  #
  if ($document{'copyright'}) {
    my $copyright = $document{'copyright'};
    push @{ $html{'preamble'} }, <<"END_OF_TEXT";
<div align="center">Copyright &copy; $copyright</div>
END_OF_TEXT
  }
}

######################################################################

sub end_preamble {

  printdebug("end_preamble") if $DEBUGGING;

  $in{'preamble'}{'text'} = 0;

  #-------------------------------------------------------------------
  # Manage Stacks
  #
  $current{'name'} = 'universal';
  pop(@{ $current{'name_stack'} });
  push(@{ $current{'name_stack'} }, $current{'name'});

  $current{'label'} = 'text';
  pop(@{ $current{'label_stack'} });
  push(@{ $current{'label_stack'} }, $current{'label'});

  $current{'title'} = 'no title';
  pop(@{ $current{'title_stack'} });
  push(@{ $current{'title_stack'} }, $current{'title'});

  my $name = $current{'name'};
  my $num  = $count{$name}{'total'};
  $data{$name}{$num}{'label'} = $current{'label'};

  #-------------------------------------------------------------------
  # HTML
  #
  push @{ $html{'preamble'} }, <<"END_OF_TEXT";
</div>

END_OF_TEXT

}

######################################################################

sub end_region_preamble {

  printdebug("end_region_preamble") if $DEBUGGING;

  $in{'region'}{'preamble'} = 0;

  foreach my $region (keys %structure) {
    $in{$region}{'preamble'} = 0;
  }

}

######################################################################

sub begin_rcsinfo {

  printdebug("begin_rcsinfo") if $DEBUGGING;

  $in{'rcsinfo'} = 1;

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {
    push @{ $html{'preamble'} }, <<"END_OF_TEXT";
<div align="center">
<table bgcolor="#eeeeee" border="0" cellpadding="1" cellspacing="0">

END_OF_TEXT
  }

}

######################################################################

sub begin_revisions {

  # This subroutine renders the entire revisions list collected during
  # pass 2.

  printdebug("begin_revisions") if $DEBUGGING;

  $in{'revisions'}{'environment'} = 1;

  $current{'name'} = 'Revisions';
  pop(@{ $current{'name_stack'} });
  push(@{ $current{'name_stack'} }, $current{'name'});

  ++$count{'revenv'}{'section'};
  ++$count{'revenv'}{'total'};

  end_pre()           if $in{'pre'};
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};
  end_baretable()     if $in{'baretable'} == 1;
  end_preamble()      if $in{'preamble'}{'text'};

  $count{'toplevel'} = $scounter{1};

  my $num         = $count{'revenv'}{'total'};
  my $title       = $data{'revisions'}{$num}{'title'};
  my $description = $data{'revisions'}{$num}{'description'};
  my $label       = $data{'revisions'}{$num}{'label'} || $EMPTY_STRING;

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum      = $current{'secnum'};
    my $outfile     = $html_revisions_file;
    my $aref        = $html{'revisions'};
    my $border      = '0';
    my $cellpadding = '6';
    my $cellspacing = '0';

    #-----------------------------------------------------------------
    # HTML: revisions list title
    #
    my $html_title       = escape_html($title);
    my $html_description = escape_html($description);

    #-----------------------------------------------------------------
    # HTML: begin table for revisions list
    #
    push @{ $aref }, "<table";       # the MDC (>) is intentionally missing

    if ($border !~ /^\s*$/) {
      push @{ $aref }, " border=\"$border\"";
    }

    else {
      push @{ $aref }, " border=\"0\"";
    }

    if ($cellpadding !~ /^\s*$/) {
      push @{ $aref }, " cellpadding=\"$cellpadding\"";
    }

    else {
      push @{ $aref }, " cellpadding=\"6\"";
    }

    if ($cellspacing !~ /^\s*$/) {
      push @{ $aref }, " cellspacing=\"$cellspacing\"";
    }

    else {
      push @{ $aref }, " cellspacing=\"0\"";
    }

    push @{ $aref }, ">\n";          # here is the MDC

    #-----------------------------------------------------------------
    # HTML: Revisions Table header
    #
    #     Render the table column heads (versions, data, summary of
    #     changes)
    #
    push @{ $aref }, <<'END_OF_TEXT';
<tr>
<th width="15%" align="left">Version</th>
<th width="15%" align="left">Date</th>
<th width="70%" align="left">Summary of Changes</th>
</tr>

END_OF_TEXT

    #-----------------------------------------------------------------
    # HTML: Render each revision description
    #
    my @revisions = @{ $data{'revisions'}{$num}{'rev'} };
    foreach my $revision (@revisions) {

      # If this revision description has all three elements (version,
      # date, and summary)
      #
      if ( $revision =~ /(.*?)=(.*?)=(.*)/) {

	my $version = trim_whitespace($1);
	my $date    = trim_whitespace($2);
	my $summary = escape_html(trim_whitespace($3));

	$version = wrap('<td>' . $version . '</td>');
	$date    = wrap('<td>' . $date    . '</td>');
	$summary = wrap('<td>' . $summary . '</td>');

	push @{ $aref }, <<"END_OF_TEXT";
<tr>
$version
$date
$summary
</tr>

END_OF_TEXT

      }

      # Otherwise this revision description does *not* have all three
      # elements (version, date, and summary) so render it only as a
      # summary.
      #
      else {

	my $version = '<td></td>';
	my $date    = '<td></td>';
	my $summary = wrap('<td>' . trim_whitespace($revision) . '</td>');

	push @latex, <<"END_OF_TEXT";
<tr>
$version
$date
$summary
</tr>

END_OF_TEXT

      }
    }
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # XML: some variables
    #
    my $xml_title   = escape_xml($title);
    my $border      = '';
    my $cellpadding = '';
    my $cellspacing = '';

    #-----------------------------------------------------------------
    # XML: begin the revisions list table
    #
    push @xml, "<table>\n\n";

    #-----------------------------------------------------------------
    # XML: revisions list title
    #
    push @xml, <<"END_OF_TEXT";
<title>$xml_title</title>

END_OF_TEXT

    #-----------------------------------------------------------------
    # XML: Table header
    #
    my @columns = ('Version','Date','Summary of Changes');
    push @xml, "<tr>\n";
    foreach my $column (@columns) {
      push @xml, "<th>$column</th>\n";
    }
    push @xml, "</tr>\n\n";
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # PDF: Retrieve the title, description and label text
    #
    my $title       = escape_latex($data{'revisions'}{$num}{'title'});
    my $description = escape_latex($data{'revisions'}{$num}{'description'});
    my $label       = $data{'revisions'}{$num}{'label'};
    my $caption     = '';

    $caption .= "$title"          if $title;
    $caption .= " - $description" if $description;

    #-----------------------------------------------------------------
    # PDF: begin revisions table
    #
    push @latex, <<'END_OF_TEXT';
\chapter*{Revisions}

\setlength\LTpre{0pt}
\setlength\LTpost{0pt}
\setlength{\tablewidth}{\textwidth}
\setlength{\extrarowheight}{4pt}
\begin{longtable}[l]{%
@{}
>{\raggedright\arraybackslash}p{0.1124\tablewidth}
>{\raggedright\arraybackslash}p{0.1124\tablewidth}
>{\raggedright\arraybackslash}p{0.7340\tablewidth}
@{}
}
\tabularnewline
\endfirsthead
\tabularnewline
\endhead
\tabularnewline
\endfoot
\endlastfoot

\textbf{Version}
&
\textbf{Date}
&
\textbf{Summary of Changes}
\\

END_OF_TEXT

    #-----------------------------------------------------------------
    # PDF: Render each revision description
    #
    my @revisions = @{ $data{'revisions'}{$num}{'rev'} };
    foreach my $revision (@revisions) {

      # If this revision description has all three elements (version,
      # date, and summary)
      #
      if ( $revision =~ /(.*?)=(.*?)=(.*)/) {

	my $version = wrap(trim_whitespace($1));
	my $date    = wrap(trim_whitespace($2));
	my $summary = wrap(escape_latex(trim_whitespace($3)));

	push @latex, <<"END_OF_TEXT";
$version
&
$date
&
$summary
\\\\

END_OF_TEXT

      }

      # Otherwise this revision description does *not* have all three
      # elements (version, date, and summary) so render it only as a
      # summary.
      #
      else {

	my $version = '';
	my $date    = '';
	my $summary = wrap(trim_whitespace($revision));

	push @latex, <<"END_OF_TEXT";
$version
&
$date
&
$summary
\\\\

END_OF_TEXT

      }
    }
  }
}

######################################################################

sub begin_table {

  printdebug("begin_table") if $DEBUGGING;

  $in{'table'}{'environment'} = 1;

  $current{'name'} = 'Table';
  pop(@{ $current{'name_stack'} });
  push(@{ $current{'name_stack'} }, $current{'name'});

  ++$count{'table'}{'section'}; # number of tables in toplevel section
  ++$count{'table'}{'total'};   # total number of tables in document

  end_pre()           if $in{'pre'};
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};
  end_baretable()     if $in{'baretable'} == 1;
  end_preamble()      if $in{'preamble'}{'text'};

  $count{'toplevel'} = $scounter{1};

  my $num         = $count{'table'}{'total'};
  my $title       = $data{'table'}{$num}{'title'};
  my $description = $data{'table'}{$num}{'description'};
  my $label       = $data{'table'}{$num}{'label'} || $EMPTY_STRING;

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum      = $current{'secnum'};
    my $outfile     = html_outfile_for_secnum($secnum);
    my $aref        = $html{'body'}{$secnum};
    my $border      = '';
    my $cellpadding = '';
    my $cellspacing = '';

    #-----------------------------------------------------------------
    # HTML: insert anchor element
    #
    #     If this table is inside a section insert an anchor that
    #     includes the section number (i.e. $count{'toplevel'}),
    #     otherwise, insert an anchor without a section number.
    #
    my $tab_num = '';
    if ($secnum) {
      $tab_num = "$count{'toplevel'}-$count{'table'}{'section'}";
    } else {
      $tab_num = "$count{'table'}{'section'}";
    }
    my $anchor  = "Table.$tab_num";
    push @{ $aref }, "<a name=\"$anchor\">\n";

    #-----------------------------------------------------------------
    # HTML: table title
    #
    my $html_title       = escape_html($title);
    my $html_description = escape_html($description);

    #-----------------------------------------------------------------
    # HTML: Build the HTML caption.
    #
    my $html_caption = "<p align=\"center\"><b>Table $tab_num";
    $html_caption .= " - $html_title" if $html_title;
    $html_caption .= "</b>";
    $html_caption .= " - $html_description" if $html_description;
    $html_caption .= "</p>";
    my $block = wrap($html_caption) . "\n\n";
    push @{ $aref }, $block;

    #-----------------------------------------------------------------
    # HTML: table index section heading
    #
    #     Put the current section heading in the table index if
    #     necessary
    #
    if (not $heading_in_table_index) {
      $heading_in_table_index = 1;
      my $heading = escape_html($current{'top_heading'});
      push @{ $html{'table'}{'index'} }, <<"END_OF_TEXT";
<h3>$heading</h3>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # HTML: if this table title occurs inside a section, make the
    # section number part of the table number
    #
    push @{ $html{'table'}{'index'} }, <<"END_OF_TEXT";
<span class="indent">$tab_num &nbsp;&nbsp; <a href="$outfile#$anchor">$html_title</a></span><br>

END_OF_TEXT

    push @{ $aref }, "<div align=\"center\">\n";
    push @{ $aref }, "<table";       # the MDC (>) is intentionally missing

    if ($border !~ /^\s*$/) {
      push @{ $aref }, " border=\"$border\"";
    }

    else {
      push @{ $aref }, " border=\"0\"";
    }

    if ($cellpadding !~ /^\s*$/) {
      push @{ $aref }, " cellpadding=\"$cellpadding\"";
    }

    else {
      push @{ $aref }, " cellpadding=\"6\"";
    }

    if ($cellspacing !~ /^\s*$/) {
      push @{ $aref }, " cellspacing=\"$cellspacing\"";
    }

    else {
      push @{ $aref }, " cellspacing=\"0\"";
    }

    push @{ $aref }, ">\n";          # here is the MDC

    #-----------------------------------------------------------------
    # HTML: Table header
    #
    #     Render the table column heads if specified.
    #
    if ( column_heads_present($num) ) {
      push @{ $aref }, "<tr>\n";

      foreach my $column ( sort {$a <=> $b} keys %{ $data{'table'}{$num} } ) {
	next if not $column =~ /^\d+$/;
	my $head = $data{'table'}{$num}{$column}{'head'} || '';
	$head = escape_html($head);
	push @{ $aref }, "<th>$head</th>\n";
      }

      push @{ $aref }, "</tr>\n\n";
    }

  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # XML: Retreive the table title captured in pass 2.
    #
    my $xml_title   = escape_xml($title);
    my $border      = '';
    my $cellpadding = '';
    my $cellspacing = '';

    #-----------------------------------------------------------------
    # XML: begin the table
    #
    push @xml, "<table";        # the MDC (>) is intentionally missing

    if ($border !~ /^\s*$/) {
      push @xml, " border=\"$border\"";
    }

    else {
      push @xml, " border=\"0\"";
    }

    if ($cellpadding !~ /^\s*$/) {
      push @xml, " cellpadding=\"$cellpadding\"";
    }

    else {
      push @xml, " cellpadding=\"6\"";
    }

    if ($cellspacing !~ /^\s*$/) {
      push @xml, " cellspacing=\"$cellspacing\"";
    }

    else {
      push @xml, " cellspacing=\"0\"";
    }

    if ($label) {
      push @xml, " id=\"$label\"";
    }

    push @xml, ">\n\n";         # here is the MDC

    #-----------------------------------------------------------------
    # XML: table title
    #
    push @xml, <<"END_OF_TEXT";
<title>$xml_title</title>

END_OF_TEXT

    #-----------------------------------------------------------------
    # XML: Table header
    #
    #     Render the table column heads if specified.
    #
    if ( column_heads_present($num) ) {
      push @{ $aref }, "<tr>\n";

      foreach my $column ( sort keys %{ $data{'table'}{$num} } ) {
	my $head = $data{'table'}{$num}{$column}{'head'} || '';
	push @{ $aref }, "<th>$head</th>\n";
      }

      push @{ $aref }, "</tr>\n\n";
    }
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # PDF: Determine the column count for this table.
    #
    my $column_count = 1;
    until (not defined $data{'table'}{$num}{'column_size'}{$column_count}) {
      ++ $column_count;
    }
    -- $column_count;

    if ($DEBUGGING) {
      printdebug("begin_table: column_count $column_count");
    }

    #-----------------------------------------------------------------
    # PDF: Determine whether this table uses color
    #
    my $uses_color = 'no';
    $uses_color = 'yes' if $data{'table'}{$num}{'uses_color'};

    printdebug("table $num column count: $column_count uses color: $uses_color") if $DEBUGGING;

    #-----------------------------------------------------------------
    # PDF: Determine this table's orientation
    #
    my $orientation = '';
    if ($data{'table'}{$num}{'orientation'} eq 'landscape') {
      $orientation = 'landscape';
    } else {
      $orientation = 'portrait';
    }

    #-----------------------------------------------------------------
    # PDF: Determine a max width number.
    #
    #     Add together the number of characters in the largest cells
    #     of each column.
    #
    #     Occaisionally I'll run across a document that hasn't been
    #     hard wrapped at column 70.  In this case, we want to assume
    #     the column width is 70.
    #
    my $total_char_count = 1;
    for my $column (1..$column_count) {
      my $column_size = $data{'table'}{$num}{'column_size'}{$column};
      $column_size = $COLUMN_CHAR_CAP if $column_size > $COLUMN_CHAR_CAP;
      $total_char_count += $column_size;
    }

    #-----------------------------------------------------------------
    # PDF: Determine column widths.
    #
    #     Determine the percentage of table width for each column
    #     based on the fraction of characters in each column.
    #
    my $column_spec = '@{}' . "\n";
    my $long_spec   = '@{}' . "\n";

    for my $column (1..$column_count) {

      my $specified_width = $data{'table'}{$num}{$column}{'width'};

      #---------------------------------------------------------------
      # The document specified a column width
      #
      if ($specified_width) {

	my $width = $specified_width / 100;
	$width = sprintf("%.4f", $width);
	# print "  column $column ($column_char_count of $total_char_count) width: $width\n";
	$column_spec .= ">{\\small\\raggedright\\arraybackslash\\setlength{\\hsize}{$width\\hsize}}X\n";
	$long_spec .= ">{\\small\\raggedright\\arraybackslash}p{$width\\tablewidth}\n";
	$current_table{'column'}{$column}{'width'} = $width;

      }

      #---------------------------------------------------------------
      # Calculate a column width
      #
      else {

	my $column_char_count = $data{'table'}{$num}{'column_size'}{$column};

	# If this is a narrow column (less than 12 characters) add 3
	# to the character count to make sure there is enough
	# whitespace.
	#
	$column_char_count = $column_char_count + 3 if $column_char_count < 12;

	# Truncate the character count at $COLUMN_CHAR_CAP
	#
	$column_char_count = $COLUMN_CHAR_CAP
	  if $column_char_count > $COLUMN_CHAR_CAP;

	# compute column width as percentage of table width
	#
	my $width = ($column_char_count/$total_char_count);
	$width = sprintf("%.4f", $width);

	$column_spec .= ">{\\small\\raggedright\\arraybackslash\\setlength{\\hsize}{$width\\hsize}}X\n";
	$long_spec .= ">{\\small\\raggedright\\arraybackslash}p{$width\\tablewidth}\n";
	$current_table{'column'}{$column}{'width'} = $width;

      }

    }

    $column_spec .= '@{}';
    $long_spec   .= '@{}';

    #-----------------------------------------------------------------
    # PDF: Determine the overall width of the table.
    #
    #     The overall width of the table depends on the following
    #     factors:
    #
    #     - sum of size of widest cell in each column
    #     - font size
    #
    #     There are 72.27 printer points per inch.  Therefore:
    #
    #       10pt font: 7.23 characters per inch
    #       11pt font: 6.57 characters per inch
    #       12pt font: 6.02 characters per inch
    #

    #-----------------------------------------------------------------
    # PDF: set the value for points per inch
    #
    my $points_per_inch = 72.27;

    #-----------------------------------------------------------------
    # PDF: determine number of points in this font size
    #
    my $font_points = 10;
    if ($fontsize =~ /^(\d+)/) {
      $font_points = $1;
    }

    #-----------------------------------------------------------------
    # PDF: Ratio of font width to font height.
    #
    #     The approximate ratio of font width to font height
    #     (experimentally determined) default = 0.54
    #
    #     !!! Bug Here !!!
    #
    #     The logic of this breaks down when you have cell text that
    #     is bold (wider than normal) or italic (narrower than
    #     normal).  Find a better way to do this!
    #
    my $ratio = .54;

    #-----------------------------------------------------------------
    # PDF: Text Width.
    #
    #     For starters, assume the text width is 6.0 inches and the
    #     width will be the same as the current \textwidth.
    #
    my $line_width = 6.0;
    my $width      = "6.0in";

    #-----------------------------------------------------------------
    # PDF: Calculate table width.
    #
    #     Calculate the table width based on the total number of
    #     characters in the table.
    #
    #     !!! Bug Here !!!
    #
    #     The logic of this breaks down when you have a table with
    #     several sparsely populated columns.  Find a better way to
    #     determine table width!
    #
    my $table_width = '';
    if ( $data{'table'}{$num}{'width'} ) {
      $width = $data{'table'}{$num}{'width'};
    } else {
      $table_width = $total_char_count * (($font_points*$ratio)/$points_per_inch);
      $table_width = sprintf("%.4f", $table_width);
      if ($table_width <= $line_width) {
	$width = "${table_width}in";
      }
    }

    #-----------------------------------------------------------------
    # PDF: table width correction
    #
    #     For some reason, the \tablewidth is not honored by LaTeX.
    #     The width of a table stretches as more columns are added to
    #     it.  I've discovered:
    #
    #     - tables without colored cells need to be reduced in width
    #       by 0.25in
    #
    #     - tables with colored cells need to be reduced in width by
    #       (0.19 x number of columns) inches.
    #
    my $width_correction = "-0.5in";

    #-----------------------------------------------------------------
    # PDF: Retrieve the title, description and label text
    #
    my $title       = escape_latex($data{'table'}{$num}{'title'});
    my $description = escape_latex($data{'table'}{$num}{'description'});
    my $label       = $data{'table'}{$num}{'label'};
    my $caption     = '';

    $caption .= "$title"          if $title;
    $caption .= " - $description" if $description;

    #-----------------------------------------------------------------
    # PDF: Longtable?
    #
    #     If the size of this table is GREATER THAN the maximum float
    #     size,
    #
    #     OR
    #
    #     If this table contains defined column headers
    #
    #     then this should be typeset as a longtable.
    #
    if (
	$data{'table'}{$num}{'table_size'} > $max_float_size
	or
	column_heads_present($num)
       ) {
      $in{'longtable'} = 1;
    }

    else {
      $in{'longtable'} = 0;
    }

    #-----------------------------------------------------------------
    # PDF: Begin landscape if orientation is landscape
    #
    if ( $orientation eq 'landscape' ) {
      push @latex, <<"END_OF_TEXT";
\\begin{landscape}

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # PDF: column headers
    #
    #     Render the table column heads if specified.
    #
    my @head_block = ();
    my $head_block = '';
    if ( column_heads_present($num) ) {
      foreach my $column ( sort {$a <=> $b} keys %{ $data{'table'}{$num} } ) {
	next if not $column =~ /^\d+$/;
	my $head = escape_latex( $data{'table'}{$num}{$column}{'head'} ) || '';
	push(@head_block,"\\bfseries\\centering $head");
      }
      $head_block = join('&',@head_block) . '\\';
    }

    #-----------------------------------------------------------------
    # PDF: If we're rendering a longtable, then start it this way...
    #
    if ($in{'longtable'} and $using_longtable) {

      my $caption_block      = wrap("\\caption[$title]{$caption}");
      my $caption_cont_block = wrap("\\caption[]{$title (\\textit{continued\\ldots})}");

      if ($DEBUGGING) {
	printdebug("pass 3 rendering table label $label");
      }

      push @latex, <<"END_OF_TEXT";
%% begin longtable
%%
\\setlength{\\tablewidth}{$width}
%% \\addtolength{\\tablewidth}{$width_correction}
\\setlength{\\extrarowheight}{4pt}
\\setlength{\\LTcapwidth}{\\hsize}
\\setlength{\\LTpre}{\\bigskipamount}
\\begin{longtable}[c]{%
$long_spec
}
$caption_block
\\label{$label}
\\tabularnewline
$head_block
\\endfirsthead
$caption_cont_block
\\tabularnewline
$head_block
\\endhead
\\tabularnewline
\\endfoot
\\endlastfoot

END_OF_TEXT

    }

    elsif ($in{'longtable'} and $using_supertabular) {

      push @latex, <<"END_OF_TEXT";
%% begin supertabular
%%
\\setlength{\\tablewidth}{$width}
%% \\addtolength{\\tablewidth}{$width_correction}
\\setlength{\\extrarowheight}{4pt}
\\tablecaption[$title]{$caption}
\\label{$label}
\\begin{supertabular}[c]{%
$long_spec
}

END_OF_TEXT

    }

    #-----------------------------------------------------------------
    # PDF: ...otherwise, we're NOT rendering a longtable, so start it
    # this way...
    #
    else {

      my $caption_block = wrap("\\caption[$title]{$caption}");

      push @latex, <<"END_OF_TEXT";
%% begin tabularx table
%%
\\begin{table}[ht]
\\centering
$caption_block
\\label{$label}
\\vspace{.5\\baselineskip}
\\setlength{\\extrarowheight}{4pt}
\\setlength{\\tablewidth}{$width}
\\begin{tabularx}{$width}{%
$column_spec
}

END_OF_TEXT

    }
  }
}

######################################################################

sub begin_celltext {

  printdebug("begin_celltext") if $DEBUGGING;

  $in{'celltext'} = 1;

}

######################################################################

sub end_celltext {

  printdebug("end_celltext") if $DEBUGGING;

  $in{'celltext'} = 0;

}

######################################################################

sub begin_title {

  my $name = shift;

  printdebug("begin_title($name)") if $DEBUGGING;

  $in{$name}{'title'} = 1;

}

######################################################################

sub end_title {

  my $name = shift;

  printdebug("end__title($name)") if $DEBUGGING;

  $in{$name}{'title'} = 0;

}

######################################################################

sub begin_baretable {

  printdebug("begin_baretable") if $DEBUGGING;

  $in{'baretable'} = 1;

  $current{'name'} = 'Baretable';
  pop(@{ $current{'name_stack'} });
  push(@{ $current{'name_stack'} }, $current{'name'});

  ++ $count{'baretable'}{'section'}; # number of baretables in toplevel section
  ++ $count{'baretable'}{'total'}; # total number of baretables in document

  end_pre()           if $in{'pre'};
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};
  end_preamble()      if $in{'preamble'}{'text'};

  $count{'toplevel'} = $scounter{1};

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {
    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};
    push @{ $aref }, "<div align=\"center\">\n";
    push @{ $aref }, "<table border=\"0=\" cellpadding=\"6\" cellspacing=\"0\">";
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, "<table>\n\n";
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # PDF: Get the number of this table.
    #
    my $num = $count{'baretable'}{'total'};

    #-----------------------------------------------------------------
    # PDF: determine the column count for this table
    #
    #     !!! BUG HERE !!!
    #
    #     This seems an odd way to determine the number of columns in
    #     a baretable.  Pass 2 should count the number of columns and
    #     here that number should simply be looked up.
    #
    #     $data{'baretable'}{$num}{'column_count'}
    #
    my $column_count = 1;
    while (defined $data{'baretable'}{$num}{'column_size'}{$column_count}) {
      ++ $column_count;
    }
    -- $column_count;

    my $uses_color = 'no';
    $uses_color = 'yes' if $data{'baretable'}{$num}{'uses_color'};

    printdebug("baretable $num column count: $column_count color: $uses_color") if $DEBUGGING;

    #-----------------------------------------------------------------
    # PDF: Max Width
    #
    #     Determine a max width number by adding together the number
    #     of characters in the largest cells of each column
    #
    #     Occaisionally I'll run across a document that hasn't been
    #     hard wrapped at column 70.  In this case, we want to assume
    #     the column width is 70.
    #
    my $total_char_count = 1;
    for my $column (1..$column_count) {
      my $column_size = $data{'baretable'}{$num}{'column_size'}{$column};
      $column_size = $COLUMN_CHAR_CAP if $column_size > $COLUMN_CHAR_CAP;
      $total_char_count += $column_size;
    }

    #-----------------------------------------------------------------
    # PDF: Column Width Percentages
    #
    #     Determine the percentage of table width for each column
    #     based on the fraction of characters in each column
    #
    my $column_spec   = '@{}' . "\n";
    my $long_spec     = '@{}' . "\n";
    for my $count (1..$column_count) {
      my $column_char_count = $data{'baretable'}{$num}{'column_size'}{$count};

      # If this is a narrow column (less than 12 characters) add 3 to
      # the character count to make sure there is enough whitespace.
      #
      $column_char_count = $column_char_count + 3 if $column_char_count < 12;

      # Truncate the character count at 70
      #
      $column_char_count = $COLUMN_CHAR_CAP if $column_char_count > $COLUMN_CHAR_CAP;

      my $width = ($column_char_count/$total_char_count);
      $width = sprintf("%.4f", $width);

      $column_spec .= ">{\\small\\raggedright\\arraybackslash\\setlength{\\hsize}{$width\\hsize}}X\n";
      $long_spec .= ">{\\small\\raggedright\\arraybackslash}p{$width\\tablewidth}\n";
      $current_table{'column'}{$count}{'width'} = $width;

    }
    $column_spec .= '@{}';
    $long_spec   .= '@{}';

    #-----------------------------------------------------------------
    # PDF: Table Width
    #
    #     Determine the overall width of the table.  The overall width
    #     of the table depends on the following factors:
    #
    #       - sum of size of widest cell in each column
    #       - font size
    #
    #     There are 72.27 printer points per inch.  Therefore:
    #
    #        10pt font: 7.23 characters per inch
    #        11pt font: 6.57 characters per inch
    #        12pt font: 6.02 characters per inch

    #-----------------------------------------------------------------
    # PDF: set the value for points per inch
    #
    my $points_per_inch = 72.27;

    #-----------------------------------------------------------------
    # PDF: determine number of points in this font size
    #
    my $font_points = 10;
    if ($fontsize =~ /^(\d+)/) {
      $font_points = $1;
    }

    #-----------------------------------------------------------------
    # PDF: Approximate Fint Width/Height Ratio
    #
    #     The approximate ratio of font width to font height
    #     (experimentally determined) default = 0.54
    #
    #     NOTE: the logic of this breaks down when you have cell text
    #     that is bold (wider than normal) or italic (narrower than
    #     normal).  Find a better way to do this!
    #
    my $ratio = .54;

    #-----------------------------------------------------------------
    # PDF: Calculated Table Width
    #
    #     Calculate the table width based on the total number of
    #     characters in the table.
    #
    #     NOTE: the logic of this breaks down when you have a table
    #     with several sparsely populated columns.  Find a better way
    #     to determine table width!
    #
    my $table_width = $total_char_count * (($font_points*$ratio)/$points_per_inch);

    #-----------------------------------------------------------------
    # PDF: Round the table width value to four decimal places.
    #
    $table_width = sprintf("%.4f", $table_width);

    #-----------------------------------------------------------------
    # PDF: For starters, assume the text width is 6.75 inches. and the
    # width will be the same as the current \textwidth.
    #
    my $line_width = 6.0;
    my $width = "\\textwidth";

    #-----------------------------------------------------------------
    # PDF: Decide how wide the table should be. If the calculated
    # table width is GREATER THAN the line width, then set the width
    # of the table ($width) to equal the linewidth. Otherwise, use the
    # calculated table width.
    #
    if ($table_width > $line_width) {
      $width = "\\textwidth";
    }

    else {
      $width = "${table_width}in";
    }

    #-----------------------------------------------------------------
    # PDF: table width correction
    #
    #     For some reason, the \tablewidth is not honored by LaTeX.
    #     The width of a table stretches as more columns are added to
    #     it.  I've discovered:
    #
    #     - tables without colored cells need to be reduced in width
    #       by 0.25in
    #
    #     - tables with colored cells need to be reduced in width by
    #       (0.19 x number of columns) inches.
    #
    my $width_correction = "-0.5in";

    #-----------------------------------------------------------------
    # PDF: Baretables are ALWAYS rendered as longtables.
    #
    $in{'longtable'} = 1;

    if ($using_longtable) {

      push @latex, <<"END_OF_TEXT";
%% begin bare longtable
%%
\\setlength\\LTpre{0pt}
\\setlength\\LTpost{0pt}
\\setlength{\\tablewidth}{$width}
%% \\addtolength{\\tablewidth}{$width_correction}
\\setlength{\\extrarowheight}{4pt}
\\begin{longtable}[l]{%
$long_spec
}
\\tabularnewline
\\endfirsthead
\\tabularnewline
\\endhead
\\tabularnewline
\\endfoot
\\endlastfoot

END_OF_TEXT

    }

    elsif ($using_supertabular) {

      push @latex, <<"END_OF_TEXT";
%% begin supertabular
%%
\\setlength{\\tablewidth}{$width}
%% \\addtolength{\\tablewidth}{$width_correction}
\\setlength{\\extrarowheight}{4pt}
\\begin{supertabular}[l]{%
$long_spec
}

END_OF_TEXT

    }
  }
}

######################################################################

sub end_revisions {

  printdebug("end_revisions") if $DEBUGGING;

  # What if we've been asked to end a revisions list but we're not
  # actually in one?
  #
  return if not $in{'revisions'}{'environment'} == 1;

  $in{'revisions'}{'environment'} = 0;
  $current{'column'}          = 0;
  # $current{'name'}            = $EMPTY_STRING;

  my $num = $count{'revenv'}{'total'};

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {
    my $secnum = $current{'secnum'};
    my $aref   = $html{'revisions'};
    push @{ $aref }, <<"END_OF_TEXT";
</table>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, <<"END_OF_TEXT";
</table>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    push @latex, <<"END_OF_TEXT";
\\end{longtable}
%%
%% end revisions

END_OF_TEXT

  }
}

######################################################################

sub end_table {

  printdebug("end_table") if $DEBUGGING;

  # What if we've been asked to end a table but we're not actually
  # in one?
  #
  return if not $in{'table'}{'environment'} == 1;

  end_table_item()   if $in{'item'};
  end_table_list()   if $in{'table_list'};
  end_celltext()     if $in{'celltext'};
  end_table_header() if $in{'header'};
  end_table_cell()   if $in{'cell'};
  end_table_row()    if $in{'row'};

  $in{'table'}{'environment'} = 0;
  $current{'column'}          = 0;
  # $current{'name'}            = $EMPTY_STRING;

  my $num = $count{'table'}{'total'};

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {
    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};
    push @{ $aref }, <<"END_OF_TEXT";
</table>
</div>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, <<"END_OF_TEXT";
</table>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # PDF: Determine this table's orientation
    #
    my $orientation = '';
    if ($data{'table'}{$num}{'orientation'} eq 'landscape') {
      $orientation = 'landscape';
    } else {
      $orientation = 'portrait';
    }

    # using longtable
    #
    if ($in{'longtable'}) {
      $in{'longtable'} = 0;
      if ($using_longtable) {
        push @latex, <<"END_OF_TEXT";
\\end{longtable}
%%
%% end table (end_table sub)

END_OF_TEXT
      }
    }

    # using supertabular
    #
    elsif ($using_supertabular) {
      push @latex, <<"END_OF_TEXT";
\\end{supertabular}
%%
%% end table

END_OF_TEXT
    }

    # using tabularx
    #
    else {
      push @latex, <<"END_OF_TEXT";
\\end{tabularx}
\\end{table}
%%
%% end table

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # PDF: End landscape if orientation is landscape
    #
    if ( $orientation eq 'landscape' ) {
      push @latex, <<"END_OF_TEXT";
\\end{landscape}

END_OF_TEXT
    }

  }
}

######################################################################

sub end_baretable {

  printdebug("end_baretable") if $DEBUGGING;

  # What if we've been asked to end a baretable but we're not actually
  # in one?
  #
  return if not $in{'baretable'} == 1;

  end_table_header() if $in{'header'};
  end_table_cell()   if $in{'cell'};
  end_table_row()    if $in{'row'};

  $in{'baretable'}   = 0;
  $current{'column'} = 0;
  # $current{'name'} = $EMPTY_STRING;

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {
    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};
    push @{ $aref }, <<"END_OF_TEXT";
</table>
</div>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, <<"END_OF_TEXT";
</table>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    if ($in{'longtable'}) {

      $in{'longtable'}   = 0;

      if ($using_longtable) {

      push @latex, <<"END_OF_TEXT";
\\end{longtable}
%%
%% end table (end_baretable sub)

END_OF_TEXT

      }

      elsif ($using_supertabular) {

      push @latex, <<"END_OF_TEXT";
\\end{supertabular}
%%
%% end table

END_OF_TEXT

    }
    }
  }
}

######################################################################

sub begin_quotation_source {

  printdebug("begin_quotation_source") if $DEBUGGING;

  my $text = shift;

  $in{'quote'}{'quotesource'} = 1;

  end_preamble() if $in{'preamble'}{'text'};

  $count{'toplevel'} = $scounter{1};

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {
    my $html_text  = escape_html($text);
    my $secnum     = $current{'secnum'};
    my $aref       = $html{'body'}{$secnum};
    push @{ $aref }, "<p align=\"right\" class=\"source\"> - $html_text";
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    my $xml_text = escape_xml($text);
    push @xml, "<quotesource>$xml_text";
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    my $latex_text = escape_latex($text);
    chomp $latex_text;

    push @latex, <<"END_OF_TEXT";
\\begin{flushright}
-- \\textit{$latex_text

END_OF_TEXT
  }
}

######################################################################

sub end_quotation_source {
  printdebug("end_quotation_source") if $DEBUGGING;

  $in{'quote'}{'quotesource'} = 0;

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {
    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};
    push @{ $aref }, "</p>\n";
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, "</quotesource>\n";
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, "}\n\\end{flushright}\n";
  }
}

######################################################################

sub begin_table_list {

  printdebug("begin_table_list") if $DEBUGGING;

  $in{'table_list'} = 1;

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, "\\begin{tablecellitemize}\n";
  }
}

######################################################################

sub end_table_list {

  printdebug("end_table_list") if $DEBUGGING;

  $in{'table_list'} = 0;

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, "\\end{tablecellitemize}\n";
  }
}

######################################################################

sub begin_table_row {

  printdebug("begin_table_row") if $DEBUGGING;

  $in{'row'} = 1;
  $current{'column'} = 0;

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {
    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};
    push @{ $aref }, <<"END_OF_TEXT";
<tr>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, <<"END_OF_TEXT";
<tr>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, <<"END_OF_TEXT";
%% begin table row
%%

END_OF_TEXT
  }
}

######################################################################

sub end_table_row {

  printdebug("end_table_row") if $DEBUGGING;

  if ($in{'row'}) {

    end_celltext()     if $in{'celltext'};
    end_table_cell()   if $in{'cell'};
    end_table_header() if $in{'header'};

    $current{'column'} = 0;
    $in{'row'} = 0;

    #-----------------------------------------------------------------
    # HTML
    #
    if ($rendering{'html'} and not $in{'hide'}{'block'}) {
      my $secnum = $current{'secnum'};
      my $aref   = $html{'body'}{$secnum};
      push @{ $aref }, "</tr>\n";
    }

    #-----------------------------------------------------------------
    # XML
    #
    if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
      push @xml, "</tr>\n";
    }

    #-----------------------------------------------------------------
    # PDF
    #
    if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
      push @latex, "\\\\ \n\n";
    }
  }
}

######################################################################

sub begin_table_header {

  printdebug("begin_table_header") if $DEBUGGING;

  my $attrs = shift;
  my $text  = shift;
  my $bg    = 'bg-white'; # predefined LaTeX color for cell background

  end_preamble()      if $in{'preamble'}{'text'};
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};
  end_table_header()  if $in{'header'};
  end_table_cell()    if $in{'cell'};
  end_table_title()   if $in{'table'}{'title'};
  begin_table_row()   if not $in{'row'};

  $in{'header'} = 1;

  #-------------------------------------------------------------------
  # Define an error message to throw if this sobroutine gets called
  # and we're neither in a table or a baretable.
  #
  my $not_in_a_table_error = <<"END_OF_TEXT";
Something is terribly wrong. The program is trying to begin a table
cell but I'm neither a table or a baretable (this is a software bug
because the software should never let this happen)

END_OF_TEXT

  #-------------------------------------------------------------------
  # Determine the number of the table (or baretable) we're currently
  # in.
  #
  my $num = 0;

  if ($in{'table'}{'environment'}) {
    $num = $count{'table'}{'total'};
  }

  elsif ( $in{'baretable'} == 1 ) {
    $num = $count{'baretable'}{'total'};
  }

  else {
    printerror($not_in_a_table_error);
  }

  #-------------------------------------------------------------------
  # Increment the current column count
  #
  ++ $current{'column'};

  #-------------------------------------------------------------------
  # If the table header indicator (::) has text on the same line, that
  # text should be considered 'celltext' (not paragraph text,
  # pre-formatted text, or a list item).
  #
  begin_celltext() if $text;

  #-------------------------------------------------------------------
  # process the attributes for this cell
  #
  my $align       = '';
  my $bgcolor     = '';
  my $bg          = 'bg-white';
  my $cellpadding = '';
  my $cellspacing = '';
  my @attrs = split(/:/,$attrs);
  foreach my $attr (@attrs) {

    if ($attr =~ /^l$/i) {
      $align = 'left';
    }

    elsif ($attr =~ /^c$/i) {
      $align = 'center';
    }

    elsif ($attr =~ /^r$/i) {
      $align = 'right';
    }

    elsif ($attr =~ /^red$/i) {
      $bgcolor = '#ff6666';
      $bg = 'bg-red';
    }

    elsif ($attr =~ /^green$/i) {
      $bgcolor = '#66ff66';
      $bg = 'bg-green';
    }

    elsif ($attr =~ /^blue$/i) {
      $bgcolor = '#6666ff';
      $bg = 'bg-blue';
    }

    elsif ($attr =~ /^yellow$/i) {
      $bgcolor = '#ffff66';
      $bg = 'bg-yellow';
    }

    elsif ($attr =~ /^orange$/i) {
      $bgcolor = '#ffaa66';
      $bg = 'bg-orange';
    }

    elsif ($attr =~ /^purple$/i) {
      $bgcolor = '#ff66ff';
      $bg = 'bg-purple';
    }

    elsif ($attr =~ /^litegrey$/i) {
      $bgcolor = '#eeeeee';
      $bg = 'bg-litegrey';
    }

    elsif ($attr =~ /^grey$/i) {
      $bgcolor = '#dddddd';
      $bg = 'bg-grey';
    }

    elsif ($attr =~ /^darkgrey$/i) {
      $bgcolor = '#cccccc';
      $bg = 'bg-darkgrey';
    }

    elsif ($attr =~ /^(#\d{6})$/) {
      $bgcolor = "$1";
      $bg = 'bg-white';
    }
  }

  #-------------------------------------------------------------------
  # Determine the width of the current column.  For cells with a
  # colored background, the width is needed for the specification of
  # the \multicolumn command for LaTex/PDF output.
  #
  # For some reason, the \multicolumn command adds a little bit of
  # horizontal space to the table cell causing the table to expand to
  # encroach into the right margin and sometimes into non-colored
  # adjacent cells.  To correct this problem, I'm scaling the width of
  # the column to $column_shrink percent of normal.
  #
  # The column_shrink thing is depricated because I think I discovered
  # why the colored cells were too wide.
  #
  my $columnnum = $current{'column'};
  my $width     = $current_table{'column'}{$columnnum}{'width'};

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # HTML: escape characters with special meaning to HTML
    #
    my $html_text = escape_html($text);
    my $secnum    = $current{'secnum'};
    my $aref      = $html{'body'}{$secnum};

    push @{ $aref }, "<th";
    push @{ $aref }, " bgcolor=\"$bgcolor\""         if $bgcolor;
    push @{ $aref }, " cellpadding=\"$cellpadding\"" if $cellpadding;
    push @{ $aref }, " cellspacing=\"$cellspacing\"" if $cellspacing;
    push @{ $aref }, " align=\"$align\""             if $align;
    push @{ $aref }, " valign=\"top\"";
    push @{ $aref }, ">";
    push @{ $aref }, "<span style=\"font-size: 8pt;\">";
    push @{ $aref }, "$html_text\n";
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # XML: escape characters with special meaning to XML
    #
    my $xml_text = escape_xml($text);

    push @xml, "<th";
    push @xml, " bgcolor=\"$bgcolor\""         if $bgcolor;
    push @xml, " cellpadding=\"$cellpadding\"" if $cellpadding;
    push @xml, " cellspacing=\"$cellspacing\"" if $cellspacing;
    push @xml, " align=\"$align\""             if $align;
    push @xml, " valign=\"top\"";
    push @xml, ">";
    push @xml, "$xml_text\n";
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # PDF: escape characters with special meaning to LaTeX
    #
    my $latex_text = escape_latex($text);

    #-----------------------------------------------------------------
    # PDF: If we're in a baretable...
    #
    if ( $in{'baretable'} == 1 ) {

      #---------------------------------------------------------------
      # PDF: If this baretable uses colored cell backgrounds, we need
      # to specify the column color here.
      #
      if ($data{'baretable'}{$num}{'uses_color'}) {
        push @latex, "\\multicolumn{1}{>{\\small\\raggedright\\columncolor{$bg}}p{$width\\tablewidth}}{";
      }

      #---------------------------------------------------------------
      # PDF: ...Otherwise just insert the text.
      #
      push @latex, "\\textbf{$latex_text\n";
    }

    #-----------------------------------------------------------------
    # PDF: ...Otherwise we're in a normal table...
    #
    else {

      #---------------------------------------------------------------
      # PDF: If this normal table uses colored cell backgrounds, we
      # need to specify the column color here.
      #
      if ($data{'table'}{$num}{'uses_color'}) {
        push @latex, "\\multicolumn{1}{>{\\small\\raggedright\\columncolor{$bg}}p{$width\\tablewidth}}{";
      }

      #---------------------------------------------------------------
      # PDF: ...Otherwise just insert the text.
      #
      push @latex, "\\textbf{$latex_text\n";
    }

  }

  #-------------------------------------------------------------------
  # reset cell attributes
  #
  my @attrs = split(/:/,$attrs);
  foreach my $attr (@attrs) {

    if ($attr =~ /^l$/i) {
      $align   = $EMPTY_STRING;
    }

    elsif ($attr =~ /^c$/i) {
      $align   = $EMPTY_STRING;
    }

    elsif ($attr =~ /^r$/i) {
      $align   = $EMPTY_STRING;
    }

    elsif ($attr =~ /^red$/i) {
      $bgcolor = $EMPTY_STRING;
      $bg      = $EMPTY_STRING;
    }

    elsif ($attr =~ /^green$/i) {
      $bgcolor = $EMPTY_STRING;
      $bg      = $EMPTY_STRING;
    }

    elsif ($attr =~ /^blue$/i) {
      $bgcolor = $EMPTY_STRING;
      $bg      = $EMPTY_STRING;
    }

    elsif ($attr =~ /^yellow$/i) {
      $bgcolor = $EMPTY_STRING;
      $bg      = $EMPTY_STRING;
    }

    elsif ($attr =~ /^orange$/i) {
      $bgcolor = $EMPTY_STRING;
      $bg      = $EMPTY_STRING;
    }

    elsif ($attr =~ /^purple$/i) {
      $bgcolor = $EMPTY_STRING;
      $bg      = $EMPTY_STRING;
    }

    elsif ($attr =~ /^litegrey$/i) {
      $bgcolor = $EMPTY_STRING;
      $bg      = $EMPTY_STRING;
    }

    elsif ($attr =~ /^grey$/i) {
      $bgcolor = $EMPTY_STRING;
      $bg      = $EMPTY_STRING;
    }

    elsif ($attr =~ /^darkgrey$/i) {
      $bgcolor = $EMPTY_STRING;
      $bg      = $EMPTY_STRING;
    }

    elsif ($attr =~ /^(#\d{6})$/) {
      $bgcolor = $EMPTY_STRING;
      $bg      = $EMPTY_STRING;
    }
  }
}

######################################################################

sub end_table_header {

  printdebug("end_table_header") if $DEBUGGING;

  #-------------------------------------------------------------------
  # End various contexts
  #
  end_pre()           if $in{'pre'};
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};
  end_celltext()      if $in{'celltext'};

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {
    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};
    push @{ $aref }, <<"END_OF_TEXT";
</span></th>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, <<"END_OF_TEXT";
</th>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # PDF: If this is a baretable that uses colored cell backgrounds,
    # add one close brace to end the cell's content (which was being
    # bolded), and another to end the cell's color definition.
    #
    if ( $in{'baretable'} == 1 ) {

      my $num = $count{'baretable'}{'total'};

      #---------------------------------------------------------------
      # PDF: If this is a baretable that uses color, we need to supply
      # two close braces.
      #
      if ($data{'baretable'}{$num}{'uses_color'}) {
        push @latex, "}\n";
        push @latex, "}\n";
      }

      #---------------------------------------------------------------
      # PDF: ...Otherwise just add one close brace to end the
      # \textbf{...
      #
      else {
        push @latex, "}\n";
      }
    }

    #-----------------------------------------------------------------
    # PDF: ...Otherwise if this is a normal table that uses colored
    # cell backgrounds, add one close brace to end the cell's content
    # (which was being bolded), and another to end the cell's color
    # definition.
    #
    else {

      my $num = $count{'table'}{'total'};

      #---------------------------------------------------------------
      # PDF: If this is a normal table that uses color, we need to
      # supply two close braces.
      #
      if ($data{'table'}{$num}{'uses_color'}) {
        push @latex, "}\n";
        push @latex, "}\n";
      }

      #---------------------------------------------------------------
      # PDF: ...Otherwise just add one close brace to end the
      # \textbf{...
      #
      else {
        push @latex, "}\n";
      }
    }
  }

  #-------------------------------------------------------------------
  # We're no longer considered inside a table header cell.
  #
  $in{'header'} = 0;

}

######################################################################

sub begin_table_cell {

  my $attrs    = shift;
  my $text     = shift;
  my $bg       = 'bg-white'; # predefined LaTeX color for cell background

  printdebug("begin_table_cell $attrs $text") if $DEBUGGING;

  end_preamble()      if $in{'preamble'}{'text'};
  end_table_item()    if $in{'item'}; # !!! bug here - what if you're in a normal item, not a table item? !!!
  end_table_list()    if $in{'table_list'};
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};
  end_table_header()  if $in{'header'};
  end_table_cell()    if $in{'cell'};
  end_table_title()   if $in{'table'}{'title'};
  begin_table_row()   if not $in{'row'};

  $in{'cell'} = 1;

  #-------------------------------------------------------------------
  # Error Message
  #
  #     Define an error message to throw if this subroutine gets
  #     called and we're neither in a table or a baretable.
  #
  my $not_in_a_table_error = <<"END_OF_TEXT";
Something is terribly wrong. The program is trying to begin a table
cell but I'm neither a table or a baretable (this is a software bug
because the software should never let this happen)

END_OF_TEXT

  #-------------------------------------------------------------------
  # Table Number
  #
  #     Determine the number of the table (or baretable) we're
  #     currently in.
  #
  my $num = 0;

  if ( $in{'table'}{'environment'} == 1 ) {
    $num = $count{'table'}{'total'};
    push @latex, "%% begin_table_cell: in table $num\n";
  }

  elsif ( $in{'baretable'} == 1 ) {
    $num = $count{'baretable'}{'total'};
    push @latex, "%% begin_table_cell: in baretable $num\n";
  }

  else {
    printerror($not_in_a_table_error);
  }

  #-------------------------------------------------------------------
  # Column Count
  #
  #     Increment the current column count.
  #
  ++ $current{'column'};

  #-------------------------------------------------------------------
  # Notes
  #
  #     Note: table cells can contain: (1) plain text, (2) paragraph
  #     text, (3) pre-formatted text, or (4) lists.
  #
  #-----------------------------------------------------------------
  #
  #     1. Text immediately following the begin cell indicator (:) is
  #     considered 'celltext' (plain text, not marked up as a
  #     paragraph). 'celltext' is ended by the beginning of a new
  #     table cell, the end of a table row, or a blank line.
  #
  #       : This is a table cell that contains only plain text.  Even
  #       if the text goes on for multiple lines, it is still
  #       considered plain text.  For HTML purposes, this text is not
  #       enclosed within paragraph tags.
  #
  #     2. If the text inside a table cell doesn't start on the same
  #     line as the begin cell indicator (:), It is interpretted as a
  #     paragraph, pre-formatted (if indented), or a list item:
  #
  #       :
  #
  #       This is the beginning of a paragraph inside of a table cell.
  #       The beginning of the paragraph text is not indented.
  #
  #       - This is a list item inside the same table cell
  #
  #       - This is another list item inside the same table cell
  #
  #       This is more paragraph text.  It is not indented.
  #
  #         This is preformatted text because it is indented.
  #
  #-------------------------------------------------------------------
  #
  #     If the table cell indicator (:) has text on the same line,
  #     that text should be considered 'celltext' (not paragraph text,
  #     pre-formatted text, or a list item).
  #
  begin_celltext() if $text;

  #-------------------------------------------------------------------
  # Cell Attributes
  #
  #     Process the attributes for this cell.  Attributes can describe
  #     the size, justification, and background color of the cell:
  #
  #       justifications: l, c, r
  #
  #       size: tiny, scriptsize, footnotesize, small, normalsize,
  #             large
  #
  #       background colors: red, green, blue, yellow, orange,
  #                          purple, litegrey, grey, darkgrey, white
  #
  my $align       = 'left';
  my $bgcolor     = '#ffffff';
  my $bg          = 'bg-white';
  my $fontsize    = $data{'table'}{$num}{'fontsize'} || 'normalsize';
  my $cellpadding = '';
  my $cellspacing = '';

  my @attrs = split(/:/,$attrs);
  foreach my $attr (@attrs) {

    if ($DEBUGGING) {
      printdebug("begin_table_cell: attr is \"$attr\"");
    }

    ##################################################################
    #
    # !!! Bug Here !!!
    #
    #     If the cell content is a list (collection of list items) or
    #     paragraphs, the requested fontsize is not honored).
    #
    #################################################################

    # align left?
    #
    if ($attr eq 'l') {
      $align = 'left';
      printdebug("begin_table_cell: table cell attribute: $align") if $DEBUGGING;
    }

    # align center?
    #
    elsif ($attr eq 'c') {
      $align = 'center';
      printdebug("begin_table_cell: table cell attribute: $align") if $DEBUGGING;
    }

    # align right?
    #
    elsif ($attr eq 'r') {
      $align = 'right';
      printdebug("begin_table_cell: table cell attribute: $align") if $DEBUGGING;
    }

    # red background?
    #
    elsif ($attr eq 'red') {
      $bgcolor = '#ff6666';
      $bg = 'bg-red';
      printdebug("begin_table_cell: table cell attribute: $bg") if $DEBUGGING;
    }

    # green background?
    #
    elsif ($attr eq 'green') {
      $bgcolor = '#66ff66';
      $bg = 'bg-green';
      printdebug("begin_table_cell: table cell attribute: $bg") if $DEBUGGING;
    }

    # blue background?
    #
    elsif ($attr eq 'blue') {
      $bgcolor = '#6666ff';
      $bg = 'bg-blue';
      printdebug("begin_table_cell: table cell attribute: $bg") if $DEBUGGING;
    }

    # yellowbackground?
    #
    elsif ($attr eq 'yellow') {
      $bgcolor = '#ffff66';
      $bg = 'bg-yellow';
      printdebug("begin_table_cell: table cell attribute: $bg") if $DEBUGGING;
    }

    # orange background?
    #
    elsif ($attr eq 'orange') {
      $bgcolor = '#ffaa66';
      $bg = 'bg-orange';
      printdebug("begin_table_cell: table cell attribute: $bg") if $DEBUGGING;
    }

    # purple background?
    #
    elsif ($attr eq 'purple') {
      $bgcolor = '#ff66ff';
      $bg = 'bg-purple';
      printdebug("begin_table_cell: table cell attribute: $bg") if $DEBUGGING;
    }

    # litegrey background?
    #
    elsif ($attr eq 'litegrey') {
      $bgcolor = '#eeeeee';
      $bg = 'bg-litegrey';
      printdebug("begin_table_cell: table cell attribute: $bg") if $DEBUGGING;
    }

    # grey background?
    #
    elsif ($attr eq 'grey') {
      $bgcolor = '#dddddd';
      $bg = 'bg-grey';
      printdebug("begin_table_cell: table cell attribute: $bg") if $DEBUGGING;
    }

    # darkgrey background?
    #
    elsif ($attr eq 'darkgrey') {
      $bgcolor = '#cccccc';
      $bg = 'bg-darkgrey';
      printdebug("begin_table_cell: table cell attribute: $bg") if $DEBUGGING;
    }

    # other color background (HTML only)?
    #
    elsif ($attr =~ /^(#\d{6})$/) {
      $bgcolor = "$1";
      $bg = 'bg-white';
      printdebug("begin_table_cell: table cell attribute: $bg") if $DEBUGGING;
    }

    # tiny fontsize?
    #
    elsif ($attr eq 'tiny') {
      $fontsize = 'tiny';
      printdebug("begin_table_cell: table cell attribute: $fontsize") if $DEBUGGING;
    }

    # scriptsize fontsize?
    #
    elsif ($attr eq 'scriptsize') {
      $fontsize = 'scriptsize';
      printdebug("begin_table_cell: table cell attribute: $fontsize") if $DEBUGGING;
    }

    # footnotesize fontsize?
    #
    elsif ($attr eq 'footnotesize') {
      $fontsize = 'footnotesize';
      printdebug("begin_table_cell: table cell attribute: $fontsize") if $DEBUGGING;
    }

    # small fontsize?
    #
    elsif ($attr eq 'small') {
      $fontsize = 'small';
      printdebug("begin_table_cell: table cell attribute: $fontsize") if $DEBUGGING;
    }

    # normalsize fontsize?
    #
    elsif ($attr eq 'normalsize') {
      $fontsize = 'normalsize';
      printdebug("begin_table_cell: table cell attribute: $fontsize") if $DEBUGGING;
    }

    # large fontsize?
    #
    elsif ($attr eq 'large') {
      $fontsize = 'large';
      printdebug("begin_table_cell: table cell attribute: $fontsize") if $DEBUGGING;
    }

    else {
      printdebug("begin_table_cell: SOMETHING HORRIBLY WRONG WITH: \"$attr\"") if $DEBUGGING;
    }
  }

  # ALL baretables use small fontsize
  #
  if ( $in{'baretable'} == 1 ) { $fontsize = 'small' };

  #-------------------------------------------------------------------
  # Column Number
  #
  #     Get the number of the current column.
  #
  my $columnnum = $current{'column'};

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # HTML: Escape
    #
    #     Escape characters with special meaning to HTML.
    #
    my $html_text = escape_html($text);
    my $secnum    = $current{'secnum'};
    my $aref      = $html{'body'}{$secnum};

    #---------------------------------------------------------------------
    # HTML: Begin
    #
    #     Begin the table cell.
    #
    push @{ $aref }, "<td";
    push @{ $aref }, " bgcolor=\"$bgcolor\""         if $bgcolor;
    push @{ $aref }, " cellpadding=\"$cellpadding\"" if $cellpadding;
    push @{ $aref }, " cellspacing=\"$cellspacing\"" if $cellspacing;
    push @{ $aref }, " align=\"$align\""             if $align;
    push @{ $aref }, " valign=\"top\"";
    push @{ $aref }, ">";
    push @{ $aref }, "$html_text\n";
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # XML: Escape
    #
    #     Escape characters with special meaning to XML.
    #
    my $xml_text = escape_xml($text);

    #---------------------------------------------------------------------
    # XML: Begin
    #
    #     Begin the table cell.
    #
    push @xml, "<td";
    push @xml, " bgcolor=\"$bgcolor\""         if $bgcolor;
    push @xml, " cellpadding=\"$cellpadding\"" if $cellpadding;
    push @xml, " cellspacing=\"$cellspacing\"" if $cellspacing;
    push @xml, " align=\"$align\""             if $align;
    push @xml, " valign=\"top\"";
    push @xml, ">";
    push @xml, "$xml_text\n";
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    my $width = $current_table{'column'}{$columnnum}{'width'};

    #-----------------------------------------------------------------
    # PDF: Escape
    #
    #     Escape characters with special meaning to LaTeX.  Also,
    #     replace all newlines with a single space.
    #
    my $latex_text = escape_latex($text);
    $latex_text =~ s{\n}{ };

    #-----------------------------------------------------------------
    # PDF: Justification
    #
    #     Determine the cell alignment/justification.
    #
    my $justification = 'raggedright';
    $justification = 'centering'  if $align eq 'center';
    $justification = 'raggedleft' if $align eq 'right';

    #-----------------------------------------------------------------
    # PDF: Baretable
    #
    if ( $in{'baretable'} == 1 ) {

      if ($DEBUGGING) {
	printdebug("begin_table_cell: starting latex table cell with fontsize $fontsize");
      }

      #---------------------------------------------------------------
      # PDF: Colored Cells
      #
      #     If this baretable uses colored cell backgrounds, we need
      #     to specify the column color here.
      #
      if ( $data{'baretable'}{$num}{'uses_color'} ) {
        push @latex, "\\multicolumn{1}{>{\\$fontsize\\$justification\\columncolor{$bg}}p{$width\\tablewidth}}{";
      }

      #---------------------------------------------------------------
      # PDF: Not Colored Cells
      #
      #     Otherwise just insert the text (as long as there is text).
      #
      if ($latex_text !~ /^\s*$/) {
        push @latex, "\\centering\n"  if $align eq 'center';
        push @latex, "\\raggedleft\n" if $align eq 'right';

        push @latex, "\\$fontsize $latex_text\n";
      }
    }

    #-----------------------------------------------------------------
    # PDF: Normal Table
    #
    #     Otherwise, we're in a normal table, not a baretable.
    #
    else {

      #---------------------------------------------------------------
      # PDF: Colored Cells
      #
      #     If this normal table uses colored cell backgrounds, we
      #     need to specify the column color here.
      #
      if ( $data{'table'}{$num}{'uses_color'} ) {
        push @latex, "\\multicolumn{1}{>{\\$fontsize\\$justification\\columncolor{$bg}}p{$width\\tablewidth}}{";
      }

      #---------------------------------------------------------------
      # PDF: Not Colored Cells
      #
      #     Otherwise, just insert the text.
      #
      if ($latex_text !~ /^\s*$/) {
        push @latex, "\\centering\n"   if $align eq 'center';
        push @latex, "\\raggedleft\n"  if $align eq 'right';

        push @latex, "\\$fontsize $latex_text\n";
      }
    }
  }

  #-------------------------------------------------------------------
  # reset cell attributes
  #
  my @attrs = split(/:/,$attrs);
  $align    = $EMPTY_STRING;
  $bgcolor  = $EMPTY_STRING;
  $fontsize = 'normalsize';

}

######################################################################

sub end_table_cell {

  printdebug("end_table_cell") if $DEBUGGING;

  #-------------------------------------------------------------------
  # End various contexts
  #
  end_pre()           if $in{'pre'};
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};
  end_celltext()      if $in{'celltext'};

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {
    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};
    push @{ $aref }, "</td>\n";
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, "</td>\n";
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # PDF: Baretable
    #
    #     If this is a baretable that uses colored cell backgrounds,
    #     add a close brace to end the cell's color definition.
    #
    if ( $in{'baretable'} == 1 ) {
      my $num = $count{'baretable'}{'total'};
      if ($data{'baretable'}{$num}{'uses_color'}) {
        push @latex, "}\n";
      }
    }

    #-----------------------------------------------------------------
    # PDF: Normal Table
    #
    #     Otherwise if this is a normal table that uses colored cell
    #     backgrounds, add a close brace to end the cell's color
    #     definition.
    #
    else {
      my $num = $count{'table'}{'total'};
      if ($data{'table'}{$num}{'uses_color'}) {
        push @latex, "}\n";
      }
    }

    #-----------------------------------------------------------------
    # PDF: Huh?
    #
    #     I have no idea why this line is here, it doesn't appear to
    #     do anything useful!
    #
    push @latex, "";
  }

  #-------------------------------------------------------------------
  # Done
  #
  #     We're no longer considered inside a table cell.
  #
  $in{'cell'} = 0;

}

######################################################################

sub insert_cell_boundary {

  printdebug("insert_cell_boundary") if $DEBUGGING;

  end_table_header() if $in{'header'};
  end_table_cell()   if $in{'cell'};

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, "&\n";
  }

}

######################################################################

sub process_pre {

  printdebug("process_pre") if $DEBUGGING;

  my $text = shift;

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {
    my $html_text  = escape_html_pre($text);
    my $secnum     = $current{'secnum'};
    my $aref       = $html{'body'}{$secnum};
    push @{ $aref }, $html_text;
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    my $xml_text  = escape_xml_pre($text);
    push @xml, $xml_text;
  }

  #-------------------------------------------------------------------
  # PDF
  #
  #     If this line of preformatted text occurrs inside a table cell,
  #     then strip off space at the beginning of the line
  #     corresponding to the initial indent of the block of
  #     preformatted text.
  #
  if ($rendering{'pdf'} and $in{'cell'} and not $in{'hide'}{'block'}) {
    my $space = $current{'initial_indent'};
    $text =~ s/^$space(.*)/$1/;
  }

  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    my $latex_text = escape_latex_pre($text);
    push @latex, $latex_text;
  }
}

######################################################################

sub process_footnote_text {

  printdebug("process_footnote_text") if $DEBUGGING;
  my $text = shift;
  $text = trim_whitespace($text);
  $current{'footnote'} .= " $text";

}

######################################################################

sub process_todo_text {

  printdebug("process_todo_text") if $DEBUGGING;
  my $text = shift;
  $text = trim_whitespace($text);
  $current{'todo'} .= " $text";

}

######################################################################

sub process_para_text {

  printdebug("process_para_text") if $DEBUGGING;

  my $text = shift;

  trim_whitespace($text);

  $current{'para'} .= "$text ";

  #-----------------------------------------------------------------
  # We need to determine whether this paragraph text occurs inside a
  # table (or baretable) or not.  If it's inside a table cell
  # (i.e. current_column is something other than 0) then we proceed as
  # normal.  But, if this paragraph is NOT inside a table cell
  # (i.e. current_column equals 0) then it means the table has ended,
  # and we need to close out the table.
  #
  # In practice, this can only happen with a baretable, so I've
  # commented out the following line that ends a normal table.
  #
  # end_table()         if $in{'table'}{'environment'}     and $current{'column'} == 0;
  end_pre()           if $in{'pre'};
  end_baretable()     if $in{'baretable'} == 1 and $current{'column'} == 0;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};
  end_preamble()      if $in{'preamble'}{'text'};
  begin_para()        if not $in{'para'};

}

######################################################################

sub process_item_text {

  printdebug("process_item_text") if $DEBUGGING;

  my $text = shift;

  trim_whitespace($text);

  $current{'item'} .= "$text ";

}

######################################################################

sub process_file {

  printdebug("process_file") if $DEBUGGING;

  my $filename = shift;
  my $cwd      = getcwd;

  $count{'toplevel'} = $scounter{1};

  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};
  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_preamble()      if $in{'preamble'}{'text'};

  #-------------------------------------------------------------------
  # !!! Bug Here !!!
  #
  #     The code below *includes* the file's contents.  Is this the
  #     intent of the "file" data element?  I thought it was supposed
  #     to be a simple file attachment mechanism not a file
  #     include-in-the-published-document mechanism.
  #
  #-------------------------------------------------------------------

  #-------------------------------------------------------------------
  # if the file is readable...
  #
  if (-r $filename) {

    printstatus("    Listing $count{'listing'}{'total'}");
    open FILE, "<$filename" || die "Couldn't open $filename: $!\n";
    while (<FILE>) {

      #---------------------------------------------------------------
      # HTML
      #
      if ($rendering{'html'} and not $in{'hide'}{'block'}) {
        my $html   = escape_html_pre($_);
	my $secnum = $current{'secnum'};
	my $aref   = $html{'body'}{$secnum};
        push @{ $aref }, $html;
      }

      #---------------------------------------------------------------
      # XML
      #
      if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
        my $xml = escape_xml_pre($_);
        push @xml, $xml;
      }

      #---------------------------------------------------------------
      # PDF
      #
      if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
        my $latex = escape_latex_pre($_);
        push @latex, $latex;
      }
    }

    close FILE;

    #---------------------------------------------------------------
    # HTML
    #
    if ($rendering{'html'} and not $in{'hide'}{'block'}) {

      #-----------------------------------------------------------------
      # Make sure the current toplevel heading is in the listing index.
      #
      if (not $heading_in_listing_index) {
        $heading_in_listing_index = 1;
	my $heading = escape_html($current{'top_heading'});
        push @{ $html{'listing'}{'index'} }, <<"END_OF_TEXT";
</ol>
<h3>$heading</h3>
<ol>

END_OF_TEXT
      }
    }
  }

  #-------------------------------------------------------------------
  # ...otherwise, the file is NOT readable...
  #
  else {
    printerror("Warning: couldn't find file $filename\n");
  }
}

######################################################################

sub process_image {

  # ARG 0: relative path and filename to image

  #-------------------------------------------------------------------
  # The first argument is the image path/filename.
  #
  my $image_spec = shift;

  printdebug("process_image $image_spec") if $DEBUGGING;

  #-------------------------------------------------------------------
  # Get just the filename of the image from the image_spec.
  #
  my $image_file = (split('/', $image_spec))[-1];

  #-------------------------------------------------------------------
  # Publish the image.  This means to make a copy of the image in the
  # 'images' sub-directory of the output directory.
  #
  publish_image($image_spec);

  #-------------------------------------------------------------------
  # end current context (can't have an image inside certain other
  # contexts)...
  #
  end_pre()           if $in{'pre'};
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};
  end_preamble()      if $in{'preamble'}{'text'};
  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;

  #-------------------------------------------------------------------
  # If we're in a slide, sidebar, or demo, insert a thumbnail image.
  #
  if (($in{'slide'}{'region'} and $option{'slide'})
      or $in{'sidebar'}{'environment'}
      or $in{'demo'}{'region'}) {

    #-----------------------------------------------------------------
    # A set of images should start with a paragraph tag to achieve
    # the proper indentation.
    #
    if (not $in{'imageset'}) {
      $count{'image'}{'consecutive'} = 0;
      $in{'imageset'} = 1;

      #---------------------------------------------------------------
      # HTML
      #
      if ($rendering{'html'} and not $in{'hide'}{'block'}) {
	my $secnum = $current{'secnum'};
	my $aref   = $html{'body'}{$secnum};
	push @{ $aref }, "<p>\n";
      }

      #---------------------------------------------------------------
      # PDF
      #
      if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
	push @latex, "\n";
      }
    }

    #-----------------------------------------------------------------
    # Create a thumbnail image.
    #
    publish_thumbnail($image_spec);

    #-----------------------------------------------------------------
    # Render HTML.
    #
    if ($rendering{'html'} or $rendering{'pdf'} and not $in{'hide'}{'block'}) {

      #---------------------------------------------------------------
      # determine image size and insert HTML markup and LaTeX
      #
      my $tsize = find_size("$output_dir/images-thumbnails/$image_file");
      my ($width,$height) = split(/x/, $tsize);

      #---------------------------------------------------------------
      # HTML
      #
      my $secnum = $current{'secnum'};
      my $aref   = $html{'body'}{$secnum};
      # push @{ $aref }, "<a href=\"javascript:popImage(\'images/$image_file\',\'Image\');\"><img src=\"images-thumbnails/$image_file\" border=\"0\" width=\"$width\" height=\"$height\"></a> ";

      push @{ $aref }, "<a href=\"images/$image_file\"><img src=\"images-thumbnails/$image_file\" border=\"0\" width=\"$width\" height=\"$height\"></a> ";

      #---------------------------------------------------------------
      # PDF
      #
      push @latex, "\\includegraphics[width=1.5in]{$image_spec}\n";

      ++$count{'image'}{'consecutive'} if $in{'slide'}{'region'};
      ++$count{'image'}{'consecutive'} if $in{'sidebar'}{'environment'};
      ++$count{'image'}{'consecutive'} if $in{'demo'}{'region'};
      if ($in{'slide'}{'region'} and $count{'image'}{'consecutive'} > 3) {
        $count{'image'}{'consecutive'} = 0;
        $in{'imageset'} = 0;

        #-------------------------------------------------------------
        # HTML
        #
        push @{ $aref }, "\n</p>\n";
      }

      if ($in{'sidebar'}{'environment'} and $count{'image'}{'consecutive'} > 3) {
        $count{'image'}{'consecutive'} = 0;
        $in{'imageset'} = 0;

        #-------------------------------------------------------------
        # HTML
        #
        push @{ $aref }, "\n</p>\n";
      }

      if ($in{'demo'}{'region'} and $count{'image'}{'consecutive'} > 3) {
        $count{'image'}{'consecutive'} = 0;
        $in{'imageset'} = 0;

        #-------------------------------------------------------------
        # HTML
        #
        push @{ $aref }, "\n</p>\n";
      }
    }
  }

  #-------------------------------------------------------------------
  # ...Otherwise insert a normal sized image.
  #
  else {

    #-----------------------------------------------------------------
    # PDF
    #
    if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

      #---------------------------------------------------------------
      # PDF: Insert the image into the LaTeX rendition...
      #
      # If a width attribute was defined, use the specified width for
      # the LaTeX rendition.
      #
      my $num = $count{'figure'}{'total'};
      if ($data{'figure'}{$num}{'width'}) {
        my $width = $data{'figure'}{$num}{'width'};

        push @latex, <<"END_OF_TEXT";
\\begin{center}
\\includegraphics[width=$width]{$image_spec}
\\end{center}

END_OF_TEXT
      }

      #---------------------------------------------------------------
      # PDF: ...Otherwise just make the image 3 inches wide.
      #
      else {
        push @latex, <<"END_OF_TEXT";
\\begin{center}
\\includegraphics[width=3in]{$image_spec}
\\end{center}

END_OF_TEXT
      }
    }

    #-----------------------------------------------------------------
    # HTML
    #
    if ($rendering{'html'} and not $in{'hide'}{'block'}) {

      my $secnum = $current{'secnum'};
      my $aref   = $html{'body'}{$secnum};

      #---------------------------------------------------------------
      # HTML: Insert the image into the HTML rendition.
      #
      my $size = find_size("$image_spec");
      my ($width,$height) = split(/x/, $size);

      #---------------------------------------------------------------
      # HTML: If the image is bigger than 600 pixels wide, make a
      # scaled down version and use it instead of the full sized
      # image.
      #
      if ($width > $scaled_size) {

        #-------------------------------------------------------------
        # HTML: Scale the image.
        #
        scale_image($image_spec);

        #-------------------------------------------------------------
        # HTML: Find the size of the newly scaled image and insert
        # HTML markup.
        #
        my $size = find_size("$output_dir/images-scaled/$image_file");
        my ($width,$height) = split(/x/, $size);

	# <a href="javascript:popImage(\'images/$image_file\',\'Image\');">

        push @{ $aref }, <<"END_OF_TEXT";
<div align="center">
<a href="images/$image_file">
<img src="images-scaled/$image_file" width="$width" height="$height" border="0">
</a>
</div>

END_OF_TEXT
      }

      #---------------------------------------------------------------
      # HTML: ...Otherwise the image is NOT bigger than 600 pixels
      # wide, just put it in the document as is.
      #
      else {

        push @{ $aref }, <<"END_OF_TEXT";
<div align="center">
<img src="images/$image_file" width="$width" height="$height">
</div>

END_OF_TEXT
      }
    }

    #-----------------------------------------------------------------
    # XML
    #
    if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
      push @xml, <<"END_OF_TEXT";
<image src="images/$image_file"/>

END_OF_TEXT
    }
  }
}

######################################################################

sub begin_footnote {

  printdebug("begin_footnote") if $DEBUGGING;

  my $tag  = shift;
  my $text = shift;

  $current{'footnote'}     = trim_whitespace($text);
  $current{'footnote-tag'} = $tag;

  end_pre()           if $in{'pre'};
  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};
  end_preamble()      if $in{'preamble'}{'text'};

  $in{'footnote'}      = 1;

  # NOTE: Footnote processing is done automatically in the LaTeX (PDF)
  # rendition.

}

######################################################################

sub end_file {

  printdebug("end_file") if $DEBUGGING;

  if ( $in{'file'} ) {
    $in{'file'} = 0;
  }

  else {
    printerror("end_file called when not in file\n")
  }

}

######################################################################

sub end_footnote {

  printdebug("end_footnote") if $DEBUGGING;

  #-------------------------------------------------------------------
  #
  #     !!! Bug Here !!!
  #
  #     This subroutine is called by the end_any_data_element
  #     subroutine which is called by the pass_two subroutine.
  #     Pushing output text onto the output arrays (like @{ $aref })
  #     should not occur during pass 2.
  #
  #-------------------------------------------------------------------

  if ($in{'footnote'}) {

    $in{'footnote'} = 0;

    ++ $count{'footnote-text'}{'total'};

    my $text   = $current{'footnote'};
    my $label  = $current{'label'};
    my $tag    = $current{'footnote-tag'};
    # my $num    = $count{'footnote-text'}{'total'};
    my $anchor = "footnote.$label.$tag";
    my $block  = '';

    #-----------------------------------------------------------------
    # HTML
    #
    if ($rendering{'html'} and not $in{'hide'}{'block'}) {

      my $html_text = escape_html($text);
      my $secnum    = $current{'secnum'};
      my $outfile   = html_outfile_for_secnum($secnum);
      my $aref      = $html{'body'}{$secnum};

      #---------------------------------------------------------------
      # footnote
      #
      $block = <<"END_OF_TEXT";
<p class="footnote"><tt>[$tag]</tt> $html_text</p>
END_OF_TEXT

      $block = wrap($block);

      push @{ $aref }, <<"END_OF_TEXT";
<!-- ========================== FOOTNOTE ========================= -->
<a name="$anchor"/>
$block

END_OF_TEXT

      #-----------------------------------------------------------------
      # section heading in footnote index
      #
      if (not $heading_in_footnote_index) {

	$heading_in_footnote_index = 1;

	my $sectype = $current{'sectype'};
	my $heading = $current{'heading'};

	$block = <<"END_OF_TEXT";
<h3>$sectype $heading</h3>
END_OF_TEXT

	$block = wrap($block);

	push @{ $html{'footnote'}{'index'} }, $block;
      }

      #-----------------------------------------------------------------
      # footnote in footnote index
      #
      $block = <<"END_OF_TEXT";
<p><tt>[<a href="$outfile#$anchor">$tag</a>]</tt> $html_text</p>
END_OF_TEXT

      $block = wrap($block);

      push @{ $html{'footnote'}{'index'} }, $block;

    }

    #-----------------------------------------------------------------
    # XML
    #
    if ($rendering{'xml'} and not $in{'hide'}{'block'}) {

      my $xml_text = escape_xml($text);

      $block = <<"END_OF_TEXT";
<footnote id="$anchor">$xml_text</footnote>
END_OF_TEXT

      $block = wrap($block);

      push @xml, $block;
    }
  }

  else {
    printerror("end_footnote called while not in footnote");
  }
}

######################################################################

sub begin_figure {

  printdebug("begin_figure") if $DEBUGGING;

  #-------------------------------------------------------------------
  # Here's what the HTML rendition of a figure should look like:
  #
  #   <a name="Figure.2-1">
  #   <div align="center">
  #   <img src="images/unix-genealogy.png" width="508" height="514">
  #   </div>
  #   <p class="title">Figure 2-1 - UNIX Genealogy</p>
  #
  # !!! Bug Here !!!
  #
  #     The HTML rendition should have a feature like the PDF
  #     rendition where the text flows around smaller pictures.
  #
  #-------------------------------------------------------------------
  # The LaTeX rendition should use wrapfig if the figure is 2 inches
  # wide or less. Here's what the wrapfig LaTeX rendition of a figure
  # should look like:
  #
  #   %%-----------------------------------
  #   %% begin figure
  #   %%
  #   \begin{wrapfigure}{R}{1.5in}
  #   \centering
  #   \caption{UNIX Genealogy}
  #   \label{fig-unix-genealogy}
  #   \includegraphics[width=1.5in]{images/unix-genealogy.png}
  #   \end{wrapfigure}
  #
  # Here's what a wider figure should look like:
  #
  #   %%-----------------------------------
  #   %% begin figure
  #   %%
  #   \begin{figure*}
  #   \centering
  #   \caption{UNIX Genealogy}
  #   \label{fig-unix-genealogy}
  #   \includegraphics[width=3in]{images/unix-genealogy.png}
  #   \end{figure*}
  #
  #-------------------------------------------------------------------
  # Here's what the XML rendition of a figure should look like:
  #
  #   <figure>
  #   <image src="images/unix-genealogy.png"/>
  #   <title>UNIX Genealogy</title>
  #   </figure>
  #
  #-------------------------------------------------------------------

  $in{'figure'}{'environment'} = 1;

  ++$count{'figure'}{'section'}; # number of figures in toplevel section
  ++$count{'figure'}{'total'};  # number of figures in document

  end_pre()               if $in{'pre'};
  end_ulist_context()     if $in{'ulist'};
  end_olist_context()     if $in{'olist'};
  end_dlist()             if $in{'dlist'};
  end_baretable()         if $in{'baretable'} == 1;

  $count{'toplevel'} = $scounter{1};

  my $num    = $count{'figure'}{'total'};
  my $label  = $data{'figure'}{$num}{'label'}  || $EMPTY_STRING;
  my $border = $data{'figure'}{$num}{'border'} || $EMPTY_STRING;

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # HTML: If this figure is inside a section, insert an anchor that
    # includes the section number (i.e. $count{'toplevel'}), otherwise
    # insert an anchor without a section number.
    #
    if ($secnum) {
      push @{ $aref }, <<"END_OF_TEXT";
<a name="Figure.$count{'toplevel'}-$count{'figure'}{'section'}">

END_OF_TEXT
    }

    else {
      push @{ $aref }, <<"END_OF_TEXT";
<a name="Figure.$count{'figure'}{'section'}">

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # HTML: If this figure has an image in it, insert it here.
    #
    my $image_spec  = $data{'figure'}{$num}{'image'};

    if ($image_spec) {

      #---------------------------------------------------------------
      # HTML: Get just the filename of the image from the image_spec.
      #
      my @parts      = split('/', $image_spec);
      my $image_file = pop @parts;

      my $html_border = 0;
      if ($border eq 'yes') {
	$html_border = 1;
      }

      #-----------------------------------------------------------------
      # HTML: Publish the image.  This means to make a copy of the
      # image in the 'images' sub-directory of the output directory.
      #
      publish_image($image_spec);

      #---------------------------------------------------------------
      # HTML: Insert the image into the HTML rendition.
      #
      my $size = find_size("$image_spec");
      my ($width,$height) = split(/x/, $size);

      #---------------------------------------------------------------
      # HTML: If the image is bigger than 600 pixels wide, make a
      # scaled down version and use it instead of the full sized
      # image.
      #
      if ($width > $scaled_size) {

        #-------------------------------------------------------------
        # HTML: Scale the image.
        #
        scale_image($image_spec);

        #-------------------------------------------------------------
        # HTML: Find the size of the newly scaled image and insert
        # HTML markup.
        #
        my $size = find_size("$output_dir/images-scaled/$image_file");
        my ($width,$height) = split(/x/, $size);

	# <a href="javascript:popImage(\'images/$image_file\',\'Image\');">

        push @{ $aref }, <<"END_OF_TEXT";
<div align="center">
<a href="images/$image_file">
<img src="images-scaled/$image_file" width="$width" height="$height" border="$html_border">
</a>
</div>

END_OF_TEXT
      }

      #---------------------------------------------------------------
      # HTML: ...Otherwise the image is NOT bigger than 600 pixels
      # wide, just put it in the document as is.
      #
      else {

        push @{ $aref }, <<"END_OF_TEXT";
<div align="center">
<img src="images/$image_file" width="$width" height="$height" border="$html_border">
</div>

END_OF_TEXT
      }
    }
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # XML: Begin the figure element
    #
    if ($label) {
      push @xml, <<"END_OF_TEXT";
<figure id="$label">

END_OF_TEXT
    }

    else {
      push @xml, <<"END_OF_TEXT";
<figure>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # XML: If this figure has an image in it, insert it here.
    #
    my $image_spec  = $data{'figure'}{$num}{'image'};

    if ($image_spec) {

      #---------------------------------------------------------------
      # XML: Get just the filename of the image from the image_spec.
      #
      my @parts      = split('/', $image_spec);
      my $image_file = pop @parts;

      #---------------------------------------------------------------
      # XML: Publish the image.  This means to make a copy of the
      # image in the 'images' sub-directory of the output directory.
      #
      publish_image($image_spec);

      #---------------------------------------------------------------
      # XML: insert the image
      #
      push @xml, <<"END_OF_TEXT";
<image src="images/$image_file"/>

END_OF_TEXT
    }
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    my $latex_title = escape_latex($data{'figure'}{$num}{'title'});
    my $width       = $data{'figure'}{$num}{'width'} || '3in';
    my $image_spec  = $data{'figure'}{$num}{'image'};
    my $image_file  = (split('/',$image_spec))[-1];
    my $label       = $data{'figure'}{$num}{'label'};

    #---------------------------------------------------------------
    # PDF: Publish the image.
    #
    #     This means to make a copy of the image in the 'images'
    #     sub-directory of the output directory.
    #
    publish_image($image_spec);

    #-----------------------------------------------------------------
    # PDF: Determine this figure's orientation
    #
    my $orientation = '';
    if ($data{'figure'}{$num}{'orientation'} eq 'landscape') {
      $orientation = 'landscape';
    } else {
      $orientation = 'portrait';
    }

    #-----------------------------------------------------------------
    # PDF: Begin landscape if orientation is landscape
    #
    if ( $orientation eq 'landscape' ) {
      push @latex, <<"END_OF_TEXT";
\\begin{landscape}

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # PDF: begin the figure
    #
    push @latex, <<"END_OF_TEXT";
%%-----------------------------------
%% figure
%%
\\begin{figure*}[ht]

END_OF_TEXT

    #-----------------------------------------------------------------
    # PDF: Insert the image if there is one with this figure.
    #
    if ($image_spec) {
      my $graphic = "\\includegraphics[width=$width]{images/$image_file}";
      if ( $border eq 'yes' ) {
	$graphic = "\\fbox{" . $graphic . "}";
      }
      push @latex, <<"END_OF_TEXT";
\\begin{center}
$graphic
\\end{center}

END_OF_TEXT
    }
  }
}

######################################################################

sub end_figure {

  printdebug("end_figure") if $DEBUGGING;

  #-------------------------------------------------------------------
  # This figure may have contained pre-formatted text.  If it did, end
  # the preformatted text before ending the figure.
  #
  end_pre() if $in{'pre'};

  $in{'figure'}{'environment'} = 0;
  my $num = $count{'figure'}{'total'};

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    $count{'toplevel'} = $scounter{1};
    my $title       = escape_html($data{'figure'}{$num}{'title'});
    my $description = escape_html($data{'figure'}{$num}{'description'});
    my $secnum      = $current{'secnum'};
    my $outfile     = html_outfile_for_secnum($secnum);
    my $aref        = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # HTML: Determine the appropriate figure number.
    #
    my $fig_num = '';
    if ($secnum) {
      $fig_num = "$count{'toplevel'}-$count{'figure'}{'section'}";
    } else {
      $fig_num = "$count{'figure'}{'section'}";
    }

    my $anchor = "Figure.$fig_num";

    #-----------------------------------------------------------------
    # HTML: Build the HTML caption.
    #
    my $html_caption = "<p align=\"center\"><b>Figure $fig_num";
    $html_caption .= " - $title" if $title;
    $html_caption .= "</b>";
    $html_caption .= " - $description" if $description;
    $html_caption .= "</p>\n\n";
    push @{ $aref }, $html_caption;

    #-----------------------------------------------------------------
    # HTML: If the current section heading hasn't been included in the
    # 'figure index' page, add it.
    #
    if (not $heading_in_figure_index) {
      $heading_in_figure_index = 1;
      my $heading = escape_html($current{'top_heading'});
      push @{ $html{'figure'}{'index'} }, <<"END_OF_TEXT";
<h3>$heading</h3>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # HTML: Add figure title to the figure index.
    #
    push @{ $html{'figure'}{'index'} }, <<"END_OF_TEXT";
<span class="indent">$fig_num &nbsp;&nbsp; <a href="$outfile#$anchor">$title</a></span><br>

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {

    $count{'toplevel'} = $scounter{1};
    my $xml_text = escape_xml($data{'figure'}{$num}{'title'});

    #-----------------------------------------------------------------
    # XML: the figure title and end of figure element
    #
    push @xml, <<"END_OF_TEXT";
<title>$xml_text</title>

</figure>

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # PDF: Determine this figure's orientation
    #
    my $orientation = '';
    if ($data{'figure'}{$num}{'orientation'} eq 'landscape') {
      $orientation = 'landscape';
    } else {
      $orientation = 'portrait';
    }

    #-----------------------------------------------------------------
    # PDF: retrieve the title and label text
    #
    my $title       = escape_latex($data{'figure'}{$num}{'title'});
    my $description = escape_latex($data{'figure'}{$num}{'description'});
    my $label       = $data{'figure'}{$num}{'label'};
    my $caption     = '';

    $caption .= "$title"          if $title;
    $caption .= " - $description" if $description;

    my $caption_block = wrap("\\caption[$title]{$caption}");

    push @latex, <<"END_OF_TEXT";
\\vspace{-1.0\\baselineskip}
$caption_block
\\label{$label}
\\end{figure*}

END_OF_TEXT

    #-----------------------------------------------------------------
    # PDF: End landscape if orientation is landscape
    #
    if ( $orientation eq 'landscape' ) {
      push @latex, <<"END_OF_TEXT";
\\end{landscape}

END_OF_TEXT
    }

  }
}

######################################################################

sub begin_attachment {

  printdebug("begin_attachment") if $DEBUGGING;

  #-------------------------------------------------------------------
  # Here's what the HTML rendition of a attachment should look like:
  #
  #   <a name="Attachment.2-1">
  #   <p class="attachment">
  #   <a href="path/to/attachment"><img src="$paperclip_icon"> Attachment $number</a>
  #   <a href="path/to/attachment">$title</a> - $description
  #   <a href="path/to/attachment">$file</a>
  #   </p>
  #
  #-------------------------------------------------------------------
  # The LaTeX rendition of an attachment should look like this:
  #
  #   %%-----------------------------------
  #   %% begin attachment
  #   %%
  #   %% \attach{file}
  #
  #-------------------------------------------------------------------
  # Here's what the XML rendition of a attachment should look like:
  #
  #   <attachment href="path/to/file">
  #   <title>Attachment Title</title>
  #   </attachment>
  #
  #-------------------------------------------------------------------

  $in{'attachment'}{'environment'} = 1;

  ++$count{'attachment'}{'section'}; # number of attachments in toplevel section
  ++$count{'attachment'}{'total'};   # number of attachments in document

  end_pre()               if $in{'pre'};
  end_ulist_context()     if $in{'ulist'};
  end_olist_context()     if $in{'olist'};
  end_dlist()             if $in{'dlist'};
  end_baretable()         if $in{'baretable'} == 1;

  $count{'toplevel'} = $scounter{1};

  #-------------------------------------------------------------------
  # Determine the basic meta-data for this attachment
  #
  my $num       = $count{'attachment'}{'total'};
  my $label     = $data{'attachment'}{$num}{'label'} || "attachment-$num";
  my $number    = $label{$label}{'number'};
  my $file_spec = $lookup{$label}{'file'};

  #-------------------------------------------------------------------
  # Return an error if there is no file_spec.
  #
  if (not $file_spec) {
    printerror("This attachment has no file!");
    return;
  }

  #-------------------------------------------------------------------
  # If this attachment has a file, publish it.
  #
  my $file = publish_file($file_spec) if $file_spec;

  #-------------------------------------------------------------------
  # Get attached file author, revision, and date info from SVN
  #
  gather_svn_metadata($file_spec);
  my $author   = $svninfo{$file_spec}{'author'}   || 'unknown author';
  my $revision = $svninfo{$file_spec}{'revision'} || '';
  my $date     = $svninfo{$file_spec}{'date'}     || 'unknown date';

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $title       = escape_html($lookup{$label}{'title'});
    my $description = escape_html($lookup{$label}{'description'});
    my $secnum      = $current{'secnum'};
    my $aref        = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # HTML: insert anchor
    #
    #     If this attachment is inside a section, insert an anchor
    #     that includes the section number (i.e. $count{'toplevel'}),
    #     otherwise insert an anchor without a section number.
    #
    my $att_num = '';
    if ($secnum) {
      $att_num = "$count{'toplevel'}-$count{'attachment'}{'section'}";
    } else {
      $att_num = "$count{'attachment'}{'section'}";
    }
    push @{ $aref }, "<a name=\"Attachment.$att_num\">\n";

    #-----------------------------------------------------------------
    # HTML: Build caption
    #
    my $caption = "<p><b><a href=\"files/$file\">Attachment $number";
    $caption .= " - $title" if $title;
    $caption .= "</a></b>";
    $caption .= " - $description" if $description;
    $caption .= "</p>";

    #-----------------------------------------------------------------
    # HTML: attachment
    #
    push @{ $aref }, <<"END_OF_TEXT";
<div class="attachment">
<table border="0" cellpadding="4">
<tr>
<td><a href="files/$file"><img src="$paperclip_icon" border="0" align="left"></a></td>
<td>$caption<p>$file, r$revision, $author</p></td>
</tr>
</table>
</div>

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {

  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    my $title       = escape_latex($lookup{$label}{'title'});
    my $description = escape_latex($lookup{$label}{'description'});
    my $safe_file   = escape_latex($file);
    my $safe_description = $safe_file . ": " . $title . " - " . $description;

    #-----------------------------------------------------------------
    # safe description, author, and revision
    #
    #     For use as a PDF tooltip (inserted as a LaTeX option value),
    #     create a description consisting of the title plus
    #     description, and remove commas and brackets to make the
    #     string safe for use inside a LaTeX option value.
    #
    $safe_description =~ s/,//g;
    $safe_description =~ s/\]//g;
    $author           =~ s/,//g;
    $author           =~ s/\]//g;
    $revision         =~ s/,//g;
    $revision         =~ s/\]//g;

    my $text  = wrap("\\textbf{Attachment \\theattachment\\ -- $title} -- $description");
    my $block = wrap("\\attachfile[icon=Paperclip,color=0.6 0.6 0.6,description=$safe_description,author=$author (r$revision)]{files/$file}");

    my $title_block = wrap("\\begin{attachment}{$title}");

    push @latex, <<"END_OF_TEXT";
%% begin attachment
%%
$title_block
\\label{$label}
$block
$text
%% \\vspace{-\\baselineskip}

END_OF_TEXT

  }
}

######################################################################

sub end_attachment {

  printdebug("end_attachment") if $DEBUGGING;

  #-------------------------------------------------------------------
  # This attachment may have contained pre-formatted text.  If it did, end
  # the preformatted text before ending the attachment.
  #
  end_pre() if $in{'pre'};

  $in{'attachment'}{'environment'} = 0;
  my $num       = $count{'attachment'}{'total'};
  my $label     = $data{'attachment'}{$num}{'label'} || "attachment-$num";
  my $file_spec = $lookup{$label}{'file'};
  my $file      = publish_file($file_spec) if $file_spec;

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    $count{'toplevel'} = $scounter{1};

    my $html_text = escape_html($data{'attachment'}{$num}{'title'});
    my $secnum    = $current{'secnum'};
    my $outfile   = html_outfile_for_secnum($secnum);
    my $anchor    = "Attachment.$count{'toplevel'}-$count{'attachment'}{'section'}";
    my $att_num   = '';

    #-----------------------------------------------------------------
    # Determine attachment number
    #
    if ( $secnum ) {
      $att_num = "$count{'toplevel'}-$count{'attachment'}{'section'}";
    } else {
      $att_num = "$count{'attachment'}{'section'}";
    }

    #-----------------------------------------------------------------
    # Add heading to index if necessary
    #
    if (not $heading_in_attachment_index) {
      $heading_in_attachment_index = 1;
      my $heading = escape_html($current{'top_heading'});
      push @{ $html{'attachment'}{'index'} }, <<"END_OF_TEXT";
<h3>$heading</h3>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # Add to the index
    #
    push @{ $html{'attachment'}{'index'} }, <<"END_OF_TEXT";
<span class="indent">$att_num &nbsp;&nbsp; 
  <a href="$outfile#$anchor">$html_text</a> 
  (<a href="files/$file">download</a>)
</span>
<br>

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, <<"END_OF_TEXT";
%% \\cbend
%% \\vspace{\\baselineskip}
%% \\flushright{\\tiny $label}
\\end{attachment}
%% end of attachment

END_OF_TEXT
  }
}

######################################################################

sub begin_slide {

  printdebug("begin_slide") if $DEBUGGING;

  $in{'slide'}{'region'} = 1;

  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};

  $count{'toplevel'} = $scounter{1};

  ++$count{'slide'}{'total'};   # number of slides in document

  my $num    = $count{'slide'}{'total'};
  my $label  = $data{'slide'}{$num}{'label'} || $EMPTY_STRING;
  my $anchor = "slide.$num";

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum  = $current{'secnum'};
    my $outfile = html_outfile_for_secnum($secnum);
    my $aref    = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # HTML: Retrieve the title captured in pass 2, and escape anything
    # with special meaning to HTML.
    #
    my $html_title = escape_html( $data{'slide'}{$num}{'title'} );

    #-----------------------------------------------------------------
    # HTML: Insert an anchor for this slide, and a table with
    # navigation links to the previous and next slides.
    #
    push @{ $aref }, <<"END_OF_TEXT";
<a name="$anchor">
<div class="slide"><!-- ============= BEGIN SLIDE  =============== -->
<table style="margin-top:0pt; margin-bottom:10pt" border="0" cellpadding="0" cellspacing="0" width="95%">
<tr>

END_OF_TEXT

    my $previous = $num - 1;
    my $next     = $num + 1;

    #-----------------------------------------------------------------
    # Previous slide link might be blank
    #
    if ($previous == 0) {
      push @{ $aref }, <<"END_OF_TEXT";
<td align="left" width="20%">&nbsp;</td>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # Previous slide link
    #
    else {
      push @{ $aref }, <<"END_OF_TEXT";
<td align="left" width="20%"><a href="#slide.$previous">&lt; previous slide</a></td>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # Link to list of slides
    #
    push @{ $aref }, <<"END_OF_TEXT";
<td align="center" width="60%"><a href="$html_slide_index_file">list of slides</a></td>

END_OF_TEXT

    #-----------------------------------------------------------------
    # Next slide link might be blank
    #
    if ($next >= $count{'slide'}{'last'}) {
      push @{ $aref }, <<"END_OF_TEXT";
<td align="right" width="20%">&nbsp;</td>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # Next slide link
    #
    else {
      push @{ $aref }, <<"END_OF_TEXT";
<td align="right" width="20%"><a href="#slide.$next">next slide &gt;</a></td>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # End the slide navigation link table.
    #
    push @{ $aref }, <<"END_OF_TEXT";
</tr>
</table>

END_OF_TEXT

    #-----------------------------------------------------------------
    # Add heading to index if necessary
    #
    if (not $heading_in_slide_index) {
      $heading_in_slide_index = 1;
      my $heading = escape_html($current{'top_heading'});
      push @{ $html{'slide'}{'index'} }, <<"END_OF_TEXT";
<h3>$heading</h3>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # Add to the index
    #
    push @{ $html{'slide'}{'index'} }, <<"END_OF_TEXT";
<span class="indent">$num &nbsp;&nbsp; <a href="$outfile#$anchor">$html_title</a></span>
<br/>

END_OF_TEXT

    #-----------------------------------------------------------------
    # HTML: Put the title of the slide at the top of the slide content
    # in the main document.
    #
    push @{ $aref }, "<b>$html_title</b><br>\n";
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # XML: Retrieve the title captured in pass 2, and escape anything
    # with special meaning to XML.
    #
    my $xml_title = escape_xml($slide{$num}{'title'});

    #-----------------------------------------------------------------
    # XML: begin the slide element and write out the title
    #
    if ($label) {
      push @xml, <<"END_OF_TEXT";
<slide id="$label">

END_OF_TEXT
    }

    else {
      push @xml, <<"END_OF_TEXT";
<slide>

END_OF_TEXT
    }
    push @xml, <<"END_OF_TEXT";
<title>$xml_title</title>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and $option{'slide'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # PDF: Retrieve the title captured in pass 2, and escape anything
    # with special meaning to LaTeX.
    #
    my $latex_title = escape_latex( $data{'slide'}{$num}{'title'} );

    #-----------------------------------------------------------------
    # PDF: Insert the beginning of the slide (including the title)
    # into the LaTeX content.
    #
    push @latex, <<"END_OF_TEXT";
%% begin slide
%%
\\footnotesize
\\begin{center}
\\ovalbox{%
\\begin{minipage}{5.5in}
\\begin{center}
\\textbf{$latex_title}
\\end{center}
\\medskip

END_OF_TEXT
  }
}

######################################################################

sub end_slide {

  printdebug("end_slide") if $DEBUGGING;

  $in{'slide'}{'region'} = 0;

  end_pre()               if $in{'pre'};
  end_ulist_context()     if $in{'ulist'};
  end_olist_context()     if $in{'olist'};
  end_dlist()             if $in{'dlist'};
  end_table()             if $in{'table'}{'environment'};
  end_baretable()         if $in{'baretable'} == 1;
  end_image_set_context() if $in{'imageset'};

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    push @{ $aref }, <<"END_OF_TEXT";
<p class="num">Slide $count{'slide'}{'total'}</p>
</div><!-- ===================== END SLIDE  ====================== -->

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, <<"END_OF_TEXT";
</slide>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and $option{'slide'} and not $in{'hide'}{'block'}) {
    push @latex, <<"END_OF_TEXT";
\\flushright{\\tiny Slide $count{'slide'}{'total'}}
\\end{minipage}
}
\\end{center}
\\normalsize

END_OF_TEXT
  }
}

######################################################################

sub begin_sidebar {

  printdebug("begin_sidebar") if $DEBUGGING;

  $in{'sidebar'}{'environment'} = 1;

  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};

  $count{'toplevel'} = $scounter{1};

  ++$count{'sidebar'}{'section'}; # number of sidebars in section
  ++$count{'sidebar'}{'total'}; # number of sidebars in document

  $count{'image'}{'consecutive'} = 0;
  printstatus("    Sidebar $count{'sidebar'}{'total'}");

  my $num   = $count{'sidebar'}{'total'};
  my $label = $data{'sidebar'}{$num}{'label'} || $EMPTY_STRING;

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum     = $current{'secnum'};
    my $outfile    = html_outfile_for_secnum($secnum);
    my $anchor     = "sidebar.$count{'toplevel'}.$num";
    my $html_title = escape_html($sidebar{$num}{'title'});
    my $aref       = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # Begin sidebar
    #
    push @{ $aref }, <<"END_OF_TEXT";
<a name="$anchor">
<div class="sidebar"><!-- ============= BEGIN SIDEBAR  =============== -->

END_OF_TEXT

    #-----------------------------------------------------------------
    # Add heading to index if necessary
    #
    if (not $heading_in_sidebar_index) {
      $heading_in_sidebar_index = 1;
      my $heading = escape_html($current{'top_heading'});
      push @{ $html{'sidebar'}{'index'} }, <<"END_OF_TEXT";
<h3>$heading</h3>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # Add to the index
    #
    push @{ $html{'sidebar'}{'index'} }, <<"END_OF_TEXT";
<span class="indent">$num &nbsp;&nbsp; <a href="$outfile#$anchor">$html_title</a></span><br>

END_OF_TEXT

    #-----------------------------------------------------------------
    # Put the title of the sidebar at the top of the sidebar content
    # in the main document.
    #
    push @{ $aref }, "<b>$html_title</b><br>\n";

  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # XML: Retrieve the title captured in pass 2, and escape anything
    # with special meaning to XML.
    #
    my $num = $count{'sidebar'}{'total'};
    my $xml_title = escape_xml($sidebar{$num}{'title'});

    #-----------------------------------------------------------------
    # XML: Begin a sidebar element and insert the sidebar title
    #
    if ($label) {
      push @xml, <<"END_OF_TEXT";
<sidebar id="$label">

END_OF_TEXT
    }

    else {
      push @xml, <<"END_OF_TEXT";
<sidebar>

END_OF_TEXT
    }
    push @xml, <<"END_OF_TEXT";
<title>$xml_title</title>

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # Retrieve the title captured in pass 2, and escape anything with
    # special meaning to LaTeX.
    #
    my $latex_title = escape_latex($sidebar{$count{'sidebar'}{'total'}}{'title'});

    #-----------------------------------------------------------------
    # Insert the beginning of the sidebar (including the title) into
    # the LaTeX content.
    #
    push @latex, <<"END_OF_TEXT";
%% begin sidebar
%%
\\footnotesize
\\begin{wrapfigure}{r}{3in}
\\begin{boxedminipage}[t]{3in}
\\begin{center}
\\textbf{$latex_title}
\\end{center}
\\medskip

END_OF_TEXT
  }
}

######################################################################

sub end_sidebar {

  printdebug("end_sidebar") if $DEBUGGING;

  $in{'sidebar'}{'environment'} = 0;

  end_pre()               if $in{'pre'};
  end_ulist_context()     if $in{'ulist'};
  end_olist_context()     if $in{'olist'};
  end_dlist()             if $in{'dlist'};
  end_table()             if $in{'table'}{'environment'};
  end_baretable()         if $in{'baretable'} == 1;
  end_image_set_context() if $in{'imageset'};

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    push @{ $aref }, <<"END_OF_TEXT";
<p class="num">Sidebar $count{'sidebar'}{'total'}</p>
</div><!-- ===================== END SIDEBAR  ====================== -->

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, <<"END_OF_TEXT";
</sidebar>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    push @latex, <<"END_OF_TEXT";
%% \\flushright{\\tiny Sidebar $count{'sidebar'}{'total'}}
\\end{boxedminipage}
\\end{wrapfigure}
\\normalsize
%% end of sidebar

END_OF_TEXT
  }
}

######################################################################

sub begin_epigraph {

  printdebug("begin_epigraph") if $DEBUGGING;

  $in{'epigraph'}{'environment'} = 1;

  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};

  $count{'toplevel'} = $scounter{1};

  ++$count{'epigraph'}{'section'}; # number of epigraphs in section
  ++$count{'epigraph'}{'total'};   # number of epigraphs in document

  $count{'image'}{'consecutive'} = 0;

  my $num = $count{'epigraph'}{'total'};

  my $title  = $data{'epigraph'}{$num}{'title'}  || $EMPTY_STRING;
  my $label  = $data{'epigraph'}{$num}{'label'}  || $EMPTY_STRING;
  my $text   = $data{'epigraph'}{$num}{'text'}   || $EMPTY_STRING;
  my $source = $data{'epigraph'}{$num}{'source'} || $EMPTY_STRING;
  my $author = $data{'epigraph'}{$num}{'author'} || $EMPTY_STRING;

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # escape HTML
    #
    #     Escape anything with special meaning to HTML.
    #
    my $html_title  = escape_html($title);
    my $html_text   = escape_html($text);
    my $html_source = escape_html($source);
    my $html_author = escape_html($author);

    if ($author and $source) {
      $html_source = $html_author . ", " . $html_source;
    }

    elsif ($author) {
      $html_source = $html_author;
    }

    #-----------------------------------------------------------------
    # insert HTML
    #
    #     Insert an anchor for this epigraph, and begin a 'div' element
    #     for it.
    #
    push @{ $aref }, <<"END_OF_TEXT";
<a name="epigraph.$count{'toplevel'}.$num">
<div class="epigraph"><!-- ============= BEGIN EPIGRAPH  =============== -->

END_OF_TEXT

    if ($text) {
      push @{ $aref }, <<"END_OF_TEXT";
<p align="right"><i>$html_text</i></p>

END_OF_TEXT
    }

    if ($html_source) {
      push @{ $aref }, <<"END_OF_TEXT";
<p align="right"><small>&mdash; $html_source</small></p>

END_OF_TEXT
    }

    if ($text or $html_source) {
      push @{ $aref }, <<"END_OF_TEXT";
<br/><br/>

END_OF_TEXT
    }
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # escape XML
    #
    #     Escape anything with special meaning to XML.
    #
    my $xml_title  = escape_xml($title);
    my $xml_text   = escape_xml($text);
    my $xml_source = escape_xml($source);
    my $xml_author = escape_xml($author);

    #-----------------------------------------------------------------
    # insert XML
    #
    #     Insert an anchor for this epigraph, and begin a 'div' element
    #     for it.
    #
    push @xml, <<"END_OF_TEXT";
<!-- ============= BEGIN EPIGRAPH  =============== -->
<epigraph id="epigraph.$num">

END_OF_TEXT

    if ($text) {
      push @xml, <<"END_OF_TEXT";
  <text>$xml_text</text>

END_OF_TEXT
    }

    if ($source) {
      push @xml, <<"END_OF_TEXT";
  <source>$xml_source</source>

END_OF_TEXT
    }

    if ($author) {
      push @xml, <<"END_OF_TEXT";
  <author>$xml_author</author>

END_OF_TEXT
    }

  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # escape latex
    #
    #     Escape anything with special meaning to latex.
    #
    my $latex_title  = escape_latex($title);
    my $latex_text   = escape_latex($text);
    my $latex_source = escape_latex($source);
    my $latex_author = escape_latex($author);

    if ($author and $source) {
      $latex_source = $latex_author . ", " . $latex_source;
    }

    elsif ($author) {
      $latex_source = $latex_author;
    }

    #-----------------------------------------------------------------
    # insert latex
    #
    my $block = '';
    if ($latex_source)
      {
	$block = wrap("\\epigraph{\\textit{$latex_text}}{--- $latex_source}");
      }
    else
      {
	$block = wrap("\\epigraph{\\textit{$latex_text}}");
      }

    push @latex, <<"END_OF_TEXT";
%% begin epigraph
%%
$block

END_OF_TEXT
  }
}

######################################################################

sub end_epigraph {

  printdebug("end_epigraph") if $DEBUGGING;

  $in{'epigraph'}{'environment'} = 0;

  end_pre()               if $in{'pre'};
  end_ulist_context()     if $in{'ulist'};
  end_olist_context()     if $in{'olist'};
  end_dlist()             if $in{'dlist'};
  end_table()             if $in{'table'}{'environment'};
  end_baretable()         if $in{'baretable'} == 1;
  end_image_set_context() if $in{'imageset'};

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    push @{ $aref }, <<"END_OF_TEXT";
</div>
<!-- ===================== END EPIGRAPH  ====================== -->

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, <<"END_OF_TEXT";
</epigraph>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    push @latex, <<"END_OF_TEXT";
%% end of epigraph

END_OF_TEXT
  }
}

######################################################################

sub begin_quotation {

  printdebug("begin_quotation") if $DEBUGGING;

  $in{'quotation'}{'region'} = 1;

  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};

  $count{'toplevel'} = $scounter{1};

  ++$count{'quotation'}{'total'}; # number of quotations in document

  my $num   = $count{'quotation'}{'total'};
  my $label = $data{'quotation'}{$num}{'label'} || $EMPTY_STRING;

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum     = $current{'secnum'};
    my $aref       = $html{'body'}{$secnum};
    my $outfile    = html_outfile_for_secnum($secnum);
    my $anchor     = "quotation.$count{'toplevel'}.$num";
    my $html_title = escape_html($data{'quotation'}{$num}{'title'});

    #-----------------------------------------------------------------
    # HTML: Insert an anchor for this quotation, and begin a 'div'
    # element for it.
    #
    push @{ $aref }, <<"END_OF_TEXT";
<!-- ============= BEGIN QUOTATION  =============== -->
<a name="$anchor">
<div class="quotation">

END_OF_TEXT

    #-----------------------------------------------------------------
    # Add heading to index if necesary
    #
    if (not $heading_in_quotation_index) {
      $heading_in_quotation_index = 1;
      my $heading = escape_html($current{'top_heading'});
      push @{ $html{'quotation'}{'index'} }, <<"END_OF_TEXT";
<h3>$heading</h3>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # add to the index
    #
    push @{ $html{'quotation'}{'index'} }, <<"END_OF_TEXT";
<span class="indent">$num &nbsp;&nbsp; <a href="$outfile#$anchor">$html_title</a></span><br>

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # XML: Retrieve the title captured in pass 2, and escape anything
    # with special meaning to XML.
    #
    my $xml_title = escape_xml($data{'quotation'}{$num}{'title'});

    #-----------------------------------------------------------------
    # XML: begin the quotation element and insert the title
    #
    if ($label) {
      push @xml, <<"END_OF_TEXT";
<quotation id="$label">

END_OF_TEXT
    }

    else {
      push @xml, <<"END_OF_TEXT";
<quotation>

END_OF_TEXT
    }
    push @xml, <<"END_OF_TEXT";
<title>$xml_title</title>

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # PDF: Insert the beginning of the quotation (but don't include
    # the title) into the LaTeX content.
    #
    push @latex, <<"END_OF_TEXT";
%% begin quotation
%%
\\begin{quotation}
\\setlength{\\listparindent}{0pt}
\\setlength{\\itemindent}{0pt}
\\setlength{\\parindent}{0pt}
\\setlength{\\parskip}{8pt}

END_OF_TEXT
  }
}

######################################################################

sub end_quotation {

  printdebug("end_quotation") if $DEBUGGING;

  $in{'quotation'}{'region'} = 0;

  my $num   = $count{'quotation'}{'total'};
  my $label = $data{'quotation'}{$num}{'label'} || $EMPTY_STRING;

  end_pre()               if $in{'pre'};
  end_ulist_context()     if $in{'ulist'};
  end_olist_context()     if $in{'olist'};
  end_dlist()             if $in{'dlist'};
  end_table()             if $in{'table'}{'environment'};
  end_baretable()         if $in{'baretable'} == 1;
  end_image_set_context() if $in{'imageset'};
  end_quotation_source()  if $in{'quote'}{'quotesource'};

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum     = $current{'secnum'};
    my $aref       = $html{'body'}{$secnum};
    my $title      = $data{'quotation'}{$num}{'title'};
    my $html_title = escape_html($title);

    push @{ $aref }, "<i>$html_title</i><br>\n";

    push @{ $aref }, <<"END_OF_TEXT";
<p class="num">Quotation $count{'quotation'}{'total'}</p>
</div><!-- ===================== END QUOTATION  ====================== -->

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, <<"END_OF_TEXT";
</quotation>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # Retrieve the title captured in pass 2, and escape anything with
    # special meaning to LaTeX.
    #
    my $num = $count{'quotation'}{'total'};
    my $latex_title = escape_latex($data{'quotation'}{$num}{'title'});
    push @latex, <<"END_OF_TEXT";
-- \\textit{$latex_title}

END_OF_TEXT

    push @latex, <<"END_OF_TEXT";
%% \\flushright{\\tiny Quotation $count{'quotation'}{'total'}}
\\end{quotation}
%% end of quotation

END_OF_TEXT
  }
}

######################################################################

sub begin_problem {

  printdebug("begin_problem") if $DEBUGGING;

  ####################################################################
  #
  # !! BUG HERE !!
  #
  # Implement XML rendering for problems
  #
  ####################################################################

  $in{'problem'}{'region'} = 1;

  #-------------------------------------------------------------------
  # End Other Regions
  #
  #     The beginning of a 'problem' region should automatically bring
  #     to an end certain text regions.
  #
  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};

  #-------------------------------------------------------------------
  # Count Things
  #
  $count{'toplevel'} = $scounter{1};
  ++ $count{'problem'}{'total'};

  #-------------------------------------------------------------------
  # Skip Problems
  #
  #     If the user does not want to render problems in the document,
  #     return here.
  #
  return if not $option{'problem'};

  #-------------------------------------------------------------------
  # Determine the basic meta-data for this problem
  #
  my $num   = $count{'problem'}{'total'};
  my $label = $data{'problem'}{$num}{'label'} || "problem-$num";

  $label = trim_whitespace($label);

  #-------------------------------------------------------------------
  # Render HTML.
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # render html meta data
    #
    push @{ $aref }, html_header_for($label);        # header
#    push @{ $aref }, html_label_for($label);        # label
    push @{ $aref }, html_owner_for($label);         # owner
    push @{ $aref }, html_assignees_for($label);     # assignees
    push @{ $aref }, html_stakeholders_for($label);  # stakeholders
    push @{ $aref }, html_validator_for($label);     # validator
#    push @{ $aref }, html_types_for($label);        # types
#    push @{ $aref }, html_priority_for($label);     # priority
    push @{ $aref }, html_results_for($label);       # status
    push @{ $aref }, html_status_for($label);        # status
    push @{ $aref }, html_reviews_for($label);       # reviews
    push @{ $aref }, html_outcomes_for($label);      # outcomes
    push @{ $aref }, html_next_for($label);          # next
    push @{ $aref }, html_previous_for($label);      # previous
    push @{ $aref }, html_directs($label);           # directs
    push @{ $aref }, html_directed_by($label);       # directed by
    push @{ $aref }, html_uses($label);              # uses
    push @{ $aref }, html_used_by($label);           # used by
    push @{ $aref }, html_extends($label);           # extends
    push @{ $aref }, html_extended_by($label);       # extended by
    push @{ $aref }, html_realizes($label);          # realizes
    push @{ $aref }, html_realized_by($label);       # realized by
    push @{ $aref }, html_derived($label);           # derived
    push @{ $aref }, html_derived_from($label);      # derived from
    push @{ $aref }, html_class_of($label);          # class of
    push @{ $aref }, html_instance_of($label);       # instance of
    push @{ $aref }, html_generalizes($label);       # generalizes
    push @{ $aref }, html_specializes($label);       # specializes
    push @{ $aref }, html_solutions_for($label);     # solutions
    push @{ $aref }, html_allocations_for($label);   # allocations
    push @{ $aref }, html_assignments_for($label);   # assignments
    push @{ $aref }, html_tests_for($label);         # tests
    push @{ $aref }, html_tasks_for($label);         # tasks
    push @{ $aref }, html_associates_of($label);     # associates
    push @{ $aref }, html_requests_for($label);      # requests
    push @{ $aref }, html_parents_of($label);        # parents
    push @{ $aref }, html_children_of($label);       # children
    push @{ $aref }, html_copyright_of($label);      # copyright
#    push @{ $aref }, html_revision_for($label);     # revision
#    push @{ $aref }, html_date_for($label);         # date
#    push @{ $aref }, html_author_for($label);       # author
    push @{ $aref }, html_effort_for($label);        # effort
    push @{ $aref }, html_attributes_of($label);     # attributes
    push @{ $aref }, html_footer_for($label);        # footer

  }

  #-------------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # render latex meta data
    #
    push @latex, latex_header_for($label);        # header
#    push @latex, latex_label_for($label);        # label
    push @latex, latex_owner_for($label);         # owner
    push @latex, latex_assignees_for($label);     # assignees
    push @latex, latex_stakeholders_for($label);  # stakeholders
    push @latex, latex_validator_for($label);     # validator
#    push @latex, latex_types_for($label);        # types
#    push @latex, latex_priority_for($label);     # priority
    push @latex, latex_status_for($label);        # status
#    push @latex, latex_results_for($label);      # results
    push @latex, latex_reviews_for($label);       # reviews
    push @latex, latex_outcomes_for($label);      # outcomes
    push @latex, latex_next_for($label);          # next
    push @latex, latex_previous_for($label);      # previous
    push @latex, latex_directs($label);           # directs
    push @latex, latex_directed_by($label);       # directed by
    push @latex, latex_uses($label);              # uses
    push @latex, latex_used_by($label);           # used by
    push @latex, latex_extends($label);           # extends
    push @latex, latex_extended_by($label);       # extended by
    push @latex, latex_realizes($label);          # realizes
    push @latex, latex_realized_by($label);       # realized by
    push @latex, latex_derived($label);           # derived
    push @latex, latex_derived_from($label);      # derived from
    push @latex, latex_class_of($label);          # class of
    push @latex, latex_instance_of($label);       # instance of
    push @latex, latex_generalizes($label);       # generalizes
    push @latex, latex_specializes($label);       # specializes
    push @latex, latex_solutions_for($label);     # solutions
    push @latex, latex_allocations_for($label);   # allocations
    push @latex, latex_assignments_for($label);   # assignments
    push @latex, latex_tests_for($label);         # tests
    push @latex, latex_tasks_for($label);         # tasks
    push @latex, latex_associates_of($label);     # associates
    push @latex, latex_requests_for($label);      # requests
    push @latex, latex_parents_of($label);        # parents
    push @latex, latex_children_of($label);       # children
    push @latex, latex_copyright_of($label);      # copyright
#    push @latex, latex_revision_for($label);     # revision
#    push @latex, latex_date_for($label);         # date
#    push @latex, latex_author_for($label);       # author
    push @latex, latex_effort_for($label);        # effort
    push @latex, latex_attributes_of($label);     # attributes
    push @latex, latex_footer_for($label);        # footer

  }
}

######################################################################

sub end_problem {

  printdebug("end_problem") if $DEBUGGING;

  $in{'problem'}{'region'} = 0;

  end_pre()               if $in{'pre'};
  end_ulist_context()     if $in{'ulist'};
  end_olist_context()     if $in{'olist'};
  end_dlist()             if $in{'dlist'};
  end_table()             if $in{'table'}{'environment'};
  end_baretable()         if $in{'baretable'} == 1;
  end_image_set_context() if $in{'imageset'};
  end_quote_source()      if $in{'quote'}{'quotesource'};

  #-------------------------------------------------------------------
  # If the user does not want to render problems in the document,
  # return here.
  #
  #     !!! bug here !!!
  #
  #     Rather than using the %data datastructure, shouldn't I be
  #     using the %lookup datastructure here?
  #
  return if not $option{'problem'};

  my $num   = $count{'problem'}{'total'};
  my $label = $data{'problem'}{$num}{'label'};
  my $type  = $data{'problem'}{$num}{'type'};

  #-------------------------------------------------------------------
  # Render HTML.
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    push @{ $aref }, <<"END_OF_TEXT";
</div>
<!-- ===================== END PROBLEM  ======================= -->

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, <<"END_OF_TEXT";
%% \\cbend
%% \\vspace{\\baselineskip}
%% \\flushright{\\tiny $label}
\\end{problem}
%% end of problem

END_OF_TEXT
  }
}

######################################################################

sub begin_solution {

  printdebug("begin_solution") if $DEBUGGING;

  ####################################################################
  #
  # !! BUG HERE !!
  #
  # Implement XML rendering for solutions
  #
  ####################################################################

  $in{'solution'}{'region'} = 1;

  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};

  #-------------------------------------------------------------------
  # Count Things
  #
  $count{'toplevel'} = $scounter{1};
  ++$count{'solution'}{'total'};

  #-------------------------------------------------------------------
  # Skip Solutions
  #
  #     If the user does not want to render solutions in the document,
  #     return here.
  #
  return if not $option{'solution'};

  #-------------------------------------------------------------------
  # Determine the basic meta-data for this solution
  #
  my $num   = $count{'solution'}{'total'};
  my $label = $data{'solution'}{$num}{'label'} || "solution-$num";
  my $title = $lookup{$label}{'title'};

  printdebug("P3 begin solution $num $label $title") if $DEBUGGING;

  #-------------------------------------------------------------------
  # Render HTML.
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # render html meta data
    #
    push @{ $aref }, html_header_for($label);          # header
#    push @{ $aref }, html_label_for($label);           # label
    push @{ $aref }, html_owner_for($label);           # owner
    push @{ $aref }, html_assignees_for($label);       # assignee
    push @{ $aref }, html_stakeholders_for($label);    # stakeholders
#    push @{ $aref }, html_types_for($label);           # types
#    push @{ $aref }, html_priority_for($label);        # priority
#    push @{ $aref }, html_status_for($label);          # status
    push @{ $aref }, html_results_for($label);         # results
    push @{ $aref }, html_reviews_for($label);         # reviews
    push @{ $aref }, html_next_for($label);            # next
    push @{ $aref }, html_previous_for($label);        # previous
    push @{ $aref }, html_directed_by($label);         # directed by
    push @{ $aref }, html_uses($label);                # uses
    push @{ $aref }, html_used_by($label);             # used by
    push @{ $aref }, html_required_by($label);         # required by
    push @{ $aref }, html_depends_on($label);          # depends on
    push @{ $aref }, html_instance_of($label);         # instance of
    push @{ $aref }, html_class_of($label);            # class of
    push @{ $aref }, html_generalizes($label);         # generalizes
    push @{ $aref }, html_specializes($label);         # specializes
    push @{ $aref }, html_realizes($label);            # realizes
    push @{ $aref }, html_realized_by($label);         # realized by
    push @{ $aref }, html_version_of($label);          # version
    push @{ $aref }, html_license_for($label);         # license
    push @{ $aref }, html_cost_of($label);             # cost
    push @{ $aref }, html_pros_for($label);            # pros
    push @{ $aref }, html_cons_for($label);            # cons
    push @{ $aref }, html_problems_for($label);        # problems
    push @{ $aref }, html_allocations_for($label);     # allocations
    push @{ $aref }, html_assignments_for($label);     # assignments
    push @{ $aref }, html_tests_for($label);           # tests
    push @{ $aref }, html_tasks_for($label);           # tasks
    push @{ $aref }, html_associates_of($label);       # associates
    push @{ $aref }, html_requests_for($label);        # requests
    push @{ $aref }, html_attributes_of($label);       # attributes
    push @{ $aref }, html_parents_of($label);          # parents
    push @{ $aref }, html_children_of($label);         # children
    push @{ $aref }, html_copyright_of($label);        # copyright
#    push @{ $aref }, html_revision_for($label);        # revision
#    push @{ $aref }, html_date_for($label);            # date
#    push @{ $aref }, html_author_for($label);          # author
    push @{ $aref }, html_footer_for($label);          # footer

  }

  #-------------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # render latex meta data
    #
    push @latex, latex_header_for($label);        # header
#    push @latex, latex_label_for($label);        # label
    push @latex, latex_owner_for($label);         # owner
    push @latex, latex_assignees_for($label);     # assignees
    push @latex, latex_stakeholders_for($label);  # stakeholders
#    push @latex, latex_types_for($label);        # types
#    push @latex, latex_priority_for($label);     # priority
#    push @latex, latex_status_for($label);       # status
#    push @latex, latex_results_for($label);      # results
    push @latex, latex_reviews_for($label);       # reviews
    push @latex, latex_next_for($label);          # next
    push @latex, latex_previous_for($label);      # previous
    push @latex, latex_directed_by($label);       # directed by
    push @latex, latex_uses($label);              # uses
    push @latex, latex_used_by($label);           # used by
    push @latex, latex_required_by($label);       # required by
    push @latex, latex_depends_on($label);        # depends on
    push @latex, latex_instance_of($label);       # instance of
    push @latex, latex_class_of($label);          # class of
    push @latex, latex_generalizes($label);       # generalizes
    push @latex, latex_specializes($label);       # specializes
    push @latex, latex_realizes($label);          # realizes
    push @latex, latex_realized_by($label);       # realized by
    push @latex, latex_version_of($label);        # version
    push @latex, latex_license_for($label);       # license
    push @latex, latex_cost_of($label);           # cost
    push @latex, latex_pros_for($label);          # pros
    push @latex, latex_cons_for($label);          # cons
    push @latex, latex_problems_for($label);      # problems
    push @latex, latex_allocations_for($label);   # allocations
    push @latex, latex_assignments_for($label);   # assignments
    push @latex, latex_tests_for($label);         # tests
    push @latex, latex_tasks_for($label);         # tasks
    push @latex, latex_associates_of($label);     # associates
    push @latex, latex_requests_for($label);      # requests
    push @latex, latex_attributes_of($label);     # attributes
    push @latex, latex_parents_of($label);        # parents
    push @latex, latex_children_of($label);       # children
    push @latex, latex_copyright_of($label);      # copyright
#    push @latex, latex_revision_for($label);     # revision
#    push @latex, latex_date_for($label);         # date
#    push @latex, latex_author_for($label);       # author
    push @latex, latex_footer_for($label);        # footer

  }
}

######################################################################

sub end_solution {

  printdebug("end_solution") if $DEBUGGING;

  $in{'solution'}{'region'} = 0;

  end_pre()               if $in{'pre'};
  end_ulist_context()     if $in{'ulist'};
  end_olist_context()     if $in{'olist'};
  end_dlist()             if $in{'dlist'};
  end_table()             if $in{'table'}{'environment'};
  end_baretable()         if $in{'baretable'} == 1;
  end_image_set_context() if $in{'imageset'};
  end_solution_source()   if $in{'quote'}{'quotesource'};

  #-------------------------------------------------------------------
  # If the user does not want to render solutions in the document,
  # return here.
  #
  return if not $option{'solution'};

  my $num   = $count{'solution'}{'total'};
  my $label = $data{'solution'}{$num}{'label'};
  my $type  = $data{'solution'}{$num}{'type'};

  #-------------------------------------------------------------------
  # Render HTML.
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    push @{ $aref }, <<"END_OF_TEXT";
</div>
<!-- ====================== END SOLUTION ========================= -->

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, <<"END_OF_TEXT";
%% \\cbend
%% \\vspace{\\baselineskip}
%% \\flushright{\\tiny $label}
\\end{solution}
%% end of solution

END_OF_TEXT
  }
}

######################################################################

sub begin_allocation {

  printdebug("begin_allocation") if $DEBUGGING;

  ####################################################################
  #
  # !! BUG HERE !!
  #
  # Implement XML rendering for allocations
  #
  ####################################################################

  $in{'allocation'}{'region'} = 1;

  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};

  #-------------------------------------------------------------------
  # Count Things
  #
  $count{'toplevel'} = $scounter{1};
  ++$count{'allocation'}{'total'};

  #-------------------------------------------------------------------
  # Skip Allocations
  #
  #     If the user does not want to render allocations in the document,
  #     return here.
  #
  return if not $option{'allocation'};

  #-------------------------------------------------------------------
  # Determine the basic meta-data for this allocation
  #
  my $num   = $count{'allocation'}{'total'};
  my $label = $data{'allocation'}{$num}{'label'} || "allocation-$num";
  my $title = $lookup{$label}{'title'};

  printdebug("P3 begin allocation $num $label $title") if $DEBUGGING;

  #-------------------------------------------------------------------
  # Render HTML.
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # render html meta data
    #
    push @{ $aref }, html_header_for($label);          # header
#    push @{ $aref }, html_label_for($label);           # label
    push @{ $aref }, html_owner_for($label);           # owner
    push @{ $aref }, html_assignees_for($label);       # assignee
    push @{ $aref }, html_stakeholders_for($label);    # stakeholders
#    push @{ $aref }, html_types_for($label);           # types
#    push @{ $aref }, html_priority_for($label);        # priority
#    push @{ $aref }, html_status_for($label);          # status
    push @{ $aref }, html_results_for($label);         # results
    push @{ $aref }, html_reviews_for($label);         # reviews
    push @{ $aref }, html_next_for($label);            # next
    push @{ $aref }, html_previous_for($label);        # previous
    push @{ $aref }, html_directed_by($label);         # directed by
    push @{ $aref }, html_uses($label);                # uses
    push @{ $aref }, html_used_by($label);             # used by
    push @{ $aref }, html_required_by($label);         # required by
    push @{ $aref }, html_depends_on($label);          # depends on
    push @{ $aref }, html_instance_of($label);         # instance of
    push @{ $aref }, html_class_of($label);            # class of
    push @{ $aref }, html_realizes($label);            # realizes
    push @{ $aref }, html_realized_by($label);         # realized by
    push @{ $aref }, html_version_of($label);          # version
    push @{ $aref }, html_license_for($label);         # license
    push @{ $aref }, html_cost_of($label);             # cost
    push @{ $aref }, html_pros_for($label);            # pros
    push @{ $aref }, html_cons_for($label);            # cons
    push @{ $aref }, html_solutions_for($label);       # solutions
    push @{ $aref }, html_problems_for($label);        # problems
    push @{ $aref }, html_tests_for($label);           # tests
    push @{ $aref }, html_release_for($label);         # release
    push @{ $aref }, html_rel_component_for($label);   # releaseable component
    push @{ $aref }, html_tasks_for($label);           # tasks
    push @{ $aref }, html_associates_of($label);       # associates
    push @{ $aref }, html_requests_for($label);        # requests
    push @{ $aref }, html_attributes_of($label);       # attributes
    push @{ $aref }, html_parents_of($label);          # parents
    push @{ $aref }, html_children_of($label);         # children
    push @{ $aref }, html_copyright_of($label);        # copyright
#    push @{ $aref }, html_revision_for($label);        # revision
#    push @{ $aref }, html_date_for($label);            # date
#    push @{ $aref }, html_author_for($label);          # author
    push @{ $aref }, html_footer_for($label);          # footer

  }

  #-------------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # render latex meta data
    #
    push @latex, latex_header_for($label);        # header
#    push @latex, latex_label_for($label);        # label
    push @latex, latex_owner_for($label);         # owner
    push @latex, latex_assignees_for($label);     # assignees
    push @latex, latex_stakeholders_for($label);  # stakeholders
#    push @latex, latex_types_for($label);        # types
#    push @latex, latex_priority_for($label);     # priority
#    push @latex, latex_status_for($label);       # status
#    push @latex, latex_results_for($label);      # results
    push @latex, latex_reviews_for($label);       # reviews
    push @latex, latex_next_for($label);          # next
    push @latex, latex_previous_for($label);      # previous
    push @latex, latex_directed_by($label);       # directed by
    push @latex, latex_uses($label);              # uses
    push @latex, latex_used_by($label);           # used by
    push @latex, latex_required_by($label);       # required by
    push @latex, latex_depends_on($label);        # depends on
    push @latex, latex_instance_of($label);       # instance of
    push @latex, latex_class_of($label);          # class of
    push @latex, latex_realizes($label);          # realizes
    push @latex, latex_realized_by($label);       # realized by
    push @latex, latex_version_of($label);        # version
    push @latex, latex_license_for($label);       # license
    push @latex, latex_cost_of($label);           # cost
    push @latex, latex_pros_for($label);          # pros
    push @latex, latex_cons_for($label);          # cons
    push @latex, latex_solutions_for($label);     # solutions
    push @latex, latex_problems_for($label);      # problems
    push @latex, latex_tests_for($label);         # tests
    push @latex, latex_release_for($label);       # release
    push @latex, latex_rel_component_for($label); # releaseable component
    push @latex, latex_tasks_for($label);         # tasks
    push @latex, latex_associates_of($label);     # associates
    push @latex, latex_requests_for($label);      # requests
    push @latex, latex_attributes_of($label);     # attributes
    push @latex, latex_parents_of($label);        # parents
    push @latex, latex_children_of($label);       # children
    push @latex, latex_copyright_of($label);      # copyright
#    push @latex, latex_revision_for($label);     # revision
#    push @latex, latex_date_for($label);         # date
#    push @latex, latex_author_for($label);       # author
    push @latex, latex_footer_for($label);        # footer

  }
}

######################################################################

sub end_allocation {

  printdebug("end_allocation") if $DEBUGGING;

  $in{'allocation'}{'region'} = 0;

  end_pre()               if $in{'pre'};
  end_ulist_context()     if $in{'ulist'};
  end_olist_context()     if $in{'olist'};
  end_dlist()             if $in{'dlist'};
  end_table()             if $in{'table'}{'environment'};
  end_baretable()         if $in{'baretable'} == 1;
  end_image_set_context() if $in{'imageset'};
  end_allocation_source() if $in{'quote'}{'quotesource'};

  #-------------------------------------------------------------------
  # If the user does not want to render allocations in the document,
  # return here.
  #
  return if not $option{'allocation'};

  my $num   = $count{'allocation'}{'total'};
  my $label = $data{'allocation'}{$num}{'label'};
  my $type  = $data{'allocation'}{$num}{'type'};

  #-------------------------------------------------------------------
  # Render HTML.
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    push @{ $aref }, <<"END_OF_TEXT";
</div>
<!-- ====================== END ALLOCATION ========================= -->

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, <<"END_OF_TEXT";
%% \\cbend
%% \\vspace{\\baselineskip}
%% \\flushright{\\tiny $label}
\\end{allocation}
%% end of allocation

END_OF_TEXT
  }
}

######################################################################

sub begin_assignment {

  printdebug("begin_assignment") if $DEBUGGING;

  ####################################################################
  #
  # !! BUG HERE !!
  #
  # Implement XML rendering for assignments
  #
  ####################################################################

  $in{'assignment'}{'region'} = 1;

  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};

  #-------------------------------------------------------------------
  # Count Things
  #
  $count{'toplevel'} = $scounter{1};
  ++$count{'assignment'}{'total'};

  #-------------------------------------------------------------------
  # Skip Assignments
  #
  #     If the user does not want to render assignments in the document,
  #     return here.
  #
  return if not $option{'assignment'};

  #-------------------------------------------------------------------
  # Determine the basic meta-data for this assignment
  #
  my $num   = $count{'assignment'}{'total'};
  my $label = $data{'assignment'}{$num}{'label'} || "assignment-$num";
  my $title = $lookup{$label}{'title'};

  printdebug("P3 begin assignment $num $label $title") if $DEBUGGING;

  #-------------------------------------------------------------------
  # Render HTML.
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # render html meta data
    #
    push @{ $aref }, html_header_for($label);          # header
#    push @{ $aref }, html_label_for($label);           # label
    push @{ $aref }, html_owner_for($label);           # owner
    push @{ $aref }, html_assignees_for($label);       # assignee
    push @{ $aref }, html_stakeholders_for($label);    # stakeholders
    push @{ $aref }, html_types_for($label);           # types
#    push @{ $aref }, html_priority_for($label);        # priority
#    push @{ $aref }, html_status_for($label);          # status
    push @{ $aref }, html_results_for($label);         # results
    push @{ $aref }, html_reviews_for($label);         # reviews
    push @{ $aref }, html_next_for($label);            # next
    push @{ $aref }, html_previous_for($label);        # previous
    push @{ $aref }, html_directed_by($label);         # directed by
    push @{ $aref }, html_uses($label);                # uses
    push @{ $aref }, html_used_by($label);             # used by
    push @{ $aref }, html_required_by($label);         # required by
    push @{ $aref }, html_depends_on($label);          # depends on
    push @{ $aref }, html_instance_of($label);         # instance of
    push @{ $aref }, html_class_of($label);            # class of
    push @{ $aref }, html_realizes($label);            # realizes
    push @{ $aref }, html_realized_by($label);         # realized by
    push @{ $aref }, html_version_of($label);          # version
    push @{ $aref }, html_license_for($label);         # license
    push @{ $aref }, html_cost_of($label);             # cost
    push @{ $aref }, html_pros_for($label);            # pros
    push @{ $aref }, html_cons_for($label);            # cons
    push @{ $aref }, html_roles_for($label);           # roles
    push @{ $aref }, html_problems_for($label);        # problems
    push @{ $aref }, html_tests_for($label);           # tests
    push @{ $aref }, html_release_for($label);         # release
    push @{ $aref }, html_rel_component_for($label);   # releaseable component
    push @{ $aref }, html_tasks_for($label);           # tasks
    push @{ $aref }, html_associates_of($label);       # associates
    push @{ $aref }, html_requests_for($label);        # requests
    push @{ $aref }, html_attributes_of($label);       # attributes
    push @{ $aref }, html_parents_of($label);          # parents
    push @{ $aref }, html_children_of($label);         # children
    push @{ $aref }, html_copyright_of($label);        # copyright
#    push @{ $aref }, html_revision_for($label);        # revision
#    push @{ $aref }, html_date_for($label);            # date
#    push @{ $aref }, html_author_for($label);          # author
    push @{ $aref }, html_footer_for($label);          # footer

  }

  #-------------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # render latex meta data
    #
    push @latex, latex_header_for($label);        # header
#    push @latex, latex_label_for($label);        # label
    push @latex, latex_owner_for($label);         # owner
    push @latex, latex_assignees_for($label);     # assignees
    push @latex, latex_stakeholders_for($label);  # stakeholders
    push @latex, latex_types_for($label);         # types
#    push @latex, latex_priority_for($label);     # priority
#    push @latex, latex_status_for($label);       # status
#    push @latex, latex_results_for($label);      # results
    push @latex, latex_reviews_for($label);       # reviews
    push @latex, latex_next_for($label);          # next
    push @latex, latex_previous_for($label);      # previous
    push @latex, latex_directed_by($label);       # directed by
    push @latex, latex_uses($label);              # uses
    push @latex, latex_used_by($label);           # used by
    push @latex, latex_required_by($label);       # required by
    push @latex, latex_depends_on($label);        # depends on
    push @latex, latex_instance_of($label);       # instance of
    push @latex, latex_class_of($label);          # class of
    push @latex, latex_realizes($label);          # realizes
    push @latex, latex_realized_by($label);       # realized by
    push @latex, latex_version_of($label);        # version
    push @latex, latex_license_for($label);       # license
    push @latex, latex_cost_of($label);           # cost
    push @latex, latex_pros_for($label);          # pros
    push @latex, latex_cons_for($label);          # cons
    push @latex, latex_roles_for($label);         # roles
    push @latex, latex_problems_for($label);      # problems
    push @latex, latex_tests_for($label);         # tests
    push @latex, latex_release_for($label);       # release
    push @latex, latex_rel_component_for($label); # releaseable component
    push @latex, latex_tasks_for($label);         # tasks
    push @latex, latex_associates_of($label);     # associates
    push @latex, latex_requests_for($label);      # requests
    push @latex, latex_attributes_of($label);     # attributes
    push @latex, latex_parents_of($label);        # parents
    push @latex, latex_children_of($label);       # children
    push @latex, latex_copyright_of($label);      # copyright
#    push @latex, latex_revision_for($label);     # revision
#    push @latex, latex_date_for($label);         # date
#    push @latex, latex_author_for($label);       # author
    push @latex, latex_footer_for($label);        # footer

  }
}

######################################################################

sub end_assignment {

  printdebug("end_assignment") if $DEBUGGING;

  $in{'assignment'}{'region'} = 0;

  end_pre()               if $in{'pre'};
  end_ulist_context()     if $in{'ulist'};
  end_olist_context()     if $in{'olist'};
  end_dlist()             if $in{'dlist'};
  end_table()             if $in{'table'}{'environment'};
  end_baretable()         if $in{'baretable'} == 1;
  end_image_set_context() if $in{'imageset'};
  end_assignment_source() if $in{'quote'}{'quotesource'};

  #-------------------------------------------------------------------
  # If the user does not want to render assignments in the document,
  # return here.
  #
  return if not $option{'assignment'};

  my $num   = $count{'assignment'}{'total'};
  my $label = $data{'assignment'}{$num}{'label'};
  my $type  = $data{'assignment'}{$num}{'type'};

  #-------------------------------------------------------------------
  # Render HTML.
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    push @{ $aref }, <<"END_OF_TEXT";
</div>
<!-- ====================== END ASSIGNMENT ========================= -->

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, <<"END_OF_TEXT";
%% \\cbend
%% \\vspace{\\baselineskip}
%% \\flushright{\\tiny $label}
\\end{assignment}
%% end of assignment

END_OF_TEXT
  }
}

######################################################################

sub begin_test {

  printdebug("begin_test") if $DEBUGGING;

  ####################################################################
  #
  # !! BUG HERE !!
  #
  # Implement XML rendering for tests
  #
  ####################################################################

  $in{'test'}{'region'} = 1;

  #-------------------------------------------------------------------
  # End Other Regions
  #
  #     The beginning of a 'test' region should automatically bring to
  #     an end certain text regions.
  #
  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};

  #-------------------------------------------------------------------
  # Count Things
  #
  $count{'toplevel'} = $scounter{1};
  ++$count{'test'}{'total'};

  #-------------------------------------------------------------------
  # Skip Tests
  #
  #     If the user does not want to render tests in the document,
  #     return here.
  #
  return if not $option{'test'};

  #-------------------------------------------------------------------
  # Determine the basic meta-data for this test
  #
  my $num   = $count{'test'}{'total'};
  my $label = $data{'test'}{$num}{'label'} || "test-$num";

  $label = trim_whitespace($label);

  #-------------------------------------------------------------------
  # Look up some lists we'll need later
  #
  my @solutions   = @{$lookup{$label}{'solution'}};
  my @allocations = @{$lookup{$label}{'allocation'}};
  my @assignments = @{$lookup{$label}{'assignment'}};
  my @problems    = @{$lookup{$label}{'problem'}};
  my @children    = @{$lookup{$label}{'children'}};
  my @types       = @{$lookup{$label}{'type'}};
  my @associates  = @{$lookup{$label}{'associated'}};
  my %attrs        = %{$attribute{$label}};

  my $problem_count = scalar @problems;

  #-------------------------------------------------------------------
  # Render HTML.
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # render html meta data
    #
    push @{ $aref }, html_header_for($label);          # header
#    push @{ $aref }, html_label_for($label);          # label
    push @{ $aref }, html_owner_for($label);           # owner
#    push @{ $aref }, html_types_for($label);          # types
    push @{ $aref }, html_previous_for($label);        # previous
    push @{ $aref }, html_next_for($label);            # next
#    push @{ $aref }, html_priority_for($label);       # priority
#    push @{ $aref }, html_status_for($label);         # status
    push @{ $aref }, html_required_by($label);         # required by
    push @{ $aref }, html_depends_on($label);          # depends on
    push @{ $aref }, html_results_for($label);         # results
    push @{ $aref }, html_reviews_for($label);         # reviews
    push @{ $aref }, html_validator_for($label);       # validator
    push @{ $aref }, html_parents_of($label);          # parents
    push @{ $aref }, html_children_of($label);         # children
    push @{ $aref }, html_solutions_for($label);       # solutions
    push @{ $aref }, html_allocations_for($label);     # allocations
    push @{ $aref }, html_problems_for($label);        # problems
    push @{ $aref }, html_tasks_for($label);           # tasks
    push @{ $aref }, html_associates_of($label);       # associates
    push @{ $aref }, html_attributes_of($label);       # attributes
    push @{ $aref }, html_requests_for($label);        # requests
#    push @{ $aref }, html_revision_for($label);       # revision
#    push @{ $aref }, html_date_for($label);           # date
#    push @{ $aref }, html_author_for($label);         # author
    push @{ $aref }, html_footer_for($label);          # footer

  }

  #-------------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # render latex meta data
    #
    push @latex, latex_header_for($label);        # header
#    push @latex, latex_label_for($label);        # label
    push @latex, latex_owner_for($label);         # owner
#    push @latex, latex_types_for($label);        # types
    push @latex, latex_previous_for($label);      # previous
    push @latex, latex_next_for($label);          # next
#    push @latex, latex_priority_for($label);     # priority
#    push @latex, latex_status_for($label);       # status
    push @latex, latex_results_for($label);       # results
    push @latex, latex_required_by($label);       # required by
    push @latex, latex_depends_on($label);        # depends on
    push @latex, latex_reviews_for($label);       # reviews
    push @latex, latex_validator_for($label);     # validator
    push @latex, latex_parents_of($label);        # parents
    push @latex, latex_children_of($label);       # children
    push @latex, latex_solutions_for($label);     # solutions
    push @latex, latex_allocations_for($label);   # allocations
    push @latex, latex_problems_for($label);      # problems
    push @latex, latex_tasks_for($label);         # tasks
    push @latex, latex_associates_of($label);     # associates
    push @latex, latex_attributes_of($label);     # attributes
    push @latex, latex_requests_for($label);      # requests
#    push @latex, latex_revision_for($label);     # revision
#    push @latex, latex_date_for($label);         # date
#    push @latex, latex_author_for($label);       # author
    push @latex, latex_footer_for($label);        # footer

  }
}

######################################################################

sub end_test {

  printdebug("end_test") if $DEBUGGING;

  $in{'test'}{'region'} = 0;

  end_pre()               if $in{'pre'};
  end_ulist_context()     if $in{'ulist'};
  end_olist_context()     if $in{'olist'};
  end_dlist()             if $in{'dlist'};
  end_table()             if $in{'table'}{'environment'};
  end_baretable()         if $in{'baretable'} == 1;
  end_image_set_context() if $in{'imageset'};
  end_test_source()       if $in{'quote'}{'quotesource'};

  #-------------------------------------------------------------------
  # If the user does not want to render tests in the document,
  # return here.
  #
  return if not $option{'test'};

  #-------------------------------------------------------------------
  # Get some basic meta-data
  #
  my $num   = $count{'test'}{'total'};
  my $label = $data{'test'}{$num}{'label'};
  my $type  = $data{'test'}{$num}{'type'};

  # my @levels    = sort { $a <=> $b } keys %{ $data{'test'}{$num}{'level'} };
  # my @questions = sort { $a <=> $b } keys %{ $data{'test'}{$num}{'question'} };


  #-------------------------------------------------------------------
  # Render HTML.
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    push @{ $aref }, <<"END_OF_TEXT";
</div>
<!-- ===================== END TEST  ====================== -->

END_OF_TEXT

#     #-----------------------------------------------------------------
#     # Render the meaning of the score levels that can be achieved on
#     # this test.
#     #
#     push @{ $aref }, "<h3>Explanation of Score Levels</h3>\n";
#     foreach my $l_num (@levels) {

#       my $description = escape_html( $data{'test'}{$num}{'level'}{$l_num} );
#       my $impact      = escape_html( $data{'test'}{$num}{'level'}{$l_num}{'impact'} );

#       push @{ $aref }, <<"END_OF_TEXT";
# <p><b>Level $l_num:</b> $description</p>

# <p><i>Level $l_num Impact:</i> $impact</p>

# END_OF_TEXT

#     }

    # #-----------------------------------------------------------------
    # # Render the questions
    # #
    # push @{ $aref }, "<h3>Questions and Spot Checks</h3>\n";
    # foreach my $q_num (@questions) {

    #   my $question
    # 	= escape_html( $data{'test'}{$num}{'question'}{$q_num} );
    #   my $topic
    # 	= escape_html( $data{'test'}{$num}{'question'}{$q_num}{'topic'} );
    #   my $description
    # 	= escape_html( $data{'test'}{$num}{'question'}{$q_num}{'description'} );
    #   my $correct_answer
    # 	= escape_html( $data{'test'}{$num}{'question'}{$q_num}{'answer'} );
    #   my $level
    # 	= escape_html( $data{'test'}{$num}{'question'}{$q_num}{'level'} );
    #   my $yes_impact
    # 	= escape_html( $data{'test'}{$num}{'question'}{$q_num}{'impact'}{'yes'} );
    #   my $no_impact
    # 	= escape_html( $data{'test'}{$num}{'question'}{$q_num}{'impact'}{'no'} );
    #   my $comment_request
    # 	= escape_html( $data{'test'}{$num}{'question'}{$q_num}{'comment'} );

    #   # is there a question?
    #   #
    #   if ($question and $topic) {
    # 	push @{ $aref }, "<p><b>Question $q_num: <i>($topic)</i> $question</b></p>\n\n";
    #   }
    #   elsif ($question) {
    # 	push @{ $aref }, "<p><b>Question $q_num: $question</b></p>\n\n";
    #   }
    #   else {
    # 	push @{ $aref }, "<p><b>Question $q_num: no question specified</b></p>\n\n";
    #   }

    #   # is there a description?
    #   #
    #   if ($description) {
    # 	push @{ $aref }, "<p>$description</p>\n\n";
    #   }

    #   # was a correct answer specified?
    #   #
    #   if ($correct_answer) {
    # 	push @{ $aref }, "<p><i>Correct Answer: </i> $correct_answer</p>\n\n";
    #   }
    #   else {
    # 	push @{ $aref }, "<p><i>Correct Answer: </i> no correct answer specified</p>\n\n";
    #   }

    #   # what level does this question pertain to?
    #   #
    #   if ($level) {
    # 	push @{ $aref }, "<p><i>Pertains to level: </i> $level</p>\n\n";
    #   }
    #   else {
    # 	push @{ $aref }, "<p><i>Pertains to level:</i> no level specified</p>\n\n";
    #   }

    #   # what is the impact of a 'yes' answer?
    #   #
    #   if ($yes_impact) {
    # 	push @{ $aref }, "<p><i>If answer is yes: </i> $yes_impact</p>\n\n";
    #   }
    #   else {
    # 	push @{ $aref }, "<p><i>If answer is yes:</i> no impact specified</p>\n\n";
    #   }

    #   # what is the impact of a 'no' answer?
    #   #
    #   if ($no_impact) {
    # 	push @{ $aref }, "<p><i>If answer is no: </i> $no_impact</p>\n\n";
    #   }
    #   else {
    # 	push @{ $aref }, "<p><i>If answer is no:</i> no impact specified</p>\n\n";
    #   }

    #   # is a comment required?
    #   #
    #   if ($comment_request) {
    # 	push @{ $aref }, "<p><i>Comment required: </i> $comment_request</p>\n\n";
    #   }
    # }

  }

  #-------------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, <<"END_OF_TEXT";
%% \\cbend
%% \\vspace{\\baselineskip}
%% \\flushright{\\tiny Test $count{'test'}{'total'}}
\\end{test}
%% end of test

END_OF_TEXT

    # #-----------------------------------------------------------------
    # # Render the meaning of the score levels that can be achieved on
    # # this test.
    # #
    # push @latex, "\\textbf{Explanation of Score Levels}\n\n";
    # foreach my $l_num (@levels) {
    #   my $description = escape_latex( $data{'test'}{$num}{'level'}{$l_num} );
    #   my $impact      = escape_latex( $data{'test'}{$num}{'level'}{$l_num}{'impact'} );

    #   my $wrapped_description = wrap("\\textbf{Level $l_num:} $description");
    #   my $wrapped_impact      = wrap("\\textit{Level $l_num Impact:} $impact");

    #   push @latex, "$wrapped_description\n\n";
    #   push @latex, "$wrapped_impact\n\n";

    # }

    # #-----------------------------------------------------------------
    # # Render the questions
    # #
    # push @latex, "\\textbf{Questions and Spot Checks}\n\n";
    # foreach my $q_num (@questions) {

    #   my $question
    # 	= escape_latex( $data{'test'}{$num}{'question'}{$q_num} );
    #   my $topic
    # 	= escape_latex( $data{'test'}{$num}{'question'}{$q_num}{'topic'} );
    #   my $description
    # 	= escape_latex( $data{'test'}{$num}{'question'}{$q_num}{'description'} );
    #   my $correct_answer
    # 	= escape_latex( $data{'test'}{$num}{'question'}{$q_num}{'answer'} );
    #   my $level
    # 	= escape_latex( $data{'test'}{$num}{'question'}{$q_num}{'level'} );
    #   my $yes_impact
    # 	= escape_latex( $data{'test'}{$num}{'question'}{$q_num}{'impact'}{'yes'} );
    #   my $no_impact
    # 	= escape_latex( $data{'test'}{$num}{'question'}{$q_num}{'impact'}{'no'} );
    #   my $comment_request
    # 	= escape_latex( $data{'test'}{$num}{'question'}{$q_num}{'comment'} );

    #   # is there a question?
    #   #
    #   if ($question and $topic) {
    # 	push @latex, "\\textbf{Question $q_num: \\textit{($topic)} $question}\n\n";
    #   }
    #   elsif ($question) {
    # 	push @latex, "\\textbf{Question $q_num: $question}\n\n";
    #   }
    #   else {
    # 	push @latex, "\\textbf{Question $q_num: no question specified}\n\n";
    #   }

    #   # is there a description?
    #   #
    #   if ($description) {
    # 	push @latex, "$description\n\n";
    #   }

    #   # was a correct answer specified?
    #   #
    #   if ($correct_answer) {
    # 	push @latex, "\\textit{Correct Answer: } $correct_answer\n\n";
    #   }
    #   else {
    # 	push @latex, "\\textit{Correct Answer: } no correct answer specified\n\n";
    #   }

    #   # what level does this question pertain to?
    #   #
    #   if ($level) {
    # 	push @latex, "\\textit{Pertains to level: } $level\n\n";
    #   }
    #   else {
    # 	push @latex, "\\textit{Pertains to level: } no level specified\n\n";
    #   }

    #   # what is the impact of a 'yes' answer?
    #   #
    #   if ($yes_impact) {
    # 	push @latex, "\\textit{If answer is yes: } $yes_impact\n\n";
    #   }
    #   else {
    # 	push @latex, "\\textit{If answer is yes: } no impact specified\n\n";
    #   }

    #   # what is the impact of a 'no' answer?
    #   #
    #   if ($no_impact) {
    # 	push @latex, "\\textit{If answer is no: } $no_impact\n\n";
    #   }
    #   else {
    # 	push @latex, "\\textit{If answer is no: } no impact specified\n\n";
    #   }

    #   # is a comment required?
    #   #
    #   if ($comment_request) {
    # 	push @latex, "\\textit{Comment required: } $comment_request\n\n";
    #   }
    # }
  }
}

######################################################################

sub begin_task {

  printdebug("begin_task") if $DEBUGGING;

  ####################################################################
  #
  # !! BUG HERE !!
  #
  # Implement XML rendering for tasks
  #
  ####################################################################

  $in{'task'}{'region'} = 1;

  #-------------------------------------------------------------------
  # End Other Regions
  #
  #     The beginning of a 'task' region should automatically bring to
  #     an end certain text regions.
  #
  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};

  #-------------------------------------------------------------------
  # Count Things
  #
  $count{'toplevel'} = $scounter{1};
  ++ $count{'task'}{'total'};

  #-------------------------------------------------------------------
  # Skip Tasks
  #
  #     If the user does not want to render tasks in the document,
  #     return here.
  #
  return if not $option{'task'};

  #-------------------------------------------------------------------
  # Determine the basic meta-data for this task
  #
  my $num      = $count{'task'}{'total'};
  my $label    = $data{'task'}{$num}{'label'} || "task-$num";

  #-------------------------------------------------------------------
  # Render HTML.
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # render html meta data
    #
    push @{ $aref }, html_header_for($label);          # header
#    push @{ $aref }, html_label_for($label);           # label
    push @{ $aref }, html_owner_for($label);           # owner
    push @{ $aref }, html_stakeholders_for($label);    # stakeholders
#    push @{ $aref }, html_types_for($label);           # types
    push @{ $aref }, html_previous_for($label);        # previous
    push @{ $aref }, html_next_for($label);            # next
#    push @{ $aref }, html_priority_for($label);        # priority
#    push @{ $aref }, html_status_for($label);          # status
    push @{ $aref }, html_results_for($label);         # results
    push @{ $aref }, html_reviews_for($label);         # reviews
    push @{ $aref }, html_validator_for($label);       # validator
    push @{ $aref }, html_directed_by($label);         # directed by
    push @{ $aref }, html_parents_of($label);          # parents
    push @{ $aref }, html_children_of($label);         # children
    push @{ $aref }, html_tasks_for($label);           # tasks
    push @{ $aref }, html_depends_on($label);          # depends on
    push @{ $aref }, html_required_by($label);         # required by
    push @{ $aref }, html_instance_of($label);         # instance of
    push @{ $aref }, html_class_of($label);            # class of
    push @{ $aref }, html_problems_for($label);        # problems
    push @{ $aref }, html_solutions_for($label);       # solutions
    push @{ $aref }, html_tests_for($label);           # tests
    push @{ $aref }, html_associates_of($label);       # associates
    push @{ $aref }, html_requests_for($label);        # requests
    push @{ $aref }, html_product_of($label);          # product
    push @{ $aref }, html_attributes_of($label);       # attributes
#    push @{ $aref }, html_revision_for($label);        # revision
#    push @{ $aref }, html_date_for($label);            # date
#    push @{ $aref }, html_author_for($label);          # author
    push @{ $aref }, html_footer_for($label);          # footer

  }

  #-------------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # render latex meta data
    #
    push @latex, latex_header_for($label);        # header
#    push @latex, latex_label_for($label);         # label
    push @latex, latex_owner_for($label);         # owner
    push @latex, latex_stakeholders_for($label);  # stakeholders
#    push @latex, latex_types_for($label);         # types
    push @latex, latex_previous_for($label);      # previous
    push @latex, latex_next_for($label);          # next
#    push @latex, latex_priority_for($label);      # priority
#    push @latex, latex_status_for($label);        # status
#    push @latex, latex_results_for($label);       # results
    push @latex, latex_reviews_for($label);       # reviews
    push @latex, latex_validator_for($label);     # validator
    push @latex, latex_directed_by($label);       # directed by
    push @latex, latex_parents_of($label);        # parents
    push @latex, latex_children_of($label);       # children
    push @latex, latex_tasks_for($label);         # tasks
    push @latex, latex_depends_on($label);        # depends on
    push @latex, latex_required_by($label);       # required by
    push @latex, latex_instance_of($label);       # instance of
    push @latex, latex_class_of($label);          # class of
    push @latex, latex_problems_for($label);      # problems
    push @latex, latex_solutions_for($label);     # solutions
    push @latex, latex_tests_for($label);         # tests
    push @latex, latex_associates_of($label);     # associates
    push @latex, latex_requests_for($label);      # requests
    push @latex, latex_product_of($label);        # product
    push @latex, latex_attributes_of($label);     # attributes
#    push @latex, latex_revision_for($label);      # revision
#    push @latex, latex_date_for($label);          # date
#    push @latex, latex_author_for($label);        # author
    push @latex, latex_footer_for($label);        # footer

  }
}

######################################################################

sub end_task {

  printdebug("end_task") if $DEBUGGING;

  $in{'task'}{'region'} = 0;

  end_pre()               if $in{'pre'};
  end_ulist_context()     if $in{'ulist'};
  end_olist_context()     if $in{'olist'};
  end_dlist()             if $in{'dlist'};
  end_table()             if $in{'table'}{'environment'};
  end_baretable()         if $in{'baretable'} == 1;
  end_image_set_context() if $in{'imageset'};
  end_quote_source()      if $in{'quote'}{'quotesource'};

  #-------------------------------------------------------------------
  # If the user does not want to render tasks in the document,
  # return here.
  #
  return if not $option{'task'};

  my $num   = $count{'task'}{'total'};
  my $label = $data{'task'}{$num}{'label'};
  my $type  = $data{'task'}{$num}{'type'};

  #-------------------------------------------------------------------
  # Render HTML.
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    push @{ $aref }, <<"END_OF_TEXT";
</div>
<!-- ===================== END TASK  ======================= -->

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, <<"END_OF_TEXT";
%% \\end{leftbar}
%% \\cbend
%% \\vspace{\\baselineskip}
%% \\flushright{\\tiny $label}
\\end{task}
%% end of task

END_OF_TEXT
  }
}

######################################################################

sub begin_result {

  printdebug("begin_result") if $DEBUGGING;

  ####################################################################
  #
  # !! BUG HERE !!
  #
  # Implement XML rendering for results
  #
  ####################################################################

  $in{'result'}{'region'} = 1;

  #-------------------------------------------------------------------
  # End Other Regions
  #
  #     The beginning of a 'result' region should automatically bring to
  #     an end certain text regions.
  #
  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};

  #-------------------------------------------------------------------
  # Count Things
  #
  $count{'toplevel'} = $scounter{1};
  ++ $count{'result'}{'total'};

  #-------------------------------------------------------------------
  # Skip Results
  #
  #     If the user does not want to render results in the document,
  #     return here.
  #
  return if not $option{'result'};

  #-------------------------------------------------------------------
  # Determine the basic meta-data for this result
  #
  my $num      = $count{'result'}{'total'};
  my $label    = $data{'result'}{$num}{'label'} || "result-$num";
  my $secnum   = $current{'secnum'};

  #-------------------------------------------------------------------
  # Render HTML.
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $aref   = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # render html meta data
    #
    push @{ $aref }, html_header_for($label);          # header
#    push @{ $aref }, html_label_for($label);           # label
#    push @{ $aref }, html_types_for($label);           # types
    push @{ $aref }, html_previous_for($label);        # previous
    push @{ $aref }, html_next_for($label);            # next
#    push @{ $aref }, html_priority_for($label);        # priority
#    push @{ $aref }, html_status_for($label);          # status
    push @{ $aref }, html_results_for($label);         # results
    push @{ $aref }, html_reviews_for($label);         # reviews
    push @{ $aref }, html_parents_of($label);          # parents
    push @{ $aref }, html_children_of($label);         # children
    push @{ $aref }, html_problems_for($label);        # problems
    push @{ $aref }, html_solutions_for($label);       # solutions
    push @{ $aref }, html_tests_for($label);           # tests
    push @{ $aref }, html_tasks_for($label);           # tasks
    push @{ $aref }, html_associates_of($label);       # associates
    push @{ $aref }, html_attributes_of($label);       # attributes
#    push @{ $aref }, html_revision_for($label);        # revision
#    push @{ $aref }, html_date_for($label);            # date
#    push @{ $aref }, html_author_for($label);          # author
    push @{ $aref }, html_footer_for($label);          # footer

  }

  #-------------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # render latex meta data
    #
    push @latex, latex_header_for($label);        # header
#    push @latex, latex_label_for($label);         # label
#    push @latex, latex_types_for($label);         # types
    push @latex, latex_previous_for($label);      # previous
    push @latex, latex_next_for($label);          # next
#    push @latex, latex_priority_for($label);      # priority
#    push @latex, latex_status_for($label);        # status
#    push @latex, latex_results_for($label);       # results
    push @latex, latex_reviews_for($label);       # reviews
    push @latex, latex_parents_of($label);        # parents
    push @latex, latex_children_of($label);       # children
    push @latex, latex_problems_for($label);      # problems
    push @latex, latex_solutions_for($label);     # solutions
    push @latex, latex_tests_for($label);         # tests
    push @latex, latex_tasks_for($label);         # tasks
    push @latex, latex_associates_of($label);     # associates
    push @latex, latex_attributes_of($label);     # attributes
#    push @latex, latex_revision_for($label);      # revision
#    push @latex, latex_date_for($label);          # date
#    push @latex, latex_author_for($label);        # author
    push @latex, latex_footer_for($label);        # footer

  }
}

######################################################################

sub end_result {

  printdebug("end_result") if $DEBUGGING;

  $in{'result'}{'region'} = 0;

  end_pre()               if $in{'pre'};
  end_ulist_context()     if $in{'ulist'};
  end_olist_context()     if $in{'olist'};
  end_dlist()             if $in{'dlist'};
  end_table()             if $in{'table'}{'environment'};
  end_baretable()         if $in{'baretable'} == 1;
  end_image_set_context() if $in{'imageset'};
  end_quote_source()      if $in{'quote'}{'quotesource'};

  #-------------------------------------------------------------------
  # If the user does not want to render results in the document,
  # return here.
  #
  return if not $option{'result'};

  my $num   = $count{'result'}{'total'};
  my $label = $data{'result'}{$num}{'label'};
  my $type  = $data{'result'}{$num}{'type'};

  #-------------------------------------------------------------------
  # Render HTML.
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    push @{ $aref }, <<"END_OF_TEXT";
</div>
<!-- ===================== END RESULT  ======================= -->

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, <<"END_OF_TEXT";
%% \\end{leftbar}
%% \\cbend
%% \\vspace{\\baselineskip}
%% \\flushright{\\tiny $label}
\\end{result}
%% end of result

END_OF_TEXT
  }
}

######################################################################

sub begin_role {

  printdebug("begin_role") if $DEBUGGING;

  ####################################################################
  #
  # !! BUG HERE !!
  #
  # Implement XML rendering for roles
  #
  ####################################################################

  $in{'role'}{'region'} = 1;

  #-------------------------------------------------------------------
  # End Other Regions
  #
  #     The beginning of a 'role' region should automatically bring to
  #     an end certain text regions.
  #
  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};

  #-------------------------------------------------------------------
  # Count Things
  #
  $count{'toplevel'} = $scounter{1};
  ++ $count{'role'}{'total'};

  #-------------------------------------------------------------------
  # Skip Roles
  #
  #     If the user does not want to render roles in the document,
  #     return here.
  #
  return if not $option{'role'};

  #-------------------------------------------------------------------
  # Determine the basic meta-data for this role
  #
  my $num      = $count{'role'}{'total'};
  my $label    = $data{'role'}{$num}{'label'} || "role-$num";
  my $secnum   = $current{'secnum'};

  #-------------------------------------------------------------------
  # Render HTML.
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $aref   = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # render html meta data
    #
    push @{ $aref }, html_header_for($label);          # header
#    push @{ $aref }, html_label_for($label);           # label
#    push @{ $aref }, html_types_for($label);           # types
    push @{ $aref }, html_previous_for($label);        # previous
    push @{ $aref }, html_next_for($label);            # next
#    push @{ $aref }, html_priority_for($label);        # priority
#    push @{ $aref }, html_status_for($label);          # status
    push @{ $aref }, html_results_for($label);         # results
    push @{ $aref }, html_reviews_for($label);         # reviews
    push @{ $aref }, html_parents_of($label);          # parents
    push @{ $aref }, html_children_of($label);         # children
    push @{ $aref }, html_assignments_for($label);     # assignments
    push @{ $aref }, html_problems_for($label);        # problems
    push @{ $aref }, html_solutions_for($label);       # solutions
    push @{ $aref }, html_tests_for($label);           # tests
    push @{ $aref }, html_tasks_for($label);           # tasks
    push @{ $aref }, html_associates_of($label);       # associates
    push @{ $aref }, html_attributes_of($label);       # attributes
#    push @{ $aref }, html_revision_for($label);        # revision
#    push @{ $aref }, html_date_for($label);            # date
#    push @{ $aref }, html_author_for($label);          # author
    push @{ $aref }, html_footer_for($label);          # footer

  }

  #-------------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # render latex meta data
    #
    push @latex, latex_header_for($label);        # header
#    push @latex, latex_label_for($label);         # label
#    push @latex, latex_types_for($label);         # types
    push @latex, latex_previous_for($label);      # previous
    push @latex, latex_next_for($label);          # next
#    push @latex, latex_priority_for($label);      # priority
#    push @latex, latex_status_for($label);        # status
#    push @latex, latex_results_for($label);       # results
    push @latex, latex_reviews_for($label);       # reviews
    push @latex, latex_parents_of($label);        # parents
    push @latex, latex_children_of($label);       # children
    push @latex, latex_assignments_for($label);   # assignments
    push @latex, latex_problems_for($label);      # problems
    push @latex, latex_solutions_for($label);     # solutions
    push @latex, latex_tests_for($label);         # tests
    push @latex, latex_tasks_for($label);         # tasks
    push @latex, latex_associates_of($label);     # associates
    push @latex, latex_attributes_of($label);     # attributes
#    push @latex, latex_revision_for($label);      # revision
#    push @latex, latex_date_for($label);          # date
#    push @latex, latex_author_for($label);        # author
    push @latex, latex_footer_for($label);        # footer

  }
}

######################################################################

sub end_role {

  printdebug("end_role") if $DEBUGGING;

  $in{'role'}{'region'} = 0;

  end_pre()               if $in{'pre'};
  end_ulist_context()     if $in{'ulist'};
  end_olist_context()     if $in{'olist'};
  end_dlist()             if $in{'dlist'};
  end_table()             if $in{'table'}{'environment'};
  end_baretable()         if $in{'baretable'} == 1;
  end_image_set_context() if $in{'imageset'};
  end_quote_source()      if $in{'quote'}{'quotesource'};

  #-------------------------------------------------------------------
  # If the user does not want to render roles in the document,
  # return here.
  #
  return if not $option{'role'};

  my $num   = $count{'role'}{'total'};
  my $label = $data{'role'}{$num}{'label'};
  my $type  = $data{'role'}{$num}{'type'};

  #-------------------------------------------------------------------
  # Render HTML.
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    push @{ $aref }, <<"END_OF_TEXT";
</div>
<!-- ===================== END ROLE  ======================= -->

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, <<"END_OF_TEXT";
%% \\end{leftbar}
%% \\cbend
%% \\vspace{\\baselineskip}
%% \\flushright{\\tiny $label}
\\end{role}
%% end of role

END_OF_TEXT
  }
}

######################################################################

sub begin_region {

  my $name = shift;

  printdebug("begin_region($name)") if $DEBUGGING;

  # !!! NOTE: This subroutine should replace all the region specific
  # subroutines that are currently just called from this one.

  #-------------------------------------------------------------------
  # reset some counters
  #
  #     The image/consecutive and step/section counters should return
  #     to zero and the beginning of ANY/EVERY region.
  #
  $count{'image'}{'consecutive'} = 0;
  $count{'step'}{'section'}      = 0;

  if ($name eq 'demo') {
    $in{'demo'}{'region'} = 1;        begin_demo();
  }

  elsif ($name eq 'exercise') {
    $in{'exercise'}{'region'} = 1;    begin_exercise();
  }

  elsif ($name eq 'keypoints') {
    $in{'keypoints'}{'region'} = 1;   begin_keypoints();
  }

  elsif ($name eq 'quotation') {
    $in{'quotation'}{'region'} = 1;   begin_quotation();
  }

  elsif ($name eq 'problem') {
    $in{'problem'}{'region'} = 1;     begin_problem();
  }

  elsif ($name eq 'slide') {
    $in{'slide'}{'region'} = 1;       begin_slide();
  }

  elsif ($name eq 'solution') {
    $in{'solution'}{'region'} = 1;    begin_solution();
  }

  elsif ($name eq 'allocation') {
    $in{'allocation'}{'region'} = 1;  begin_allocation();
  }

  elsif ($name eq 'assignment') {
    $in{'assignment'}{'region'} = 1;  begin_assignment();
  }

  elsif ($name eq 'test') {
    $in{'test'}{'region'} = 1;        begin_test();
  }

  elsif ($name eq 'task') {
    $in{'task'}{'region'} = 1;        begin_task();
  }

  elsif ($name eq 'result') {
    $in{'result'}{'region'} = 1;      begin_result();
  }

  elsif ($name eq 'role') {
    $in{'role'}{'region'} = 1;        begin_role();
  }

}

######################################################################

sub end_region {

  my $name = shift;

  printdebug("end_region($name)") if $DEBUGGING;

  # !!! NOTE: This subroutine should replace all the region specific
  # subroutines that are currently just called from this one.

  if ($name eq 'demo') {
    end_demo();        $in{'demo'}{'region'} = 0;
  }

  elsif ($name eq 'exercise') {
    end_exercise();    $in{'exercise'}{'region'} = 0;
  }

  elsif ($name eq 'keypoints') {
    end_keypoints();   $in{'keypoints'}{'region'} = 0;
  }

  elsif ($name eq 'quotation') {
    end_quotation();   $in{'quotation'}{'region'} = 0;
  }

  elsif ($name eq 'problem') {
    end_problem();     $in{'problem'}{'region'} = 0;
  }

  elsif ($name eq 'slide') {
    end_slide();       $in{'slide'}{'region'} = 0;
  }

  elsif ($name eq 'solution') {
    end_solution();    $in{'solution'}{'region'} = 0;
  }

  elsif ($name eq 'allocation') {
    end_allocation();  $in{'allocation'}{'region'} = 0;
  }

  elsif ($name eq 'assignment') {
    end_assignment();  $in{'assignment'}{'region'} = 0;
  }

  elsif ($name eq 'test') {
    end_test();        $in{'test'}{'region'} = 0;
  }

  elsif ($name eq 'task') {
    end_task();        $in{'task'}{'region'} = 0;
  }

  elsif ($name eq 'result') {
    end_result();      $in{'result'}{'region'} = 0;
  }

  elsif ($name eq 'role') {
    end_role();        $in{'role'}{'region'} = 0;
  }

}

######################################################################

sub begin_environment {

  my $name = shift;

  printdebug("begin_environment($name)") if $DEBUGGING;

  if ($name eq 'figure') {
    begin_figure();
  }

  elsif ($name eq 'attachment') {
    begin_attachment();
  }

  elsif ($name eq 'listing') {
    begin_listing();
  }

  elsif ($name eq 'preformatted') {
    begin_preformatted();
  }

  elsif ($name eq 'sidebar') {
    begin_sidebar();
  }

  elsif ($name eq 'source') {
    begin_source();
  }

  elsif ($name eq 'table') {
    begin_table();
  }

  elsif ($name eq 'revisions') {
    begin_revisions();
  }

  elsif ($name eq 'epigraph') {
    begin_epigraph();
  }

  $current{'label'} = "temp-" . $name . "-label";
  push(@{ $current{'label_stack'} }, $current{'label'});

}

######################################################################

sub end_environment {

  my $name = shift;

  printdebug("end_environment($name)") if $DEBUGGING;

  if ($name eq 'figure') {
    end_figure();
  }

  elsif ($name eq 'attachment') {
    end_attachment();
  }

  elsif ($name eq 'listing') {
    end_listing();
  }

  elsif ($name eq 'preformatted') {
    end_preformatted();
  }

  elsif ($name eq 'sidebar') {
    end_sidebar();
  }

  elsif ($name eq 'source') {
    end_source();
  }

  elsif ($name eq 'table') {
    end_table();
  }

  elsif ($name eq 'revisions') {
    end_revisions();
  }

  elsif ($name eq 'epigraph') {
    end_epigraph();
  }

  pop(@{ $current{'label_stack'} });
  $current{'label'} = (@{ $current{'label_stack'} })[-1];
}

######################################################################

sub begin_demo {

  printdebug("begin_demo") if $DEBUGGING;

  $in{'demo'}{'region'} = 1;

  end_pre()           if $in{'pre'};
  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};

  $count{'toplevel'} = $scounter{1};

  ++$count{'demo'}{'total'};    # number of demos in document

  my $num         = $count{'demo'}{'total'};
  my $label       = $data{'demo'}{$num}{'label'}       || $EMPTY_STRING;
  my $title       = $data{'demo'}{$num}{'title'}       || $EMPTY_STRING;
  my $description = $data{'demo'}{$num}{'description'} || $EMPTY_STRING;

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum      = $current{'secnum'};
    my $title       = escape_html($title);
    my $description = escape_html($description);
    my $outfile     = html_outfile_for_secnum($secnum);
    my $anchor      = "demo.$num";
    my $aref        = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # label anchor
    #
    if ($label) {
      push @{ $aref }, <<"END_OF_TEXT";
<a name="$label">

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # Begin demo
    #
    push @{ $aref }, <<"END_OF_TEXT";
<!-- ============== BEGIN DEMO ================= -->
<a name="$anchor">
<div class="demo">
<table style="margin-top:0pt; margin-bottom:10pt" border="0" cellpadding="0" cellspacing="0" width="95%">
<tr>

END_OF_TEXT

    my $previous = $num - 1;
    my $next     = $num + 1;

    #-----------------------------------------------------------------
    # Previous demo link (may be blank)
    #
    if ($previous == 0) {
      push @{ $aref }, <<"END_OF_TEXT";
<td align="left" width="20%">&nbsp;</td>

END_OF_TEXT
    } else {
      push @{ $aref }, <<"END_OF_TEXT";
<td align="left" width="20%"><a href="#demo.$previous">&lt; previous demo</a></td>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # Link to the list of demos.
    #
    push @{ $aref }, <<"END_OF_TEXT";
<td align="center" width="60%"><a href="$html_demo_index_file">list of demonstations</a></td>

END_OF_TEXT

    #-----------------------------------------------------------------
    # Next demo link (may be blank)
    #
    if ($next >= $count{'demo'}{'last'}) {
      push @{ $aref }, <<"END_OF_TEXT";
<td align="right" width="20%">&nbsp;</td>

END_OF_TEXT
    } else {
      push @{ $aref }, <<"END_OF_TEXT";
<td align="right" width="20%"><a href="#demo.$next">next demo &gt;</a></td>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # End the demo navigation link table.
    #
    push @{ $aref }, <<"END_OF_TEXT";
</tr>
</table>

END_OF_TEXT

    #-----------------------------------------------------------------
    # Add heading to index if necessary
    #
    if (not $heading_in_demo_index) {
      $heading_in_demo_index = 1;
      my $heading = escape_html($current{'top_heading'});
      push @{ $html{'demo'}{'index'} }, <<"END_OF_TEXT";
<h3>$heading</h3>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # Add to index
    #
    push @{ $html{'demo'}{'index'} }, <<"END_OF_TEXT";
<span class="indent">$num &nbsp;&nbsp; <a href="$outfile#$anchor">$title</a></span>
<br/>

END_OF_TEXT

    #-----------------------------------------------------------------
    # Put the title of the demo at the top of the demo content in the
    # main document.
    #
    push @{ $aref }, "<b>Demo $num - $title</b><br>\n";

  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # XML: Retrieve the title captured in pass 2, and escape anything
    # with special meaning to XML.
    #
    my $title = escape_xml($data{'demo'}{$num}{'title'});

    #-----------------------------------------------------------------
    # XML: Begin the demo element and insert the title
    #
    if ($label) {
      push @xml, <<"END_OF_TEXT";
<demo id="$label">

END_OF_TEXT
     }

    else {
      push @xml, <<"END_OF_TEXT";
<demo>

END_OF_TEXT
    }
    push @xml, <<"END_OF_TEXT";
<title>$title</title>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # PDF: Retrieve the title captured in pass 2, and escape anything
    # with special meaning to LaTeX.
    #
    my $title = escape_latex($title);

    #-----------------------------------------------------------------
    # PDF: Insert the beginning of the demo (including the title) into
    # the LaTeX content.
    #
    push @latex, <<"END_OF_TEXT";
%% begin demo
%%
\\begin{demonstration}{$title}

END_OF_TEXT

    #-----------------------------------------------------------------
    # PDF: Insert an label.
    #
    if ($label) {
      push @latex, <<"END_OF_TEXT";
\\label{$label}

END_OF_TEXT
    }

  }
}

######################################################################

sub end_demo {

  printdebug("end_demo") if $DEBUGGING;

  $in{'demo'}{'region'} = 0;

  end_pre()               if $in{'pre'};
  end_ulist_context()     if $in{'ulist'};
  end_olist_context()     if $in{'olist'};
  end_dlist()             if $in{'dlist'};
  end_table()             if $in{'table'}{'environment'};
  end_baretable()         if $in{'baretable'} == 1;
  end_image_set_context() if $in{'imageset'};

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    push @{ $aref }, <<"END_OF_TEXT";
<p class="num">Demo $count{'demo'}{'total'}</p>
</div><!-- ====================== END DEMO  ====================== -->

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, <<"END_OF_TEXT";
</demo>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    push @latex, <<"END_OF_TEXT";
\\end{demonstration}
%%
%% end demonstration

END_OF_TEXT
  }
}

######################################################################

sub begin_note {

  printdebug("begin_note") if $DEBUGGING;

  $in{'note'}{'region'} = 1;

}

######################################################################

sub end_note {

  printdebug("end_note") if $DEBUGGING;

  $in{'note'}{'region'} = 0;

}

######################################################################

sub begin_listing {

  printdebug("begin_listing") if $DEBUGGING;

  $in{'listing'}{'environment'} = 1;

  ++$count{'listing'}{'section'}; # number of listings in toplevel section
  ++$count{'listing'}{'total'}; # number of listings in document

  end_pre()               if $in{'pre'};
  end_baretable()         if $in{'baretable'} == 1;
  end_ulist_context()     if $in{'ulist'};
  end_olist_context()     if $in{'olist'};
  end_dlist()             if $in{'dlist'};

  $count{'toplevel'} = $scounter{1};

  my $num   = $count{'listing'}{'total'};
  my $label = $data{'listing'}{$num}{'label'} || $EMPTY_STRING;

  $label = trim_whitespace($label);

  #-------------------------------------------------------------------
  # Blank Lines
  #
  #     Skip blank lines at the beginning of a listing.  To do this,
  #     we'll set a variable to track whether we've seen the first
  #     non-blank line of the listing.
  #
  $seen{'first_nonblank_line'} = 0;

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum     = $current{'secnum'};
    my $outfile    = html_outfile_for_secnum($secnum);
    my $anchor     = "listing.$num";
    my $html_title = escape_html($data{'listing'}{$num}{'title'});
    my $previous   = $num - 1;
    my $next       = $num + 1;
    my $lis_num    = '';
    my $aref       = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # Determine list number
    #
    if ( $secnum ) {
      $lis_num = "$count{'toplevel'}-$count{'listing'}{'section'}";
    } else {
      $lis_num = "$count{'listing'}{'section'}";
    }

    #-----------------------------------------------------------------
    # Begin listing
    #
    push @{ $aref }, <<"END_OF_TEXT";
<!-- =========== BEGIN LISTING  ============= -->
<a name="$anchor">
<div class="listing">
<table style="margin-top:0pt; margin-bottom:10pt" border="0" cellpadding="0" cellspacing="0" width="95%">

END_OF_TEXT

    #-----------------------------------------------------------------
    # Link to previous listing (may be blank)
    #
    if ($previous == 0) {
      push @{ $aref }, <<"END_OF_TEXT";
<td align="left" width="20%">&nbsp;</td>

END_OF_TEXT
    } else {
      my $label = $data{'listing'}{$previous}{'label'};

      $label = trim_whitespace($label);

      my $file  = html_outfile_for_label($label);
      push @{ $aref }, <<"END_OF_TEXT";
<td align="left" width="20%"><a href="$file#listing.$previous">&lt; previous listing</a></td>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # Link to the list of listings.
    #
    push @{ $aref }, <<"END_OF_TEXT";
<td align="center" width="60%"><a href="$html_listing_index_file">list of listings</a></td>

END_OF_TEXT

    #-----------------------------------------------------------------
    # Link to next listing (may be blank)
    #
    if ($next >= $count{'listing'}{'last'}) {
      push @{ $aref }, <<"END_OF_TEXT";
<td align="right" width="20%">&nbsp;</td>

END_OF_TEXT
    } else {
      my $label = $data{'listing'}{$next}{'label'};

      $label = trim_whitespace($label);

      my $file  = html_outfile_for_label($label);
      push @{ $aref }, <<"END_OF_TEXT";
<td align="right" width="20%"><a href="$file#listing.$next">next listing &gt;</a></td>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # End the listing navigation link table
    #
    push @{ $aref }, <<"END_OF_TEXT";
</tr>
</table>

END_OF_TEXT

    #-----------------------------------------------------------------
    # Add heading to index if necessary
    #
    if (not $heading_in_listing_index) {
      $heading_in_listing_index = 1;
      my $heading = escape_html($current{'top_heading'});
      push @{ $html{'listing'}{'index'} }, <<"END_OF_TEXT";
<h3>$heading</h3>

END_OF_TEXT
    }

    #---------------------------------------------------------------
    # Add to index
    #
    push @{ $html{'listing'}{'index'} }, <<"END_OF_TEXT";
<span class="indent">$lis_num &nbsp;&nbsp; <a href="$outfile#$anchor">$html_title</a></span><br>

END_OF_TEXT

    #---------------------------------------------------------------
    # Insert the title of this listing in the main HTML document.
    #
    push @{ $aref }, <<"END_OF_TEXT";
<b>Listing $lis_num - $html_title</b>
<br>
<pre>

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # XML: Retrieve the title captured in pass 2, and escape anything
    # with special meaning to XML.
    #
    my $xml_title = escape_xml($data{'listing'}{$num}{'title'});

    #-----------------------------------------------------------------
    # XML: Start the listing element and insert the title
    #
    if ($label) {
      push @xml, <<"END_OF_TEXT";
<listing id="$label">

END_OF_TEXT
    }

    else {
      push @xml, <<"END_OF_TEXT";
<listing>

END_OF_TEXT
    }
    push @xml, <<"END_OF_TEXT";
<title>$xml_title</title>

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    my $latex_title = escape_latex($data{'listing'}{$num}{'title'});

    my $numbers          = $data{'listing'}{$num}{'numbers'}          || $EMPTY_STRING;
    my $language         = $data{'listing'}{$num}{'language'}         || $EMPTY_STRING;
    my $fontsize         = $data{'listing'}{$num}{'fontsize'}         || $EMPTY_STRING;
    my $showspaces       = $data{'listing'}{$num}{'showspaces'}       || $EMPTY_STRING;
    my $showtabs         = $data{'listing'}{$num}{'showtabs'}         || $EMPTY_STRING;
    my $showstringspaces = $data{'listing'}{$num}{'showstringspaces'} || $EMPTY_STRING;
    my $orientation      = $data{'listing'}{$num}{'orientation'}      || 'portrait';

    #-----------------------------------------------------------------
    # PDF: Begin landscape if orientation is landscape
    #
    if ( $orientation eq 'landscape' ) {
      push @latex, <<"END_OF_TEXT";
\\begin{landscape}

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # If special directives were sepcified for this listing (nubers,
    # language, fontsize, showspaces, showtabs, or
    # showstringspaces)...
    #
    if (   $numbers
        or $language
        or $fontsize
        or $showspaces
        or $showtabs
        or $showstringspaces) {
      push @latex, <<"END_OF_TEXT";
%% begin listing
%%
\\begin{listing}{$latex_title}

\\label{$label}

END_OF_TEXT
      #--------------------
      # line numbering
      #
      if ($numbers) {
        push @latex, <<"END_OF_TEXT";
\\lstset{numbers=$numbers}

END_OF_TEXT
      }

      #--------------------
      # language highlighting
      #
      if ($language) {
        push @latex, <<"END_OF_TEXT";
\\lstset{language=$language}

END_OF_TEXT
      }

      #--------------------
      # basic font size
      #
      if ($fontsize) {
        push @latex, <<"END_OF_TEXT";
\\lstset{basicstyle=\\$fontsize}

END_OF_TEXT
      }

      else {
        push @latex, <<"END_OF_TEXT";
\\lstset{basicstyle=\\small}

END_OF_TEXT
      }

      #--------------------
      # indicate spaces
      #
      if ($showspaces) {
        push @latex, <<"END_OF_TEXT";
\\lstset{showspaces=\\$showspaces}

END_OF_TEXT
      }

      else {
        push @latex, <<"END_OF_TEXT";
\\lstset{showspaces=\\false}

END_OF_TEXT
      }

      #--------------------
      # indicate stringspaces
      #
      if ($showstringspaces) {
        push @latex, <<"END_OF_TEXT";
\\lstset{showstringspaces=\\$showstringspaces}

END_OF_TEXT
      }

      else {
        push @latex, <<"END_OF_TEXT";
\\lstset{showstringspaces=\\false}

END_OF_TEXT
      }

      #--------------------
      # indicate tabs
      #
      if ($showtabs) {
        push @latex, <<"END_OF_TEXT";
\\lstset{showtabs=\\$showtabs}

END_OF_TEXT
      }

      else {
        push @latex, <<"END_OF_TEXT";
\\lstset{showtabs=\\false}

END_OF_TEXT
      }

      push @latex, <<"END_OF_TEXT";
\\begin{lstlisting}
END_OF_TEXT
    }

    else {
      push @latex, <<"END_OF_TEXT";
%% begin listing
%%
\\begin{listing}{$latex_title}
\\label{$label}
\\small
\\begin{verbatim}
END_OF_TEXT
    }
  }
}

######################################################################

sub end_listing {

  printdebug("end_listing") if $DEBUGGING;

  $in{'listing'}{'environment'} = 0;

  my $num = $count{'listing'}{'total'};

  #-------------------------------------------------------------------
  # Insert file
  #
  #     If the listing contained a 'file:' data element, insert the
  #     file here.
  #
  if (defined $data{'listing'}{$num}{'file'}) {
    my $file = $data{'listing'}{$num}{'file'};
    process_file($file);
  }

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    push @{ $aref }, <<"END_OF_TEXT";
</pre>
<p class="num">Listing $count{'listing'}{'total'}</p>
</div><!-- ===================== END LISTING ===================== -->

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, <<"END_OF_TEXT";
</listing>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    my $numbers          = $data{'listing'}{$num}{'numbers'}          || $EMPTY_STRING;
    my $language         = $data{'listing'}{$num}{'language'}         || $EMPTY_STRING;
    my $fontsize         = $data{'listing'}{$num}{'fontsize'}         || $EMPTY_STRING;
    my $showspaces       = $data{'listing'}{$num}{'showspaces'}       || $EMPTY_STRING;
    my $showtabs         = $data{'listing'}{$num}{'showtabs'}         || $EMPTY_STRING;
    my $showstringspaces = $data{'listing'}{$num}{'showstringspaces'} || $EMPTY_STRING;
    my $orientation      = $data{'listing'}{$num}{'orientation'}      || 'portrait';

    if ($numbers
        or $language
        or $fontsize
        or $showspaces
        or $showtabs
        or $showstringspaces) {

      push @latex, <<"END_OF_TEXT";
\\end{lstlisting}
\\lstset{numbers=none,language=Clean,basicstyle=\\small,showspaces=false,showtabs=false}
\\end{listing}
%%
%% end listing

END_OF_TEXT
    }

    else {

      push @latex, <<"END_OF_TEXT";
\\end{verbatim}
\\normalsize
\\end{listing}
%%
%% end listing

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # PDF: End landscape if orientation is landscape
    #
    if ( $orientation eq 'landscape' ) {
      push @latex, <<"END_OF_TEXT";
\\end{landscape}

END_OF_TEXT
    }

  }
}

######################################################################

sub begin_exercise {

  printdebug("begin_exercise") if $DEBUGGING;

  $in{'exercise'}{'region'} = 1;

  end_pre()           if $in{'pre'};
  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};

  $count{'toplevel'} = $scounter{1};
  ++$count{'exercise'}{'section'}; # number of exercises in toplevel section
  ++$count{'exercise'}{'total'}; # number of exercises in document

  my $num   = $count{'exercise'}{'total'};
  my $label = $data{'exercise'}{$num}{'label'} || $EMPTY_STRING;

  $label = trim_whitespace($label);

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum     = $current{'secnum'};
    my $outfile    = html_outfile_for_secnum($secnum);
    my $anchor     = "exercise.$num";
    my $html_title = escape_html($data{'exercise'}{$num}{'title'});
    my $previous   = $num - 1;
    my $next       = $num + 1;
    my $exe_num    = "$count{'toplevel'}-$count{'exercise'}{'section'}";
    my $aref       = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # HTML: Insert an anchor for this exercise, and a table with
    # navigation links to the previous and next exercises.
    #
    push @{ $aref }, <<"END_OF_TEXT";
<!-- =========== BEGIN EXERCISE  ============= -->
<a name="$anchor">
<div class="exercise">
<table style="margin-top:0pt; margin-bottom:10pt" border="0" cellpadding="0" cellspacing="0" width="95%">
<tr>

END_OF_TEXT

    #-----------------------------------------------------------------
    # Link to previous exercise (may be blank)
    #
    if ($previous == 0) {
      push @{ $aref }, <<"END_OF_TEXT";
<td align="left" width="20%">&nbsp;</td>

END_OF_TEXT
    } else {
      push @{ $aref }, <<"END_OF_TEXT";
<td align="left" width="20%"><a href="#exercise.$previous">&lt; previous exercise</a></td>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # Link to the list of exercises
    #
    push @{ $aref }, <<"END_OF_TEXT";
<td align="center" width="60%"><a href="$html_exercise_index_file">list of exercises</a></td>

END_OF_TEXT

    #-----------------------------------------------------------------
    # Link to next exercise (may be blank)
    #
    if ($next >= $count{'exercise'}{'last'}) {
      push @{ $aref }, <<"END_OF_TEXT";
<td align="right" width="20%">&nbsp;</td>

END_OF_TEXT
    } else {
      push @{ $aref }, <<"END_OF_TEXT";
<td align="right" width="20%"><a href="#exercise.$next">next exercise &gt;</a></td>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # End the exercise navigation link table
    #
    push @{ $aref }, <<"END_OF_TEXT";
</tr>
</table>

END_OF_TEXT

    #-----------------------------------------------------------------
    # Insert heading in index if necessary
    #
    if (not $heading_in_exercise_index) {
      $heading_in_exercise_index = 1;
      my $heading = escape_html($current{'top_heading'});
      push @{ $html{'exercise'}{'index'} }, <<"END_OF_TEXT";
<h3>$heading</h3>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # Add to index
    #
    push @{ $html{'exercise'}{'index'} }, <<"END_OF_TEXT";
<span class="indent">$exe_num &nbsp;&nbsp; <a href="$outfile#$anchor">$html_title</a></span><br>

END_OF_TEXT

    #-----------------------------------------------------------------
    # Put the title of the exercise at the top of the exercise content
    # in the main document.
    #
    push @{ $aref }, "<b>Exercise $exe_num - $html_title</b><br>\n";

  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # XML: Retrieve the title captured in pass 2, and escape anything
    # with special meaning to XML.
    #
    my $xml_title = escape_xml($data{'exercise'}{$num}{'title'});

    #-----------------------------------------------------------------
    # XML: begin the exercise element and insert the title.
    #
    if ($label) {
      push @xml, <<"END_OF_TEXT";
<exercise id="$label">

END_OF_TEXT
    }

    else {
      push @xml, <<"END_OF_TEXT";
<exercise>

END_OF_TEXT
    }
    push @xml, <<"END_OF_TEXT";
<title>$xml_title</title>

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # PDF: Retrieve the title captured in pass 2, and escape anything
    # with special meaning to LaTeX.
    #
    my $title = escape_latex($data{'exercise'}{$num}{'title'});

    #-----------------------------------------------------------------
    # PDF: Insert the beginning of the exercise (including the title)
    # into the LaTeX content.
    #
    push @latex, <<"END_OF_TEXT";
%% begin exercise
%%
\\begin{exercise}{$title}

END_OF_TEXT
  }
}

######################################################################

sub end_exercise {

  printdebug("end_exercise") if $DEBUGGING;

  end_pre()           if $in{'pre'};
  end_para()          if $in{'para'};
  end_footnote()      if $in{'footnote'};
  end_table()         if $in{'table'}{'environment'};
  end_baretable()     if $in{'baretable'} == 1;
  end_ulist_context() if $in{'ulist'};
  end_olist_context() if $in{'olist'};
  end_dlist()         if $in{'dlist'};

  $in{'exercise'}{'region'} = 0;

  $count{'toplevel'} = $scounter{1};

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    push @{ $aref }, <<"END_OF_TEXT";
<p class="num">Exercise $count{'toplevel'}.$count{'exercise'}{'section'}</p>
</div><!-- ===================== END EXERCISE ===================== -->

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, <<"END_OF_TEXT";
</exercise>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, <<"END_OF_TEXT";
\\end{exercise}
%%
%% end exercise

END_OF_TEXT
  }
}

######################################################################

sub begin_keypoints {

  printdebug("begin_keypoints") if $DEBUGGING;

  my $region = 'keypoints';

  $in{$region}{'region'} = 1;
  ++ $count{$region}{'total'};

  my $num   = $count{$region}{'total'};
  my $label = $data{'keypoints'}{$num}{'label'} || $EMPTY_STRING;

  $label = trim_whitespace($label);

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    #-----------------------------------------------------------------
    # HTML: Retrieve the title captured in pass 2, and escape anything
    # with special meaning to HTML.
    #
    my $html_title = escape_html($data{$region}{$num}{'title'});

    #-----------------------------------------------------------------
    # HTML: Insert an anchor for this keypoints summary, and a table
    # with navigation links to the previous and next keypoints
    # summaries.
    #
    push @{ $aref }, <<"END_OF_TEXT";
<a name="keypoints.$num">
<div class="keypoints"><!-- =========== KEYPOINTS  ============= -->
<table style="margin-top:0pt; margin-bottom:10pt" border="0" cellpadding="0" cellspacing="0" width="95%">
<tr>

END_OF_TEXT

    my $previous = $num - 1;
    my $next     = $num + 1;

    #-----------------------------------------------------------------
    # HTML: If there was no previous keypoints summary, the spot where
    # the link to the previous keypoints summary would normally go
    # should be blank.
    #
    if ($previous == 0) {
      push @{ $aref }, <<"END_OF_TEXT";
<td align="left" width="20%">&nbsp;</td>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # HTML: ...Otherwise, include a hyperlink to the previous
    # keypoints summary.
    #
    else {
      push @{ $aref }, <<"END_OF_TEXT";
<td align="left" width="20%"><a href="#keypoints.$previous">&lt; previous key points</a></td>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # HTML: Insert a link to the list of keypoints summaries.
    #
    push @{ $aref }, <<"END_OF_TEXT";
<td align="center" width="60%">&nbsp;</td>

END_OF_TEXT

    #-----------------------------------------------------------------
    # HTML: If this is the last keypoints summary, the spot where the
    # link to the next keypoints summary whould normally go should be
    # blank.
    #
    if ($next >= $count{'keypoints'}{'last'}) {
      push @{ $aref }, <<"END_OF_TEXT";
<td align="right" width="20%">&nbsp;</td>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # HTML: ...Otherwise, include a hyperlink to the next keypoints
    # summary.
    #
    else {
      push @{ $aref }, <<"END_OF_TEXT";
<td align="right" width="20%"><a href="#keypoints.$next">next key points &gt;</a></td>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # HTML: End the keypoints summary navigation link table.
    #
    push @{ $aref }, <<"END_OF_TEXT";
</tr>
</table>

END_OF_TEXT

    #-----------------------------------------------------------------
    # HTML: Put the title of this keypoints summary at the top of the
    # keypoints summary content in the main document.
    #
    push @{ $aref }, "<b>$html_title</b><br>\n";
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # XML: Retrieve the title captured in pass 2, and escape anything
    # with special meaning to XML.
    #
    my $num = $count{$region}{'total'};
    my $xml_title = escape_xml($data{$region}{$num}{'title'});

    #-----------------------------------------------------------------
    # XML: begin the keypoints element and insert the title
    #
    if ($label) {
      push @xml, <<"END_OF_TEXT";
<keypoints id="$label">

END_OF_TEXT
    }

    else {
      push @xml, <<"END_OF_TEXT";
<keypoints>

END_OF_TEXT
    }
    push @xml, <<"END_OF_TEXT";
<title>$xml_title</title>

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {

    #-----------------------------------------------------------------
    # PDF: Retrieve the title captured in pass 2, and escape anything
    # with special meaning to LaTeX.
    #
    my $num = $count{$region}{'total'};
    my $latex_title = escape_latex($data{$region}{$num}{'title'});

    #-----------------------------------------------------------------
    # PDF: Insert the beginning of the keypoints summary (including
    # the title) into the LaTeX content.
    #
    push @latex, <<"END_OF_TEXT";
%%-----------------------------------
%% keypoints
%%
\\begin{center}
\\shadowbox{%
\\begin{minipage}{5in}
\\small
\\textbf{$latex_title}
\\medskip

END_OF_TEXT
  }
}

######################################################################

sub end_keypoints {

  printdebug("end_keypoints") if $DEBUGGING;

  $in{'keypoints'}{'region'} = 0;

  end_pre()               if $in{'pre'};
  end_ulist_context()     if $in{'ulist'};
  end_olist_context()     if $in{'olist'};
  end_dlist()             if $in{'dlist'};
  end_table()             if $in{'table'}{'environment'};
  end_baretable()         if $in{'baretable'} == 1;
  end_image_set_context() if $in{'imageset'};

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    push @{ $aref }, <<"END_OF_TEXT";
</div><!-- ===================== END KEYPOINTS ===================== -->

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, <<"END_OF_TEXT";
</keypoints>

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, <<"END_OF_TEXT";
\\normalsize
\\end{minipage}
}
\\end{center}

END_OF_TEXT
  }
}

######################################################################

sub begin_comment {

  printdebug("begin_comment") if $DEBUGGING;

  $in{'comment'}{'block'} = 1;

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    push @{ $aref }, <<"END_OF_TEXT";
<!-- =========== BEGIN COMMENT  ============= -->

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, <<"END_OF_TEXT";
<!-- 

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, <<"END_OF_TEXT";
%% begin comment
%%

END_OF_TEXT
  }

}

######################################################################

sub end_comment {

  printdebug("end_comment") if $DEBUGGING;

  $in{'comment'}{'block'} = 0;

  #-------------------------------------------------------------------
  # HTML
  #
  if ($rendering{'html'} and not $in{'hide'}{'block'}) {

    my $secnum = $current{'secnum'};
    my $aref   = $html{'body'}{$secnum};

    push @{ $aref }, <<"END_OF_TEXT";
<!-- =========== END COMMENT  ============= -->

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # XML
  #
  if ($rendering{'xml'} and not $in{'hide'}{'block'}) {
    push @xml, <<"END_OF_TEXT";
-->

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # PDF
  #
  if ($rendering{'pdf'} and not $in{'hide'}{'block'}) {
    push @latex, <<"END_OF_TEXT";
%%
%% end comment

END_OF_TEXT
  }

}

######################################################################

sub begin_source {

  printdebug("begin_source") if $DEBUGGING;

  $in{'source'}{'environment'} = 1;
  ++$count{'source'}{'section'}; # number of sidebars in section
  ++$count{'source'}{'total'};   # number of sidebars in document
}

######################################################################

sub end_source {

  printdebug("end_source") if $DEBUGGING;

  # check the validity of the source
  #
  check_source();

  $in{'source'}{'environment'} = 0;

}

######################################################################

sub check_source {

  printdebug("check_source") if $DEBUGGING;

  # Check a bibliographic source to ensure the author provided all
  # necessary data elements and that a correct 'source' value was
  # specified.
  #
  # All of the bibliographic data for this source is in the %data
  # hash.
  #
  # The %structure hash defines the data elements that can go into a
  # source environment.
  #
  # The %bibstructure hash defines the 14 acceptable source types and
  # which data elements are required and which are optional for each
  # source type.

  #-------------------------------------------------------------------
  # !!! Bug Here !!!
  #
  #     When publishing a large document that contains bibliographic
  #     source errors (and using the gui), the FIRST publishing run
  #     shows the errors but second and subsequent ones do not.
  #
  #     Perhaps some data structure is not getting re-initialized
  #     between runs?
  #
  #-------------------------------------------------------------------

  #-------------------------------------------------------------------
  # !!! Bug Here !!!
  #
  #     When a document has two consecutive source environments and
  #     both have unacceptable source types, only the first one
  #     produces an error.
  #
  #-------------------------------------------------------------------

  #-------------------------------------------------------------------
  # What is the current source?
  #
  my $num = $count{'source'}{'total'};

  #-------------------------------------------------------------------
  # Check #1 - Was a source type specified?
  #
  if ( not exists $data{'source'}{$num}{'source'} ) {
    printerror("no \"source\" type specified");
    return();
  }

  #-------------------------------------------------------------------
  # Check #2 - is the source type one of the acceptable ones?
  #
  my $acceptable  = 0;
  my $source_type = $data{'source'}{$num}{'source'};
  my @acceptable_types = keys %bibstructure;

  foreach my $acceptable_type (@acceptable_types) {
    if ($source_type eq $acceptable_type) {
      $acceptable = 1;
    }
  }

  if (not $acceptable) {
    printerror("\"$source_type\" is not an acceptable source type");
  }

  #-------------------------------------------------------------------
  # Check #3 - were all required data elements provided?
  #
  my $provided = 1;
  my @provided_elements = keys %{ $data{'source'}{$num} };
  my @required_elements = @{ $bibstructure{$source_type}{'required'} };

  foreach my $required_element (@required_elements) {

    my $element_was_provided = 0;

    # The value of $required_element could be a string or a reference
    # to a hash.

    # If this "required element" is a REFERENCE TO A HASH, it means
    # you have a choice of providing one or more of the elements
    # specified in the hash.  For example, for a "book" you must
    # specify one or more authors and/or editors.  If you don't have
    # either, this is an error.
    #
    if (ref $required_element) {
      my $option_provided = 0;
      my @options = @{ $required_element };
      foreach my $optional_element (@options) {
	foreach my $provided_element (@provided_elements) {
	  if ($provided_element eq $optional_element) {
	    $option_provided      = 1;
	    $element_was_provided = 1;
	  }
	}
      }

      if (not $option_provided) {
	my $options = join(', ', @options);
	printerror("\"$source_type\" sources require at least one of: $options");
      }
    }

    # If this "required element" is a STRING, it simply identifies the
    # name of a required data element.
    #
    else {
      foreach my $provided_element (@provided_elements) {
	if ($provided_element eq $required_element) {
	  $element_was_provided = 1;
	}
      }

      if (not $element_was_provided) {
	printerror("\"$source_type\" sources require a $required_element element");
      }
    }
  }

  #-------------------------------------------------------------------
  # Check #4 - were any disallowed options provided?
  #
  #     !!! Bug Here !!!
  #
  #     Implement check #4.

}

######################################################################

sub escape_html {

  my $text = shift;

  # printdebug("escape_html: $text") if $DEBUGGING;

  # !!! BUG HERE !!!
  #
  # This subroutine only works for single line text strings.  You'll
  # likely send the program into an infinite loop if you send it a
  # multi-line string (e.g. any string containing newlines) with
  # markup that must be escaped.  The culprit is the way inline markup
  # like bold, italics, and tt are escaped using a while loop that
  # never returns false.  Here is a test fix:

  $text = remove_newlines($text);

  #-------------------------------------------------------------------
  # Literal strings (part 1)
  #
  #     Look for strings to be literally interpretted like
  #     [lit:__init__.py] which will be literally interpretted rather
  #     than underlining the word `init'.
  #
  #     This is a two part process.  In this first part, we'll
  #     substitute the literal string with a place-holder
  #     (LITERAL-STRING-1, LITERAL-STRING-2, etc).  In the second part
  #     at the end of this function, we'll replace these placeholders
  #     with the actual literal text.
  #
  #     LIMITATION: literal strings cannot cross line boundaries
  #
  my $literals  = 0;  # detect presence of literal strings
  my @literal   = (); # array of literal strings
  my $lsc       = 0;  # literal string count
  while ($text =~ /\{lit:(.*?)\}/) {
    my $string = $1;
    $literals  = 1;   # found a literal string
    $literal[$lsc] = $string;
    $text =~ s/\{lit:(.*?)\}/LITERAL-STRING-$lsc/;
    ++ $lsc;
  }

  #-------------------------------------------------------------------
  # <html>
  #
  #     Look for things that look like HTML tags.  Replace MDO (<) and
  #     MDC (>) with entities.
  #
  $text =~ s/<(\S+?)>/\&lt\;$1\&gt\;/g;

  #-------------------------------------------------------------------
  # double quotes
  #
  $text =~ s/``/"/g;
  $text =~ s/''/"/g;

  #-------------------------------------------------------------------
  # copyright, registered, and trademark symbols
  #
  $text =~ s/\[c\]/\&copy\;/ig;
  $text =~ s/\[r\]/<sup><span style=\"font-size: 8pt;\">\&reg\;<\/span><\/sup>/ig;
  $text =~ s/\[tm\]/<sup><span style=\"font-size: 8pt;\">TM<\/span><\/sup>/ig;

  #-------------------------------------------------------------------
  # Take Note! Indicators
  #
  #     If the author of the document put "[[take_note]]" in the text,
  #     then put a writing hand in the margin.
  #
  $text =~ s/\[\[take_note\]\]/<b>(take note!)<\/b>/g;

  #-------------------------------------------------------------------
  # Section Signs
  #
  #     If the author of the document put "[[section]]" in the text,
  #     then replace it with a section sign (&#167;, &sect;).
  #
  $text =~ s/\[\[section\]\]/&sect;/g;

  #-------------------------------------------------------------------
  # keystroke indicators
  #
  # The keystroke indicator is all on one line...
  #
  $text =~ s/\[\[(.*?)\]\]/<span class=\"keystroke\">$1<\/span>/g;

  # The keystroke indicator begins on one line...
  #
  if ($text =~ /\[\[(.*)$/) {
    $text =~ s/\[\[(.*?)$/<span class=\"keystroke\">$1/;
    $in{'keystroke'} = 1;
  }

  # ...And ends on another...
  #
  if ($text =~ /^(.*?)\]\]/ and $in{'keystroke'}) {
    $text =~ s/^(.*?)\]\]/$1<\/span>/;
    $in{'keystroke'} = 0;
  }

  #-------------------------------------------------------------------
  # Glossary Terms (g and gls)
  #
  #     This block of code looks for glossary terms that occur all on
  #     one line:
  #
  #     [g:Perl]
  #     [g:ieee:Perl]
  #     [gls:Perl]
  #
  while ( $text =~ /\[(g|gls):(([^ \t\n\r\f\]]*?):)?\s*(.*?)\s*\]/ ) {

    my $alt  = $3 || '';
    my $term = $4;

    # replace '\&' with '&' in term
    $term =~ s/\\&/&/g;

    if ( term_in_glossary($term,$alt) ) {
      my $target_term = lc($term);
      $target_term =~ s/\s+/_/g;
      my $target  = "$html_glossary_file#$target_term:$alt";
      my $link    = "<a href=\"$target\">$term</a>";
      $text =~ s/\[(g|gls):.*?\]/$link/;
    }

    else {
      $text =~ s/\[(g|gls):.*?\]/$term/;
      printwarning("escape_html: no glossary entry for \"$alt:$term\"");
      printwarning("  line: $text");
    }
  }

  #-------------------------------------------------------------------
  # Glossary: Split Terms (g and gls)
  #
  #     Handle instances when glossary terms begin at the end of one
  #     line, then end at the beginning of the next line (i.e. the
  #     term is split across a newline boundary).
  #
  #     This first block of code looks for the end of a term, started
  #     on the previous line, at the beginning of this line.
  #
  if ( $in{'glossary_term'} and $text =~ /^\s*(.*?)\s*\]/ ) {

    my $remainder      = $1;
    my ($partial,$alt) = @{ $current{'glossary_partial_term'} };
    my $term           = "$partial $remainder";

    # replace '\&' with '&'
    $term =~ s/\\&/&/g;

    if ( term_in_glossary($term,$alt) ) {
      $text =~ s/^(.*?)\]/<i>$term<\/i>/;
    }

    else {
      printwarning("escape_html: no glossary entry for \"$alt:$term\"");
      $text =~ s/^(.*?)\]/<i>$term<\/i>/;
    }

    $in{'glossary_term'} = 0;

  }

  #-------------------------------------------------------------------
  # Glossary: Split Terms (g and gls)
  #
  #     This block of code looks for the beginning of a split term at
  #     the end of this line.
  #
  if ( $text =~ /\[(g|gls):(([^ \t\n\r\f\]]*?):)?\s*(.*?)\s*$/ ) {

    my $alt     = $3 || '';
    my $partial = $4;

    $current{'glossary_partial_term'} = [$partial,$alt];

    $in{'glossary_term'} = 1;

    $text =~ s/\[(g|gls):.*?$//;

  }

  #-------------------------------------------------------------------
  # Glossary Terms (G and Gls)
  #
  #     This block of code looks for glossary terms that occur all on
  #     one line:
  #
  #     [G:Perl]
  #     [Gls:Perl]
  #
  while ( $text =~ /\[(G|Gls):(([^ \t\n\r\f\]]*?):)?\s*(.*?)\s*\]/ ) {

    my $alt  = $3 || '';
    my $term = $4;

    # replace '\&' with '&'
    $term =~ s/\\&/&/g;

    if ( term_in_glossary($term,$alt) ) {
      my $ucf_term = ucfirst($term);
      my $target_term = lc($term);
      $target_term =~ s/\s+/_/g;
      my $target = "$html_glossary_file#$target_term:$alt";
      my $link   = "<a href=\"$target\">$ucf_term</a>";
      $text =~ s/\[(G|Gls):(.*?)\]/$link/;
    }

    else {
      printwarning("escape_html: no glossary entry for \"$alt:$term\"");
      $ucf_term = ucfirst($term);
      $text =~ s/\[(G|Gls):(.*?)\]/$ucf_term/;
    }
  }

  #-------------------------------------------------------------------
  # Glossary: Split Terms (G and Gls)
  #
  #     Handle instances when glossary terms begin at the end of one
  #     line, then end at the beginning of the next line (i.e. the
  #     term is split across a newline boundary).
  #
  #     This first block of code looks for the end of a term, started
  #     on the previous line, at the beginning of this line.
  #
  if ( $in{'Glossary_term'} and $text =~ /^\s*(.*?)\s*\]/ ) {

    my $remainder      = $1;
    my ($partial,$alt) = @{ $current{'Glossary_partial_term'} };
    my $term           = "$partial $remainder";

    # replace '\&' with '&'
    $term =~ s/\\&/&/g;

    if ( term_in_glossary($term,$alt) ) {
      $ucf_term = ucfirst($term);
      $text =~ s/^(.*?)\]/<i>$ucf_term<\/i>/;
    }

    else {
      printwarning("escape_html: no glossary entry for \"$alt:$term\"");
      $ucf_term = ucfirst($term);
      $text =~ s/^(.*?)\]/<i>$ucf_term<\/i>/;
    }

    $in{'glossary_term'} = 0;

  }

  #-------------------------------------------------------------------
  # Glossary: Split Terms (G and Gls)
  #
  #     This block of code looks for the beginning of a split term at
  #     the end of this line.
  #
  if ( $text =~ /\[(G|Gls):(([^ \t\n\r\f\]]*?):)?\s*(.*?)\s*$/ ) {

    my $alt     = $3 || '';
    my $partial = $4;

    $current{'Glossary_partial_term'} = [$partial,$alt];

    $in{'Glossary_term'} = 1;

    $text =~ s/\[(G|Gls):.*?$//;

  }

  #-------------------------------------------------------------------
  # Glossary Definitions (def)
  #
  #     This block of code looks for glossary definition references
  #     that occur all on one line:
  #
  #     [def:Perl]
  #
  while ( $text =~ /\[def:(([^ \t\n\r\f\]]*?):)?\s*(.*?)\s*\]/ ) {

    my $alt  = $2 || '';
    my $term = $3;
    my $html = '';

    # replace '\&' with '&'
    $term =~ s/\\&/&/g;

    if ( term_in_glossary($term,$alt) ) {
      $html = escape_html($glossary{$term}{$alt});
      $text =~ s/\[def:.*?\]/$html/;
    }

    else {
      $text =~ s/\[def:.*?\]/(missing $alt definition of $term)/;
      printwarning("escape_html: no glossary entry for \"$alt:$term\"");
    }
  }

  #-------------------------------------------------------------------
  # Glossary: Split Definition References (def)
  #
  #     Handle instances when glossary definition references begin at
  #     the end of one line, then end at the beginning of the next
  #     line (i.e. the reference is split across a newline boundary).
  #
  #     This first block of code looks for the end of a definition
  #     reference, started on the previous line, at the beginning of
  #     this line.
  #
  if ( $in{'glossary_def'} and $text =~ /^\s*(.*?)\s*\]/ ) {

    my $remainder      = $1;
    my ($partial,$alt) = @{ $current{'glossary_partial_def'} };
    my $term           = "$partial $remainder";
    my $html           = '';

    # replace '\&' with '&'
    $term =~ s/\\&/&/g;

    if ( term_in_glossary($term,$alt) ) {
      $html = escape_html($glossary{$term}{$alt});
      $text =~ s/^(.*?)\]/$html/;
    }

    else {
      printwarning("escape_html: no glossary entry for \"$alt:$term\"");
      $text =~ s/^(.*?)\]/(missing $alt definition of $term)/;
    }

    $in{'glossary_def'} = 0;

  }

  #-------------------------------------------------------------------
  # Glossary: Split Definition References (def)
  #
  #     This block of code looks for the beginning of a split term at
  #     the end of this line.
  #
  if ( $text =~ /\[def:(([^ \t\n\r\f\]]*?):)?\s*(.*?)\s*$/ ) {

    my $alt     = $2 || '';
    my $partial = $3;

    $current{'glossary_partial_def'} = [$partial,$alt];

    $in{'glossary_def'} = 1;

    $text =~ s/\[def:.*?$//;

  }

  #-------------------------------------------------------------------
  # Variable
  #
  #     This block of code looks for variables that occur all on one
  #     line:
  #
  #     [var:truth-count]
  #
  while ( $text =~ /\[var:(.*?)\]/ ) {
    my $name = $1;
    if ( defined $variable{$name} ) {
      my $value = escape_html($variable{$name});
      $text =~ s/\[var:(.*?)\]/$value/;
    }
    else {
      printwarning("no variable definition for \"$name\"");
      $text =~ s/\[var:(.*?)\]/$name/;
    }
  }

  #-------------------------------------------------------------------
  # Variable: Split Names
  #
  #     Handle instances when variable names begin at the end of one
  #     line, then end at the beginning of the next line (i.e. the
  #     term is split across a newline boundary).
  #
  #     This first block of code looks for the end of a name, started
  #     on the previous line, at the beginning of this line.
  #
  if ( $in{'var_name'} and $text =~ /^(.*?)\]/ ) {

    my $remainder = trim_whitespace($1);
    my $partial   = $current{'var_partial_name'};
    my $name      = $partial . $remainder;

    if ( defined $variable{$name} ) {
      my $value = escape_html($variable{$name});
      $text =~ s/^(.*?)\]/$value/;
    }
    else {
      printwarning("no variable definition for \"$name\"");
      $text =~ s/^(.*?)\]/$name/;
    }

    $in{'var_name'} = 0;

  }

  #-------------------------------------------------------------------
  # Lookup
  #
  #     This block of code looks for lookup replacements that occur
  #     all on one line:
  #
  #     [lookup:Manufacturer:ci-000638]
  #     [l:Manufacturer:ci-000638]
  #
  # WANT: Handle nested lookups (handy in templates).
  #
  while ( $text =~ /\[(lookup|l):([^:]+):(.*?)\]/ ) {

    my $element = $2;
    my $label   = $3;
    my $name    = name_for($label);

    # Element may be a simple pre-defined data element
    #
    if ( defined $lookup{$label}{$element} ) {

      # Determine whether this data element is multi-valued
      #
      my $is_multivalued = 0;
      # if ( $structure{$name}{'elements'}{$element}{'multivalued'} ) {
      # 	$is_multivalued = 1;
      # }

      if ( ref $lookup{$label}{$element} eq 'ARRAY' ) {
	$is_multivalued = 1;
      }

      # If the data element is NOT multivalued...
      #
      if (not $is_multivalued) {
	my $value = escape_html($lookup{$label}{$element});
	$text     =~ s/\[(lookup|l):([^:]+):(.*?)\]/$value/;
      }

      # If the data element IS multivalued...
      #
      else {
	my @value = @{ $lookup{$label}{$element} };
	# my $value = join(' -- ',@value);
	my $value = join(', ',@value);
	$value    = escape_html($value);
	$text     =~ s/\[(lookup|l):([^:]+):(.*?)\]/$value/;
      }
    }

    # Element is 'status'
    #
    elsif ($element eq 'status') {
      my $value = status_of($label);
      $text     =~ s/\[(lookup|l):([^:]+):(.*?)\]/$value/;
    }

    elsif ( defined $attribute{$label}{$element} ) {
      my @value = @{ $attribute{$label}{$element} };
      my $value = join(' -- ',@value);
      $value    = escape_html($value);
      $text     =~ s/\[(lookup|l):([^:]+):(.*?)\]/$value/;
    }

    else {
      printwarning("escape_html: no lookup value for \"$label\" \"$element\"");
      $text =~ s/\[(lookup|l):([^:]+):(.*?)\]/?/;
    }
  }

  #-------------------------------------------------------------------
  # Enter - text to be entered by the user
  #
  #     This block of code looks for text to be entered by the user
  #     that occurs all on one line:
  #
  #     [enter:your name here]
  #     [en:your name here]
  #
  #     Text to be entered by the user is rendered in a bold
  #     constant-width font.
  #
  while ( $text =~ /\[(enter:|en:)(.*?)\]/ ) {
    my $string = $2;
    $text =~ s/\[(enter:|en:)(.*?)\]/<b><tt>$string<\/tt><\/b>/;
  }

  #-------------------------------------------------------------------
  # Enter - split across newline boundary (end)
  #
  #     Handle instances when text to be entered by the user begins at
  #     the end of one line, and ends at the beginning of a subsequent
  #     line (i.e. the text is split across one or more newline
  #     boundaries).
  #
  #     This first block of code looks for the end of text to be
  #     entered by the user, started on the previous line, at the
  #     beginning of this line.
  #
  if ( $in{'user_entered_text'} and $text =~ /^(.*?)\]/ ) {

    my $remainder = trim_whitespace($1);
    my $partial   = $current{'user_entered_text_partial'};
    my $string    = $partial . $remainder;

    $text =~ s/^(.*?)\]/<b><tt>$string<\/tt><\/b>/;

    $in{'user_entered_text'} = 0;

  }

  #-------------------------------------------------------------------
  # Enter - split across newline boundary (begin)
  #
  #     This block of code looks for the beginning of a split region
  #     of text to be entered by the user at the end of this line.
  #
  if ( $text =~ /\[(enter:|en:)(.*?)$/ ) {

    $current{'user_entered_text_partial'} = trim_whitespace($2);

    $in{'user_entered_text'} = 1;

    $text =~ s/\[(enter:|en:)(.*?)$//;

  }

  #-------------------------------------------------------------------
  # Acronyms
  #
  #     This block of code looks for acronyms that occur all on one
  #     line:
  #
  #     [ac:TLA]
  #     [acs:TLA]
  #     [acl:TLA]
  #
  while ( $text =~ /\[(ac:|acs:|acl:)(.*?)\]/ ) {
    my $tag  = $1;
    my $term = $2;
    if ( acronym_defined($term) ) {
      $text =~ s/\[(ac:|acs:|acl:)(.*?)\]/$term/;
    }
    else {
      printwarning("no definition for acronym \"$term\"");
      $text =~ s/\[(ac:|acs:|acl:)(.*?)\]/$term/;
    }
  }

  #-------------------------------------------------------------------
  # Index Terms
  #
  #     This block of code looks for index terms that occur all on
  #     one line:
  #
  #     [i:Perl]
  #     [index:Perl]
  #
  #     !!! Bug Here !!!
  #
  #     Provide hyperlinks to index entries once the code for writing
  #     the index pages is complete.
  #
  while ( $text =~ /\[(i|index):(.*?)\]/ ) {
    my $term = $2;
    $text =~ s/\[(i|index):(.*?)\]/$term/;
  }

  #-------------------------------------------------------------------
  # Index: Split Terms
  #
  #     Handle instances when index terms begin at the end of one
  #     line, then end at the beginning of the next line (i.e. the
  #     term is split across a newline boundary).
  #
  #     This first block of code looks for the end of a term, started
  #     on the previous line, at the beginning of this line.
  #
  if ( $in{'index_term'} and $text =~ /^(.*?)\]/ ) {
    my $remainder = trim_whitespace($1);
    my $partial   = $current{'index_partial_term'};
    my $term      = "$partial $remainder";
    $text =~ s/^(.*?)\]/$term/;
    $in{'index_term'} = 0;
  }

  #-------------------------------------------------------------------
  # Index: Split Terms
  #
  #     This block of code looks for the beginning of a split term at
  #     the end of this line.
  #
  if ( $text =~ /\[(i|index):(.*?)$/ ) {
    my $partial = trim_whitespace($2);
    $current{'index_partial_term'} = $partial;
    $in{'index_term'} = 1;
    $text =~ s/\[(i|index):(.*?)$//;
  }

  #-------------------------------------------------------------------
  # Email Addresses
  #
  #     !!! BUG HERE !!!
  #
  #     This regular expression for finding email addresses is VERY
  #     lame.  I need to find a better one.
  #
  $text =~ s/($emailre)/<a href=\"mailto:$1\">$1<\/a>/xog;

  #-------------------------------------------------------------------
  # Bold (**)
  #
  while ($text =~ /\*\*/) {

    if (not $in{'b'}) {
      $text =~ s/(.*?)\*\*(.*)$/$1<b>$2/;
      $in{'b'} = 1;
    }

    else {
      $text =~ s/(.*?)\*\*(.*)$/$1<\/b>$2/;
      $in{'b'} = 0;
    }
  }

  #-------------------------------------------------------------------
  # Bold (!!)
  #
  while ($text =~ /\!\!/) {

    if (not $in{'b'}) {
      $text =~ s/(.*?)\!\!(.*)$/$1<b>$2/;
      $in{'b'} = 1;
    }

    else {
      $text =~ s/(.*?)\!\!(.*)$/$1<\/b>$2/;
      $in{'b'} = 0;
    }
  }

  #-------------------------------------------------------------------
  # Typewriter-Text (||)
  #
  while ($text =~ /\|\|/) {

    if (not $in{'tt'}) {
      $text =~ s/(.*?)\|\|(.*)$/$1<tt>$2/;
      $in{'tt'} = 1;
    }

    else {
      $text =~ s/(.*?)\|\|(.*)$/$1<\/tt>$2/;
      $in{'tt'} = 0;
    }
  }

  #-------------------------------------------------------------------
  # Italics (~~)
  #
  while ($text =~ /\~\~/) {

    if (not $in{'i'}) {
      $text =~ s/(.*?)\~\~(.*)$/$1<i>$2/;
      $in{'i'} = 1;
    }

    else {
      $text =~ s/(.*?)\~\~(.*)$/$1<\/i>$2/;
      $in{'i'} = 0;
    }
  }

  #-------------------------------------------------------------------
  # Underline (__)
  #
  while ($text =~ /[^_]\_\_[^_]/) {

    if (not $in{'u'}) {
      $text =~ s/(.*?)\_\_(.*)$/$1<u>$2/;
      $in{'u'} = 1;
    }

    else {
      $text =~ s/(.*?)\_\_(.*)$/$1<\/u>$2/;
      $in{'u'} = 0;
    }
  }

  #-------------------------------------------------------------------
  # Superscript (^^)
  #
  while ($text =~ /[^\^]\^\^[^\^]/) {

    if (not $in{'sup'}) {
      $text =~ s/(.*?)\^\^(.*)$/$1<sup>$2/;
      $in{'sup'} = 1;
    }

    else {
      $text =~ s/(.*?)\^\^(.*)$/$1<\/sup>$2/;
      $in{'sup'} = 0;
    }
  }

  #-------------------------------------------------------------------
  # Subscript (,,)
  #
  while ($text =~ /[^,],,[^,]/) {

    if (not $in{'sup'}) {
      $text =~ s/(.*?),,(.*)$/$1<sub>$2/;
      $in{'sup'} = 1;
    }

    else {
      $text =~ s/(.*?),,(.*)$/$1<\/sub>$2/;
      $in{'sup'} = 0;
    }
  }

  #-------------------------------------------------------------------
  # Mdash (--)
  #
  $text =~ s/([^-])--([^-])/$1&mdash;$2/g;

  #-------------------------------------------------------------------
  #
  #     !!! BUG HERE !!!
  #
  #     Only one type of the following two hyperlink styles may be
  #     used on any single line of input text (this is minor).
  #
  #-------------------------------------------------------------------

  #-------------------------------------------------------------------
  # resolve hyperlinks like "link: textfiles/myfile.txt"
  #
  if ($text =~ /link:\s+(\S+)\s/) {
    if (-f $1) {
      my $file = publish_file($1);
      $text =~ s/link:\s+(\S+)(\s+)/See: <a href=\"files\/$file\">$file<\/a>$2/;
    }
  }

  #-------------------------------------------------------------------
  # resolve hyperlinks like (click here::http://www.cnn.com)
  #
  if ($text =~ /\(.*?::.*?\)/) {
    $text =~ s/\((.*?)::(.*?)\)/<a href="$2">$1<\/a>/s;
  }

  #-------------------------------------------------------------------
  # resolve hyperlinks like http://www.cnn.com
  #
  # COMMENTED out because it conflicts with the
  # [url:http://www.cnn.com/] form.
  #
#   elsif ($text =~ /http:\/\/\S+?[\s\)]/) {
#     $text =~ s/(http:\/\/\S+?)([\s\)\<])/<a href=\"$1\">$1<\/a>$2/;
#   }

  #-------------------------------------------------------------------
  # substitute footnote doohickies with a hyperlink
  #
  #     !!! Bug Here !!!
  #
  #     When publishing two renditions at the same time (e.g., html
  #     and pdf), incrementing this total footnote count here, in this
  #     block of code (escape_html), causes the footnote count to be
  #     off since the count also gets incremented in another block of
  #     code in escape_latex.  The interim solution to this problem is
  #     to only render one rendition at a time.  This problem doesn't
  #     affect the LaTeX revision since LaTeX does all the footnote
  #     counting.
  #
  while ($text =~ /\[f:(\S+?):(\S+?)\]/) {
    my $label = $1;
    my $tag   = $2;
    # my $num = ++ $count{'footnote'}{'total'};
    $text =~ s/\[f:(\S+?):(\S+?)\]/<span style=\"font-size: 8pt;\"><sup><a href="#footnote.$label.$tag">$tag<\/a><\/sup><\/span>/;
  }

  #-------------------------------------------------------------------
  # References (ref, r)
  #
  #     Resolve inline references (i.e. [ref:fig-my-picture]).
  #     References are replaced with hyperlinked text as follows:
  #
  #         [ref:tab-my-table]         =>   Table 12-1
  #         [ref:fig-my-figure]        =>   Figure 12-1
  #         [ref:att-my-attachment]    =>   Attachment 12-1
  #         [ref:sli-my-slide]         =>   Slide 12-1
  #         [ref:sbr-my-sidebar]       =>   Sidebar 12-1
  #         [ref:qte-my-qouote]        =>   Quotation 12-1
  #         [ref:req-my-problem]       =>   Problem 12-1
  #         [ref:req-my-solution]      =>   Solution 12-1
  #         [ref:req-my-allocation]    =>   Allocation 12-1
  #         [ref:req-my-assignment]    =>   Assignment 12-1
  #         [ref:req-my-test]          =>   Test 12-1
  #         [ref:req-my-task]          =>   Task 12-1
  #         [ref:req-my-result]        =>   Result 12-1
  #         [ref:dem-my-demo]          =>   Demonstration 12-1
  #         [ref:not-my-note]          =>   Note 12-1
  #         [ref:lis-my-listing]       =>   Listing 12-1
  #         [ref:exe-my-exercise]      =>   Exercise 12-1
  #
  #     Note: The first three characters in the label (e.g. tab, fig,
  #     sli, dem, not, lis, and exe) are NOT significant.  I've chosen
  #     these labels for convenience only.
  #
  while ($text =~ /\[(r:|ref:)(.*?)\]/) {

    my $label    = trim_whitespace($2);
    my $type     = $label{$label}{'type'}    || 'unknown';
    my $name     = $label{$label}{'name'}    || 'unknown';
    my $toplevel = $label{$label}{'topnum'}  || '0';
    my $secnum   = $label{$label}{'secnum'}  || '0.0.0';
    my $number   = $label{$label}{'number'}  || '0-0';
    my $outfile  = html_outfile_for_label($label);

    if ( $name eq 'section' ) {
      my $sectype = $label{$label}{'sectype'};
      if ($sectype) {
	$name = $sectype;
      }
    }

    my $ucf_name = ucfirst $name;

    # Label exists?
    #
    if ( label_exists($label) ) {

      # Section Number
      #
      #     If this label refers to an environment (i.e. table,
      #     figure, attachment, listing, preformatted, etc.) use the
      #     name and number (i.e. table.2-3) otherwise, use the name
      #     and section number (i.e. section.2-3-12).
      #
      if ($type eq 'environment' or $type eq 'region') {
	my $target = "$outfile#$name.$number";
	$text =~ s/\[(r:|ref:)(.*?)\]/<a href=\"$target\">$ucf_name $number<\/a>/;
	# print "DEBUG: \"$label\" is a \"$type\" - using $number instead of $secnum\n";
      }

      else {
	my $target = "$outfile#$name.$secnum";
	$text =~ s/\[(r:|ref:)(.*?)\]/<a href=\"$target\">$ucf_name $secnum<\/a>/;
	# print "DEBUG: \"$label\" is a \"$type\" - using $secnum instead of $number\n";
      }

    }

    # Label doesn't exist
    #
    else {
      printwarning("broken reference: $label");
      $text =~ s/\[(r:|ref:)(.*?)\]/<font color="red">(broken reference to $label)<\/font>/;
    }
  }

  #-------------------------------------------------------------------
  # References (id)
  #
  #     Resolve inline references (i.e. [id:rq-000023]).  References
  #     are replaced with hyperlinked ID as follows:
  #
  #         [id:rq-000023]         =>   rq-000023
  #
  while ($text =~ /\[id:(.*?)\]/) {

    my $label = trim_whitespace($1);

    # Label exists?
    #
    if ( label_exists($label) ) {
      my $outfile = html_outfile_for_label($label);
      $text =~ s/\[id:(.*?)\]/<a href=\"$outfile#$label\">$label<\/a>/;
    }

    # Label doesn't exist
    #
    else {
      printwarning("broken reference: $label");
      $text =~ s/\[id:(.*?)\]/<font color="red">(broken reference to $label)<\/font>/;
    }
  }

  #-------------------------------------------------------------------
  # Resolve Citations
  #
  #     Citations (i.e. [cite:lamport96]) are replaced with
  #     hyperlinked text as follows:
  #
  #     [cite:Lamport96]                => Lamport96
  #     [cite:Lamport96,pages~161-164]  => Lamport96 (pages 161-164)
  #
  #     Authors and editors can replace spaces with tildes (~) to
  #     prevent a citation from breaking across a newline.
  #
  while ($text =~ /\[(c:|cite:)(.*?)\]/) {

    my $citation = $2;
    $citation =~ s/~/ /g;

    my $label = '';
    my $other = '';
    if ($citation =~ /(.*?),(.*)/) {
      $label = trim_whitespace($1);
      $other = trim_whitespace($2);
    } else {
      $label = trim_whitespace($citation);
    }

    # Source exists?
    #
    if ( source_exists($label) ) {
      my $target = "$output_file.source.html#$label";
      if ($other) {
	$text =~ s/\[(c:|cite:)(.*?)\]/\[<a href=\"$target\">$label, $other<\/a>\]/;
      }
      else {
	$text =~ s/\[(c:|cite:)(.*?)\]/\[<a href=\"$target\">$label<\/a>\]/;
      }
    }

    # Source does not exist
    #
    else {
      printwarning("broken citation: $label");
      $text =~ s/\[(c:|cite:)(.*?)\]/<font color="red">(broken citation to $citation)<\/font>/;
    }

  }

  #-------------------------------------------------------------------
  # look for "steps"
  #
  if ($text =~ /^step::/i) {
    $text =~ s/^step::/<input type=\"checkbox\"><b><span style=\"font-size: 8pt;\">STEP $count{'step'}{'section'}<\/span><\/b> - /;
  }

  #-------------------------------------------------------------------
  # look for URLs like [url:http://www.cnn.com/]
  #
  # The whole URL is on one line...
  #
  my $url_part_one = '';
  my $url_part_two = '';
  while ($text =~ /\[url:(.*?)\]/) {
    my $url = $1;
    $text =~ s/\[url:(.*?)\]/<a href=\"$url\">$url<\/a>/g;
  }

  # The URL begins on one line...
  #
  if ($text =~ /\[url:(.*)/) {
    $url_part_one = $1;
    $text =~ s/\[url:(.*)//g;
    $in{'html_url'} = 1;
  }

  # ...And ends on another (assumed to be the NEXT line)...
  #
  if ($text =~ /(.*?)\]/ and $in{'html_url'}) {
    $url_part_two = $1;
    my $url = $url_part_one . $url_part_two;
    $text =~ s/(.*?)\]/<a href=\"$url\">$url<\/a>/g;
    $in{'html_url'} = 0;

    # now that we've used these two URL parts, reset them to empty
    # strings.
    #
    $url_part_one = $EMPTY_STRING;
    $url_part_two = $EMPTY_STRING;
  }

  #-------------------------------------------------------------------
  # Paths and Files
  #
  #   [p:C:\Program Files]
  #   [path:C:\Program Files]
  #   [f:krm.conf]
  #   [file:krm.conf]
  #
  # The whole thing is on one line...
  #
  while ($text =~ /\[(p:|f:|path:|file:)(.*?)\]/) {
    my $path = trim_whitespace($2);
    $text =~ s/\[(p:|f:|path:|file:)(.*?)\]/<tt>$path<\/tt>/g;
  }

  # It begins on one line...
  #
  if ($text =~ /\[(p:|f:|path:|file:)(.*)/) {
    my $partial = trim_whitespace($2);
    $text =~ s/\[(p:|f:|path:|file:)(.*)/<tt>$partial/g;
    $in{'html_path'} = 1;
  }

  # ...And ends on another...
  #
  if ($text =~ /^([^\]]*)\]/ and $in{'html_path'}) {
    my $partial = trim_whitespace($1);
    $text =~ s/^([^\]]*)\]/$partial<\/tt>/g;
    $in{'html_path'} = 0;
  }

  #-------------------------------------------------------------------
  # Commands
  #
  #     [cmd:ls -al | grep -i bin | sort]
  #
  while ($text =~ /\[cmd:(.*?)\]/) {
    my $command = trim_whitespace($1);
    $text =~ s/\[cmd:(.*?)\]/<tt>$command<\/tt>/g;
  }

  # The command (cmd) begins on one line...
  #
  if ($text =~ /\[cmd:(.*)/) {
    my $partial = trim_whitespace($1);
    $text =~ s/\[cmd:(.*)/<tt>$partial/g;
    $in{'html_cmd'} = 1;
  }

  # ...And ends on another...
  #
  if ($text =~ /^([^\]]*)\]/ and $in{'html_cmd'}) {
    my $partial = trim_whitespace($1);
    $text =~ s/^([^\]]*)\]/$partial<\/tt>/g;
    $in{'html_cmd'} = 0;
  }

  #-------------------------------------------------------------------
  # Line Breaks
  #
  #     A `[linebreak]' in the SML text indicates a line break.
  #
  if ( $text =~ /\[linebreak\]/ ) {
    $text =~ s/\[linebreak\]/<br\/>/g;
  }

  #-------------------------------------------------------------------
  # thepage (has no meaning in html)
  #
  if ( $text =~ /\[thepage\]/ ) {
    $text =~ s/\[thepage\]//g;
  }

  #-------------------------------------------------------------------
  # version
  #
  if ( $text =~ /\[version\]/ ) {
    my $version = $document{'version'};
    $text =~ s/\[version\]/$version/g;
  }

  #-------------------------------------------------------------------
  # revision
  #
  if ( $text =~ /\[revision\]/ ) {
    my $revision = $document{'revision'};
    $text =~ s/\[revision\]/$revision/g;
  }

  #-------------------------------------------------------------------
  # date
  #
  if ( $text =~ /\[date\]/ ) {
    my $modified_date = '';
    if ( $document{'date'} ) {
      my $original_date = $document{'date'};
      if ( $original_date =~ /\((\w+,\s+\d+\s+\w+\s+\d+)\)/ ) {
	$modified_date = $1;
      }
      else {
	$modified_date = $original_date;
      }
    }
    $text =~ s/\[date\]/$modified_date/g;
  }

  #-------------------------------------------------------------------
  # Title References
  #
  #     [t:sec-label]
  #     [title:sec-label]
  #
  #     This block of substitution code should appear early in the
  #     subroutine so that markup in the title is escaped.
  #
  #     !!! Bug Here !!!
  #
  #     If publishing both PDF and HTML renditions, a broken title
  #     reference will cause two errors, one from escape_latex, and
  #     one from escape_html.
  #
  #     !!! BUG HERE !!!
  #
  #     Perhaps this subroutine should be invoked recursively to
  #     ensure all substitutions are performed.
  #
  while ($text =~ /\[(t:|title:)(.*?)\]/) {

    my $label   = trim_whitespace($2);
    my $outfile = html_outfile_for_label($label);

    if ( label_exists($label) ) {
      my $title = escape_html( $lookup{$label}{'title'} );
      $text =~ s/\[(t:|title:)(.*?)\]/<a href="$outfile#$label">$title<\/a>/;
    }

    else {
      printwarning("broken title reference: $label");
      $text =~ s/\[(t:|title:)(.*?)\]/<font color="red">(broken title reference to $label)<\/font>/;
    }
  }

  #-------------------------------------------------------------------
  # Page References
  #
  #     [pg:sec-label]
  #     [page:sec-label]
  #
  while ($text =~ /\[(pg|page):(.*?)\]/) {

    my $label   = trim_whitespace($2);
    my $outfile = html_outfile_for_label($label);

    if ( label_exists($label) ) {
      $text =~ s/\[(pg|page):(.*?)\]/<a href="$outfile#$label">link<\/a>/;
    }

    else {
      printwarning("broken page reference: $label");
      $text =~ s/\[(pg|page):(.*?)\]/<font color="red">(broken page reference to $label)<\/font>/;
    }
  }

  #-------------------------------------------------------------------
  # Description References
  #
  #     [d:label]
  #     [desc:label]
  #     [description:label]
  #
  #     This block of substitution code should appear early in the
  #     subroutine so that markup in the title is escaped.
  #
  #     !!! BUG HERE !!!
  #
  #     Perhaps this subroutine should be invoked recursively to
  #     ensure all substitutions are performed.
  #
  while ($text =~ /\[(d:|desc:|description:)(.*?)\]/) {

    my $label = trim_whitespace($2);

    # Label exists?
    #
    if ( label_exists($label) ) {
      my $description = escape_html( $lookup{$label}{'description'} );
      $text =~ s/\[(d:|desc:|description:)(.*?)\]/<span>$description<\/span>/;
    }

    # Label doesn't exist
    #
    else {
      printwarning("broken description reference: $label");
      $text =~ s/\[(d:|desc:|description:)(.*?)\]/<font color="red">(broken description reference to $label)<\/font>/;
    }
  }

  #-------------------------------------------------------------------
  # Type References
  #
  #     [type:label]
  #
  #     Substitute an item's type.
  #
  while ($text =~ /\[type:(.*?)\]/) {

    my $label = trim_whitespace($1);

    # Label exists?
    #
    if ( label_exists($label) ) {
      my @types = @{ $lookup{$label}{'type'} };
      my $type  = join(', ',@types);
      $text =~ s/\[type:(.*?)\]/<span>$type<\/span>/;
    }

    # Label doesn't exist
    #
    else {
      printwarning("broken type reference: $label");
      $text =~ s/\[type:(.*?)\]/<font color="red">(broken type reference to $label)<\/font>/;
    }
  }

  #-------------------------------------------------------------------
  # Owner References
  #
  #     [owner:label]
  #
  #     Substitute an item's owner.  An item can only have 1 owner.
  #
  while ($text =~ /\[owner:(.*?)\]/) {
    my $label   = trim_whitespace($1);
    if ( label_exists($label) ) {
      my $owner   = $lookup{$label}{'owner'};
      if ($owner) {
	if ( label_exists($owner) ) {
	  my $outfile = html_outfile_for_label($owner);
	  my $title   = escape_html( $lookup{$owner}{'title'} );
	  $text =~ s/\[owner:(.*?)\]/<a href="$outfile#$owner">$owner $title<\/a>/;
	} else {
	  $text =~ s/\[owner:(.*?)\]/$owner/;
	}
      } else {
	printwarning("no owner assigned to $label");
	$text =~ s/\[owner:(.*?)\]/<font color="red">(no owner assigned to $label)<\/font>/;
      }
    } else {
      printwarning("broken owner reference: $label");
      $text =~ s/\[owner:(.*?)\]/<font color="red">(broken owner reference to $label)<\/font>/;
    }
  }

  #-------------------------------------------------------------------
  # Status References
  #
  #     [status:label]
  #
  #     Substitute an item's status.  An item can only have 1 status.
  #
  while ($text =~ /\[status:(.*?)\]/) {
    my $label   = trim_whitespace($1);
    if ( label_exists($label) ) {
      my $status = status_of($label);
      if ($status) {
	my $icon = html_status_icon_for($status);
	$text =~ s/\[status:(.*?)\]/$icon &nbsp;/;
      }
      else {
	printwarning("no status assigned to $label");
	$text =~ s/\[status:(.*?)\]/<font color="red">(no status assigned to $label)<\/font>/;
      }
    }

    elsif ( $label =~ (/(green|yellow|red|grey)/) ) {
      my $status = $1;
      my $icon = html_status_icon_for($status);
      $text =~ s/\[status:(.*?)\]/$icon &nbsp;/;
    }

    else {
      printwarning("broken status reference: $label");
      $text =~ s/\[status:(.*?)\]/<font color="red">(broken status reference to $label)<\/font>/;
    }
  }

  #-------------------------------------------------------------------
  # Literal strings (part 2)
  #
  #     In part one of this process near the beginning of the
  #     function, literal strings were detected and replaced with
  #     special placeholders (LITERAL-STRING-1, LITERAL-STRING-2, etc).
  #
  #     In this (part 2) part of the process, we'll replace those
  #     placeholders with the original strings.
  #
  if ($literals) {
    while ($text =~ /LITERAL-STRING-(\d+)/) {
      my $lsc    = $1;  # literal string count
      my $string = $literal[$lsc];

      # There are certain characters that need to be substituted even
      # in literal text...
      #
      $string =~ s/<(\S+)>/\&lt\;$1\&gt\;/g;  # MDO and MDC

      $text =~ s/LITERAL-STRING-(\d+)/$string/;
    }
  }

  return $text;
}

######################################################################

sub escape_xml {

  #-------------------------------------------------------------------
  #
  # !!! Bug Here !!!
  #
  #     I have not made updates to this subroutine as I've been
  #     improving the escape_html and escape_latex subroutines.
  #     Therefore, this one needs A LOT of updating.
  #
  #-------------------------------------------------------------------

  my $text = shift;

  #-------------------------------------------------------------------
  # escape some html special characters
  #
  $text =~ s/\&/\&amp\;/g;
  $text =~ s/<(\S+)>/\&lt\;$1\&gt\;/g;

  #-------------------------------------------------------------------
  # look for special double quotes
  #
  $text =~ s/``/"/g;
  $text =~ s/''/"/g;

  #-------------------------------------------------------------------
  # look for copyright, registered, and trademark symbols
  #
  #  $text =~ s/\(c\)/\&copyright\;/ig;
  #  $text =~ s/\(r\)/\&reg\;/ig;
  #  $text =~ s/\(tm\)/&trademark\;/ig;

  #-------------------------------------------------------------------
  # keystroke indicators
  #
  $text =~ s/\[\[(.*?)\]\]/<keystroke>$1<\/keystroke>/g;
  if ($text =~ /\[\[(.*)$/) {
    $text =~ s/\[\[(.*?)$/<keystroke>$1/;
  }
  if ($text =~ /^(.*?)\]\]/) {
    $text =~ s/^(.*?)\]\]/$1<\/keystroke>/;
  }

  #-------------------------------------------------------------------
  # !!! BUG HERE !!!
  #
  # This regular expression for finding email addresses seems VERY
  # lame.  I need to find a better one.
  #-------------------------------------------------------------------

  #-------------------------------------------------------------------
  # provide hyperlinks for email addresses
  #
  #  $text =~ s/(\S+@\S+)/<a href=\"mailto:$1\">$1<\/a>/g;

  #-------------------------------------------------------------------
  # insert inline bold element begin and end tags (**)
  #
  while ($text =~ /\*\*/) {

    if (not $in{'b'}) {
      $text =~ s/(.*?)\*\*(.*)$/$1<b>$2/;
      $in{'b'} = 1;
    }

    else {
      $text =~ s/(.*?)\*\*(.*)$/$1<\/b>$2/;
      $in{'b'} = 0;
    }
  }

  #-------------------------------------------------------------------
  # insert inline bold element begin and end tags (!!)
  #
  while ($text =~ /\!\!/) {

    if (not $in{'b'}) {
      $text =~ s/(.*?)\!\!(.*)$/$1<b>$2/;
      $in{'b'} = 1;
    }

    else {
      $text =~ s/(.*?)\!\!(.*)$/$1<\/b>$2/;
      $in{'b'} = 0;
    }
  }

  #-------------------------------------------------------------------
  # insert inline typewriter-text element begin and end tags
  #
  while ($text =~ /\|\|/) {

    if (not $in{'tt'}) {
      $text =~ s/(.*?)\|\|(.*)$/$1<tt>$2/;
      $in{'tt'} = 1;
    }

    else {
      $text =~ s/(.*?)\|\|(.*)$/$1<\/tt>$2/;
      $in{'tt'} = 0;
    }
  }

  #-------------------------------------------------------------------
  # insert inline italics element begin and end tags
  #
  while ($text =~ /\~\~/) {

    if (not $in{'i'}) {
      $text =~ s/(.*?)\~\~(.*)$/$1<i>$2/;
      $in{'i'} = 1;
    }

    else {
      $text =~ s/(.*?)\~\~(.*)$/$1<\/i>$2/;
      $in{'i'} = 0;
    }
  }

  #-------------------------------------------------------------------
  # insert inline underline element begin and end tags
  #
  while ($text =~ /[^_]\_\_[^_]/) {

    if (not $in{'u'}) {
      $text =~ s/(.*?)\_\_(.*)$/$1<u>$2/;
      $in{'u'} = 1;
    }

    else {
      $text =~ s/(.*?)\_\_(.*)$/$1<\/u>$2/;
      $in{'u'} = 0;
    }
  }

  #-------------------------------------------------------------------
  # !!! BUG HERE !!!
  #
  # Only one type of the following two hyperlink styles may be used on
  # any single line of input text (this is minor).
  #-------------------------------------------------------------------

  #-------------------------------------------------------------------
  # resolve hyperlinks like link: textfiles/myfile.txt
  #
  if ($text =~ /link:\s+(\S+)\s/) {
    if (-f $1) {
      my $file = publish_file($1);
      $text =~ s/link:\s+(\S+)(\s+)/See: <a href=\"files\/$file\">$file<\/a>$2/;
    }
  }

  #-------------------------------------------------------------------
  # resolve hyperlinks like (click here::http://www.cnn.com)
  #
  if ($text =~ /\(.*?::.*?\)/) {
    $text =~ s/\((.*?)::(.*?)\)/<a href="$2">$1<\/a>/s;
  }

  #-------------------------------------------------------------------
  # resolve hyperlinks like http://www.cnn.com
  #
  elsif ($text =~ /http:\/\/\S+?[\s\)]/) {
    $text =~ s/(http:\/\/\S+?)([\s\)\<])/<a href=\"$1\">$1<\/a>$2/;
  }

  #-------------------------------------------------------------------
  # substitute footnote doohickies with a hyperlink
  #
  $text =~ s/\[f:(\S+?):(\S+?)\]/<a href="#footnote.$1.$2">$2<\/a>/;

  #-------------------------------------------------------------------
  # Resolve inline references (i.e. [ref:fig-my-picture]).  References
  # are replaced with hyperlinked text as follows:
  #
  #   [ref:tab-my-table]         =>   Table 12-1
  #   [ref:fig-my-figure]        =>   Figure 12-1
  #   [ref:att-my-attachment]    =>   Attachment 12-1
  #   [ref:sli-my-slide]         =>   Slide 12-1
  #   [ref:sbr-my-sidebar]       =>   Sidebar 12-1
  #   [ref:qte-my-qouote]        =>   Quotation 12-1
  #   [ref:req-my-problem]       =>   Problem 12-1
  #   [ref:req-my-solution]      =>   Solution 12-1
  #   [ref:req-my-allocation]    =>   Allocation 12-1
  #   [ref:req-my-assignment]    =>   Assignment 12-1
  #   [ref:req-my-test]          =>   Test 12-1
  #   [ref:req-my-task]          =>   Task 12-1
  #   [ref:req-my-result]        =>   Result 12-1
  #   [ref:dem-my-demo]          =>   Demonstration 12-1
  #   [ref:not-my-note]          =>   Note 12-1
  #   [ref:lis-my-listing]       =>   Listing 12-1
  #   [ref:exe-my-exercise]      =>   Exercise 12-1
  #
  # Note: The first three characters in the label (e.g. tab, fig, sli,
  # dem, not, lis, and exe) are NOT significant.  I've chosen these
  # labels for convenience only.
  #
  # !!! BUG HERE !!!
  #
  # This block of code doesn't recognize references written with only
  # an 'r' (e.g., [r:fig-my-figure]).  See the "escape_html"
  # subroutine for an example of how this should be written.
  #
  #
  while ($text =~ /\[ref:(.*?)\]/) {
    my $label    = $1;
    my $type     = $label{$label}{'type'}            || 'unknown';
    my $name     = $label{$label}{'name'}            || 'unknown';
    my $toplevel = $label{$label}{'topnum'}          || '0';
    my $secnum   = $label{$label}{'secnum'}          || '0.0.0';
    my $number   = $label{$label}{'number'}          || '0-0';

    $name = ucfirst $name;

    if ($type eq 'environment') {
      my $target = "#$name.$number";
      $text =~ s/\[ref:(.*?)\]/<a href=\"$target\">$name $number<\/a>/;
    }

    else {
      my $target = "#$name.$secnum";
      $text =~ s/\[ref:(.*?)\]/<a href=\"$target\">$name $secnum<\/a>/;
    }
  }

  #-------------------------------------------------------------------
  # References (id)
  #
  #     Resolve inline references (i.e. [id:rq-000023]).  References
  #     are replaced with hyperlinked ID as follows:
  #
  #         [id:rq-000023]         =>   rq-000023
  #
  while ($text =~ /\[id:(.*?)\]/) {

    my $label = trim_whitespace($1);

    my $type     = $label{$label}{'type'}   || 'unknown';
    my $name     = $label{$label}{'name'}   || 'unknown';
    my $toplevel = $label{$label}{'topnum'} || '0';
    my $secnum   = $label{$label}{'secnum'} || '0.0.0';
    my $number   = $label{$label}{'number'} || '0-0';

    $name = ucfirst $name;

    # Label exists?
    #
    if ( label_exists($label) ) {

      # Section Number
      #
      #     If this label refers to an environment (i.e. table,
      #     figure, attachment, listing, preformatted, etc.) use the
      #     name and number (i.e. table.2-3) otherwise, use the name
      #     and section number (i.e. section.2-3-12).
      #
      if ($type eq 'environment' or $type eq 'region') {
	my $target = "#$name.$number";
	$text =~ s/\[id:(.*?)\]/<a href=\"$target\">$label<\/a>/;
      }

      else {
	my $target = "#$name.$secnum";
	$text =~ s/\[id:(.*?)\]/<a href=\"$target\">$label<\/a>/;
      }

    }

    # Label doesn't exist
    #
    else {
      printwarning("broken reference: $label");
      $text =~ s/\[id:(.*?)\]/<font color="red">(broken reference to $label)<\/font>/;
    }
  }

  #-------------------------------------------------------------------
  # Resolve citations (i.e. [cite:lamport96]).  Citations are replaced
  # with hyperlinked text as follows:
  #
  #   [cite:Lamport96]                => Lamport96
  #   [cite:Lamport96,pages~161-164]  => Lamport96 (pages 161-164)
  #
  while ($text =~ /\[cite:(.*?)\]/) {
    my $label = $1;
    $label =~ s/~/ /g;
    my ($cite,$other) = split(/\s*,\s*/, $label);
    my $target = "$output_file.source.html#$cite";

    if ($other) {
      $text =~ s/\[cite:(.*?)\]/\[<a href=\"$target\">$cite, $other<\/a>\]/;
    }

    else {
      $text =~ s/\[cite:(.*?)\]/\[<a href=\"$target\">$cite<\/a>\]/;
    }
  }

  #-------------------------------------------------------------------
  # !!! BUG HERE !!!
  #
  # Consider adding other forms of references like title references
  # that will render the title of the referenced text elelement.
  # -------------------------------------------------------------------
  # I need an internal linking mechanism that enables my to hyperlink
  # arbitrary text to any label in the document.  Perhaps:
  #
  #    [tab-my-problems: My Basic Problems]
  #
  # In this case, the publisher would simply hyperlink the text "My
  # Basic Problems" to a target in the document corresponding to
  # the label "tab-my-problems".  Other possiblities are:
  #
  #    [title:tab-my-problems]
  #
  #    and
  #
  #    [tab-my-problems]
  #
  # Insert a link where the text is the title (title) of the table
  # with the "tab-my-problems" label and a link to that location
  # in the document.
  #
  #    [page:tab-my-problems]
  #
  # Insert a hyperlinked page number to the page containing the table.
  # In an HTML context you might just use "click here" in place of the
  # page number.

  #-------------------------------------------------------------------
  # look for "steps"
  #
  if ($text =~ /^step:/i) {
    $text =~ s/^step:/<checkbox\/>STEP $count{'step'}{'section'} - /;
  }

  return $text;
}

######################################################################

sub escape_latex {

  my $text = shift;

  # printdebug("escape_latex: $text") if $DEBUGGING;

  $text = remove_newlines($text);

  #-------------------------------------------------------------------
  # Literal strings (part 1)
  #
  #     Look for strings to be literally interpretted like
  #     [lit:__init__.py] which will be literally interpretted rather
  #     than underlining the word `init'.
  #
  #     This is a two part process.  In this first part, we'll
  #     substitute the literal string with a place-holder
  #     (LITERAL-STRING-1, LITERAL-STRING-2, etc).  In the second part
  #     at the end of this function, we'll replace these placeholders
  #     with the actual literal text.
  #
  #     LIMITATION: literal strings cannot cross line boundaries!!!
  #
  #     LIMITATION: only one literal string per line!!!
  #
  my $literals  = 0;  # detect presence of literal strings
  my @literal   = (); # array of literal strings
  my $lsc       = 0;  # literal string count
  while ($text =~ /\{lit:(.*?)\}/) {
    my $string = $1;
    $literals  = 1;   # found a literal string
    $literal[$lsc] = $string;
    $text =~ s/\{lit:(.*?)\}/LITERAL-STRING-$lsc/;
    ++ $lsc;
  }

  #-------------------------------------------------------------------
  # LaTeX Special Characters
  #
  #     The backslash must be escaped first otherwise the backslashes
  #     used to escape other special characters (like curly braces)
  #     will themselves get escaped and mess everything up!
  #
  if ($text =~ /\\/) {
    ++ $count{'mathsymbol'}{'total'};
    $text =~ s/\\/\$\\backslash\$/g;
  }
  $text =~ s/\{/\\\{/g;
  $text =~ s/\}/\\\}/g;

  #-------------------------------------------------------------------
  # Special Characters (escape them)
  #
  $text =~ s/\$/\\\$/g;
  $text =~ s/%/\\%/g;
  $text =~ s/#/\\#/g;
  $text =~ s/&/\\&/g;
  $text =~ s/\^/\\^/g;
  $text =~ s/_/\\_/g;

  #-------------------------------------------------------------------
  # Footnote References
  #
  #     A footnote reference is a "[f]".
  #
  #     This block of code has to go *after* the preceeding three
  #     LaTeX special character text substitutions ('{','}', and '\'})
  #     because these special characters are used to place the
  #     footnote into the TeX source.  If any of these special
  #     characters are in the footnote text, they will be escaped
  #     *inside* this block of code.
  #
  while ($text =~ /\S.*?\[f:(\S+?):(\S+?)\]/) {

    my $label = $1;
    my $tag   = $2;

    ++ $count{'footnote'}{'total'};

    # insert the footnote text (gathered during PASS 2) into the
    # latex file
    #
    my $num           = $count{'footnote'}{'total'};
    my $footnote_text = '';

    if ( exists $footnote{$label}{$tag} ) {
      $footnote_text = escape_latex( $footnote{$label}{$tag} );
    }

    else {
      printerror("escape_latex: footnote $label $tag does not exist");
    }

    if ($DEBUGGING) {
      printdebug("escape_latex: inserting footnote $label $tag $text");
    }

    $text =~ s/\[f:(\S+?):(\S+?)\]/\\footnote{$footnote_text}/;
  }

  #-------------------------------------------------------------------
  # Take Note! Indicators
  #
  #     If the author of the document put "[[take_note]]" in the text,
  #     then put a writing hand in the margin.
  #
  $text =~ s/\[\[take_note\]\]/\\marginpar{\\Huge\\Writinghand}/g;

  #-------------------------------------------------------------------
  # Section Signs
  #
  #     If the author of the document put "[[section]]" in the text,
  #     then replace it with a section sign (\S).
  #
  $text =~ s/\[\[section\]\]/{\\S}/g;

  #-------------------------------------------------------------------
  # Single Tildes
  #
  #     Escape single tildes but not double tildes. (a double tilde
  #     represents the beginning or ending of italicized text, so
  #     leave double tilde's alone).
  #
  #     Ignore single tildes within URLs.  The LaTeX URL package
  #     handles these correctly.
  #
  unless (
	  $text =~ /\[url:.*?[^~]~[^~].*?\]/
	  or
	  $text =~ /\\url{.*?[^~]~[^~].*?}/
	 ) {
    $text =~ s/([^~])~([^~])/$1\$\\sim\$$2/g;
  }

  #-------------------------------------------------------------------
  # Smileys and Frownys
  #
  $text =~ s/:-\)/{\\large\\Smiley}/g;
  $text =~ s/:-\(/{\\large\\Frowny}/g;

  #-------------------------------------------------------------------
  # Keystroke Indicators
  #
  #     All on one line...
  #
  if ($text =~ /\[\[(.*?)\]\]/) {
    ++ $count{'keystroke'}{'total'};
    $text =~ s/\[\[(.*?)\]\]/\\keystroke{$1}/g;
  }

  #     Begins on one line...
  #
  if ($text =~ /\[\[(.*)$/) {
    ++ $count{'keystroke'}{'total'};
    $text =~ s/\[\[(.*?)$/\\keystroke{$1/;
    $in{'keystroke'} = 1;
  }

  #     ...And ends on another...
  #
  if ($text =~ /^(.*?)\]\]/ and $in{'keystroke'}) {
    $text =~ s/^(.*?)\]\]/$1}/;
    $in{'keystroke'} = 0;
  }

  #-------------------------------------------------------------------
  # Glossary Terms (g or gls)
  #
  #     This block of code looks for glossary terms that occur all on
  #     one line:
  #
  #     [g:Perl]
  #     [g:ieee:configuration item]
  #     [gls:Perl]
  #
  while ($text =~ /\[(g|gls):(([^ \t\n\r\f\]]*?):)?\s*(.*?)\s*\]/) {

    my $alt          = $3 || '';
    my $escaped_term = $4;

    # replace ampersands escaped earlier in the term
    #
    my $term = $escaped_term;

    $term =~ s/\\&/ and /g;

    if ( term_in_glossary($term,$alt) ) {
      $text =~ s/\[(g|gls):.*?\]/\\gls{$term:$alt}/;
    }

    else {
      printwarning("escape_latex: no glossary entry for \"$alt:$term\"");
      $text =~ s/\[(g|gls):.*?\]/$term/;
    }
  }

  #-------------------------------------------------------------------
  # Glossary: Split Terms (Second Half) (g or gls)
  #
  #     Handle instances when glossary terms begin at the end of one
  #     line, then end at the beginning of the next line (i.e. the
  #     term is split across a newline boundary).
  #
  #     This first block of code looks for the end of a term, started
  #     on the previous line, at the beginning of this line.
  #
  if ( $in{'glossary_term'} and $text =~ /^\s*(.*?)\s*\]/ ) {

    my $remainder      = $1;
    my ($partial,$alt) = @{ $current{'glossary_partial_term'} };
    my $escaped_term   = "$partial $remainder";

    # replace ampersands escaped earlier in the term
    #
    my $term = $escaped_term;
    $term =~ s/\\&/ and /g;

    # term in glossary?
    #
    if ( term_in_glossary($term,$alt) ) {
      $text =~ s/^(.*?)\]/\\gls{$term:$alt}/;
    }

    # term NOT in glossary
    #
    else {
      printwarning("escape_latex: no glossary entry for \"$alt:$term\"");
      $text =~ s/^(.*?)\]/$term/;
    }

    $in{'glossary_term'} = 0;

  }

  #-------------------------------------------------------------------
  # Glossary: Split Terms (First Half) (g or gls)
  #
  #     This block of code looks for the beginning of a split term at
  #     the end of this line.
  #
  if ( $text =~ /\[(g|gls):(([^ \t\n\r\f\]]*?):)?\s*(.*?)\s*$/ ) {

    my $alt     = $3 || '';
    my $partial = $4;

    $current{'glossary_partial_term'} = [$partial,$alt];

    $in{'glossary_term'} = 1;

    $text =~ s/\[(g|gls):.*?$//;

  }

  #-------------------------------------------------------------------
  # Glossary Terms (G or Gls)
  #
  #     This block of code looks for glossary terms that occur all on
  #     one line:
  #
  #     [G:Perl]
  #     [G:ieee:configuration item]
  #     [Gls:Perl]
  #
  while ($text =~ /\[(G|Gls):(([^ \t\n\r\f\]]*?):)?\s*(.*?)\s*\]/) {

    my $alt          = $3 || '';
    my $escaped_term = $4;

    # replace ampersands escaped earlier in the term
    #
    my $term = $escaped_term;
    $term =~ s/\\&/ and /g;

    if ( term_in_glossary($term,$alt) ) {
      $text =~ s/\[(G|Gls):(.*?)\]/\\Gls{$term:$alt}/;
    }
    else {
      printwarning("escape_latex: no glossary entry for \"$alt:$term\"");
      my $ucf_term = ucfirst($term);
      $text =~ s/\[(G|Gls):(.*?)\]/$ucf_term/;
    }
  }

  #-------------------------------------------------------------------
  # Glossary: Split Terms (Second Half) (G or Gls)
  #
  #     Handle instances when glossary terms begin at the end of one
  #     line, then end at the beginning of the next line (i.e. the
  #     term is split across a newline boundary).
  #
  #     This first block of code looks for the end of a term, started
  #     on the previous line, at the beginning of this line.
  #
  if ( $in{'Glossary_term'} and $text =~ /^\s*(.*?)\s*\]/ ) {

    my $remainder      = $1;
    my ($partial,$alt) = @{ $current{'Glossary_partial_term'} };
    my $escaped_term   = "$partial $remainder";

    # replace ampersands escaped earlier in the term
    #
    my $term = $escaped_term;
    $term =~ s/\\&/ and /g;

    # term in glossary?
    #
    if ( term_in_glossary($term,$alt) ) {
      # my $ucf_term = ucfirst($term);
      $text =~ s/^(.*?)\]/\\Gls{$term:$alt}/;
    }

    # term NOT in glossary
    #
    else {
      printwarning("escape_latex: no glossary entry for \"$alt:$term\"");
      my $ucf_term = ucfirst($term);
      $text =~ s/^(.*?)\]/$ucf_term/;
    }

    $in{'Glossary_term'} = 0;

  }

  #-------------------------------------------------------------------
  # Glossary: Split Terms (First Half) (G or Gls)
  #
  #     This block of code looks for the beginning of a split term at
  #     the end of this line.
  #
  if ( $text =~ /\[(G|Gls):(([^ \t\n\r\f\]]*?):)?\s*(.*?)\s*$/ ) {

    my $alt     = $3 || '';
    my $partial = $4;

    $current{'Glossary_partial_term'} = [$partial,$alt];

    $in{'Glossary_term'} = 1;

    $text =~ s/\[(G|Gls):(.*?)$//;

  }

  #-------------------------------------------------------------------
  # Glossary Definitions (def)
  #
  #     This block of code looks for glossary definition references
  #     that occur all on one line:
  #
  #     [d:Perl]
  #     [d:ieee:Perl]
  #     [def:Perl]
  #
  while ( $text =~ /\[def:(([^ \t\n\r\f\]]*?):)?\s*(.*?)\s*\]/ ) {

    my $alt   = $2 || '';
    my $term  = $3;
    my $latex = '';

    # replace '\&' with '&' in term
    $term =~ s/\\&/&/g;

    if ( term_in_glossary($term,$alt) ) {
      $latex = escape_latex($glossary{$term}{$alt});
      $text =~ s/\[def:.*?\]/$latex/;
    }

    else {
      $text =~ s/\[def:.*?\]/(missing $alt definition of $term)/;
      printwarning("escape_html: no glossary entry for \"$alt:$term\"");
    }
  }

  #-------------------------------------------------------------------
  # Glossary: Split Definition References (def)
  #
  #     Handle instances when glossary definition references begin at
  #     the end of one line, then end at the beginning of the next
  #     line (i.e. the reference is split across a newline boundary).
  #
  #     This first block of code looks for the end of a definition
  #     reference, started on the previous line, at the beginning of
  #     this line.
  #
  if ( $in{'glossary_def'} and $text =~ /^\s*(.*?)\s*\]/ ) {

    my $remainder      = $1;
    my ($partial,$alt) = @{ $current{'glossary_partial_def'} };
    my $term           = "$partial $remainder";
    my $latex          = '';

    if ( term_in_glossary($term,$alt) ) {
      $latex = escape_latex($glossary{$term}{$alt});
      $text =~ s/^(.*?)\]/$latex/;
    }

    else {
      printwarning("escape_latex: no glossary entry for \"$alt:$term\"");
      $text =~ s/^(.*?)\]/(missing $alt definition of $term)/;
    }

    $in{'glossary_def'} = 0;

  }

  #-------------------------------------------------------------------
  # Glossary: Split Definition References (def)
  #
  #     This block of code looks for the beginning of a split term at
  #     the end of this line.
  #
  if ( $text =~ /\[def:(([^ \t\n\r\f\]]*?):)?\s*(.*?)\s*$/ ) {

    my $alt     = $2 || '';
    my $partial = $3;

    $current{'glossary_partial_def'} = [$partial,$alt];

    $in{'glossary_def'} = 1;

    $text =~ s/\[def:.*?$//;

  }

  #-------------------------------------------------------------------
  # Variable
  #
  #     This block of code looks for variable references that occur
  #     all on one line:
  #
  #     [var:truth-count]
  #
  while ($text =~ /\[var:(.*?)\]/) {
    my $name = $1;
    if ( defined $variable{$name} ) {
      my $value = escape_latex($variable{$name});
      $text =~ s/\[var:(.*?)\]/$value/;
    }
    else {
      printwarning("escape_latex: no variable named \"$name\" in \"$text\"");
      $text =~ s/\[var:(.*?)\]/$name/;
    }
  }

  #-------------------------------------------------------------------
  # Variable: Split References (Second Half)
  #
  #     Handle instances when variable references begin at the end of
  #     one line, then end at the beginning of the next line (i.e. the
  #     variable reference is split across a newline boundary).
  #
  #     This first block of code looks for the end of a variable
  #     reference, started on the previous line, at the beginning of
  #     this line.
  #
  if ( $in{'var_name'} and $text =~ /^(.*?)\]/ ) {

    my $remainder = trim_whitespace($1);
    my $partial   = $current{'var_name'};
    my $name      = $partial . $remainder;

    # variable defined?
    #
    if ( defined $variable{$name} ) {
      my $value = $variable{$name};
      $text =~ s/^(.*?)\]/$value/;
    }

    # variable not defined
    #
    else {
      printwarning("escape_latex: no variable named \"$name\" in \"$text\"");
      $text =~ s/^(.*?)\]/$name/;
    }

    $in{'var_name'} = 0;

  }

  #-------------------------------------------------------------------
  # Variable: Split References (First Half)
  #
  #     This block of code looks for the beginning of a split variable
  #     reference at the end of this line.
  #
  if ( $text =~ /\[var:(.*?)$/ ) {

    my $partial = trim_whitespace($1);
    $current{'var_name'} = $partial;

    $in{'var_name'} = 1;

    $text =~ s/\[var:(.*?)$//;

  }

  #-------------------------------------------------------------------
  # Lookup
  #
  #     This block of code looks for lookup replacements that occur
  #     all on one line:
  #
  #     [lookup:ci-000638:Manufacturer]
  #     [l:ci-000638:Manufacturer]
  #
  while ( $text =~ /\[(lookup|l):([^:]+):(.*?)\]/ ) {

    my $element = $2;
    my $label   = $3;
    my $name    = name_for($label);

    # Element may be a simple pre-defined data element
    #
    if ( defined $lookup{$label}{$element} ) {

      # Determine whether this data element is multi-valued
      #
      my $is_multivalued = 0;
      # if ( $structure{$name}{'elements'}{$element}{'multivalued'} ) {
      # 	$is_multivalued = 1;
      # }

      if ( ref $lookup{$label}{$element} eq 'ARRAY' ) {
	$is_multivalued = 1;
      }

      # If the data element is NOT multivalued...
      #
      if (not $is_multivalued) {
	my $value = escape_latex($lookup{$label}{$element});
	$text     =~ s/\[(lookup|l):([^:]+):(.*?)\]/$value/;
      }

      # If the data element IS multivalued...
      #
      else {
	my @value = @{ $lookup{$label}{$element} };
	my $value = join(' -- ',@value);
	$value    = escape_latex($value);
	$text     =~ s/\[(lookup|l):([^:]+):(.*?)\]/$value/;
      }

    }

    # Element is 'status'
    #
    elsif ($element eq 'status') {
      my $value = status_of($label);
      $text     =~ s/\[(lookup|l):([^:]+):(.*?)\]/$value/;
    }

    # Element may be a user-defined attribute
    #
    else {

      if ( defined $attribute{$label}{$element} ) {
	my @value = @{ $attribute{$label}{$element} };
	my $value = join(' -- ',@value);
	$value    = escape_latex($value);
	$text     =~ s/\[(lookup|l):([^:]+):(.*?)\]/$value/;
      }

      else {
	printwarning("escape_latex: no lookup value for \"$label\" \"$element\"");
	$text =~ s/\[(lookup|l):([^:]+):(.*?)\]/?/;
      }
    }
  }

  #-------------------------------------------------------------------
  # Enter - text to be entered by the user
  #
  #     This block of code looks for text to be entered by the user
  #     that occurs all on one line:
  #
  #     [enter:your name here]
  #     [en:your name here]
  #
  #     Text to be entered by the user is rendered in a bold
  #     constant-width font.
  #
  while ( $text =~ /\[(enter:|en:)(.*?)\]/ ) {
    my $string = $2;
    $text =~ s/\[(enter:|en:)(.*?)\]/\\textbf{\\texttt{$string}}/;
  }

  #-------------------------------------------------------------------
  # Enter - split across newline boundary (end)
  #
  #     Handle instances when text to be entered by the user begins at
  #     the end of one line, and ends at the beginning of a subsequent
  #     line (i.e. the text is split across one or more newline
  #     boundaries).
  #
  #     This first block of code looks for the end of text to be
  #     entered by the user, started on the previous line, at the
  #     beginning of this line.
  #
  if ( $in{'user_entered_text'} and $text =~ /^(.*?)\]/ ) {

    my $remainder = trim_whitespace($1);
    my $partial   = $current{'user_entered_text_partial'};
    my $string    = $partial . $remainder;

    $text =~ s/^(.*?)\]/\\textbf{\\texttt{$string}}/;

    $in{'user_entered_text'} = 0;

  }

  #-------------------------------------------------------------------
  # Enter - split across newline boundary (begin)
  #
  #     This block of code looks for the beginning of a split region
  #     of text to be entered by the user at the end of this line.
  #
  if ( $text =~ /\[(enter:|en:)(.*?)$/ ) {

    $current{'user_entered_text_partial'} = trim_whitespace($2);

    $in{'user_entered_text'} = 1;

    $text =~ s/\[(enter:|en:)(.*?)$//;

  }

  #-------------------------------------------------------------------
  # Acronyms
  #
  #     This block of code looks for acronyms.  Acronyms cannot span
  #     line endings.
  #
  #     [ac:TLA]
  #     [acs:TLA]
  #     [acl:TLA]
  #
  while ($text =~ /\[(ac|acs|acl):(.*?)\]/) {
    my $tag  = $1;
    my $term = $2;
    if ( acronym_defined($term) ) {
      $text =~ s/\[(ac|acs|acl):(.*?)\]/\\$tag\{$term\}/;
    }
    else {
      printwarning("escape_latex: no acronym definition for \"$term\"");
      $text =~ s/\[(ac|acs|acl):(.*?)\]/$term/;
    }
  }

  #-------------------------------------------------------------------
  # References: All on one line (ref, r)
  #
  while ($text =~ /\[(r:|ref:)(.*?)\]/) {

    my $label    = trim_whitespace($2);
    my $name     = $label{$label}{'name'} || 'unknown';

    if ( $name eq 'section' ) {
      my $sectype = $label{$label}{'sectype'};
      if ($sectype) {
	$name = $sectype;
      }
    }

    my $ucf_name = ucfirst $name;

    # Label exists?
    #
    if ( label_exists($label) ) {
      $text =~ s/\[(r:|ref:)(.*?)\]/$ucf_name~\\vref{$label}/;
    }

    # Label doesn't exist
    #
    else {
      printwarning("escape: broken reference: $label");
      $text =~ s/\[(r:|ref:)(.*?)\]/(broken reference to $label)/;
    }
  }

  #-------------------------------------------------------------------
  # References: Split (First Half)
  #
  if ( $text =~ /\[(r:|ref:)(.*?)$/ ) {
    my $partial = trim_whitespace($2);
    $current{'partial_reference'} = $partial;
    $in{'reference'} = 1;
    $text =~ s/\[(r:|ref:)(.*?)$//;
  }

  #-------------------------------------------------------------------
  # References: Split (Second Half)
  #
  #     Handle instances when references begin at the end of one line,
  #     then end at the end of the next line (i.e. the reference is
  #     split across a newline boundary).
  #
  if ( $in{'reference'} and $text =~ /^(.*?)\]/ ) {

    my $remainder = trim_whitespace($1);
    my $partial   = $current{'partial_reference'};
    my $label     = "$partial $remainder";

    my $name    = $label{$label}{'name'} || 'Section';
    my $sectype = $label{$label}{'sectype'};

    if ($sectype eq 'chapter' or $sectype eq 'appendix') {
      $name = $sectype;
    }

    $name  = ucfirst($name);

    $label = trim_whitespace($label);

    # Label exists?
    #
    if ( label_exists($label) ) {
      $text =~ s/^(.*?)\]/$name~\\vref{$label}/;
    }

    # Label doesn't exist
    #
    else {
      printwarning("escape_latex: broken reference: $label");
      $text =~ s/^(.*?)\]/(broken reference to $label)/;
    }

    $in{'reference'} = 0;

  }

  #-------------------------------------------------------------------
  # References: All on one line (id)
  #
  while ($text =~ /\[id:(.*?)\]/) {

    my $label = trim_whitespace($1);

    # Label exists?
    #
    if ( label_exists($label) ) {
      $text =~ s/\[id:(.*?)\]/\\hyperref[$label]{$label}/;
    }

    # Label doesn't exist
    #
    else {
      printwarning("escape_latex: broken reference: $label");
      $text =~ s/\[id:(.*?)\]/(broken reference to $label)/;
    }
  }

  #-------------------------------------------------------------------
  # References: Split (First Half) (id)
  #
  if ( $text =~ /\[id:(.*?)$/ ) {
    my $partial = trim_whitespace($1);
    $current{'partial_idreference'} = $partial;
    $in{'idreference'} = 1;
    $text =~ s/\[id:(.*?)$//;
  }

  #-------------------------------------------------------------------
  # References: Split (Second Half) (id)
  #
  #     Handle instances when references begin at the end of one line,
  #     and end at the beginning of the next line (i.e. the reference
  #     is split across a newline boundary).
  #
  if ( $in{'idreference'} and $text =~ /^(.*?)\]/ ) {

    my $remainder = trim_whitespace($1);
    my $partial   = $current{'partial_idreference'};

    # !!! BUG HERE !!!
    #
    # Should we really insert a space into a label (i.e., between
    # $partial and $remainder)?

    my $label     = "$partial $remainder";

    $label = trim_whitespace($label);

    # Label exists?
    #
    if ( label_exists($label) ) {
      $text =~ s/^(.*?)\]/$label~\\vref{$label}/;
    }

    # Label doesn't exist
    #
    else {
      printwarning("escape_latex: broken reference: $label");
      $text =~ s/^(.*?)\]/(broken reference to $label)/;
    }

    $in{'idreference'} = 0;

  }

  #-------------------------------------------------------------------
  # Citations
  #
  while ($text =~ /\[(c:|cite:)(.*?)\]/) {

    my $citation = trim_whitespace($2);

    my $label = '';
    my $other = '';
    if ($citation =~ /(.*?),(.*)/) {
      $label = trim_whitespace($1);
      $other = trim_whitespace($2);
    } else {
      $label = trim_whitespace($citation);
    }

    # cited source exists?
    #
    if ( source_exists($label) ) {

      if ($other) {
	$text =~ s/\[(c:|cite:)(.*?)\]/\\cite\[$other\]\{$label\}/;
      }

      else {
	$text =~ s/\[(c:|cite:)(.*?)\]/\\cite\{$label\}/;
      }
    }

    # cited source DOESN'T exist
    #
    else {

      printwarning("escape_latex: broken citation: $label");
      $text =~ s/\[(c:|cite:)(.*?)\]/(broken citation to $citation)/;
    }
  }

  #-------------------------------------------------------------------
  # Citations: Split (Second Half)
  #
  #     Handle instances when citations begin at the end of one line,
  #     then end at the end of the next line (i.e. the citation is
  #     split across a newline boundary).
  #
  if ( $in{'citation'} and $text =~ /^(.*?)\]/ ) {

    my $remainder = trim_whitespace($1);
    my $partial   = $current{'partial_citation'};
    my $citation  = "$partial $remainder";

    my ($cite,$other) = split(/,/, $citation);

    $cite  = trim_whitespace($cite);
    $other = trim_whitespace($other);

    # cited source exists?
    #
    if ( source_exists($cite) ) {
      if ($other) {
	$text =~ s/^(.*?)\]/\\cite\[$other\]\{$cite\}/;
      }
      else {
	$text =~ s/^(.*?)\]/\\cite\{$cite\}/;
      }
    }

    # cited source DOESN'T exist
    #
    else {
      printwarning("broken citation: $cite");
      $text =~ s/^(.*?)\]/(broken citation to $cite)/;
    }

    $in{'citation'} = 0;

  }


  #-------------------------------------------------------------------
  # Citations: Split (First Half)
  #
  if ( $text =~ /\[(c:|cite:)(.*?)$/ ) {
    my $partial = trim_whitespace($2);
    $current{'partial_citation'} = $partial;
    $in{'citation'} = 1;
    $text =~ s/\[(c:|cite:)(.*?)$//;
  }

  #-------------------------------------------------------------------
  # Index Entries
  #
  #     [i:Perl]
  #     [index:Perl]
  #
  while ($text =~ /\[(i:|index:)(.*?)\]/) {
    my $term = trim_whitespace($2);
    ++ $count{'index'}{'total'};
    $text =~ s/\[(i:|index:)(.*?)\]/$term \\index{$term}/;
  }

  #-------------------------------------------------------------------
  # Horizontal Rules
  #
  #    Three or more underscores should be turned into a horizontal
  #    rule
  #
  while ($text =~ /(_{3,})/) {
    my $underscores = $1;
    my $count       = length($underscores) / 2;
    $text =~ s/_{3,}/\\rule{${count}em}{0.5pt}/;
  }

  #-------------------------------------------------------------------
  # Underline
  #
  while ($text =~ /[^\_\s]\\_\\_/ or $text =~ /\\_\\_[^\_\s]/) {

    if (not $in{'latex_u'}) {
      $text =~ s/([^\_\s]?)\\_\\_([^\_\s])/$1\\underline\{$2/;
      $in{'latex_u'} = 1;
    }

    else {
      $text =~ s/([^\_\s]?)\\_\\_([^\_\s]?)/$1\}$2/;
      $in{'latex_u'} = 0;
    }
  }

  #-------------------------------------------------------------------
  # Superscript (^^)
  #
  while ($text =~ /[^\^]\\\^\\\^/ or $text =~ /\\\^\\\^[^\^]/) {

    if (not $in{'latex_sup'}) {
      $text =~ s/([^\^]?)\\\^\\\^([^\^])/$1\\textsuperscript\{$2/;
      $in{'latex_sup'} = 1;
    }

    else {
      $text =~ s/([^\^\s]?)\\\^\\\^([^\^]?)/$1\}$2/;
      $in{'latex_sup'} = 0;
    }
  }

  #-------------------------------------------------------------------
  # Subscript (,,)
  #
  while ($text =~ /[^\,]\,\,/ or $text =~ /\,\,[^\,]/) {

    if (not $in{'latex_sub'}) {
      $text =~ s/([^\,]?)\,\,([^\,])/$1\\subscript\{$2/;
      $in{'latex_sub'} = 1;
    }

    else {
      $text =~ s/([^\,]?)\,\,([^\,]?)/$1\}$2/;
      $in{'latex_sub'} = 0;
    }
  }

  #-------------------------------------------------------------------
  # Italics
  #
  while ($text =~ /[^\~\s]\~\~/ or $text =~ /\~\~[^\~\s]/) {

    if (not $in{'latex_i'}) {
      $text =~ s/([^\~\s]?)\~\~([^\~\s])/$1\\textit\{$2/;
      $in{'latex_i'} = 1;
    }

    else {
      $text =~ s/([^\~\s]?)\~\~([^\~\s]?)/$1\}$2/;
      $in{'latex_i'} = 0;
    }
  }

  #-------------------------------------------------------------------
  # Arrows (right and left)
  #
  if (($text =~ /->/) or ($text =~ /<-/)) {
    ++ $count{'mathsymbol'}{'total'};
    $text =~ s/->/\$\\rightarrow\$/g;
    $text =~ s/<-/\$\\leftarrow\$/g;
  }

  #-------------------------------------------------------------------
  # Symbols
  #
  $text =~ s/</\$<\$/g;
  $text =~ s/>/\$>\$/g;
  $text =~ s/\bLaTeX\b/\\LaTeX{}/g;
  $text =~ s/\bTeX\b/\\TeX{}/g;
  $text =~ s/\[c\]/\\tiny\$^{\\copyright}\$\\normalsize/ig;
  $text =~ s/\[r\]/\\tiny\$^{\\textregistered}\$\\normalsize/ig;
  $text =~ s/\[tm\]/\\tiny\$^{\\texttrademark}\$\\normalsize/ig;

  #-----------------------------------------------------------------
  # Bold (**)
  #
  while ($text =~ /[^\*\s]\*\*/ or $text =~ /\*\*[^\*\s]/) {

    if (not $in{'latex_b'}) {
      $text =~ s/([^\*\s]?)\*\*([^\*\s])/$1\\textbf\{$2/;
      $in{'latex_b'} = 1;
    }

    else {
      $text =~ s/([^\*\s]?)\*\*([^\*\s]?)/$1\}$2/;
      $in{'latex_b'} = 0;
    }
  }

  #-----------------------------------------------------------------
  # Bold (!!)
  #
  while ($text =~ /[^\!\s]\!\!/ or $text =~ /\!\![^\!\s]/) {

    if (not $in{'latex_b'}) {
      $text =~ s/([^\!\s]?)\!\!([^\!\s])/$1\\textbf\{$2/;
      $in{'latex_b'} = 1;
    }

    else {
      $text =~ s/([^\!\s]?)\!\!([^\!\s]?)/$1\}$2/;
      $in{'latex_b'} = 0;
    }
  }

  #-------------------------------------------------------------------
  # Typewriter Text (||)
  #
  while ($text =~ /[^\|\s]\|\|/ or $text =~ /\|\|[^\|\s]/) {

    if (not $in{'latex_tt'}) {
      $text =~ s/([^\|\s]?)\|\|([^\|\s])/$1\\texttt\{$2/;
      $in{'latex_tt'} = 1;
    }

    else {
      $text =~ s/([^\|\s]?)\|\|([^\|\s]?)/$1\}$2/;
      $in{'latex_tt'} = 0;
    }
  }

  #-------------------------------------------------------------------
  # Raw Backslashes (fix them)
  #
  $text =~ s/\\\$\\backslash\\\$/\$\\backslash\$/g;

  #-------------------------------------------------------------------
  # Single Vertical Pipes (escape them)
  #
  if (not $in{'pre'}) {
    $text =~ s/([^|])\|([^|])/$1\$\\vert\$$2/g;
  }

  #-------------------------------------------------------------------
  # Steps
  #
  if ($text =~ /^step::/i) {
    $text =~ s/^step::/\\step{$count{'step'}{'section'}}/;
  }

  #-------------------------------------------------------------------
  # URL
  #
  #     Handle instances when URLs occur all on one line.
  #
  while ($text =~ /\[url:(.*?)\]/) {

    my $url = $1;

    # escape un-escaped percent signs
    #
    $url =~ s/([^\\])%/$1\\%/g;

    # replace previously escaped characters
    #
    $url =~ s/~{ }/~/g;
    $url =~ s/\\&/&/g;

    $text =~ s/\[url:(.*?)\]/\\urlstyle{sf}\\url{$url}/g;
  }

  #-------------------------------------------------------------------
  # URL: Split (Second Half)
  #
  #     Handle instances when URLs begin at the end of one line, then
  #     end at the beginning of the next line (i.e. the URL is split
  #     across a newline boundary).
  #
  if ($text =~ /^(.*?)\]/ and $in{'latex_url'}) {

    my $remainder = trim_whitespace($1);
    my $partial   = $current{'partial_url'};
    my $url       = "$partial $remainder";

    # escape un-escaped percent signs
    #
    $url =~ s/([^\\])%/$1\\%/g;

    # replace previously escaped characters
    #
    $url =~ s/~{ }/~/g;
    $url =~ s/\\&/&/g;

    $text =~ s/^(.*?)\]/\\urlstyle{sf}\\url{$url}/;

    $in{'latex_url'} = 0;
  }

  #-------------------------------------------------------------------
  # URL: Split (First Half)
  #
  #     This block of code looks for the beginning of a split URL at
  #     the end of this line.
  #
  if ($text =~ /\[url:(.*)/) {
    my $partial = $1;
    $current{'partial_url'} = $partial;
    $in{'latex_url'} = 1;
  }

  #-------------------------------------------------------------------
  # Paths and Files
  #
  #     !!! Bug Here !!!
  #
  #     You can have a '\' in a path string as long as it is not the
  #     LAST character of the string.  The last character of the
  #     string cannot be a backslash.  In this (rare) case, we insert
  #     a space after that final backslash to partailly avoid the
  #     problem.  The residual problem is that the ending space
  #     appears BEFORE the backslash, not with the author intended.
  #
  #     At least this prevents the publisher from barfing all over
  #     itself while I look for an acceptable solution.
  #
  #     !!! Bug Here !!!
  #
  #     Modify code to enable [p:...] variation of inline path.
  #
  #-------------------------------------------------------------------

  # The whole path is on one line...
  #
  while ($text =~ /\[(p:|f:|path:|file:)(.*?)\]/) {

    my $string = trim_whitespace($2);

    # replace 'normal' characters escaped earlier
    #
    $string =~ s/\$\\backslash\$/\\/g;
    $string =~ s/\$>\$/>/g;
    $string =~ s/\$<\$/</g;
    $string =~ s/\\_/_/g;

    # detect presence of (and remove) trailing backslash
    #
    my $trailing_backslash = 0;
    if ($string =~ /\\$/) {
      $trailing_backslash = 1;
      $string =~ s/\\$//;
    }

    # if there was a trailing backslash, put it back AFTER the \path
    # command
    #
    if ($trailing_backslash) {
      $text =~ s/\[(p:|f:|path:|file:)(.*?)\]/\\path{$string}\$\\backslash\$/;
    }

    # otherwise don't worry about no stinkin' trailing backslash
    #
    else {
      $text =~ s/\[(p:|f:|path:|file:)(.*?)\]/\\path{$string}/;
    }
  }

  # begins on one line...
  #
  if ($text =~ /\[(p:|f:|path:|file:)(.*)/) {

    my $string = trim_whitespace($2);

    # replace 'normal' characters escaped earlier
    #
    $string =~ s/\$\\backslash\$/\\/g;
    $string =~ s/\$>\$/>/g;
    $string =~ s/\$<\$/</g;
    $string =~ s/\\_/_/g;

    $text =~ s/\[(p:|f:|path:|file:)(.*)/\\path{$string/g;

    $in{'latex_path'} = 1;
  }

  #-------------------------------------------------------------------
  # !!! bug here !!!
  #
  #    What happens when a line contains the end of one path and the
  #    beginning of another and both cross newline boudaries?
  #
  #-------------------------------------------------------------------

  # ...And ends on another...
  #
  if ($text =~ /(.*?)\]/ and $in{'latex_path'}) {

    my $string = $1;

    # replace 'normal' characters escaped earlier
    #
    $string =~ s/\$\\backslash\$/\\/g;
    $string =~ s/\$>\$/>/g;
    $string =~ s/\$<\$/</g;
    $string =~ s/\\_/_/g;

    # detect presence of (and remove) trailing backslash
    #
    $string =~ s/\\$/\\  /; # trailing backslash (BAD!!)

    $text =~ s/(.*?)\]/$string}/g;
    $in{'latex_path'} = 0;
  }

  #-------------------------------------------------------------------
  # Commands (like [cmd:ls -al])
  #
  #     All on one line...
  #
  while ($text =~ /\[cmd:(.*?)\]/) {

    my $string = trim_whitespace($1);

    # replace 'normal' characters which were escaped earlier
    #
    $string =~ s/\$\\backslash\$/\\/g;
    $string =~ s/\$>\$/>/g;
    $string =~ s/\$<\$/</g;
    $string =~ s/\$\|\$/|/g;
    $string =~ s/\\$/\\ /g;
    $string =~ s/\\\$/\$/g;
    $string =~ s/\\_/_/g;

    $text =~ s/\[cmd:(.*?)\]/\\path{$string}/;

  }

  # begins on one line...
  #
  if ($text =~ /\[cmd:(.*)/) {

    my $string = trim_whitespace($1);

    # replace 'normal' characters which were escaped earlier
    #
    $string =~ s/\$\\backslash\$/\\/g;
    $string =~ s/\$>\$/>/g;
    $string =~ s/\$<\$/</g;
    $string =~ s/\$\|\$/|/g;
    $string =~ s/\\$/\\ /g;
    $string =~ s/\\\$/\$/g;
    $string =~ s/\\_/_/g;

    $text =~ s/\[cmd:(.*)/\\path{$string/g;

    $in{'latex_cmd'} = 1;

  }

  # ...whole line within a cmd...
  #
  if ($text !~ /^[^\]]*\]/ and $in{'latex_cmd'}) {

    # replace 'normal' characters which were escaped earlier
    #
    $text =~ s/\$\\backslash\$/\\/g;
    $text =~ s/\$>\$/>/g;
    $text =~ s/\$<\$/</g;
    $text =~ s/\$\|\$/|/g;
    $text =~ s/\\$/\\ /g;
    $text =~ s/\\\$/\$/g;
    $text =~ s/\\_/_/g;

  }

  # ...And ends on another...
  #
  if ($text =~ /^([^\]]*)\]/ and $in{'latex_cmd'}) {

    my $partial = trim_whitespace($1);

    # replace 'normal' characters which were escaped earlier
    #
    $partial =~ s/\$\\backslash\$/\\/g;
    $partial =~ s/\$>\$/>/g;
    $partial =~ s/\$<\$/</g;
    $partial =~ s/\$\|\$/|/g;
    $partial =~ s/\\$/\\ /g;
    $partial =~ s/\\\$/\$/g;
    $partial =~ s/\\_/_/g;

    $text =~ s/^([^\]]*)\]/ $partial}/g;

    $in{'latex_cmd'} = 0;

  }

  #-------------------------------------------------------------------
  # Line Breaks
  #
  #     A `[linebreak]' in the SML text indicates a line break.
  #
  if ( $text =~ /\[linebreak\]/ ) {
    $text =~ s/\[linebreak\]/\\\\/g;
  }

  #-------------------------------------------------------------------
  # thepage
  #
  if ( $text =~ /\[thepage\]/ ) {
    $text =~ s/\[thepage\]/\\thepage/g;
  }

  #-------------------------------------------------------------------
  # version
  #
  if ( $text =~ /\[version\]/ ) {
    my $version = $document{'version'};
    $text =~ s/\[version\]/$version/g;
  }

  #-------------------------------------------------------------------
  # revision
  #
  if ( $text =~ /\[revision\]/ ) {
    my $revision = $document{'revision'};
    $text =~ s/\[revision\]/$revision/g;
  }

  #-------------------------------------------------------------------
  # date
  #
  if ( $text =~ /\[date\]/ ) {
    my $modified_date = '';
    if ( $document{'date'} ) {
      my $original_date = $document{'date'};
      if ( $original_date =~ /\((\w+,\s+\d+\s+\w+\s+\d+)\)/ ) {
	$modified_date = $1;
      }
      else {
	$modified_date = $original_date;
      }
    }
    $text =~ s/\[date\]/$modified_date/g;
  }

  #-------------------------------------------------------------------
  # Title References
  #
  #     [t:sec-label]
  #     [title:sec-label]
  #
  #     This block of substitution code should appear early in the
  #     subroutine so that markup in the title is escaped.
  #
  #     !!! BUG HERE !!!
  #
  #     Perhaps this subroutine should be invoked recursively to
  #     ensure all substitutions are performed.
  #
  while ($text =~ /\[(t:|title:)(.*?)\]/) {

    my $label = trim_whitespace($2);

    # Label exists?
    #
    if ( label_exists($label) ) {
      my $title = escape_latex( $lookup{$label}{'title'} );
      $text =~ s/\[(t:|title:)(.*?)\]/\\hyperref[$label]{$title}/;
    }

    # Label doesn't exist
    #
    else {
      printwarning("broken title reference: $label");
      $text =~ s/\[(t:|title:)(.*?)\]/(broken title reference to $label)/;
    }
  }

  #-------------------------------------------------------------------
  # Page References
  #
  #     [pg:sec-label]
  #     [page:sec-label]
  #
  while ($text =~ /\[(pg|page):(.*?)\]/) {

    my $label = trim_whitespace($2);

    # Label exists?
    #
    if ( label_exists($label) ) {
      $text =~ s/\[(pg|page):(.*?)\]/p. \\pageref{$label}/;
    }

    # Label doesn't exist
    #
    else {
      printwarning("broken title reference: $label");
      $text =~ s/\[(pg|page):(.*?)\]/(broken page reference to $label)/;
    }
  }

  #-------------------------------------------------------------------
  # Description References
  #
  #     [d:label]
  #     [desc:label]
  #     [description:label]
  #
  #     This block of substitution code should appear early in the
  #     subroutine so that markup in the title is escaped.
  #
  #     !!! BUG HERE !!!
  #
  #     Perhaps this subroutine should be invoked recursively to
  #     ensure all substitutions are performed.
  #
  while ($text =~ /\[(d:|desc:|description:)(.*?)\]/) {

    my $label = trim_whitespace($2);

    # Label exists?
    #
    if ( label_exists($label) ) {
      my $description = escape_latex( $lookup{$label}{'description'} );
      $text =~ s/\[(d:|desc:|description:)(.*?)\]/$description/;
    }

    # Label doesn't exist
    #
    else {
      printwarning("broken description reference: $label");
      $text =~ s/\[(d:|desc:|description:)(.*?)\]/(broken description reference to $label)/;
    }
  }

  #-------------------------------------------------------------------
  # Type References
  #
  #     [type:label]
  #
  #     Substitute an item's type.
  #
  while ($text =~ /\[type:(.*?)\]/) {

    my $label = trim_whitespace($1);

    # Label exists?
    #
    if ( label_exists($label) ) {
      my @types = @{ $lookup{$label}{'type'} };
      my $type  = join(', ',@types);
      $text =~ s/\[type:(.*?)\]/$type/;
    }

    # Label doesn't exist
    #
    else {
      printwarning("broken type reference: $label");
      $text =~ s/\[type:(.*?)\]/(broken type reference to $label)/;
    }
  }

  #-------------------------------------------------------------------
  # Owner References
  #
  #     [owner:label]
  #
  #     Substitute an item's owner.  An item can only have 1 owner.
  #
  while ($text =~ /\[owner:(.*?)\]/) {
    my $label = trim_whitespace($1);
    if ( label_exists($label) ) {
      my $owner = $lookup{$label}{'owner'};
      if ($owner) {
	if ( label_exists($owner) ) {
	  my $title = escape_latex( $lookup{$owner}{'title'} );
	  $text =~ s/\[owner:(.*?)\]/\\hyperref[$owner]{$owner} \\hyperref[$owner]{$title} (p. \\pageref{$owner})/;
	} else {
	  $text =~ s/\[owner:(.*?)\]/$owner/;
	}
      } else {
	printwarning("no owner assigned to $label");
	$text =~ s/\[owner:(.*?)\]/(no owner assigned to $label)/;
      }
    } else {
      printwarning("broken owner reference: $label");
      $text =~ s/\[owner:(.*?)\]/(broken owner reference to $label)/;
    }
  }

  #-------------------------------------------------------------------
  # Status References
  #
  #     [status:label]
  #
  #     Substitute an item's status.  An item can only have 1 status.
  #
  while ($text =~ /\[status:(.*?)\]/) {
    my $label = trim_whitespace($1);
    if ( label_exists($label) ) {
      my $status   = status_of($label) if label_exists($label);
      if ($status) {
	my $icon = latex_status_icon_for($status);
	$text =~ s/\[status:(.*?)\]/$icon/;
      } else {
	printwarning("no status assigned to $label");
	$text =~ s/\[status:(.*?)\]/(no status assigned to $label)/;
      }
    }

    elsif ( $label =~ (/(green|yellow|red|grey)/) ) {
      my $status = $label;
      my $icon = latex_status_icon_for($status);
      $text =~ s/\[status:(.*?)\]/$icon/;
    }

    else {
      printwarning("broken status reference: $label");
      $text =~ s/\[status:(.*?)\]/(broken status reference to $label)/;
    }
  }

  #-------------------------------------------------------------------
  # Literal strings (part 2)
  #
  #     In part one of this process (near the beginning of the
  #     function) literal strings were detected and replaced with
  #     special placeholders (LITERAL-STRING-1, LITERAL-STRING-2,
  #     etc).
  #
  #     In this (part 2) part of the process, we'll replace those
  #     placeholders with the original strings.
  #
  if ($literals) {
    while ($text =~ /LITERAL-STRING-(\d+)/) {
      my $lsc    = $1;  # lsc = literal string count
      my $string = $literal[$lsc];

      # There are certain characters that need to be substituted even
      # in literal text...
      #
      $string =~ s/\$/\\\$/g;                # dollar signs
      $string =~ s/\\/\$\\backslash\$/g;     # backslash
      $string =~ s/~/\$\\sim\$/g;            # tildes
      $string =~ s/#/\\#/g;                  # octothorpe
      $string =~ s/&/\\&/g;                  # ampersand
      $string =~ s/\^/\\^/g;                 # circumflex
      $string =~ s/_/\\_/g;                  # underscore
      $string =~ s/%/\\%/g;                  # percent sign
      $string =~ s/\{/\\\{/g;
      $string =~ s/\}/\\\}/g;

      $text =~ s/LITERAL-STRING-(\d+)/$string/;
    }
  }

  return $text;
}

######################################################################

sub escape_html_pre {

  # Escape certain characters in preformatted text that goes into an
  # HTML file.

  my $text = shift;

  # escape some html special characters
  #
  $text =~ s/</\&lt\;/g;
  $text =~ s/>/\&gt\;/g;

  # provide hyperlinks
  #
  $text =~ s/(\S+@\S+)/<a href=\"mailto:$1\">$1<\/a>/g;
  $text =~ s/(http:\/\/\S+?)([\s\)])/<a href=\"$1\">$1<\/a>$2/;

  # substitute footnote doohickies with a hyperlink
  #
  $text =~ s/\[f:(\S+?):(\S+?)\]/<span style=\"font-size: 8pt;\"><sup><a href="#footnote.$1.$2">$2<\/a><\/sup><\/span>/;

  return $text;
}

######################################################################

sub escape_latex_pre {

  # Escape certain characters in preformatted text that goes into a
  # LaTeX document.

  my $text = shift;

  #  $text =~ s/\\/\\\\/g;
  #  $text =~ s/\$/\\\$/g;

  return $text;
}

######################################################################

sub escape_xml_pre {

  # Escape certain characters in preformatted text that goes into an
  # XML file.

  my $text = shift;

  # escape some xml special characters
  #
  $text =~ s/</\&lt\;/g;
  $text =~ s/>/\&gt\;/g;

  # provide hyperlinks
  #
  $text =~ s/(\S+@\S+)/<link href=\"mailto:$1\">$1<\/link>/g;
  $text =~ s/(http:\/\/\S+?)([\s\)])/<link href=\"$1\">$1<\/link>$2/;

  # substitute footnote doohickies with a hyperlink
  #
  $text =~ s/\[f:(\S+?):(\S+?)\]/<link href="#footnote.$1.$2">$2<\/link>/;

  return $text;
}

######################################################################

sub escape_csv {

  my $text = shift;

  #-------------------------------------------------------------------
  # If the text contains commas or double quotes, escape the double
  # quotes and enclose the string in (non-escaped) double quotes.
  #
  if ($text =~ /[,"]/) {
    $text =~ s/"/\\"/g;
    $text = "\"" . $text . "\"";
  }

  return $text;
}

######################################################################

sub parse_csv {
  use Text::ParseWords;
  return quoteword(",",0, $_[0]);
}

######################################################################

sub escape_regexp {

  # escape special characters in strings used as regular expressions.

  my $regexp = shift;

  $regexp =~ s/\\/\\\\/g;
  $regexp =~ s/\-/\\\-/g;
  $regexp =~ s/\[/\\\[/g;
  $regexp =~ s/\]/\\\]/g;
  $regexp =~ s/\^/\\\^/g;
  $regexp =~ s/\$/\\\$/g;
  $regexp =~ s/\./\\\./g;
  $regexp =~ s/\|/\\\|/g;
  $regexp =~ s/\?/\\\?/g;
  $regexp =~ s/\*/\\\*/g;
  $regexp =~ s/\+/\\\+/g;
  $regexp =~ s/\(/\\\(/g;
  $regexp =~ s/\)/\\\)/g;
  $regexp =~ s/\{/\\\{/g;
  $regexp =~ s/\}/\\\}/g;

  return $regexp;

}

######################################################################

sub term_in_glossary {

  # If the specified term has a corresponding glossary entry return 1,
  # otherwise return 0.

  # !!! BUG HERE !!!
  #
  # Shouldn't this subroutine check the glossary data structure and
  # not the data data structure?

  my $term = shift;
  my $alt  = shift || '';

  if ( defined $data{'glossary'}{$term}{$alt} ) {
    return 1;
  } else {
    return 0;
  }

}

######################################################################

sub acronym_defined {

  # If the specified acronym has been defined return 1, otherwise
  # return 0.

  my $term = shift;
  my $alt  = shift;

  if ( exists $data{'acronym'}{$term}{$alt} ) {
    return 1;
  }

  else {
    return 0;
  }

}

######################################################################

sub source_exists {

  # If the specified label has a corresponding bibliography entry
  # return 1, otherwise return 0.

  my $label = shift;

  if ( exists $lookup{$label}{'source'} ) {
    return 1;
  }

  else {
    return 0;
  }

}

######################################################################

sub label_exists {

  # If the specified label exists return 1, otherwise return 0.

  my $label = shift;

  if ( $label
       and exists $label{$label}
       and $label{$label} !~ /^\s*$/ ) {

    return 1;
  }

  else {
    return 0;
  }

}

######################################################################

sub name_for {

  # Return the name (problem, solution, allocation, assignment, test,
  # task, result, role...) for the item with the specified label.

  my $label = shift;

  if ( exists $label{$label}{'name'} )
    {
      return $label{$label}{'name'};
    }

  # elsif (   $label =~ /^rq-/
  # 	 or $label =~ /^uc-/ )
  #   {
  #     return 'problem';
  #   }

  # elsif (   $label =~ /^ci-/
  # 	 or $label =~ /^ba-/
  # 	 or $label =~ /^do-/
  # 	 or $label =~ /^pt-/ )
  #   {
  #     return 'solution';
  #   }

  # elsif (   $label =~ /^tc-/
  # 	 or $label =~ /^td-/ )
  #   {
  #     return 'test';
  #   }

  # elsif (   $label =~ /^ca-/
  # 	 or $label =~ /^qr-/
  # 	 or $label =~ /^rr-/
  # 	 or $label =~ /^ts-/
  # 	 or $label =~ /^tr-/ )
  #   {
  #     return 'result';
  #   }

  # elsif (   $label =~ /^ta-/ )
  #   {
  #     return 'task';
  #   }

  # elsif (   $label =~ /^ro-/ )
  #   {
  #     return 'role';
  #   }

  # elsif (   $label =~ /^al-/ )
  #   {
  #     return 'allocation';
  #   }

  # elsif (   $label =~ /^as-/ )
  #   {
  #     return 'assignment';
  #   }

  else
    {
      return 0;
    }
}

######################################################################

sub is_context_sensitive {

  # Certain types of generated content are context sensitive.  This
  # subroutine checks the context sensitivity of a generated content
  # type and returns 1 if it is context sensitive and 0 if it is not.
  #
  # How is such magic possible?  The hash of acceptable generated
  # content types is named "%generated_content_types" and is a set of
  # key-value pairs where the keys are the names of generated content
  # types and the values are either "context sensitive" or "not
  # context sensitive".

  my $type = shift;

  if ( $generated_content_types{$type} eq "context sensitive" ) {
    return 1;
  }

  else {
    return 0;
  }

}

######################################################################

sub strip_format_markup {

  # Strip all text sequences that represent format markup:
  #
  #   **content** - bold
  #   !!content!! - bold (deprecated)
  #   ~~content~~ - italics
  #   __content__ - underline
  #   ||content|| - typewriter type
  #   [[content]] - keystroke indicator
  #
  # Also strip leading and trailing whitespace
  #

  my $text = shift;

  $text =~ s/([^~])~~([^~])/$1$2/g;     # ignore italics markup
  $text =~ s/([^_])__([^_])/$1$2/g;     # ignore underline markup
  $text =~ s/([^\*])\*\*([^\*])/$1$2/g; # ignore bold markup
  $text =~ s/([^\!])\!\!([^\!])/$1$2/g; # ignore bold markup
  $text =~ s/([^|])||([^|])/$1$2/g;     # ignore tt markup
  $text =~ s/\[\[([^\]]+)\]\]/$1/g;     # ignore keystroke indicators

  $text = trim_whitespace($text);

  return $text;

}

######################################################################

sub trim_whitespace {

  # Trim leading and trailing whitespace from a line of text.

  my $text = shift;

  $text =~ s/^\s*//m;            # ignore leading whitespace
  $text =~ s/\s*$//m;            # ignore trailing whitespace

  return $text;
}

######################################################################

sub compress_whitespace {

  # Compress multiple whitespaces within a string into a single
  # whitespace.

  my $text = shift;

  $text =~ s/\s+/ /g;

  return $text;

}

######################################################################

sub organize_document_metadata {

  # Re-organize the document metadata stored in the 'data' and
  # 'svninfo' data structure and put it into the 'document' hash:
  #
  #   $data{preamble}{1}{title}           => $document{title}
  #   $data{preamble}{1}{author}          => $document{author}
  #   $data{preamble}{1}{classification}  => $document{classification}
  #   $data{preamble}{1}{classified_by}   => $document{classified_by}
  #   $data{preamble}{1}{classif_reason}  => $document{classif_reason}
  #   $data{preamble}{1}{copyright}       => $document{copyright}
  #   $data{preamble}{1}{date}            => $document{date}
  #   $data{preamble}{1}{declassify_on}   => $document{declassify_on}
  #   $data{preamble}{1}{define}          => $document{define}
  #   $data{preamble}{1}{doctype}         => $document{doctype}
  #   $data{preamble}{1}{editor}          => $document{editor}
  #   $data{preamble}{1}{fontsize}        => $document{fontsize}
  #   $data{preamble}{1}{handling_caveat} => $document{handling_caveat}
  #   $data{preamble}{1}{organization}    => $document{organization}
  #   $data{preamble}{1}{revision}        => $document{revision}
  #   $data{preamble}{1}{version}         => $document{version}

  # Note about versions and revisions.  Revisions (sometimes called
  # build numbers) are the numbers automatically assigned by the
  # change management system.  Versions are assigned by humans as
  # documents are baselined.  For instance, an organization may wish
  # to release version 3.1 of a document.  This number is assigned by
  # humans in the organization and should not be confused with the
  # automatically assigned and incremented revision (or build number)
  # which might be something like 4159.  In a case like this, you
  # might name the published file:
  #
  #     document-v3.1.4159.pdf

  # !!! Bug Here !!!
  #
  #     This code doesn't look like it will handle multi-valued
  #     document metadata elements like author and editor.

  printstatus("organizing document metadata...");

  foreach my $mde (keys %{ $data{preamble}{1} }) {

    # mde = metadata element

    # Skip header and footer elements which are organized during
    # pass_two.  This is terribly inconsistent and needs to be
    # refactored some day.
    #
    # The root problem is that the %document datastructure doesn't
    # accomodate data element attributes and neither does the %lookup
    # datastructure.  Fixing this problem will require significant
    # code refactoring.  The following line of code is part of an ugly
    # little work-around to this problem.  The other code for this
    # ugly little work-around is in the pass_two subroutine.  You'll
    # find it if you search for the string 'header)'.
    #
    next if $mde =~ /^header|^footer/;

    my $value = $data{preamble}{1}{$mde};

    if (ref $value eq 'ARRAY') {
      @{ $document{$mde} } = @{ $value };
      my $string = join(', ',@{$value});
      printdebug("organize_document_metadata: document $mde = array $string") if $DEBUGGING;
    } else {
      $document{$mde} = $value;
      printdebug("organize_document_metadata: document $mde = $value") if $DEBUGGING;
    }

    if ( $mde eq 'no_titlepage'     ) { $option{'titlepage'}     = 0 };
    if ( $mde eq 'no_toc'           ) { $option{'toc'}           = 0 };
    if ( $mde eq 'no_revisions'     ) { $option{'revisions'}     = 0 };
    if ( $mde eq 'no_updates'       ) { $option{'updates'}       = 0 };
    if ( $mde eq 'no_secnums'       ) { $option{'secnums'}       = 0 };
    if ( $mde eq 'no_glossary'      ) { $option{'glossary'}      = 0 };
    if ( $mde eq 'no_changelog'     ) { $option{'changelog'}     = 0 };
    if ( $mde eq 'no_loacronyms'    ) { $option{'loacronyms'}    = 0 };
    if ( $mde eq 'no_index'         ) { $option{'index'}         = 0 };
    if ( $mde eq 'no_lofigures'     ) { $option{'lof'}           = 0 };
    if ( $mde eq 'no_loattachments' ) { $option{'loa'}           = 0 };
    if ( $mde eq 'no_lotables'      ) { $option{'lot'}           = 0 };
    if ( $mde eq 'no_lolistings'    ) { $option{'lolistings'}    = 0 };
    if ( $mde eq 'no_loslides'      ) { $option{'loslides'}      = 0 };
    if ( $mde eq 'no_loexercises'   ) { $option{'loexercises'}   = 0 };
    if ( $mde eq 'no_lodemos'       ) { $option{'lodemos'}       = 0 };
    if ( $mde eq 'no_lofootnotes'   ) { $option{'lofootnotes'}   = 0 };
    if ( $mde eq 'no_losidebars'    ) { $option{'losidebars'}    = 0 };
    if ( $mde eq 'no_loquotations'  ) { $option{'loquotations'}  = 0 };
    if ( $mde eq 'no_todo'          ) { $option{'todo'}          = 0 };
    if ( $mde eq 'no_lotodo'        ) { $option{'lotodo'}        = 0 };
    if ( $mde eq 'no_loproblems'    ) { $option{'loproblems'}    = 0 };
    if ( $mde eq 'no_losolutions'   ) { $option{'losolutions'}   = 0 };
    if ( $mde eq 'no_loallocations' ) { $option{'loallocations'} = 0 };
    if ( $mde eq 'no_loassignments' ) { $option{'loassignments'} = 0 };
    if ( $mde eq 'no_lotests'       ) { $option{'lotests'}       = 0 };
    if ( $mde eq 'no_lotasks'       ) { $option{'lotasks'}       = 0 };
    if ( $mde eq 'no_loresults'     ) { $option{'loresults'}     = 0 };
    if ( $mde eq 'no_loroles'       ) { $option{'loroles'}       = 0 };
    if ( $mde eq 'no_sources'       ) { $option{'sources'}       = 0 };
    if ( $mde eq 'no_losources'     ) { $option{'losources'}     = 0 };

  }

  #--------------------------------------------------------------------
  # Modified?
  #
  #     If any file used to assemble this document has been modified,
  #     consider this document modified.
  #
  if ( $option{'use_svn'} ) {
    foreach my $file (keys %svninfo) {
      gather_svn_metadata($file,'recheck');
      if ($svninfo{$file}{'modified'}) {
	printmessage("WARNING: uncommitted changes in: $file");
	push @LOG_CHANGES_FILE, "uncommitted changes in: $file\n";
	$document{'modified'} = 1;
      }
    }
  }
}

######################################################################

sub create_lookup_datastructure {

  #-------------------------------------------------------------------
  # NOTES
  #
  #     Create the 'lookup' datastructure by re-factoring the data
  #     from the 'data' and 'csvdata' datastructures.
  #
  #     The 'data' datastructure indexes metadata by *number* in the
  #     order the environment or region appears in the document.  The
  #     'lookup' datastructure, on the other hand, indexes metadata by
  #     *label*.  The 'lookup' datastructure is used to lookup
  #     information by label.
  #
  #     The data in the 'data' structure looks like this:
  #
  #       $data{$name}{$num}{$element};
  #
  #       $data{'problem'}{'1'}{'title'}       = 'My Title';
  #       $data{'problem'}{'1'}{'label'}       = 'rq-1111';
  #       $data{'problem'}{'1'}{'parent'}      = 'rq-2222';
  #       $data{'problem'}{'1'}{'type'}        = 'functional';
  #       $data{'problem'}{'1'}{'priority'}    = 'critical';
  #       $data{'problem'}{'1'}{'status'}      = 'yellow';
  #       $data{'problem'}{'1'}{'stakeholder'} = 'Don Johnson';
  #       $data{'problem'}{'1'}{'owner'}       = 'Don Johnson';
  #       $data{'problem'}{'1'}{'author'}      = 'Don Johnson';
  #       $data{'problem'}{'1'}{'validator'}   = 'Don Johnson';
  #       $data{'problem'}{'1'}{'solution'}    = ['sol-2004-11-21-001',
  #                                               'sol-2004-11-21-002',
  #                                               'sol-2004-11-21-003'];
  #       $data{'problem'}{'1'}{'test'}        = 'test-2004-11-21-001';
  #       $data{'problem'}{'1'}{'description'} = 'the description...';
  #       $data{'problem'}{'1'}{'attr'}        = ['cpu = i386',
  #                                               'memory = 1024 MB'];
  #
  #     The data in the 'csvdata' structure looks like this:
  #
  #       $csvdata->{$key}{$name} = [ 'value_1', 'value_2', ...];
  #
  #     In other words, the content of the 'csvdata' data structure is
  #     ALREADY structured the way it needs to be in the 'lookup' data
  #     structure, it just needs to be merged in.
  #
  #     The corresponding data in the 'lookup' datastructure should
  #     look like this:
  #
  #       $lookup{$label}{$element};
  #
  #       $lookup{'rq-1111'}{'title'}       = 'My Title';
  #       $lookup{'rq-1111'}{'label'}       = 'rq-1111';
  #       $lookup{'rq-1111'}{'parent'}      = 'rq-2222';
  #       $lookup{'rq-1111'}{'type'}        = 'functional';
  #       $lookup{'rq-1111'}{'priority'}    = 'critical';
  #       $lookup{'rq-1111'}{'status'}      = 'yellow';
  #       $lookup{'rq-1111'}{'stakeholder'} = 'Don Johnson';
  #       $lookup{'rq-1111'}{'owner'}       = 'Don Johnson';
  #       $lookup{'rq-1111'}{'author'}      = 'Don Johnson';
  #       $lookup{'rq-1111'}{'validator'}   = 'Don Johnson';
  #       $lookup{'rq-1111'}{'solution'}    = ['sol-2004-11-21-001',
  #                                            'sol-2004-11-21-002',
  #                                            'sol-2004-11-21-003'];
  #       $lookup{'rq-1111'}{'test'}        = 'test-2004-11-21-001';
  #       $lookup{'rq-1111'}{'description'} = 'the description...';
  #       $lookup{'rq-1111'}{'tier'}        = 3;
  #       $lookup{'rq-1111'}{'attr'}        = ['cpu = i386',
  #                                            'memory = 1024 MB'];
  #-------------------------------------------------------------------

  printstatus("creating \"lookup\" datastructure...");

  #-------------------------------------------------------------------
  # List Environments and Regions
  #
  #    To begin, make a list of environments and a list of regions.
  #    We'll need these lists later in the subroutine.
  #
  my @environments = ();
  my @regions      = ();

  foreach my $name (keys %structure) {
    my $type = $structure{$name}{'type'};
    if ($type eq 'environment') {
      push @environments, $name;
    } elsif ($type eq 'region') {
      push @regions, $name;
    }
  }

  #-------------------------------------------------------------------
  # Each Name in %data...
  #
  #     Loop over each environment and region name and turn the
  #     collected data into a lookup data structure.  The keys of the
  #     %data datastructure are names of environments and regions (and
  #     perhaps other things) as shown in the example above where the
  #     key is the name of the region 'problem'.
  #
  #     Foreach environment and region name in the structure hash...
  #
  foreach my $name ( keys %data ) {

    #-----------------------------------------------------------------
    # Each Instance
    #
    #     Loop over each instance of this environment or region. For
    #     each instance of this environment or region found in the
    #     document...
    #
    foreach my $num ( sort {$a <=> $b} keys %{ $data{$name} } ) {

      #---------------------------------------------------------------
      # Label
      #
      #     Determine the label for this instance. If a label was
      #     provided by the author use it.  Otherwise, create a fake
      #     label ($name-$num) for internal use by the program.
      #
      my $label = $data{$name}{$num}{'label'} || "$name-$num";

      $label = trim_whitespace($label);

      printdebug("create_lookup_datastructure: $name $num ($label)") if $DEBUGGING;

      #---------------------------------------------------------------
      # Each Data Element
      #
      #     Loop over each data element of this instance. Foreach data
      #     element found in this instance...
      #
      foreach my $element ( keys %{ $data{$name}{$num} } ) {

	#-------------------------------------------------------------
	# Element Value
	#
	#     Get the value of this element. Note that for
	#     multi-valued elements, $value is a reference to an array
	#     containing those multiple values.
	#
	my $value = $data{$name}{$num}{$element};

	printdebug("  $element => $value") if $DEBUGGING;

	#-------------------------------------------------------------
	# Value Type
	#
	#     Determine the type of the value (scalar, array or hash)
	#
	my $value_isa_scalar = 0;
	my $value_isa_array  = 0;
	my $value_isa_hash   = 0;

	if ( ref $value eq 'HASH' ) {
	  $value_isa_hash = 1;
	}

	elsif ( ref $value eq 'ARRAY' ) {
	  $value_isa_array = 1;
	}

	else {
	  $value_isa_scalar = 1;
	}

	#-------------------------------------------------------------
	# Multivalued?
	#
	#     Determine if this type of element is multivalued.
	#
	my $is_multivalued = 0;
	if ( $structure{$name}{'elements'}{$element}{'multivalued'} ) {
	  if ($value_isa_array or $value_isa_hash) {
	    $is_multivalued = 1;
	  }
 	  else {
 	    print "name:    $name\n";
 	    print "element: $element\n";
 	    print "value:   $value\n";
 	    die "($label) disagreement between structure and data over $element being multi-valued.  The structure hash says $element is multivalued, but the value \"$value\" is a scalar.\n";
 	  }
	}

	#-------------------------------------------------------------
	# Multivalued.
	#
	#     The value is multi-valued...
	#
	if ($is_multivalued) {

	  #-----------------------------------------------------------
	  # Find Array
	  #
	  #     Get the reference to the array of data element values
	  #     in the lookup datastructure.
	  #
	  my $arrayref = $lookup{$label}{$element};

	  #-----------------------------------------------------------
	  # Value An Array?
	  #
	  #     If the value is an array...
	  #
	  if ($value_isa_array) {
	    foreach my $subvalue ( @{$value} ) {

	      # trim any whitespace

	      $subvalue = trim_whitespace($subvalue);

	      # Check to see whether this subvalue is already in the
	      # array.
	      #
	      # my $already_in_array = 0;
	      # foreach my $item ( @{ $lookup{$label}{$element} } ) {
	      # 	if ($item eq $subvalue) {
	      # 	  $already_in_array = 1;
	      # 	}
	      # }

	      # If this subvalue is not already in the array, put it
	      # there.
	      #
	      if (not already_in_array($subvalue,$lookup{$label}{$element})) {
		push @{ $lookup{$label}{$element} }, $subvalue;
		printdebug("pushed lookup->$label->$element => $subvalue") if $DEBUGGING;
	      } else {
		printdebug("already in array: lookup->$label->$element => $subvalue") if $DEBUGGING;
	      }
	    }
	  }
	}

	#-------------------------------------------------------------
	# Not Multivalued
	#
	#     Otherwise, this data element is NOT multivalued.  Just
	#     assign it to the lookup data structure.
	#
	else {
	  $value = trim_whitespace($value);
	  $lookup{$label}{$element} = $value;
	  printdebug("assigned lookup->$label->$element => $value") if $DEBUGGING;
	}

	#-------------------------------------------------------------
	# 'parent' Elements
	#
	#     If this is a 'parent' element, the $value should be a
	#     label. Record this relationship in the lookup structure.
	#
	#     !!! Bug Here !!!
	#
	#     The error checking function below of seeing if the value
	#     is a label ought to occur in pass three rather than in
	#     this subroutine.
	#
	if ($element eq 'parent') {

	  if ( label_exists($value) ) {

	    if (not already_in_array($label,$lookup{$value}{'children'})) {
	      $label = trim_whitespace($label);
	      push @{ $lookup{$value}{'children'} }, $label;
	    }

	    if (not already_in_array($value,$lookup{$label}{'parent'})) {
	      $value = trim_whitespace($value);
	      push @{ $lookup{$label}{'parent'} }, $value;
	    }

	  }

	  else {
	    # printerror("\"parent\" value is not a label: $value");
	  }
	}

	#-------------------------------------------------------------
	# 'child' Elements
	#
	#     If this is a 'child' element, the $value should be a
	#     label. Record this relationship in the lookup structure.
	#
	#     !!! Bug Here !!!
	#
	#     The error checking function below of seeing if the value
	#     is a label ought to occur in pass three rather than in
	#     this subroutine.
	#
# 	if ($element eq 'child') {
# 	  if ( label_exists($value) ) {
# 	    push @{ $lookup{$value}{'parent'} }, $label;
# 	  }
# 	  else {
# 	    printerror("\"parent\" value is not a label: $value");
# 	  }
# 	}

	#-------------------------------------------------------------
	# 'next' Elements
	#
	#     If this is a 'next' element, the $value should be a
	#     label. Record the previous/next relationship in the
	#     lookup structure.
	#
	#     !!! Bug Here !!!
	#
	#     The error checking function below of seeing if the value
	#     is a label ought to occur in pass three rather than in
	#     this subroutine.
	#
	if ($element eq 'next') {

	  my @list = @{ $value };
	  foreach my $value (@list) {

	    if ( label_exists($value) ) {

	      if ( not already_in_array($value,$lookup{$label}{'next'}) ) {
		$value = trim_whitespace($value);
		push(@{$lookup{$label}{'next'}},$value);
	      }

	      if ( not already_in_array($label,$lookup{$value}{'previous'}) ) {
		$label = trim_whitespace($label);
		push(@{$lookup{$value}{'previous'}},$label);
	      }

	    }
	    else {
	      printerror("\"next\" value is not a label: $value");
	    }
	  }
	}

	#-------------------------------------------------------------
	# 'previous' Elements
	#
	#     If this is a 'previous' element, the $value should be a
	#     label. Record the previous/next relationship in the
	#     lookup structure.
	#
	#     !!! Bug Here !!!
	#
	#     The error checking function below of seeing if the value
	#     is a label ought to occur in pass three rather than in
	#     this subroutine.
	#
	if ($element eq 'previous') {

	  my @list = @{ $value };
	  foreach my $value (@list) {

	    if ( label_exists($value) ) {

	      if ( not already_in_array($value,$lookup{$label}{'previous'}) ) {
		$value = trim_whitespace($value);
		push(@{$lookup{$label}{'previous'}},$value);
	      }

	      if ( not already_in_array($label,$lookup{$value}{'next'}) ) {
		$label = trim_whitespace($label);
		push(@{$lookup{$value}{'next'}},$label);
	      }

	    }
	    else {
	      printerror("\"previous\" value is not a label: $value");
	    }
	  }
	}

	#-------------------------------------------------------------
	# 'derived_from' Elements
	#
	#     If this is a 'derived_from' element, the $value should
	#     be a label. Record this relationship in the lookup
	#     structure.
	#
	#     !!! Bug Here !!!
	#
	#     The error checking function below of seeing if the value
	#     is a label ought to occur in pass three rather than in
	#     this subroutine.
	#
	if ($element eq 'derived_from') {

	  my @list = @{ $value };
	  foreach my $value (@list) {

	    if ( label_exists($value) ) {

	      if (not already_in_array($value,$lookup{$label}{'derived_from'})) {
		$value = trim_whitespace($value);
		push @{ $lookup{$label}{'derived_from'} }, $value;
	      }

	      if (not already_in_array($label,$lookup{$value}{'derived'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$value}{'derived'} }, $label;
	      }

	    }

	    else {
	      # printerror("\"derived_from\" value is not a label: $value");
	    }
	  }
	}

	#-------------------------------------------------------------
	# 'derived' Elements
	#
	#     If this is a 'derived' element, the $value should be a
	#     label. Record this relationship in the lookup structure.
	#
	#     !!! Bug Here !!!
	#
	#     The error checking function below of seeing if the value
	#     is a label ought to occur in pass three rather than in
	#     this subroutine.
	#
	if ($element eq 'derived') {

	  my @list = @{ $value };
	  foreach my $value (@list) {

	    if ( label_exists($value) ) {

	      if (not already_in_array($value,$lookup{$label}{'derived'})) {
		$value = trim_whitespace($value);
		push @{ $lookup{$label}{'derived'} }, $value;
	      }

	      if (not already_in_array($label,$lookup{$value}{'derived_from'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$value}{'derived_from'} }, $label;
	      }

	    }

	    else {
	      printerror("\"derived\" value is not a label: $value");
	    }
	  }
	}

	#-------------------------------------------------------------
	# 'directs' Elements
	#
	#     If this is a 'directs' element, the $value might be a
	#     label. Record this relationship in the lookup structure.
	#
	#     !!! Bug Here !!!
	#
	#     The error checking function below of seeing if the value
	#     is a label ought to occur in pass three rather than in
	#     this subroutine.
	#
	if ($element eq 'directs') {
	  foreach my $subvalue (@{ $value }) {

	    my $extracted_label = '';
	    if ( $subvalue =~ /^(\S+),/) {
	      $extracted_label = $1;
	    }

	    if ( label_exists($subvalue) ) {
	      if (not already_in_array($label,$lookup{$subvalue}{'directed_by'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$subvalue}{'directed_by'} }, $label;
	      }
	    }

	    elsif ( label_exists($extracted_label) ) {
	      if (not already_in_array($label,$lookup{$extracted_label}{'directed_by'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$extracted_label}{'directed_by'} }, $label;
	      }
	    }

	    else {
	      # printerror("\"directs\" value is not a label: $subvalue");
	    }
	  }
	}

	#-------------------------------------------------------------
	# 'directed_by' Elements
	#
	#     If this is a 'directed_by' element, the $value might
	#     be a label. Record this relationship in the lookup
	#     structure.
	#
	#     !!! Bug Here !!!
	#
	#     The error checking function below of seeing if the value
	#     is a label ought to occur in pass three rather than in
	#     this subroutine.
	#
	if ($element eq 'directed_by') {
	  foreach my $subvalue (@{ $value }) {

	    my $extracted_label = '';
	    if ( $subvalue =~ /^(\S+),/) {
	      $extracted_label = $1;
	    }

	    if ( label_exists($subvalue) ) {
	      if (not already_in_array($label,$lookup{$subvalue}{'directs'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$subvalue}{'directs'} }, $label;
	      }
	    }

	    elsif ( label_exists($extracted_label) ) {
	      if (not already_in_array($label,$lookup{$extracted_label}{'directs'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$extracted_label}{'directs'} }, $label;
	      }
	    }

	    else {
	      # printerror("\"directed_by\" value is not a label: $subvalue");
	    }
	  }
	}

	#-------------------------------------------------------------
	# 'uses' Elements
	#
	#     If this is a 'uses' element, the $value might be a
	#     label. Record this relationship in the lookup structure.
	#
	#     !!! Bug Here !!!
	#
	#     The error checking function below of seeing if the value
	#     is a label ought to occur in pass three rather than in
	#     this subroutine.
	#
	if ($element eq 'uses') {
	  foreach my $subvalue (@{ $value }) {

	    my $extracted_label = '';
	    if ( $subvalue =~ /^(\S+),/) {
	      $extracted_label = $1;
	    }

	    if ( label_exists($subvalue) ) {
	      if (not already_in_array($label,$lookup{$subvalue}{'used_by'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$subvalue}{'used_by'} }, $label;
	      }
	    }

	    elsif ( label_exists($extracted_label) ) {
	      if (not already_in_array($label,$lookup{$extracted_label}{'used_by'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$extracted_label}{'used_by'} }, $label;
	      }
	    }

	    else {
	      # printerror("\"uses\" value is not a label: $subvalue");
	    }
	  }
	}

	#-------------------------------------------------------------
	# 'used_by' Elements
	#
	#     If this is a 'used_by' element, the $value might
	#     be a label. Record this relationship in the lookup
	#     structure.
	#
	#     !!! Bug Here !!!
	#
	#     The error checking function below of seeing if the value
	#     is a label ought to occur in pass three rather than in
	#     this subroutine.
	#
	if ($element eq 'used_by') {
	  foreach my $subvalue (@{ $value }) {

	    my $extracted_label = '';
	    if ( $subvalue =~ /^(\S+),/) {
	      $extracted_label = $1;
	    }

	    if ( label_exists($subvalue) ) {
	      if (not already_in_array($label,$lookup{$subvalue}{'uses'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$subvalue}{'uses'} }, $label;
	      }
	    }

	    elsif ( label_exists($extracted_label) ) {
	      if (not already_in_array($label,$lookup{$extracted_label}{'uses'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$extracted_label}{'uses'} }, $label;
	      }
	    }

	    else {
	      # printerror("\"used_by\" value is not a label: $subvalue");
	    }
	  }
	}

	#-------------------------------------------------------------
	# 'extends' Elements
	#
	#     If this is a 'extends' element, the $value might be a
	#     label. Record this relationship in the lookup structure.
	#
	#     !!! Bug Here !!!
	#
	#     The error checking function below of seeing if the value
	#     is a label ought to occur in pass three rather than in
	#     this subroutine.
	#
	if ($element eq 'extends') {
	  foreach my $subvalue (@{ $value }) {

	    my $extracted_label = '';
	    if ( $subvalue =~ /^(\S+),/) {
	      $extracted_label = $1;
	    }

	    if ( label_exists($subvalue) ) {
	      if (not already_in_array($label,$lookup{$subvalue}{'extended_by'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$subvalue}{'extended_by'} }, $label;
	      }
	    }

	    elsif ( label_exists($extracted_label) ) {
	      if (not already_in_array($label,$lookup{$extracted_label}{'extended_by'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$extracted_label}{'extended_by'} }, $label;
	      }
	    }

	    else {
	      # printerror("\"extends\" value is not a label: $subvalue");
	    }
	  }
	}

	#-------------------------------------------------------------
	# 'extended_by' Elements
	#
	#     If this is a 'extended_by' element, the $value might
	#     be a label. Record this relationship in the lookup
	#     structure.
	#
	#     !!! Bug Here !!!
	#
	#     The error checking function below of seeing if the value
	#     is a label ought to occur in pass three rather than in
	#     this subroutine.
	#
	if ($element eq 'extended_by') {
	  foreach my $subvalue (@{ $value }) {

	    my $extracted_label = '';
	    if ( $subvalue =~ /^(\S+),/) {
	      $extracted_label = $1;
	    }

	    if ( label_exists($subvalue) ) {
	      if (not already_in_array($label,$lookup{$subvalue}{'extends'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$subvalue}{'extends'} }, $label;
	      }
	    }

	    elsif ( label_exists($extracted_label) ) {
	      if (not already_in_array($label,$lookup{$extracted_label}{'extends'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$extracted_label}{'extends'} }, $label;
	      }
	    }

	    else {
	      # printerror("\"extended_by\" value is not a label: $subvalue");
	    }
	  }
	}

	#-------------------------------------------------------------
	# 'realizes' Elements
	#
	#     If this is a 'realizes' element, the $value might be a
	#     label. Record this relationship in the lookup structure.
	#
	#     !!! Bug Here !!!
	#
	#     The error checking function below of seeing if the value
	#     is a label ought to occur in pass three rather than in
	#     this subroutine.
	#
	if ($element eq 'realizes') {
	  foreach my $subvalue (@{ $value }) {

	    my $extracted_label = '';
	    if ( $subvalue =~ /^(\S+),/) {
	      $extracted_label = $1;
	    }

	    if ( label_exists($subvalue) ) {
	      if (not already_in_array($label,$lookup{$subvalue}{'realized_by'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$subvalue}{'realized_by'} }, $label;
	      }
	    }

	    elsif ( label_exists($extracted_label) ) {
	      if (not already_in_array($label,$lookup{$extracted_label}{'realized_by'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$extracted_label}{'realized_by'} }, $label;
	      }
	    }

	    else {
	      # printerror("\"realizes\" value is not a label: $subvalue");
	    }
	  }
	}

	#-------------------------------------------------------------
	# 'realized_by' Elements
	#
	#     If this is a 'realized_by' element, the $value might
	#     be a label. Record this relationship in the lookup
	#     structure.
	#
	#     !!! Bug Here !!!
	#
	#     The error checking function below of seeing if the value
	#     is a label ought to occur in pass three rather than in
	#     this subroutine.
	#
	if ($element eq 'realized_by') {
	  foreach my $subvalue (@{ $value }) {

	    my $extracted_label = '';
	    if ( $subvalue =~ /^(\S+),/) {
	      $extracted_label = $1;
	    }

	    if ( label_exists($subvalue) ) {
	      if (not already_in_array($label,$lookup{$subvalue}{'realizes'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$subvalue}{'realizes'} }, $label;
	      }
	    }

	    elsif ( label_exists($extracted_label) ) {
	      if (not already_in_array($label,$lookup{$extracted_label}{'realizes'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$extracted_label}{'realizes'} }, $label;
	      }
	    }

	    else {
	      # printerror("\"realized_by\" value is not a label: $subvalue");
	    }
	  }
	}

	#-------------------------------------------------------------
	# 'depends_on' Elements
	#
	#     If this is a 'depends_on' element, the $value should be
	#     a label. Record the corresponding 'required_by' element
	#     in the lookup structure.  'depends_on' elements are
	#     ALWAYS multivalued.
	#
	if ($element eq 'depends_on') {

	  #-----------------------------------------------------------
	  # Each Subvalue
	  #
	  foreach my $subvalue ( @{ $value } ) {

	    # is $subvalue recognized as a label?
	    #
	    if ( label_exists($subvalue) ) {

	      # add $subvalue to the array, if not already there
	      #
	      if (not already_in_array($label,$lookup{$subvalue}{'required_by'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$subvalue}{'required_by'} }, $label;
	      }
	    }

	    # $subvalue is not recognized as a label
	    #
	    else {
	      printerror("\"depends_on\" value is not a label: $subvalue");
	    }
	  }
	}

	#-------------------------------------------------------------
	# 'required_by' Elements
	#
	#     If this is a 'required_by' element, record the
	#     corresponding 'depends_on' element in the lookup
	#     structure.
	#
	if ($element eq 'required_by') {

	  #-----------------------------------------------------------
	  # Each Subvalue
	  #
	  foreach my $subvalue ( @{ $value } ) {

	    # is $subvalue a label?
	    #
	    if ( label_exists($subvalue) ) {

	      # add $subvalue to the array, if not already there
	      #
	      if (not already_in_array($label,$lookup{$subvalue}{'depends_on'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$subvalue}{'depends_on'} }, $label;
	      }
	    }

	    # $subvalue is not recognized as a label
	    #
	    else {
	      printerror("\"required_by\" value is not a label: $subvalue");
	    }

	  }
	}

	#-------------------------------------------------------------
	# 'instance_of' Elements
	#
	#     If this is a 'instance_of' element, the $value should be
	#     a label. Record the corresponding 'class_of' element in
	#     the lookup structure.  'instance_of' elements are ALWAYS
	#     multivalued.
	#
	if ($element eq 'instance_of') {

	  #-----------------------------------------------------------
	  # Each Subvalue
	  #
	  foreach my $subvalue ( @{ $value } ) {

	    # is $subvalue recognized as a label?
	    #
	    if ( label_exists($subvalue) ) {

	      # add $subvalue to the array, if not already there
	      #
	      if (not already_in_array($label,$lookup{$subvalue}{'class_of'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$subvalue}{'class_of'} }, $label;
	      }
	    }

	    # $subvalue is not recognized as a label
	    #
	    else {
	      printerror("\"instance_of\" value is not a label: $subvalue");
	    }
	  }
	}

	#-------------------------------------------------------------
	# 'class_of' Elements
	#
	#     If this is a 'class_of' element, record the
	#     corresponding 'instance_of' element in the lookup
	#     structure.
	#
	if ($element eq 'class_of') {

	  #-----------------------------------------------------------
	  # Each Subvalue
	  #
	  foreach my $subvalue ( @{ $value } ) {

	    # is $subvalue a label?
	    #
	    if ( label_exists($subvalue) ) {

	      # add $subvalue to the array, if not already there
	      #
	      if (not already_in_array($label,$lookup{$subvalue}{'instance_of'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$subvalue}{'instance_of'} }, $label;
	      }
	    }

	    # $subvalue is not recognized as a label
	    #
	    else {
	      printerror("\"class_of\" value is not a label: $subvalue");
	    }

	  }
	}

	#-------------------------------------------------------------
	# 'generalizes' Elements
	#
	#     If this is a 'generalizes' element, the $value should be
	#     a label. Record the corresponding 'specializes' element in
	#     the lookup structure.  'generalizes' elements are ALWAYS
	#     multivalued.
	#
	if ($element eq 'generalizes') {

	  #-----------------------------------------------------------
	  # Each Subvalue
	  #
	  foreach my $subvalue ( @{ $value } ) {

	    # is $subvalue recognized as a label?
	    #
	    if ( label_exists($subvalue) ) {

	      # add $subvalue to the array, if not already there
	      #
	      if (not already_in_array($label,$lookup{$subvalue}{'specializes'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$subvalue}{'specializes'} }, $label;
	      }
	    }

	    # $subvalue is not recognized as a label
	    #
	    else {
	      printerror("\"generalizes\" value is not a label: $subvalue");
	    }
	  }
	}

	#-------------------------------------------------------------
	# 'specializes' Elements
	#
	#     If this is a 'specializes' element, record the
	#     corresponding 'generalizes' element in the lookup
	#     structure.
	#
	if ($element eq 'specializes') {

	  #-----------------------------------------------------------
	  # Each Subvalue
	  #
	  foreach my $subvalue ( @{ $value } ) {

	    # is $subvalue a label?
	    #
	    if ( label_exists($subvalue) ) {

	      # add $subvalue to the array, if not already there
	      #
	      if (not already_in_array($label,$lookup{$subvalue}{'generalizes'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$subvalue}{'generalizes'} }, $label;
	      }
	    }

	    # $subvalue is not recognized as a label
	    #
	    else {
	      printerror("\"specializes\" value is not a label: $subvalue");
	    }

	  }
	}

	#-------------------------------------------------------------
	# 'associated' Elements
	#
	#     If this is an 'associated' element, record the
	#     corresponding 'associated' element in the lookup
	#     structure.
	#
	if ($element eq 'associated') {

	  #-----------------------------------------------------------
	  # Each Subvalue
	  #
	  foreach my $subvalue ( @{ $value } ) {

	    # is $subvalue a label?
	    #
	    if ( label_exists($subvalue) ) {

	      # add $subvalue to the array, if not already there
	      #
	      if (not already_in_array($label,$lookup{$subvalue}{'associated'})) {
		$label = trim_whitespace($label);
		push @{ $lookup{$subvalue}{'associated'} }, $label;
	      }
	    }

	    # $subvalue is not recognized as a label
	    #
	    else {
	      printerror("\"associated\" value is not a label: $subvalue");
	    }

	  }
	}

	#-------------------------------------------------------------
	# 'owner' Elements
	#
	#     If this is an 'owner' element, the $value might be a
	#     label. If so, record this relationship in the lookup
	#     structure.
	#
	#     !!! Bug Here !!!
	#
	#     The error checking function below of seeing if the value
	#     is a label ought to occur in pass three rather than in
	#     this subroutine.
	#
	if ($element eq 'owner') {
	  if ( label_exists($value) ) {
	    if (not already_in_array($label,$lookup{$value}{$name})) {
		$label = trim_whitespace($label);
	      push @{ $lookup{$value}{$name} }, $label;
	    }
	  }
	}

	#-------------------------------------------------------------
	# 'assignee' Elements
	#
	#     If this is an 'assignee' element, the $value might be a
	#     label. If so, record this relationship in the lookup
	#     structure.
	#
	#     !!! Bug Here !!!
	#
	#     The error checking function below of seeing if the value
	#     is a label ought to occur in pass three rather than in
	#     this subroutine.
	#
	if ($element eq 'assignee') {
	  if ( label_exists($value) ) {
	    if (not already_in_array($label,$lookup{$value}{$name})) {
	      $label = trim_whitespace($label);
	      push @{ $lookup{$value}{$name} }, $label;
	    }
	  }
	}

	#-------------------------------------------------------------
	# 'stakeholder' Elements
	#
	#     If this is an 'stakeholder' element, the $value might be
	#     a label. If so, record this relationship in the lookup
	#     structure.
	#
	#     !!! Bug Here !!!
	#
	#     The error checking function below of seeing if the value
	#     is a label ought to occur in pass three rather than in
	#     this subroutine.
	#
	if ($element eq 'stakeholder') {
	  if ( label_exists($value) ) {
	    if (not already_in_array($label,$lookup{$value}{$name})) {
		$label = trim_whitespace($label);
	      push @{ $lookup{$value}{$name} }, $label;
	    }
	  }
	}

	#-------------------------------------------------------------
	# Automatic Semantics
	#
	#     If the name of this data element corresponds to the name
	#     of a region, it indicates there is a relationship
	#     between this region and another.
	#
	#     This is poor man's semantics.
	#
	#     For instance, if the name of this data element is
	#     'solution' and is in a 'problem' region, it means there
	#     is a relationship between the problem and the
	#     solution. However, the predicate is not specified.
	#
	#     This is a very powerful and somewhat scary feature. It
	#     will even support future semantic additions to the
	#     %structure.
	#
	#     Other examples include:
	#
	#       problem    -> solution
	#       problem    -> test
	#       solution   -> problem
	#       solution   -> test
	#       solution   -> allocation
	#       test       -> problem
	#       test       -> solution
	#       task       -> problem
	#       task       -> solution
	#       test       -> allocation
	#       allocation -> test
	#
	#     This only works for regions, not environments because
	#     regions represent things with semantic meaning like
	#     problems solutions, and tests.  Environments are just
	#     structural blocks like tables and figures.
	#
	#     First, determine if the name of this data element
	#     matches the name for a region.
	#
	#     In order for this automatic mapping to occur, the key
	#     MUST be the valid name of a region defined in the
	#     %structure datastructure, AND the value must be a label
	#     seen in the document.  For instance:
	#
	#       problem: prob-2006-03-07-001
	#
	#     Would work as long as there exists in the document a
	#     problem labeled "prob-2006-03-07-001" But...
	#
	#       problem: to be determined...
	#
	#     Would NOT work because "to be determined..." is not a
	#     valid label (contains spaces).
	#
	#     !!! Bug Here !!!
	#
	#     I have tests that contain lines like:
	#
	#       problem: prob-2006-03-07-001
	#
	#     and this code is failing to map the problem to the
	#     containing test.
	#
	#
	if ($value_isa_array) {
	  foreach my $subvalue (@{$value}) {
	    foreach my $region (@regions) {
	      if ($element eq $region) {

		#-----------------------------------------------------
		# If this label is not already in the array, put it
		# there.
		#
		if (not already_in_array($label,$lookup{$subvalue}{$name})) {
		  $label = trim_whitespace($label);
		  push @{$lookup{$subvalue}{$name}}, $label;
		  printdebug("pushed lookup->$subvalue->$name => $label") if $DEBUGGING;
		} else {
		  printdebug("already in array lookup->$subvalue->$name => $label") if $DEBUGGING;
		}
	      }
	    }
	  }
	}

	else {
	  foreach my $region (@regions) {
	    if ($element eq $region) {

	      #-------------------------------------------------------
	      # If this label is not already in the array, put it
	      # there.
	      #
	      if (not already_in_array($label,$lookup{$value}{$name})) {
		$label = trim_whitespace($label);
		push @{$lookup{$value}{$name}}, $label;
		printdebug("pushed lookup->$value->$name => $label") if $DEBUGGING;
	      } else {
		printdebug("already in array lookup->$value->$name => $label") if $DEBUGGING;
	      }
	    }
	  }
	}
      }
    }
  }

  #--------------------------------------------------------------------
  # Merge data from the 'csvdata' datastructure
  #
  foreach my $key ( keys %{ $csvdata } )
    {
      foreach my $name ( keys %{ $csvdata->{$key} } )
	{
	  foreach my $value (@{ $csvdata->{$key}{$name} })
	    {
	      push @{ $lookup{$key}{$name} }, $value;
	    }
	}
    }

  #-------------------------------------------------------------------
  # Tiers
  #
  #     Walk the lookup data structure and compute the "tier" of each
  #     label.  The "tier" of a label is it's depth in the
  #     parent-child hierarchy.
  #
  #     MAX_LABEL_HIERARCHY_DEPTH defines the maximum number of tiers.
  #     This is important because if an author creates a label with
  #     ITSELF as its parent, it could create an infinite loop in the
  #     program.
  #
  foreach my $label ( keys %lookup ) {
    my $tier   = 1;
    my $parent = $lookup{$label}{'parent'} || '';
    while ($parent !~ /^\s*$/) {
      ++ $tier;
      $parent = $lookup{$parent}{'parent'} || '';
      #
      # bail out if necessary
      #
      if ( $tier > $MAX_LABEL_HIERARCHY_DEPTH ) {
	printerror("MAX_LABEL_HIERARCHY_DEPTH exceeded: tier: $tier, label: $label, parent: $parent");
	last;
      }
    }
    $lookup{$label}{'tier'} = $tier;
  }
}

######################################################################

sub create_allocation_titles {

  printstatus("creating allocation titles...");

  foreach my $entity (keys %lookup) {
    my $name = name_for($entity);
    if ($name eq 'allocation') {

      # determine problem
      my $problem_value = $lookup{$entity}{'problem'};
      my $problem       = '';
      if ( ref $problem_value eq 'ARRAY' ) {
	$problem = @{ $problem_value }[0];
      } else {
	$problem = $problem_value;
      }

      $problem = trim_whitespace($problem);

      # determine solution
      my $solution_value = $lookup{$entity}{'solution'};
      my $solution       = '';
      if ( ref $solution_value eq 'ARRAY' ) {
	$solution = @{ $solution_value }[0];
      } else {
	$solution = $solution_value;
      }

      $solution = trim_whitespace($solution);

      my $problem_title    = $lookup{$problem}{'title'};
      my $solution_title   = $lookup{$solution}{'title'};
      my $allocation_title = "~~The~~ $solution_title ~~shall~~ $problem_title";

      if ($problem_title and $solution_title) {
	$lookup{$entity}{'title'} = $allocation_title;
      } else {
	if (not $problem_title) {
	  printerror("create_allocation_titles: problem \"$problem\" title not in lookup");
	}
	elsif (not $solution_title) {
	  printerror("create_allocation_titles: solution \"$solution\" title not in lookup");
	}
      }
    }
  }
}

######################################################################

sub create_assignment_titles {

  printstatus("creating assignment titles...");

  foreach my $entity (keys %lookup) {
    my $name = name_for($entity);
    if ($name eq 'assignment') {

      # determine problem
      my $problem_value = $lookup{$entity}{'problem'};
      my $problem       = '';
      if ( ref $problem_value eq 'ARRAY' ) {
	$problem = @{ $problem_value }[0];
      } else {
	$problem = $problem_value;
      }

      $problem = trim_whitespace($problem);

      # determine role
      my $role_value = $lookup{$entity}{'role'};
      my $role       = '';
      if ( ref $role_value eq 'ARRAY' ) {
	$role = @{ $role_value }[0];
      } else {
	$role = $role_value;
      }

      $role = trim_whitespace($role);

      my $problem_title    = $lookup{$problem}{'title'};
      my $role_title   = $lookup{$role}{'title'};
      my $assignment_title = "~~The~~ $role_title ~~shall~~ $problem_title";

      if ($problem_title and $role_title) {
	$lookup{$entity}{'title'} = $assignment_title;
      } else {
	if (not $problem_title) {
	  printerror("create_assignment_titles: problem \"$problem\" title not in lookup");
	}
	elsif (not $role_title) {
	  printerror("create_assignment_titles: role \"$role\" title not in lookup");
	}
      }
    }
  }
}

######################################################################

sub create_attribute_datastructure {

  #-------------------------------------------------------------------
  # NOTES
  #
  #     Create the 'attribute' datastructure by sifting through the
  #     'lookup' datastructure to organize attribute information by
  #     label.
  #
  #     The 'lookup' datastructure might look like this:
  #
  #       $lookup{'ci-000078'}{'attr'} = ['cpu = i386',
  #                                                   'cpu = i868',
  #                                                   'mem = 1GB']
  #
  #     And the corresponding 'attribute' datastructure would then
  #     look like this:
  #
  #       $attribute{'ci-000078'}{'cpu'} = ['i386','i686'],
  #       $attribute{'ci-000078'}{'mem'} = ['1GB],
  #
  #-------------------------------------------------------------------

  printstatus("creating \"attribute\" datastructure...");

  #-------------------------------------------------------------------
  # Populate the attribute datastructure.
  #
  foreach my $label ( keys %lookup ) {
    if (exists $lookup{$label}{'attr'}) {
      my @attr = @{ $lookup{$label}{'attr'} };
      foreach my $attr (@attr) {
	my ($key,$value) = split(/\s*=\s*/,$attr);
	if (not already_in_array($value,$attribute{$label}{$key})) {
	  push @{ $attribute{$label}{$key} }, $value;
	}
      }
    }
  }
}

######################################################################

sub create_specials_datastructure {

  #-------------------------------------------------------------------
  # NOTES
  #
  #     Create the 'specials' datastructure by sifting through the
  #     'lookup' datastructure to count the number of special items in
  #     each section.  The data in the 'lookup' datastructure looks
  #     like this:
  #
  #       $lookup{$label}{$element};
  #
  #       $lookup{'rq-1111'}{'title'}   = 'My Title';
  #       $lookup{'rq-1111'}{'label'}   = 'rq-1111';
  #       $lookup{'rq-1111'}{'parent'}  = 'rq-2222';
  #       $lookup{'rq-1111'}{'type'}    = 'functional';
  #       $lookup{'rq-1111'}{'section'} = '2.6.1';
  #
  #     Assuming section 2.6.1 has only that one 'problem' region, the
  #     corresponding entry in the 'specials' datastructure would be:
  #
  #       $specials{'problem'}{'2.6.1'} = 1;
  #
  #-------------------------------------------------------------------

  printstatus("creating \"specials\" datastructure...");

  foreach my $label ( keys %lookup ) {
    my $name = name_for($label);
    if ( is_special($name) and defined $lookup{$label}{'section'} ) {
      my $section = $lookup{$label}{'section'};
      ++ $specials{$name}{$section};
    }
  }

}

######################################################################

sub render_matrix {

  # Render a traceability matrix

  my $name = shift;

  printstatus("rendering $name traceability matrix");

  if ($rendering{'html'}) {

    my $aref = $html{$name}{'index'};

    #-----------------------------------------------------------------
    # Make a queue of items to be added to this index and add all of
    # the toplevel items.  A toplevel item is simply any item that
    # either doesn't have a parent, or the parent is not in the
    # document being published.
    #
    my @queue = ();
    my @toplevelitems = ();
    foreach my $item ( list_by_name($name) ) {
      my $item_parent = $lookup{$item}{'parent'} || '';
      if ( not $item_parent or not $lookup{$item_parent}{'title'} ) {
        push @toplevelitems, $item;
      }
    }

    #-----------------------------------------------------------------
    # Count items
    #
    my $part_count = scalar(@toplevelitems);
    my $total_count = 0;
    foreach my $item (@toplevelitems) {
      $total_count = $total_count + count_children($item);
    }
    $total_count = '' if $total_count == 0;

    #-----------------------------------------------------------------
    # Start the HTML listing.
    #
    push @{ $aref }, <<"END_OF_TEXT";
<table align="center" border="0" width="80%">
<tr>

<td align="left">
<b>status:</b>
<image src="$status_green_icon" border="0"/>=100%
<image src="$status_yellow_icon" border="0"/>=partial
<image src="$status_red_icon" border="0"/>=0%
<image src="$status_grey_icon" border="0"/>=unknown
</td>

<td align="right">
<b>priority:</b>
<image src="$priority_red_icon" border="0"/>=critical
<image src="$priority_orange_icon" border="0"/>=high
<image src="$priority_yellow_icon" border="0"/>=routine
<image src="$priority_grey_icon" border="0"/>=low/unknown
</td>

</tr>
</table>

<!-- ############################################################ -->

<table width="100%" cellspacing="0" cellpadding="4">

<!-- ============================================================ -->

<tr class="req_header">
<td></td>
<td colspan="3"><a name="toplevel_list"/><span class="req_title">Top Level</span></td>
<td align="right">$part_count parts, $total_count total</td>
</tr>

<!-- ============================================================ -->

<tr class="req_header">
<td class="req_header"></td>
<td class="req_header" width="42%">$name</td>
<!-- <td class="req_header">priority</td> -->
<!-- <td class="req_header">status</td> -->
<td class="req_header" align="center">parts</td>
<td class="req_header" align="center">total</td>
<td class="req_header" width="42%">traceability</td>
</tr>

END_OF_TEXT

    #---------------------------------------------------------------
    # $ord switches between even and odd for each row.
    #
    my $ord = 'odd';

    #-----------------------------------------------------------------
    # Process each toplevel item, adding it to the items index.
    #
    foreach my $item (@toplevelitems) {

      #---------------------------------------------------------------
      # If this item has children, add it to the list of items in the
      # queue.
      #
      if (@{$lookup{$item}{'children'}}) {
        push @queue, $item;
      }

      if ($ord eq 'odd') {
        $ord = 'even';
      } else {
        $ord = 'odd';
      }

      #---------------------------------------------------------------
      # figure out all of the values that need to go into the index
      # for this item.
      #
      my $html_title    = escape_html($lookup{$item}{'title'});
      my $description   = escape_html($lookup{$item}{'description'});
      my @children      = @{$lookup{$item}{'children'}};
      my @type          = @{ $lookup{$item}{'type'} };
      my $type          = join(', ', @type);
      my $priority      = $lookup{$item}{'priority'};
      my $priority_icon = html_priority_icon_for($priority);
      my $tier          = $lookup{$item}{'tier'};
      my $childcount    = @{$lookup{$item}{'children'}};
      my @requests      = @{$lookup{$item}{'request'}};
      my $requests      = join(', ', @requests);
      my $status        = status_of($item) if label_exists($item);
      my $status_icon   = html_status_icon_for($status);
      my $status_source = $status{$item}{'source'} || '';
      my $status_date   = $status{$item}{'date'}   || '';
      my $number        = $label{$item}{'number'};
      my $outfile       = html_outfile_for_label($item);
      my $days_old      = $days_old{$item}{'num'}  || 0;
      my $last_changed  = $days_old{$item}{'date'} || 0;
      my $anchor        = "$item";

      #---------------------------------------------------------------
      # Assemble info
      #
      my @info = ();
      push @info, $item                if $item;
      push @info, $type                if $type;
      push @info, "tier $tier"         if $tier;
      push @info, $requests            if $requests;

      if ( $days_old < $RECENT and $option{'use_svn'} ) {
	push @info, "<span class=\"recent\">last changed $last_changed</span>";
      } elsif ( $last_changed and $option{'use_svn'} ) {
	push @info, "last changed $last_changed";
      }

      my $info = join(', ', @info);

      #-----------------------------------------------------------------
      # Count items
      #
      my $total_count = scalar(@children);
      foreach my $item (@children) {
	$total_count = $total_count + count_children($item);
      }
      $total_count = '' if $total_count == 0;

      #---------------------------------------------------------------
      # If the status_source is a label, turn it into a hyperlink
      #
      if ( label_exists($status_source) ) {
	my $src_outfile = html_outfile_for_label($status_source);
	my $src_label   = $status_source;
	$status_source = "<a href=\"$src_outfile#$src_label\">$status_source</a>";
      }

      #---------------------------------------------------------------
      # Put this toplevel item into the matrix.
      #
      push @{ $aref }, <<"END_OF_TEXT";
<!-- ============================================================ -->

<tr class="req_${ord}">
<td>
<a name="$item"/>
<p style="margin: 0px; padding-bottom: 4px;" align="center">$status_icon</p>
<p style="margin: 0px; padding-bottom: 0px;" align="center">$priority_icon</p>
</td>
<td>

<span class="req_title"><a href="$outfile#$anchor">$html_title</a></span>
 - $description<br/> <span class="req_info">$info</span>

</td>
<!-- <td class="req_${priority}"><a name="$item"/>$priority</td> -->
<!-- <td class="req_${status}">$status $status_date $status_source</td> -->
<td class="req_grey" align="center"><a href="#${item}_list">$childcount</a></td>
<td class="req_grey" align="center">$total_count</td>
<td>

END_OF_TEXT

      #---------------------------------------------------------------
      # owner
      #
      my $owner = $lookup{$item}{'owner'};
      if ($owner) {
	my $string = render_html_trace('owner', $owner);
	push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # assignees
      #
      my @assignee = ();
      if ( ref $lookup{$item}{'assignee'} eq 'ARRAY' ) {
	@assignee = @{$lookup{$item}{'assignee'}};
      }
      elsif ($lookup{$item}{'assignee'}) {
	push @assignee, $lookup{$item}{'assignee'};
      }
      foreach my $assignee (@assignee) {
	my $string = render_html_trace('assignee', $assignee);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # stakeholders
      #
      my @stakeholder = ();
      if ( ref $lookup{$item}{'stakeholder'} eq 'ARRAY' ) {
	@stakeholder = @{$lookup{$item}{'stakeholder'}};
      }
      elsif ($lookup{$item}{'stakeholder'}) {
	push @stakeholder, $lookup{$item}{'stakeholder'};
      }
      foreach my $stakeholder (@stakeholder) {
	my $string = render_html_trace('stakeholder', $stakeholder);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # directs
      #
      my @directs = ();
      if ( ref $lookup{$item}{'direct'} eq 'ARRAY' ) {
	@directs = @{$lookup{$item}{'directs'}};
      }
      elsif ($lookup{$item}{'directs'}) {
	push @directs, $lookup{$item}{'directs'};
      }
      foreach my $directs (@directs) {
	my $string = render_html_trace('directs', $directs);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # directed_by
      #
      my @directed_by = ();
      if ( ref $lookup{$item}{'directed_by'} eq 'ARRAY' ) {
	@directed_by = @{$lookup{$item}{'directed_by'}};
      }
      elsif ($lookup{$item}{'directed_by'}) {
	push @directed_by, $lookup{$item}{'directed_by'};
      }
      foreach my $directed_by (@directed_by) {
	my $string = render_html_trace('directed_by', $directed_by);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # class_of
      #
      my @class_of = ();
      if ( ref $lookup{$item}{'class_of'} eq 'ARRAY' ) {
	@class_of = @{$lookup{$item}{'class_of'}};
      }
      elsif ($lookup{$item}{'class_of'}) {
	push @class_of, $lookup{$item}{'class_of'};
      }
      foreach my $class_of (@class_of) {
	my $string = render_html_trace('class_of', $class_of);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # instance_of
      #
      my @instance_of = ();
      if ( ref $lookup{$item}{'instance_of'} eq 'ARRAY' ) {
	@instance_of = @{$lookup{$item}{'instance_of'}};
      }
      elsif ($lookup{$item}{'instance_of'}) {
	push @instance_of, $lookup{$item}{'instance_of'};
      }
      foreach my $instance_of (@instance_of) {
	my $string = render_html_trace('instance_of', $instance_of);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # generalizes
      #
      my @generalizes = ();
      if ( ref $lookup{$item}{'generalizes'} eq 'ARRAY' ) {
	@generalizes = @{$lookup{$item}{'generalizes'}};
      }
      elsif ($lookup{$item}{'generalizes'}) {
	push @generalizes, $lookup{$item}{'generalizes'};
      }
      foreach my $generalizes (@generalizes) {
	my $string = render_html_trace('generalizes', $generalizes);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # specializes
      #
      my @specializes = ();
      if ( ref $lookup{$item}{'specializes'} eq 'ARRAY' ) {
	@specializes = @{$lookup{$item}{'specializes'}};
      }
      elsif ($lookup{$item}{'specializes'}) {
	push @specializes, $lookup{$item}{'specializes'};
      }
      foreach my $specializes (@specializes) {
	my $string = render_html_trace('specializes', $specializes);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # uses
      #
      my @uses = ();
      if ( ref $lookup{$item}{'uses'} eq 'ARRAY' ) {
	@uses = @{$lookup{$item}{'uses'}};
      }
      elsif ($lookup{$item}{'uses'}) {
	push @uses, $lookup{$item}{'uses'};
      }
      foreach my $uses (@uses) {
	my $string = render_html_trace('uses', $uses);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # used_by
      #
      my @used_by = ();
      if ( ref $lookup{$item}{'used_by'} eq 'ARRAY' ) {
	@used_by = @{$lookup{$item}{'used_by'}};
      }
      elsif ($lookup{$item}{'used_by'}) {
	push @used_by, $lookup{$item}{'used_by'};
      }
      foreach my $used_by (@used_by) {
	my $string = render_html_trace('used_by', $used_by);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # depends_on
      #
      my @depends_on = ();
      if ( ref $lookup{$item}{'depends_on'} eq 'ARRAY' ) {
	@depends_on = @{$lookup{$item}{'depends_on'}};
      }
      elsif ($lookup{$item}{'depends_on'}) {
	push @depends_on, $lookup{$item}{'depends_on'};
      }
      foreach my $depends_on (@depends_on) {
	my $string = render_html_trace('depends_on', $depends_on);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # required_by
      #
      my @required_by = ();
      if ( ref $lookup{$item}{'required_by'} eq 'ARRAY' ) {
	@required_by = @{$lookup{$item}{'required_by'}};
      }
      elsif ($lookup{$item}{'required_by'}) {
	push @required_by, $lookup{$item}{'required_by'};
      }
      foreach my $required_by (@required_by) {
	my $string = render_html_trace('required_by', $required_by);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # extends
      #
      my @extends = ();
      if ( ref $lookup{$item}{'extends'} eq 'ARRAY' ) {
	@extends = @{$lookup{$item}{'extends'}};
      }
      elsif ($lookup{$item}{'extends'}) {
	push @extends, $lookup{$item}{'extends'};
      }
      foreach my $extends (@extends) {
	my $string = render_html_trace('extends', $extends);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # extended_by
      #
      my @extended_by = ();
      if ( ref $lookup{$item}{'extended_by'} eq 'ARRAY' ) {
	@extended_by = @{$lookup{$item}{'extended_by'}};
      }
      elsif ($lookup{$item}{'extended_by'}) {
	push @extended_by, $lookup{$item}{'extended_by'};
      }
      foreach my $extended_by (@extended_by) {
	my $string = render_html_trace('extended_by', $extended_by);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # realizes
      #
      my @realizes = ();
      if ( ref $lookup{$item}{'realizes'} eq 'ARRAY' ) {
	@realizes = @{$lookup{$item}{'realizes'}};
      }
      elsif ($lookup{$item}{'realizes'}) {
	push @realizes, $lookup{$item}{'realizes'};
      }
      foreach my $realizes (@realizes) {
	my $string = render_html_trace('realizes', $realizes);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # realized_by
      #
      my @realized_by = ();
      if ( ref $lookup{$item}{'realized_by'} eq 'ARRAY' ) {
	@realized_by = @{$lookup{$item}{'realized_by'}};
      }
      elsif ($lookup{$item}{'realized_by'}) {
	push @realized_by, $lookup{$item}{'realized_by'};
      }
      foreach my $realized_by (@realized_by) {
	my $string = render_html_trace('realized_by', $realized_by);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # derived_from
      #
      my @derived_from = ();
      if ( ref $lookup{$item}{'derived_from'} eq 'ARRAY' ) {
	@derived_from = @{$lookup{$item}{'derived_from'}};
      }
      elsif ($lookup{$item}{'derived_from'}) {
	push @derived_from, $lookup{$item}{'derived_from'};
      }
      foreach my $derived_from (@derived_from) {
	my $string = render_html_trace('derived_from', $derived_from);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # derived
      #
      my @derived = ();
      if ( ref $lookup{$item}{'derived'} eq 'ARRAY' ) {
	@derived = @{$lookup{$item}{'derived'}};
      }
      elsif ($lookup{$item}{'derived'}) {
	push @derived, $lookup{$item}{'derived'};
      }
      foreach my $derived (@derived) {
	my $string = render_html_trace('derived', $derived);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # roles
      #
      my @roles = ();
      if ( ref $lookup{$item}{'role'} eq 'ARRAY' ) {
	@roles = @{$lookup{$item}{'role'}};
      }
      elsif ($lookup{$item}{'role'}) {
	push @roles, $lookup{$item}{'role'};
      }
      foreach my $role (@roles) {
	my $string = render_html_trace('role', $role);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # solutions
      #
      my @solutions = ();
      if ( ref $lookup{$item}{'solution'} eq 'ARRAY' ) {
	@solutions = @{$lookup{$item}{'solution'}};
      }
      elsif ($lookup{$item}{'solution'}) {
	push @solutions, $lookup{$item}{'solution'};
      }
      foreach my $solution (@solutions) {
	my $string = render_html_trace('solution', $solution);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # problems
      #
      my @problems = ();
      if ( ref $lookup{$item}{'problem'} eq 'ARRAY' ) {
	@problems = @{$lookup{$item}{'problem'}};
      }
      elsif ($lookup{$item}{'problem'}) {
	push @problems, $lookup{$item}{'problem'};
      }
      foreach my $problem (@problems) {
	my $string = render_html_trace('problem', $problem);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # allocations
      #
      my @allocations = ();
      if ( ref $lookup{$item}{'allocation'} eq 'ARRAY' ) {
	@allocations = @{$lookup{$item}{'allocation'}};
      }
      elsif ($lookup{$item}{'allocation'}) {
	push @allocations, $lookup{$item}{'allocation'};
      }
      foreach my $allocation (@allocations) {
	my $string = render_html_trace('allocation', $allocation);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # assignments
      #
      my @assignments = ();
      if ( ref $lookup{$item}{'assignment'} eq 'ARRAY' ) {
	@assignments = @{$lookup{$item}{'assignment'}};
      }
      elsif ($lookup{$item}{'assignment'}) {
	push @assignments, $lookup{$item}{'assignment'};
      }
      foreach my $assignment (@assignments) {
	my $string = render_html_trace('assignment', $assignment);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # tasks
      #
      my @tasks = ();
      if ( ref $lookup{$item}{'task'} eq 'ARRAY' ) {
	@tasks = @{$lookup{$item}{'task'}};
      }
      elsif ($lookup{$item}{'task'}) {
	push @tasks, $lookup{$item}{'task'};
      }
      foreach my $task (@tasks) {
	my $string = render_html_trace('task', $task);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # tests
      #
      my @tests = ();
      if ( ref $lookup{$item}{'test'} eq 'ARRAY' ) {
	@tests = @{$lookup{$item}{'test'}};
      }
      elsif ($lookup{$item}{'test'}) {
	push @tests, $lookup{$item}{'test'};
      }
      foreach my $test (@tests) {
	my $string = render_html_trace('test', $test);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # results
      #
      my @results = ();
      if ( ref $lookup{$item}{'result'} eq 'ARRAY' ) {
	@results = @{$lookup{$item}{'result'}};
      }
      elsif ($lookup{$item}{'result'}) {
	push @results, $lookup{$item}{'result'};
      }
      foreach my $result (@results) {
	my $string = render_html_trace('result', $result);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # next
      #
      my @next = ();
      if ( ref $lookup{$item}{'next'} eq 'ARRAY' ) {
	@next = @{$lookup{$item}{'next'}};
      }
      elsif ($lookup{$item}{'next'}) {
	push @next, $lookup{$item}{'next'};
      }
      foreach my $next (@next) {
	my $string = render_html_trace('next', $next);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # previous
      #
      my @previous = ();
      if ( ref $lookup{$item}{'previous'} eq 'ARRAY' ) {
	@previous = @{$lookup{$item}{'previous'}};
      }
      elsif ($lookup{$item}{'previous'}) {
	push @previous, $lookup{$item}{'previous'};
      }
      foreach my $previous (@previous) {
	my $string = render_html_trace('previous', $previous);
        push @{ $aref }, "$string";
      }

      #---------------------------------------------------------------
      # effort
      #
      my $effort = effort_for($item);
      if ($effort =~ /^\s*(\d+\.\d+|\d+\.|\.\d+|\d+)/ and $1 != 0) {
	my $string = render_html_trace('effort', $effort);
        push @{ $aref }, "$string";
      }

      #----------------------------------------------------------------
      # end the table cell and row
      #
      push @{ $aref }, <<"END_OF_TEXT";
</td>
</tr>

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # Put a spacer row between the top level items and all the rest.
    #
    push @{ $aref }, <<"END_OF_TEXT";
<!-- ============================================================ -->
<tr>
<td colspan="5">&nbsp;</td>
</tr>

END_OF_TEXT

    #-----------------------------------------------------------------
    # Now process each item on the queue, adding new items to the back
    # of the queue as you find ones that have children.
    #
    foreach my $item (@queue) {

      #---------------------------------------------------------------
      # Get the title of this item
      #
      my $title    = escape_html($lookup{$item}{'title'});
      my $parent   = $lookup{$item}{'parent'};
      my @children = @{$lookup{$item}{'children'}};
      my $outfile  = html_outfile_for_label($item);
      my $anchor   = "$item";
      my @type     = @{ $lookup{$item}{'type'} };
      my $type     = join(', ', @type);
      my $tier     = $lookup{$item}{'tier'};
      my @requests = @{$lookup{$item}{'request'}};
      my $requests = join(', ', @requests);
      my $days_old = $days_old{$item}{'num'} || 0;
      my $last_changed = $days_old{$item}{'date'} || 0;

      #-----------------------------------------------------------------
      # Count items
      #
      my $part_count  = scalar(@children);
      my $total_count = scalar(@children);
      foreach my $item (@children) {
	$total_count = $total_count + count_children($item);
      }
      $total_count = '' if $total_count == 0;

      #-------------------------------------------------------------
      # Assemble info
      #
      my @info = ();
      push @info, $item                if $item;
      push @info, $type                if $type;
      push @info, "tier $tier"         if $tier;
      push @info, $requests            if $requests;

      if ( $days_old < $RECENT and $option{'use_svn'} ) {
	push @info, "<span class=\"recent\">last changed $last_changed</span>";
      } elsif ($last_changed and $option{'use_svn'} ) {
	push @info, "last changed $last_changed";
      }

      my $info = join(', ', @info);

      #---------------------------------------------------------------
      # Insert the header for this item
      #
      push @{ $aref }, <<"END_OF_TEXT";
<!-- ============================================================ -->

<tr class="req_header">
<td></td>
<td>
<a name="${item}_list"/>
<a href="$outfile#$anchor"><span class="req_title">$title</span></a>
<br/>
<span class="req_info">$info</span>
</td>
<!-- <td></td> -->
<!-- <td></td> -->
<td align="center"><span style="font-size: 8pt;"><a href="#$anchor">up</a></span></td>
<td></td>
<td align="right">$part_count parts, $total_count total</td>
</tr>

<!-- ============================================================ -->

<tr class="req_header">
<td class="req_header"></td>
<td class="req_header" width="42%">$name</td>
<!-- <td class="req_header">priority</td> -->
<!-- <td class="req_header">status</td> -->
<td class="req_header" align="center">parts</td>
<td class="req_header" align="center">total</td>
<td class="req_header" width="42%">traceability</td>
</tr>

END_OF_TEXT

      #---------------------------------------------------------------
      # $ord switches between even and odd for each row.
      #
      my $ord = 'odd';

      #---------------------------------------------------------------
      # Insert the children of this item.
      #
      foreach my $child (sort by_doc_order @children) {

        #-------------------------------------------------------------
        # If this child has children, add it to the queue.
        #
        if (@{$lookup{$child}{'children'}}) {
          push @queue, $child;
        }

        #-------------------------------------------------------------
        # figure out all of the values that need to go into the index
        # for this child
        #
        if ($ord eq 'odd') {
          $ord = 'even';
        } else {
          $ord = 'odd';
        }

        my $title         = escape_html($lookup{$child}{'title'});
        my $description   = escape_html($lookup{$child}{'description'});
	my @grandchildren = @{$lookup{$child}{'children'}};
        my @type          = @{ $lookup{$child}{'type'} };
        my $type          = join(', ', @type);
        my $priority      = $lookup{$child}{'priority'};
	my $priority_icon = html_priority_icon_for($priority);
	my $tier          = $lookup{$child}{'tier'};
        my $childcount    = @{$lookup{$child}{'children'}};
        my @requests      = @{$lookup{$child}{'request'}};
        my $requests      = join(', ', @requests);
        my $status        = status_of($child) if label_exists($child);
	my $status_icon   = html_status_icon_for($status);
	my $status_source = $status{$child}{'source'} || '';
	my $status_date   = $status{$child}{'date'}   || '';
        my $number        = $label{$child}{'number'};
	my $outfile       = html_outfile_for_label($child);
	my $days_old      = $days_old{$child}{'num'} || 0;
	my $last_changed  = $days_old{$child}{'date'} || 0;
	my $anchor        = "$child";

        #-------------------------------------------------------------
	# Assemble info
	#
        my @info = ();
        push @info, $child               if $child;
        push @info, $type                if $type;
	push @info, "tier $tier"         if $tier;
        push @info, $requests            if $requests;

	if ( $days_old < $RECENT and $option{'use_svn'} ) {
	  push @info, "<span class=\"recent\">last changed $last_changed</span>";
	} elsif ( $last_changed and $option{'use_svn'} ) {
	  push @info, "last changed $last_changed";
	}

        my $info = join(', ', @info);

	#-----------------------------------------------------------------
	# Count items
	#
	my $total_count = scalar(@grandchildren);
	foreach my $item (@grandchildren) {
	  $total_count = $total_count + count_children($item);
	}
	$total_count = '' if $total_count == 0;

        #-------------------------------------------------------------
	# If the status_source is a label, turn it into a hyperlink
	#
	if ( label_exists($status_source) ) {
	  my $src_outfile = html_outfile_for_label($status_source);
	  my $src_anchor  = "$status_source";
	  $status_source  = "<a href=\"$src_outfile#$src_anchor\">$status_source</a>";
	}

        #-------------------------------------------------------------
        # Put this item into the index.
        #
        push @{ $aref }, <<"END_OF_TEXT";
<!-- ============================================================ -->

<tr class="req_${ord}">
<td>
<a name="$child"/>
<p style="margin: 0px; padding-bottom: 4px;" align="center">$status_icon</p>
<p style="margin: 0px; padding-bottom: 0px;" align="center">$priority_icon</p>
</td>
<td>

<span class="req_title"><a href="$outfile#$anchor">$title</a></span>
 - $description<br/> <span class="req_info">$info</span>

</td>
<!-- <td class="req_${priority}"><a name="$child"/>$priority</td> -->
<!-- <td class="req_${status}">$status $status_date $status_source</td> -->
<td class="req_grey" align="center"><a href="#${child}_list">$childcount</a></td>
<td class="req_grey" align="center">$total_count</td>
<td>

END_OF_TEXT

	#-------------------------------------------------------------
	# owner
	#
	my $owner = $lookup{$child}{'owner'};
	if ($owner) {
	  my $string = render_html_trace('owner', $owner);
	  push @{ $aref }, "$string";
	}

	#---------------------------------------------------------------
	# assignees
	#
	my @assignee = ();
	if ( ref $lookup{$child}{'assignee'} eq 'ARRAY' ) {
	  @assignee = @{$lookup{$child}{'assignee'}};
	}
	elsif ($lookup{$child}{'assignee'}) {
	  push @assignee, $lookup{$child}{'assignee'};
	}
	foreach my $assignee (@assignee) {
	  my $string = render_html_trace('assignee', $assignee);
	  push @{ $aref }, "$string";
	}

	#-------------------------------------------------------------
	# stakeholders
	#
	my @stakeholder = ();
	if ( ref $lookup{$child}{'stakeholder'} eq 'ARRAY' ) {
	  @stakeholder = @{$lookup{$child}{'stakeholder'}};
	}
	elsif ($lookup{$child}{'stakeholder'}) {
	  push @stakeholder, $lookup{$child}{'stakeholder'};
	}
	foreach my $stakeholder (@stakeholder) {
	  my $string = render_html_trace('stakeholder', $stakeholder);
	  push @{ $aref }, "$string";
	}

	#-------------------------------------------------------------
	# directs
	#
	my @directs = ();
	if ( ref $lookup{$child}{'direct'} eq 'ARRAY' ) {
	  @directs = @{$lookup{$child}{'directs'}};
	}
	elsif ($lookup{$child}{'directs'}) {
	  push @directs, $lookup{$child}{'directs'};
	}
	foreach my $directs (@directs) {
	  my $string = render_html_trace('directs', $directs);
	  push @{ $aref }, "$string";
	}

	#-------------------------------------------------------------
	# directed_by
	#
	my @directed_by = ();
	if ( ref $lookup{$child}{'directed_by'} eq 'ARRAY' ) {
	  @directed_by = @{$lookup{$child}{'directed_by'}};
	}
	elsif ($lookup{$child}{'directed_by'}) {
	  push @directed_by, $lookup{$child}{'directed_by'};
	}
	foreach my $directed_by (@directed_by) {
	  my $string = render_html_trace('directed_by', $directed_by);
	  push @{ $aref }, "$string";
	}

      #---------------------------------------------------------------
      # class_of
      #
	my @class_of = ();
	if ( ref $lookup{$child}{'class_of'} eq 'ARRAY' ) {
	  @class_of = @{$lookup{$child}{'class_of'}};
	} elsif ($lookup{$child}{'class_of'}) {
	  push @class_of, $lookup{$child}{'class_of'};
	}
	foreach my $class_of (@class_of) {
	  my $string = render_html_trace('class_of', $class_of);
	  push @{ $aref }, "$string";
	}

	#---------------------------------------------------------------
	# instance_of
	#
	my @instance_of = ();
	if ( ref $lookup{$child}{'instance_of'} eq 'ARRAY' ) {
	  @instance_of = @{$lookup{$child}{'instance_of'}};
	} elsif ($lookup{$child}{'instance_of'}) {
	  push @instance_of, $lookup{$child}{'instance_of'};
	}
	foreach my $instance_of (@instance_of) {
	  my $string = render_html_trace('instance_of', $instance_of);
	  push @{ $aref }, "$string";
	}

	#---------------------------------------------------------------
	# generalizes
	#
	my @generalizes = ();
	if ( ref $lookup{$child}{'generalizes'} eq 'ARRAY' ) {
	  @generalizes = @{$lookup{$child}{'generalizes'}};
	} elsif ($lookup{$child}{'generalizes'}) {
	  push @generalizes, $lookup{$child}{'generalizes'};
	}
	foreach my $generalizes (@generalizes) {
	  my $string = render_html_trace('generalizes', $generalizes);
	  push @{ $aref }, "$string";
	}

	#---------------------------------------------------------------
	# specializes
	#
	my @specializes = ();
	if ( ref $lookup{$child}{'specializes'} eq 'ARRAY' ) {
	  @specializes = @{$lookup{$child}{'specializes'}};
	} elsif ($lookup{$child}{'specializes'}) {
	  push @specializes, $lookup{$child}{'specializes'};
	}
	foreach my $specializes (@specializes) {
	  my $string = render_html_trace('specializes', $specializes);
	  push @{ $aref }, "$string";
	}

	#-------------------------------------------------------------
	# uses
	#
	my @uses = ();
	if ( ref $lookup{$child}{'uses'} eq 'ARRAY' ) {
	  @uses = @{$lookup{$child}{'uses'}};
	}
	elsif ($lookup{$child}{'uses'}) {
	  push @uses, $lookup{$child}{'uses'};
	}
	foreach my $uses (@uses) {
	  my $string = render_html_trace('uses', $uses);
	  push @{ $aref }, "$string";
	}

	#-------------------------------------------------------------
	# used_by
	#
	my @used_by = ();
	if ( ref $lookup{$child}{'used_by'} eq 'ARRAY' ) {
	  @used_by = @{$lookup{$child}{'used_by'}};
	}
	elsif ($lookup{$child}{'used_by'}) {
	  push @used_by, $lookup{$child}{'used_by'};
	}
	foreach my $used_by (@used_by) {
	  my $string = render_html_trace('used_by', $used_by);
	  push @{ $aref }, "$string";
	}

	#-------------------------------------------------------------
	# depends_on
	#
	my @depends_on = ();
	if ( ref $lookup{$child}{'depends_on'} eq 'ARRAY' ) {
	  @depends_on = @{$lookup{$child}{'depends_on'}};
	}
	elsif ($lookup{$child}{'depends_on'}) {
	  push @depends_on, $lookup{$child}{'depends_on'};
	}
	foreach my $depends_on (@depends_on) {
	  my $string = render_html_trace('depends_on', $depends_on);
	  push @{ $aref }, "$string";
	}

	#-------------------------------------------------------------
	# required_by
	#
	my @required_by = ();
	if ( ref $lookup{$child}{'required_by'} eq 'ARRAY' ) {
	  @required_by = @{$lookup{$child}{'required_by'}};
	}
	elsif ($lookup{$child}{'required_by'}) {
	  push @required_by, $lookup{$child}{'required_by'};
	}
	foreach my $required_by (@required_by) {
	  my $string = render_html_trace('required_by', $required_by);
	  push @{ $aref }, "$string";
	}

	#-------------------------------------------------------------
	# extends
	#
	my @extends = ();
	if ( ref $lookup{$child}{'extends'} eq 'ARRAY' ) {
	  @extends = @{$lookup{$child}{'extends'}};
	}
	elsif ($lookup{$child}{'extends'}) {
	  push @extends, $lookup{$child}{'extends'};
	}
	foreach my $extends (@extends) {
	  my $string = render_html_trace('extends', $extends);
	  push @{ $aref }, "$string";
	}

	#-------------------------------------------------------------
	# extended_by
	#
	my @extended_by = ();
	if ( ref $lookup{$child}{'extended_by'} eq 'ARRAY' ) {
	  @extended_by = @{$lookup{$child}{'extended_by'}};
	}
	elsif ($lookup{$child}{'extended_by'}) {
	  push @extended_by, $lookup{$child}{'extended_by'};
	}
	foreach my $extended_by (@extended_by) {
	  my $string = render_html_trace('extended_by', $extended_by);
	  push @{ $aref }, "$string";
	}

	#-------------------------------------------------------------
	# realizes
	#
	my @realizes = ();
	if ( ref $lookup{$child}{'realizes'} eq 'ARRAY' ) {
	  @realizes = @{$lookup{$child}{'realizes'}};
	}
	elsif ($lookup{$child}{'realizes'}) {
	  push @realizes, $lookup{$child}{'realizes'};
	}
	foreach my $realizes (@realizes) {
	  my $string = render_html_trace('realizes', $realizes);
	  push @{ $aref }, "$string";
	}

	#-------------------------------------------------------------
	# realized_by
	#
	my @realized_by = ();
	if ( ref $lookup{$child}{'realized_by'} eq 'ARRAY' ) {
	  @realized_by = @{$lookup{$child}{'realized_by'}};
	}
	elsif ($lookup{$child}{'realized_by'}) {
	  push @realized_by, $lookup{$child}{'realized_by'};
	}
	foreach my $realized_by (@realized_by) {
	  my $string = render_html_trace('realized_by', $realized_by);
	  push @{ $aref }, "$string";
	}

	#-------------------------------------------------------------
	# derived_from
	#
	my @derived_from = ();
	if ( ref $lookup{$child}{'derived_from'} eq 'ARRAY' ) {
	  @derived_from = @{$lookup{$child}{'derived_from'}};
	}
	elsif ($lookup{$child}{'derived_from'}) {
	  push @derived_from, $lookup{$child}{'derived_from'};
	}
	foreach my $derived_from (@derived_from) {
	  my $string = render_html_trace('derived_from', $derived_from);
	  push @{ $aref }, "$string";
	}

	#---------------------------------------------------------------
	# derived
	#
	my @derived = ();
	if ( ref $lookup{$child}{'derived'} eq 'ARRAY' ) {
	  @derived = @{$lookup{$child}{'derived'}};
	}
	elsif ($lookup{$child}{'derived'}) {
	  push @derived, $lookup{$child}{'derived'};
	}
	foreach my $derived (@derived) {
	  my $string = render_html_trace('derived', $derived);
	  push @{ $aref }, "$string";
	}

	#-------------------------------------------------------------
	# solutions
	#
	my @solutions = ();
	if ( ref $lookup{$child}{'solution'} eq 'ARRAY' ) {
	  @solutions = @{$lookup{$child}{'solution'}};
	}
	elsif ($lookup{$child}{'solution'}) {
	  push @solutions, $lookup{$child}{'solution'};
	}
	foreach my $solution (@solutions) {
	  my $string = render_html_trace('solution', $solution);
	  push @{ $aref }, "$string";
	}

	#-------------------------------------------------------------
	# problems
	#
	my @problems = ();
	if ( ref $lookup{$child}{'problem'} eq 'ARRAY' ) {
	  @problems = @{$lookup{$child}{'problem'}};
	}
	elsif ($lookup{$child}{'problem'}) {
	  push @problems, $lookup{$child}{'problem'};
	}
	foreach my $problem (@problems) {
	  my $string = render_html_trace('problem', $problem);
	  push @{ $aref }, "$string";
	}

	#-------------------------------------------------------------
	# allocations
	#
	my @allocations = ();
	if ( ref $lookup{$child}{'allocation'} eq 'ARRAY' ) {
	  @allocations = @{$lookup{$child}{'allocation'}};
	}
	elsif ($lookup{$child}{'allocation'}) {
	  push @allocations, $lookup{$child}{'allocation'};
	}
	foreach my $allocation (@allocations) {
	  my $string = render_html_trace('allocation', $allocation);
	  push @{ $aref }, "$string";
	}

	#-------------------------------------------------------------
	# assignments
	#
	my @assignments = ();
	if ( ref $lookup{$child}{'assignment'} eq 'ARRAY' ) {
	  @assignments = @{$lookup{$child}{'assignment'}};
	}
	elsif ($lookup{$child}{'assignment'}) {
	  push @assignments, $lookup{$child}{'assignment'};
	}
	foreach my $assignment (@assignments) {
	  my $string = render_html_trace('assignment', $assignment);
	  push @{ $aref }, "$string";
	}

	#-------------------------------------------------------------
	# tasks
	#
	my @tasks = ();
	if ( ref $lookup{$child}{'task'} eq 'ARRAY' ) {
	  @tasks = @{$lookup{$child}{'task'}};
	}
	elsif ($lookup{$child}{'task'}) {
	  push @tasks, $lookup{$child}{'task'};
	}
	foreach my $task (@tasks) {
	  my $string = render_html_trace('task', $task);
	  push @{ $aref }, "$string";
	}

	#-------------------------------------------------------------
	# tests
	#
	my @tests = ();
	if ( ref $lookup{$child}{'test'} eq 'ARRAY' ) {
	  @tests = @{$lookup{$child}{'test'}};
	}
	elsif ($lookup{$child}{'test'}) {
	  push @tests, $lookup{$child}{'test'};
	}
	foreach my $test (@tests) {
	  my $string = render_html_trace('test', $test);
	  push @{ $aref }, "$string";
	}

	#-------------------------------------------------------------
	# results
	#
	my @results = ();
	if ( ref $lookup{$child}{'result'} eq 'ARRAY' ) {
	  @results = @{$lookup{$child}{'result'}};
	}
	elsif ($lookup{$child}{'result'}) {
	  push @results, $lookup{$child}{'result'};
	}
	foreach my $result (@results) {
	  my $string = render_html_trace('result', $result);
	  push @{ $aref }, "$string";
	}

	#-------------------------------------------------------------
	# roles
	#
	my @roles = ();
	if ( ref $lookup{$child}{'role'} eq 'ARRAY' ) {
	  @roles = @{$lookup{$child}{'role'}};
	}
	elsif ($lookup{$child}{'role'}) {
	  push @roles, $lookup{$child}{'role'};
	}
	foreach my $role (@roles) {
	  my $string = render_html_trace('role', $role);
	  push @{ $aref }, "$string";
	}

	#---------------------------------------------------------------
	# next
	#
	my @next = ();
	if ( ref $lookup{$child}{'next'} eq 'ARRAY' ) {
	  @next = @{$lookup{$child}{'next'}};
	}
	elsif ($lookup{$child}{'next'}) {
	  push @next, $lookup{$child}{'next'};
	}
	foreach my $next (@next) {
	  my $string = render_html_trace('next', $next);
	  push @{ $aref }, "$string";
	}

	#---------------------------------------------------------------
	# previous
	#
	my @previous = ();
	if ( ref $lookup{$child}{'previous'} eq 'ARRAY' ) {
	  @previous = @{$lookup{$child}{'previous'}};
	}
	elsif ($lookup{$child}{'previous'}) {
	  push @previous, $lookup{$child}{'previous'};
	}
	foreach my $previous (@previous) {
	  my $string = render_html_trace('previous', $previous);
	  push @{ $aref }, "$string";
	}

	#---------------------------------------------------------------
	# effort
	#
	my $effort = effort_for($child);
	if ($effort =~ /^\s*(\d+\.\d+|\d+\.|\.\d+|\d+)/ and $1 != 0) {
	  my $string = render_html_trace('effort', $effort);
	  push @{ $aref }, "$string";
	}

        #-------------------------------------------------------------
        # end the table cell and row
        #
        push @{ $aref }, <<"END_OF_TEXT";
</td>
</tr>

END_OF_TEXT

      }

      #---------------------------------------------------------------
      # Insert a spacer row.
      #
      push @{ $aref }, <<"END_OF_TEXT";
<tr><td colspan="5">&nbsp;</td></tr>

END_OF_TEXT

    }

    #-----------------------------------------------------------------
    # end the table
    #
    push @{ $aref }, <<"END_OF_TEXT";
</table>

END_OF_TEXT
  }
}

######################################################################

sub render_csvfile {

  my $name    = shift;
  my $aref    = $csv{$name};
  my %heading = ();
  my %row     = ();

  printstatus("rendering $name csv file");

  # print "rendering $name csv file...\n";

  #-------------------------------------------------------------------
  # Get a list of all problem labels.
  #
  my @items = list_by_name($name);

  # my $item_count = scalar @items;
  # print "  $item_count $name items\n";

  #-------------------------------------------------------------------
  # Make a consolidated list of attribute names for all items.
  #
  my %attr_names = ();
  foreach my $item (@items) {
    my @attrs = sort keys %{ $attribute{$item} };
    foreach my $attr (@attrs) {
      $attr_names{$attr} = 1;
    }
  }
  my @attr_names = sort keys %attr_names;

  #-------------------------------------------------------------------
  # Header row data elements
  #
  $heading{'problem'} = [
    'label',        'tier',       'title',        'description',
    'revision',     'date',       'author',       'copyright',
    'parent',       'type',       'priority',     'status',
    'stakeholder',  'owner',      'validator',    'directed_by',
    'solution',     'test',       'associated',   'request',
    'instance_of',  'class_of',   'derived_from', 'derived',
    'allocation',   'assignment', 'generalizes',  'specializes',
  ];

  $heading{'solution'} = [
    'label',       'tier',        'title',        'description',
    'revision',    'date',        'author',       'copyright',
    'parent',      'type',        'priority',     'status',
    'stakeholder', 'owner',       'pro',          'con',
    'depends_on',  'required_by', 'directed_by',
    'version',     'license',     'cost',
    'problem',     'test',        'associated',   'request',
    'instance_of', 'class_of',    'allocation',   'assignment',
    'generalizes', 'specializes',
  ];

  $heading{'allocation'} = [
    'label',       'tier',        'title',        'description',
    'revision',    'date',        'author',
    'parent',      'type',        'priority',     'status',
    'stakeholder', 'owner',       'solution',
    'problem',     'test',        'associated',   'request',
    'instance_of', 'class_of',
  ];

  $heading{'assignment'} = [
    'label',       'tier',        'title',        'description',
    'revision',    'date',        'author',
    'parent',      'type',        'priority',     'status',
    'stakeholder', 'owner',       'solution',
    'problem',     'test',        'associated',   'request',
    'instance_of', 'class_of',
  ];

  $heading{'task'} = [
    'label',       'tier',        'title',        'description',
    'revision',    'date',        'author',       'copyright',
    'parent',      'type',        'priority',     'status',
    'owner',       'product',     'deadline',
    'depends_on',  'required_by', 'directed_by',
    'problem',     'solution',    'test',         'associated',
    'instance_of', 'class_of',
  ];

  $heading{'test'} = [
    'label',       'tier',        'title',        'description',
    'revision',    'date',        'author',       'copyright',
    'parent',      'type',        'priority',     'status',
    'tester',      'owner',       'validator',
    'level',       'question',    'script',
    'depends_on',  'required_by', 'directed_by',
    'problem',     'solution',    'associated',   'request',
    'instance_of', 'class_of',
  ];

  $heading{'result'} = [
    'label',       'tier',        'title',       'description',
    'revision',    'date',        'author',      'copyright',
    'parent',      'type',        'priority',    'status',
    'owner',       'product',     'deadline',
    'depends_on',  'required_by', 'directed_by',
    'problem',     'solution',    'test',        'associated',
    'instance_of', 'class_of',
  ];

  $heading{'role'} = [
    'label',       'tier',        'title',       'description',
    'revision',    'date',        'author',      'copyright',
    'parent',      'type',        'priority',    'status',
    'owner',       'product',     'deadline',
    'depends_on',  'required_by', 'directed_by',
    'problem',     'solution',    'test',        'associated',
    'instance_of', 'class_of',
  ];

  #-------------------------------------------------------------------
  # Add attribute names to the header row.
  #
  foreach my $attr_name (@attr_names) {
    push @{ $heading{$name} }, $attr_name;
  }

  #-------------------------------------------------------------------
  # Add the header (and a newline) to the index.
  #
  my $header = join(',',@{ $heading{$name} });
  push @{ $aref }, $header, "\n";

  #-------------------------------------------------------------------
  # Build a data row for each problem.
  #
  foreach my $item (@items) {

    # print "  $item...\n";

    #-----------------------------------------------------------------
    # Look up common data elements.
    #
    my $tier          = escape_csv($lookup{$item}{'tier'});
    my $title         = escape_csv($lookup{$item}{'title'});
    my $description   = escape_csv($lookup{$item}{'description'});
    my $revision      = escape_csv($lookup{$item}{'revision'});
    my $date          = escape_csv($lookup{$item}{'date'});
    my $author        = escape_csv($lookup{$item}{'author'});
    my $copyright     = escape_csv($lookup{$item}{'copyright'});
    my $parent        = escape_csv($lookup{$item}{'parent'});
    my @type          = @{$lookup{$item}{'type'}};
    my $type          = escape_csv(join('; ',@type));
    my $priority      = escape_csv($lookup{$item}{'priority'});
    my $status        = escape_csv(status_of($item));
    my $product       = escape_csv($lookup{$item}{'product'});
    my $version       = escape_csv($lookup{$item}{'version'});
    my $license       = escape_csv($lookup{$item}{'license'});
    my $cost          = escape_csv($lookup{$item}{'cost'});
    my $deadline      = escape_csv($lookup{$item}{'deadline'});
    my $tester        = escape_csv($lookup{$item}{'tester'});
    my $level         = escape_csv($lookup{$item}{'level'});
    my $question      = escape_csv($lookup{$item}{'question'});
    my $script        = escape_csv($lookup{$item}{'script'});
    my @stakeholder   = @{$lookup{$item}{'stakeholder'}};
    my $stakeholder   = escape_csv(join('; ', @stakeholder));
    my $owner         = escape_csv($lookup{$item}{'owner'});
    my $validator     = escape_csv($lookup{$item}{'validator'});
    my @directed_by   = @{$lookup{$item}{'directed_by'}};
    my $directed_by   = escape_csv(join('; ', @directed_by));
    my @problem       = @{$lookup{$item}{'problem'}};
    my $problem       = escape_csv(join('; ', @problem));
    my @solution      = @{$lookup{$item}{'solution'}};
    my $solution      = escape_csv(join('; ', @solution));
    my @allocation    = @{$lookup{$item}{'allocation'}};
    my $allocation    = escape_csv(join('; ', @allocation));
    my @assignment    = @{$lookup{$item}{'assignment'}};
    my $assignment    = escape_csv(join('; ', @assignment));
    my @task          = @{$lookup{$item}{'task'}};
    my $task          = escape_csv(join('; ', @task));
    my @test          = @{$lookup{$item}{'test'}};
    my $test          = escape_csv(join('; ', @test));
    my @result        = @{$lookup{$item}{'result'}};
    my $result        = escape_csv(join('; ', @result));
    my @role          = @{$lookup{$item}{'role'}};
    my $role          = escape_csv(join('; ', @role));
    my @associated    = @{$lookup{$item}{'associated'}};
    my $associated    = escape_csv(join('; ', @associated));
    my @request       = @{$lookup{$item}{'request'}};
    my $request       = escape_csv(join('; ', @request));
    my @instance_of   = @{$lookup{$item}{'instance_of'}};
    my $instance_of   = escape_csv(join('; ', @instance_of));
    my @class_of      = @{$lookup{$item}{'class_of'}};
    my $class_of      = escape_csv(join('; ', @class_of));
    my @generalizes   = @{$lookup{$item}{'generalizes'}};
    my $generalizes   = escape_csv(join('; ', @generalizes));
    my @specializes   = @{$lookup{$item}{'specializes'}};
    my $specializes   = escape_csv(join('; ', @specializes));
    my @pro           = @{$lookup{$item}{'pro'}};
    my $pro           = escape_csv(join('; ', @pro));
    my @con           = @{$lookup{$item}{'con'}};
    my $con           = escape_csv(join('; ', @con));
    my @depends_on    = @{$lookup{$item}{'depends_on'}};
    my $depends_on    = escape_csv(join('; ', @depends_on));
    my @required_by   = @{$lookup{$item}{'required_by'}};
    my $required_by   = escape_csv(join('; ', @required_by));
    my @derived_from  = @{$lookup{$item}{'derived_from'}};
    my $derived_from  = escape_csv(join('; ', @derived_from));
    my @derived       = @{$lookup{$item}{'derived'}};
    my $derived       = escape_csv(join('; ', @derived));


    #-----------------------------------------------------------------
    # Add common data elements to the row.
    #
    $row{'problem'} = [
      "$item",         "$tier",        "$title",        "$description",
      "$revision",     "$date",        "$author",       "$copyright",
      "$parent",       "$type",        "$priority",     "$status",
      "$stakeholder",  "$owner",       "$validator",    "$directed_by",
      "$solution",     "$test",        "$associated",   "$request",
      "$instance_of",  "$class_of",    "$derived_from", "$derived",
      "$allocation",   "$assignment",  "$generalizes",  "$specializes",
    ];

    $row{'solution'} = [
      "$item",         "$tier",        "$title",       "$description",
      "$revision",     "$date",        "$author",      "$copyright",
      "$parent",       "$type",        "$priority",    "$status",
      "$stakeholder",  "$owner",       "$pro",         "$con",
      "$depends_on",   "$required_by", "$directed_by",
      "$version",      "$license",     "$cost",
      "$problem",      "$test",        "$associated",  "$request",
      "$instance_of",  "$class_of",    "$allocation",  "$assignment",
      "$generalizes",  "$specializes",
    ];

    $row{'allocation'} = [
      "$item",         "$tier",        "$title",       "$description",
      "$revision",     "$date",        "$author",
      "$parent",       "$type",        "$priority",    "$status",
      "$stakeholder",  "$owner",       "$solution",
      "$problem",      "$test",        "$associated",  "$request",
      "$instance_of",  "$class_of",
    ];

    $row{'assignment'} = [
      "$item",         "$tier",        "$title",       "$description",
      "$revision",     "$date",        "$author",
      "$parent",       "$type",        "$priority",    "$status",
      "$stakeholder",  "$owner",       "$solution",
      "$problem",      "$test",        "$associated",  "$request",
      "$instance_of",  "$class_of",
    ];

    $row{'task'} = [
      "$item",         "$tier",        "$title",       "$description",
      "$revision",     "$date",        "$author",      "$copyright",
      "$parent",       "$type",        "$priority",    "$status",
      "$owner",        "$product",     "$deadline",
      "$depends_on",   "$required_by", "$directed_by",
      "$problem",      "$solution",    "$test",        "$associated",
      "$instance_of",  "$class_of",
    ];

    $row{'test'} = [
      "$item",         "$tier",        "$title",       "$description",
      "$revision",     "$date",        "$author",      "$copyright",
      "$parent",       "$type",        "$priority",    "$status",
      "$tester",       "$owner",       "$validator",
      "$level",        "$question",    "$script",
      "$depends_on",   "$required_by", "$directed_by",
      "$problem",      "$solution",    "$associated",  "$request",
      "$instance_of",  "$class_of",
    ];

    $row{'result'} = [
      "$item",         "$tier",        "$title",       "$description",
      "$revision",     "$date",        "$author",      "$copyright",
      "$parent",       "$type",        "$priority",    "$status",
      "$owner",        "$product",     "$deadline",
      "$depends_on",   "$required_by", "$directed_by",
      "$problem",      "$solution",    "$test",        "$associated",
      "$instance_of",  "$class_of",
    ];

    $row{'role'} = [
      "$item",         "$tier",        "$title",       "$description",
      "$revision",     "$date",        "$author",      "$copyright",
      "$parent",       "$type",        "$priority",    "$status",
      "$owner",        "$product",     "$deadline",
      "$depends_on",   "$required_by", "$directed_by",
      "$problem",      "$solution",    "$test",        "$associated",
      "$instance_of",  "$class_of",
    ];

    #-----------------------------------------------------------------
    # Add attributes to the row.
    #
    foreach my $attr_name (@attr_names) {
      my @value = @{ $attribute{$item}{$attr_name} };
      my $value = join('; ', @value);
      push @{ $row{$name} }, $value;

    }

    #-----------------------------------------------------------------
    # Add this row (and a newline) to the index.
    #
    my $row = join(',',@{ $row{$name} });
    push @{ $aref }, $row, "\n";
  }

  # my $row_count = scalar @{ $row{$name} };
  # print "  $name row count: $row_count\n";
}

######################################################################

sub render_tree {

  my $name   = shift;
  my $size   = shift;
  my $ucname = ucfirst($name);

  printstatus("rendering $size $name tree");

  # The tree is a special HTML table listing all items of a specific
  # name.  Indenting is used to represent the item hierarchy (parent -
  # child relationships).  Sub items can be displayed and hidden by
  # clicking an item's title.

  #-------------------------------------------------------------------
  # Only render the tree if we're rendering HTML
  #
  if ($rendering{'html'}) {

    my $currentid = "table1";
    my $aref      = tree_outfile_aref_for($name,$size);
    my $rowcount  = 0;

    #-----------------------------------------------------------------
    # Start the table
    #
    push @{ $aref }, <<"END_OF_TEXT";
<table align="center" border="0" width="80%">
<tr>

<td align="left">
<b>status:</b>
<image src="$status_green_icon" border="0"/>=100%
<image src="$status_yellow_icon" border="0"/>=partial
<image src="$status_red_icon" border="0"/>=0%
<image src="$status_grey_icon" border="0"/>=unknown
</td>

<td align="right">
<b>priority:</b>
<image src="$priority_red_icon" border="0"/>=critical
<image src="$priority_orange_icon" border="0"/>=high
<image src="$priority_yellow_icon" border="0"/>=routine
<image src="$priority_grey_icon" border="0"/>=low/unknown
</td>

</tr>
</table>

<table id="$currentid" class="treetable">

<tr>
<td colspan="14" class="header" cellpadding="8" cellspacing="0">
<span style="font-size: 8pt">
<a href="#" onclick="treetable_expandAll('table1');">Expand all</a>
/
<a href="#" onclick="treetable_collapseAll('table1');">Collapse all</a>
/ Click on folders to expand and collapse individual branches.
</span>
</td>
</tr>

<tr>
<td class="header" cellpadding="8" cellspacing="0">$ucname</td>
<td class="header" cellpadding="8" cellspacing="0">&nbsp;</td>
<td class="header" cellpadding="8" cellspacing="0">&nbsp;</td>
END_OF_TEXT

if ( $option{'use_svn'} )
  {
    push @{ $aref }, <<"END_OF_TEXT";
<td class="header" cellpadding="8" cellspacing="0">Changed</td>
END_OF_TEXT
  }

  push @{ $aref }, <<"END_OF_TEXT";
<td class="header" cellpadding="8" cellspacing="0">Parts</td>
<td class="header" cellpadding="8" cellspacing="0">Total</td>
<td class="header" cellpadding="8" cellspacing="0">REQ</td>
<td class="header" cellpadding="8" cellspacing="0">SOL</td>
<td class="header" cellpadding="8" cellspacing="0">ALO</td>
<td class="header" cellpadding="8" cellspacing="0">ASN</td>
<td class="header" cellpadding="8" cellspacing="0">TST</td>
<td class="header" cellpadding="8" cellspacing="0">RES</td>
<td class="header" cellpadding="8" cellspacing="0">TSK</td>
<td class="header" cellpadding="8" cellspacing="0">ROL</td>
</tr>

END_OF_TEXT

    #-----------------------------------------------------------------
    # List top-level results
    #
    #     Look through the complete list of results and use only those
    #     that don't have parents (and are therefore "toplevel"
    #     results).
    #
    my @toplevelitems = ();
    foreach my $item ( list_by_name($name) ) {
      my $item_parent = $lookup{$item}{'parent'} || '';
      if ( not $item_parent or not $lookup{$item_parent}{'title'} ) {
        push @toplevelitems, $item;
      }
    }

    #-----------------------------------------------------------------
    # Render a table row for each toplevel item
    #
    foreach my $item (@toplevelitems) {

      #---------------------------------------------------------------
      # Get metadata about this item
      #
      my $title          = escape_html($lookup{$item}{'title'});
      my $description    = escape_html($lookup{$item}{'description'});
      my @type           = @{ $lookup{$item}{'type'} };
      my $type           = join(', ', @type);
      my $priority       = $lookup{$item}{'priority'};
      my $priority_icon  = html_priority_icon_for($priority);
      my $pri_bgcolor    = html_cell_bgcolor_for($priority);
      my @children       = @{$lookup{$item}{'children'}};
      my $childcount     = scalar(@children);
      my @stakeholders   = @{$lookup{$item}{'stakeholder'}};
      my $stakeholders   = join(', ', @stakeholders);
      my @requests       = @{$lookup{$item}{'request'}};
      my $requests       = join(', ', @requests);
      my $status         = status_of($item) if label_exists($item);
      my $status_icon    = html_status_icon_for($status);
      my $sta_bgcolor    = html_cell_bgcolor_for($status);
      my $number         = $label{$item}{'number'};
      my $outfile        = html_outfile_for_label($item);
      my $days_old       = $days_old{$item}{'num'}  || 0;
      my $last_changed   = $days_old{$item}{'date'} || 0;
      my $anchor         = "$item";
      my $icon           = '';
      my $rowid          = "$currentid" . "_" . "$rowcount";
      my $padding        = '0px';
      my $chg_bgcolor    = "white";

      if ( $days_old < $RECENT ) {
	$chg_bgcolor = "#ffff66";
      }

      my @problems = ();
      if (ref $lookup{$item}{'problem'} eq 'ARRAY') {
	@problems = @{$lookup{$item}{'problem'}};
      } elsif ($lookup{$item}{'problem'}) {
	push @problems, $lookup{$item}{'problem'};
      }

      my @solutions = ();
      if (ref $lookup{$item}{'solution'} eq 'ARRAY') {
	@solutions = @{$lookup{$item}{'solution'}};
      } elsif ($lookup{$item}{'solution'}) {
	push @solutions, $lookup{$item}{'solution'};
      }

      my @allocations = ();
      if (ref $lookup{$item}{'allocation'} eq 'ARRAY') {
	@allocations = @{$lookup{$item}{'allocation'}};
      } elsif ($lookup{$item}{'allocation'}) {
	push @allocations, $lookup{$item}{'allocation'};
      }

      my @assignments = ();
      if (ref $lookup{$item}{'assignment'} eq 'ARRAY') {
	@assignments = @{$lookup{$item}{'assignment'}};
      } elsif ($lookup{$item}{'assignment'}) {
	push @assignments, $lookup{$item}{'assignment'};
      }

      my @tests = ();
      if (ref $lookup{$item}{'test'} eq 'ARRAY') {
	@tests = @{$lookup{$item}{'test'}};
      } elsif ($lookup{$item}{'test'}) {
	push @tests, $lookup{$item}{'test'};
      }

      my @results = ();
      if (ref $lookup{$item}{'result'} eq 'ARRAY') {
	@results = @{$lookup{$item}{'result'}};
      } elsif ($lookup{$item}{'result'}) {
	push @results, $lookup{$item}{'result'};
      }

      my @tasks = ();
      if (ref $lookup{$item}{'task'} eq 'ARRAY') {
	@tasks = @{$lookup{$item}{'task'}};
      } elsif ($lookup{$item}{'task'}) {
	push @tasks, $lookup{$item}{'task'};
      }

      my @roles = ();
      if (ref $lookup{$item}{'role'} eq 'ARRAY') {
	@roles = @{$lookup{$item}{'role'}};
      } elsif ($lookup{$item}{'role'}) {
	push @roles, $lookup{$item}{'role'};
      }

      my $problem_count    = scalar(@problems)    || ' ';
      my $solution_count   = scalar(@solutions)   || ' ';
      my $allocation_count = scalar(@allocations) || ' ';
      my $assignment_count = scalar(@assignments) || ' ';
      my $test_count       = scalar(@tests)       || ' ';
      my $result_count     = scalar(@results)     || ' ';
      my $task_count       = scalar(@tasks)       || ' ';
      my $role_count       = scalar(@roles)       || ' ';

      #---------------------------------------------------------------
      # Assemble info
      #
      my @info = ();
      push @info, $type         if $type;
      push @info, $stakeholders if $stakeholders;
      push @info, $requests     if $requests;
      my $info = join(', ', @info);

      #-----------------------------------------------------------------
      # Count items
      #
      my $part_count  = scalar(@children);
      my $total_count = scalar(@children);
      foreach my $item (@children) {
	$total_count = $total_count + count_children($item);
      }

      #---------------------------------------------------------------
      # Determine which icon to use (folder or page)
      #
      #     Use the folder icon if this item has children.  Otherwise,
      #     use the page icon.
      #
      if ($childcount) {
	$icon = <<END_OF_TEXT;
<a href="#" onclick="treetable_toggleRow('$rowid');"><img src="$folder_open_icon" class="button" alt="" width="16" height="16" /></a>

END_OF_TEXT
      } else {
	$icon = <<END_OF_TEXT;
<img src="$page_icon" class="button" alt="" width="16" height="16" />

END_OF_TEXT
      }

      #---------------------------------------------------------------
      # Begin a row for this item
      #
      push @{ $aref }, <<"END_OF_TEXT";
<tr id="$rowid">
<td style="padding-left:$padding">
$icon

END_OF_TEXT

      if ($size eq 'big') {
	push @{ $aref }, <<"END_OF_TEXT";
<a href="$outfile#$anchor"><span style="font-size: 8pt">$item - <b>$title</b></span></a>
<span id="description" style="font-size: 8pt">&nbsp;$description</span>
<div style="padding-bottom: 4pt"></div>

END_OF_TEXT
      } elsif ($size eq 'small') {
	push @{ $aref }, <<"END_OF_TEXT";
<a href="$outfile#$anchor"><span style="font-size: 8pt">$item - $title</span></a>

END_OF_TEXT
      }

      #---------------------------------------------------------------
      # End the row
      #
      push @{ $aref }, <<"END_OF_TEXT";
</td>
<td>$status_icon</td>
<td>$priority_icon</td>
END_OF_TEXT

      if ( $option{'use_svn'} )
	{
	  push @{ $aref }, <<"END_OF_TEXT";
<td bgcolor="$chg_bgcolor" style="font-size: 8pt"><nobr>$last_changed</nobr></td>
END_OF_TEXT
	}

      push @{ $aref }, <<"END_OF_TEXT";
<td class="number" style="font-size: 8pt">$part_count</td>
<td class="number" style="font-size: 8pt">$total_count</td>
<td class="number" style="font-size: 8pt">$problem_count</td>
<td class="number" style="font-size: 8pt">$solution_count</td>
<td class="number" style="font-size: 8pt">$allocation_count</td>
<td class="number" style="font-size: 8pt">$assignment_count</td>
<td class="number" style="font-size: 8pt">$test_count</td>
<td class="number" style="font-size: 8pt">$result_count</td>
<td class="number" style="font-size: 8pt">$task_count</td>
<td class="number" style="font-size: 8pt">$role_count</td>
</tr>

END_OF_TEXT

      #---------------------------------------------------------------
      # Render children of this problem
      #
      my $childcount = 0;
      my $newid      = $rowid . "_" . $childcount;
      my $depth      = 1;

      foreach my $child (sort by_env_number @children) {
        render_tree_row($child,$newid,$depth,$size);
        ++ $childcount;
        $newid = $rowid . "_" . $childcount;
      }

      #---------------------------------------------------------------
      # Increment the rowcount
      #
      ++ $rowcount;

    }

    #-----------------------------------------------------------------
    # End the table
    #
    push @{ $aref }, <<"END_OF_TEXT";
</table>

END_OF_TEXT

  }
}

######################################################################

sub render_tree_row {

  my $item  = shift;     # id of item
  my $rowid = shift;     # e.g. table1_0_2
  my $depth = shift;     # current depth in hierarchy
  my $size  = shift;     # big or small

  #-------------------------------------------------------------------
  # Get metadata for this child
  #
  my $title          = escape_html($lookup{$item}{'title'});
  my $description    = escape_html($lookup{$item}{'description'});
  my @type           = @{ $lookup{$item}{'type'} };
  my $type           = join(', ', @type);
  my $priority       = $lookup{$item}{'priority'};
  my $priority_icon  = html_priority_icon_for($priority);
  my $pri_bgcolor    = html_cell_bgcolor_for($priority);
  my @children       = @{$lookup{$item}{'children'}};
  my $childcount     = scalar(@children);
  my @stakeholders   = @{$lookup{$item}{'stakeholder'}};
  my $stakeholders   = join(', ', @stakeholders);
  my @requests       = @{$lookup{$item}{'request'}};
  my $requests       = join(', ', @requests);
  my $status         = status_of($item) if label_exists($item);
  my $status_icon    = html_status_icon_for($status);
  my $sta_bgcolor    = html_cell_bgcolor_for($status);
  my $number         = $label{$item}{'number'};
  my $outfile        = html_outfile_for_label($item);
  my $days_old       = $days_old{$item}{'num'}  || 0;
  my $last_changed   = $days_old{$item}{'date'} || 0;
  my $anchor         = "$item";
  my $icon           = '';
  my $indent         = $depth * 20;
  my $padding        = $indent . "px";
  my $name           = name_for($item);
  my $aref           = tree_outfile_aref_for($name,$size);
  my $chg_bgcolor    = "white";

  if ( $days_old < $RECENT ) {
    $chg_bgcolor = "#ffff66";
  }

  my @problems = ();
  if (ref $lookup{$item}{'problem'} eq 'ARRAY') {
    @problems = @{$lookup{$item}{'problem'}};
  } elsif ($lookup{$item}{'problem'}) {
    push @problems, $lookup{$item}{'problem'};
  }

  my @solutions = ();
  if (ref $lookup{$item}{'solution'} eq 'ARRAY') {
    @solutions = @{$lookup{$item}{'solution'}};
  } elsif ($lookup{$item}{'solution'}) {
    push @solutions, $lookup{$item}{'solution'};
  }

  my @allocations = ();
  if (ref $lookup{$item}{'allocation'} eq 'ARRAY') {
    @allocations = @{$lookup{$item}{'allocation'}};
  } elsif ($lookup{$item}{'allocation'}) {
    push @allocations, $lookup{$item}{'allocation'};
  }

  my @assignments = ();
  if (ref $lookup{$item}{'assignment'} eq 'ARRAY') {
    @assignments = @{$lookup{$item}{'assignment'}};
  } elsif ($lookup{$item}{'assignment'}) {
    push @assignments, $lookup{$item}{'assignment'};
  }

  my @tests = ();
  if (ref $lookup{$item}{'test'} eq 'ARRAY') {
    @tests = @{$lookup{$item}{'test'}};
  } elsif ($lookup{$item}{'test'}) {
    push @tests, $lookup{$item}{'test'};
  }

  my @results = ();
  if (ref $lookup{$item}{'result'} eq 'ARRAY') {
    @results = @{$lookup{$item}{'result'}};
  } elsif ($lookup{$item}{'result'}) {
    push @results, $lookup{$item}{'result'};
  }

  my @tasks = ();
  if (ref $lookup{$item}{'task'} eq 'ARRAY') {
    @tasks = @{$lookup{$item}{'task'}};
  } elsif ($lookup{$item}{'task'}) {
    push @tasks, $lookup{$item}{'task'};
  }

  my @roles = ();
  if (ref $lookup{$item}{'role'} eq 'ARRAY') {
    @roles = @{$lookup{$item}{'role'}};
  } elsif ($lookup{$item}{'role'}) {
    push @roles, $lookup{$item}{'role'};
  }

  my $problem_count    = scalar(@problems)    || ' ';
  my $solution_count   = scalar(@solutions)   || ' ';
  my $allocation_count = scalar(@allocations) || ' ';
  my $assignment_count = scalar(@assignments) || ' ';
  my $test_count       = scalar(@tests)       || ' ';
  my $result_count     = scalar(@results)     || ' ';
  my $task_count       = scalar(@tasks)       || ' ';
  my $role_count       = scalar(@roles)       || ' ';

  #-------------------------------------------------------------------
  # Assemble info
  #
  my @info = ();
  push @info, $type         if $type;
  push @info, $stakeholders if $stakeholders;
  push @info, $requests     if $requests;
  my $info = join(', ', @info);

  #-----------------------------------------------------------------
  # Count items
  #
  my $part_count  = scalar(@children);
  my $total_count = scalar(@children);
  foreach my $item (@children) {
    $total_count = $total_count + count_children($item);
  }

  #-------------------------------------------------------------------
  # Determine which icon to use (folder or page)
  #
  if ($childcount) {
    $icon = <<END_OF_TEXT;
<a href="#" onclick="treetable_toggleRow('$rowid');"><img src="$folder_open_icon" class="button" alt="" width="16" height="16" /></a>

END_OF_TEXT
  } else {
    $icon = <<END_OF_TEXT;
<img src="$page_icon" class="button" alt="" width="16" height="16" />

END_OF_TEXT
  }

  #-------------------------------------------------------------------
  # Begin a row for this item
  #
  push @{ $aref }, <<"END_OF_TEXT";
<tr id="$rowid">
<td style="padding-left:$padding">
$icon

END_OF_TEXT

  #-------------------------------------------------------------------
  # If this is a big tree, bold the title and include the description.
  #
  if ($size eq 'big') {
    push @{ $aref }, <<"END_OF_TEXT";
<a href="$outfile#$anchor"><span style="font-size: 8pt">$item - <b>$title</b></span></a>
<span id="description" style="font-size: 8pt">&nbsp;$description</span>
<div style="padding-bottom: 4pt"></div>

END_OF_TEXT
  } elsif ($size eq 'small') {
    push @{ $aref }, <<"END_OF_TEXT";
<a href="$outfile#$anchor"><span style="font-size: 8pt">$item - $title</span></a>

END_OF_TEXT
  }

  #---------------------------------------------------------------
  # End row
  #
  push @{ $aref }, <<"END_OF_TEXT";
</td>
<td>$status_icon</td>
<td>$priority_icon</td>
END_OF_TEXT

  if ( $option{'use_svn'} )
    {
      push @{ $aref }, <<"END_OF_TEXT";
<td bgcolor="$chg_bgcolor" style="font-size: 8pt"><nobr>$last_changed</nobr></td>
END_OF_TEXT
    }

  push @{ $aref }, <<"END_OF_TEXT";
<td class="number" style="font-size: 8pt">$part_count</td>
<td class="number" style="font-size: 8pt">$total_count</td>
<td class="number" style="font-size: 8pt">$problem_count</td>
<td class="number" style="font-size: 8pt">$solution_count</td>
<td class="number" style="font-size: 8pt">$allocation_count</td>
<td class="number" style="font-size: 8pt">$assignment_count</td>
<td class="number" style="font-size: 8pt">$test_count</td>
<td class="number" style="font-size: 8pt">$result_count</td>
<td class="number" style="font-size: 8pt">$task_count</td>
<td class="number" style="font-size: 8pt">$role_count</td>
</tr>

END_OF_TEXT

  #---------------------------------------------------------------
  # Render children of this item
  #
  my $childcount = 0;
  my $newid      = $rowid . "_" . $childcount;
  my $newdepth   = $depth + 1;
  foreach my $child (sort by_doc_order @children) {
    render_tree_row($child,$newid,$newdepth,$size);
    ++ $childcount;
    $newid = $rowid . "_" . $childcount;
  }
}

######################################################################

sub render_spreadsheet {

  my $name    = shift;
  my $aref    = $html{$name}{'spreadsheet'};
  my %de_cols = ();         # data element columns
  my @at_cols = ();         # attribute columns

  printstatus("rendering $name spreadsheet");

  #-------------------------------------------------------------------
  # Rows
  #
  my @rows = list_by_name($name);

  #-------------------------------------------------------------------
  # Data element columns
  #
  $de_cols{'problem'} = [
    'label',        'tier',        'title',        'description',
    'revision',     'date',        'author',       'copyright',
    'parent',       'type',        'priority',     'status',
    'stakeholder',  'owner',       'validator',    'directed_by',
    'solution',     'test',        'associated',   'request',
    'instance_of',  'class_of',
  ];

  $de_cols{'solution'} = [
    'label',        'tier',        'title',        'description',
    'revision',     'date',        'author',       'copyright',
    'parent',       'type',        'priority',     'status',
    'stakeholder',  'owner',       'pro',          'con',
    'depends_on',   'required_by', 'directed_by',
    'version',      'license',     'cost',
    'problem',      'test',        'associated',   'request',
    'instance_of',  'class_of',    'allocation',   'assignment',
  ];

  $de_cols{'allocation'} = [
    'label',        'tier',        'title',        'description',
    'revision',     'date',        'author',
    'parent',       'type',        'priority',     'status',
    'stakeholder',  'owner',       'solution',
    'problem',      'test',        'associated',   'request',
    'instance_of',  'class_of',
  ];

  $de_cols{'assignment'} = [
    'label',        'tier',        'title',        'description',
    'revision',     'date',        'author',
    'parent',       'type',        'priority',     'status',
    'stakeholder',  'owner',       'solution',
    'problem',      'test',        'associated',   'request',
    'instance_of',  'class_of',
  ];

  $de_cols{'task'} = [
    'label',        'tier',        'title',        'description',
    'revision',     'date',        'author',       'copyright',
    'parent',       'type',        'priority',     'status',
    'owner',        'product',     'deadline',
    'depends_on',   'required_by', 'directed_by',
    'problem',      'solution',    'test',         'associated',
    'instance_of',  'class_of',
  ];

  $de_cols{'test'} = [
    'label',        'tier',        'title',        'description',
    'revision',     'date',        'author',       'copyright',
    'parent',       'type',        'priority',     'status',
    'tester',       'owner',       'validator',
    'level',        'question',    'script',
    'depends_on',   'required_by', 'directed_by',
    'problem',      'solution',    'associated',   'request',
    'instance_of',  'class_of',
  ];

  $de_cols{'result'} = [
    'label',        'tier',        'title',        'description',
    'revision',     'date',        'author',       'parent',
    'type',         'priority',    'status',
    'problem',      'solution',    'test',         'associated',
  ];

  $de_cols{'role'} = [
    'label',        'tier',        'title',        'description',
    'revision',     'date',        'author',       'parent',
    'type',         'priority',    'status',
    'problem',      'solution',    'test',         'associated',
  ];

  #-------------------------------------------------------------------
  # Attribute columns
  #
  my %attr_names = ();
  foreach my $label (@rows) {
    my @attrs = sort keys %{ $attribute{$label} };
    foreach my $attr (@attrs) {
      $attr_names{$attr} = 1;
    }
  }
  @at_cols = sort keys %attr_names;

  #-----------------------------------------------------------------
  # Start the HTML listing.
  #
  push @{ $aref }, <<"END_OF_TEXT";
<!-- ############################################################ -->

<table width="100%" cellspacing="0" cellpadding="4">

END_OF_TEXT

  #-------------------------------------------------------------------
  # Build the header row
  #
  push @{ $aref }, "<tr>\n";
  foreach my $column (@{ $de_cols{$name} }, @at_cols) {
    push @{ $aref }, "<td class=\"header\">$column</td>\n";
  }
  push @{ $aref }, "</tr>\n\n";

  #-------------------------------------------------------------------
  # Build a data row for each item.
  #
  my $toggle = 'odd';
  foreach my $label (sort by_doc_order @rows) {

    my $outfile = html_outfile_for_label($label);

    #-----------------------------------------------------------------
    # Toggle between even and odd rows
    #
    if ($toggle eq 'odd') {
      $toggle = 'even';
    } else {
      $toggle = 'odd';
    }

    #-----------------------------------------------------------------
    # Build a row
    #
    push @{ $aref }, "<tr>\n";
    foreach my $column (@{ $de_cols{$name} }) {

      #---------------------------------------------------------------
      # Determine whether the content of this field can be
      # multivalued (assume it's not).
      #
      my $is_multivalued = 0;
      $is_multivalued = $structure{$name}{'elements'}{$column}{'multivalued'};

      #---------------------------------------------------------------
      # If this is the status column and we are only using formal
      # status computed from results, compute the status rather than
      # looking it up.
      #
      if ($column eq 'status') {
	my $value = status_of($label) if label_exists($label);
	my $cssclass = html_cell_class_for($value) || $toggle;
	if (exists $label{$value}) {
	  $value = "<a href=\"$outfile#$value\">$value</a>";
	}
	push @{ $aref }, "<td class=\"$cssclass\">$value</td>\n";
      }

      #---------------------------------------------------------------
      # If this field is multivalued...
      #
      elsif ($is_multivalued) {
	my @field  = ();
	my @values = @{$lookup{$label}{$column}};
	foreach my $value (@values) {
	  my $html_value = escape_html($value);
	  if (exists $label{$value}) {
	    my $outfile = html_outfile_for_label($value);
	    $value = "<a href=\"$outfile#$value\">$html_value</a>";
	  }
	  push @field, $value;
	}
	my $field = join('; ', @field);
	push @{ $aref }, "<td class=\"$toggle\">$field</td>\n";
      }

      #---------------------------------------------------------------
      # If this field is *not* multivalued...
      #
      else {
	my $value      = $lookup{$label}{$column};
	my $html_value = escape_html($value);
	my $cssclass   = html_cell_class_for($value) || $toggle;
	if (exists $label{$value}) {
	  my $outfile = html_outfile_for_label($value);
	  $value = "<a href=\"$outfile#$value\">$html_value</a>";
	}
	push @{ $aref }, "<td class=\"$cssclass\">$html_value</td>\n";
      }
    }

    #-----------------------------------------------------------------
    # attribute fields, get values from the %attribute datastructure
    #
    foreach my $attribute (@at_cols) {
      my @field  = ();
      my @values = @{$attribute{$label}{$attribute}};
      foreach my $value (@values) {
	my $html_value = escape_html($value);
	if (exists $label{$value}) {
	  my $outfile = html_outfile_for_label($value);
	  $value = "<a href=\"$outfile#$value\">$html_value</a>";
	}
	push @field, $value;
      }
      my $field = join('; ', @field);
      my $cssclass = html_cell_class_for($field) || $toggle;
      push @{ $aref }, "<td class=\"$cssclass\">$field</td>\n";
    }

    push @{ $aref }, "</tr>\n\n";
  }

  #-----------------------------------------------------------------
  # end the table
  #
  push @{ $aref }, <<"END_OF_TEXT";
</table>

END_OF_TEXT

}

######################################################################

sub render_bibliography {

  # Render the bibliography

  printstatus("rendering bibliography...");

  #-------------------------------------------------------------------
  # Render HTML.
  #
  if ($rendering{'html'}) {

    printdebug("creating sources page content") if $DEBUGGING;

    my $aref = $html{'source'}{'index'};

    #-----------------------------------------------------------------
    # Put in a line break for good measure.
    #
    push @{ $aref }, "<br>\n";

    #-----------------------------------------------------------------
    # Start the table.
    #
    push @{ $aref }, <<"END_OF_TEXT";
<table border="0" width="100%">

END_OF_TEXT

    #-----------------------------------------------------------------
    # Process each source.
    #
    foreach my $label ( list_by_name('source') ) {

      push @{ $aref }, <<"END_OF_TEXT";
<tr>
<td colspan="2" valign="top" bgcolor="#eeeeee"><a name="$label"></a>[$label]</td>
</tr>

END_OF_TEXT

      #---------------------------------------------------------------
      # Process each source attribute.
      #
      my $sourcetype = $lookup{$label}{'source'};
      foreach my $fieldtype (
                             'author',
                             'editor',
                             'title',
                             'school',
                             'chapter',
                             'booktitle',
                             'journal',
                             'howpublished',
                             'oranization',
                             'publisher',
                             'month',
                             'year',
                             'volume',
                             'number',
                             'series',
                             'type',
                             'pages',
                             'address',
                             'edition',
                             'note',
                            ) {

        #-------------------------------------------------------------
        # Perform magic.
        #
        if ($lookup{$label}{$fieldtype}) {

          if ($fieldtype eq 'author' or $fieldtype eq 'editor') {
            my @list = @{$lookup{$label}{$fieldtype}};
            my @newlist = ();
            foreach my $name (@list) {
              push @newlist, "$name";
            }
            my $value = join(' and ', @newlist);
            push @{ $aref }, <<"END_OF_TEXT";
<tr>
<td valign="top" width="20%" align="right"><i>$fieldtype:&nbsp;&nbsp;</i></td>
<td valign="top" width="80%">$value</td>
</tr>

END_OF_TEXT
          }

          elsif ($fieldtype eq 'title') {
            my $value = escape_html( $lookup{$label}{$fieldtype} );
            push @{ $aref }, <<"END_OF_TEXT";
<tr>
<td valign="top" width="20%" align="right"><i>$fieldtype:&nbsp;&nbsp;</i></td>
<td valign="top" width="80%"><b>$value</b></td>
</tr>

END_OF_TEXT
          }

          else {
            my $value = escape_html( $lookup{$label}{$fieldtype} );
            push @{ $aref }, <<"END_OF_TEXT";
<tr>
<td valign="top" width="20%" align="right"><i>$fieldtype:&nbsp;&nbsp;</i></td>
<td valign="top" width="80%">$value</td>
</tr>

END_OF_TEXT
          }
        }
      }

      #---------------------------------------------------------------
      # attachment
      #
      if ($lookup{$label}{'file'}) {

	my $file_spec = $lookup{$label}{'file'};
	my $file      = publish_file($file_spec);

	push @{ $aref }, <<"END_OF_TEXT";
<tr>
<td valign="top" width="20%" align="right"><i>file:&nbsp;&nbsp;</i></td>
<td valign="top" width="80%"><a href=\"files/$file\">$file</a></td>
</tr>

END_OF_TEXT
      }

    }

    push @{ $aref }, <<"END_OF_TEXT";
</table>
<br>

END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # Render PDF.
  #
  if ($rendering{'pdf'}) {
    printdebug("writing bibliography (BiBTeX) file") if $DEBUGGING;

    #---------------------------------------------------------------
    # Open the LaTeX bibliography file for writing.
    #
    open BIB, ">$output_dir/$bibliography_file"
      or die "Couldn't open $bibliography_file: $!\n";

    #---------------------------------------------------------------
    # Process each bibliography entry.
    #
    foreach my $label ( list_by_name('source') ) {
      my $source = $lookup{$label}{'source'};
      print BIB "\@$source\{$label,\n";
      foreach my $record ( keys %{$lookup{$label}} ) {
        next if $record eq 'source';
        next if $record eq 'label';
        if ($record eq 'author' or $record eq 'editor') {
          my @list = @{$lookup{$label}{$record}};
          my @newlist = ();
          foreach my $name (@list) {
            push @newlist, "{$name}";
          }
          my $value = join(' and ', @newlist);
          print BIB "  $record = {$value},\n";
        }
        my $value = escape_latex( $lookup{$label}{$record} );

        if ($record eq 'title') {
          print BIB "  $record = {{$value}},\n";
        }

        else {
          print BIB "  $record = {$value},\n";
        }
      }
      print BIB "\}\n\n";
    }
    close BIB;
  }
}

######################################################################

sub render_glossary {

  # Render the glossary

  printdebug("creating glossary content") if $DEBUGGING;

  printstatus("rendering glossary...");

  #-------------------------------------------------------------------
  # Render HTML
  #
  if ( $rendering{'html'} ) {

    my $aref         = $html{'glossary'};
    my $toggle       = 'odd';
    my $initial      = '';
    my $prev_initial = '';

    #-----------------------------------------------------------------
    # Render navigation buttons
    #
    push @{ $aref }, <<"END_OF_TEXT";
<div align="center">
<table cellpadding="0" cellspacing="0">
<tr>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#A');">A</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#B');">B</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#C');">C</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#D');">D</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#E');">E</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#F');">F</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#G');">G</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#H');">H</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#I');">I</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#J');">J</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#K');">K</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#L');">L</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#M');">M</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#N');">N</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#O');">O</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#P');">P</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#Q');">Q</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#R');">R</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#S');">S</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#T');">T</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#U');">U</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#V');">V</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#W');">W</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#W');">X</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#Y');">Y</button></td>
<td align="center"><button type="button" style="width:25px" onclick="goToA('#Z');">Z</button></td>
</tr>
</table>
</div>

END_OF_TEXT

    #-----------------------------------------------------------------
    # Begin a table
    #
    push @{ $aref }, <<"END_OF_TEXT";
<table width="100%" border="0" cellpadding="4">
END_OF_TEXT

    #-----------------------------------------------------------------
    # Render each glossary term in (case insensitive) alphabetical
    # order
    #
    foreach my $term ( sort {lc $a cmp lc $b} keys %glossary ) {

      foreach my $alt ( sort {lc $a cmp lc $b} keys %{ $glossary{$term} } ) {

	my $lc_term = lc($term);
	$lc_term =~ s/\s+/_/g;
	my $name = "$lc_term:$alt";

	#---------------------------------------------------------------
	# Render new initial header if necessary
	#
	$term =~ /^\s*(\S)/;
	$initial = $1;
	if ( lc($initial) ne lc($prev_initial)) {
	  $initial = uc $initial;
	  push @{ $aref }, <<"END_OF_TEXT";
<tr>
<td class="header" colspan="2"><a name="$initial"><big><b>$initial</b></big></td>
</tr>

END_OF_TEXT
	}
	$prev_initial = $initial;

	#---------------------------------------------------------------
	# Render glossary definition
	#
	my $definition      = $glossary{$term}{$alt};
	my $html_entry      = escape_html($term);
	my $html_definition = escape_html($definition);
	my $html            = <<"END_OF_TEXT";
<tr>
<td class="$toggle"><a name="$name"/><b>$html_entry</b></td>
<td class="$toggle">$html_definition</td>
</tr>

END_OF_TEXT

	push @{ $aref }, wrap($html), "\n\n";

	#---------------------------------------------------------------
	# Toggle table row background
	#
	if ( $toggle eq 'even' ) {
	  $toggle = 'odd';
	} else {
	  $toggle = 'even';
	}
      }
    }

    #-----------------------------------------------------------------
    # End the definition list
    #
    push @{ $aref }, <<"END_OF_TEXT";
</table>
END_OF_TEXT

  }

}

######################################################################

sub render_recent_update_listing {

  # Render the recent update listing

  return if not $option{'use_svn'};

  printdebug("creating recent update listing") if $DEBUGGING;

  printstatus("rendering recent update listing...");

  my @names = ('problem','solution','allocation','assignment','test','result','task','role','other');

  # sort items into catagories: problem, solution, allocation,
  # assignment, test, result, task, role, and other
  #
  my %items_by_category = ();
  foreach my $item (sort by_days_old keys %days_old) {
    my $name = name_for($item);
    if ( $name eq 'problem' )
      {
	push(@{ $items_by_category{'problem'} },$item);
      }
    elsif ( $name eq 'solution' )
      {
	push(@{ $items_by_category{'solution'} },$item);
      }
    elsif ( $name eq 'allocation' )
      {
	push(@{ $items_by_category{'allocation'} },$item);
      }
    elsif ( $name eq 'assignment' )
      {
	push(@{ $items_by_category{'assignment'} },$item);
      }
    elsif ( $name eq 'test' )
      {
	push(@{ $items_by_category{'test'} },$item);
      }
    elsif ( $name eq 'result' )
      {
	push(@{ $items_by_category{'result'} },$item);
      }
    elsif ( $name eq 'task' )
      {
	push(@{ $items_by_category{'task'} },$item);
      }
    elsif ( $name eq 'role' )
      {
	push(@{ $items_by_category{'role'} },$item);
      }
    else
      {
	push(@{ $items_by_category{'other'} },$item);
      }
  }

  #-------------------------------------------------------------------
  # Render HTML
  #
  if ( $rendering{'html'} ) {

    my $aref         = $html{'updates'};
    my $toggle       = 'odd';

    #-----------------------------------------------------------------
    # Render each glossary term in (case insensitive) alphabetical
    # order
    #
  NAME:
    foreach my $name (@names) {

      my $updates_exist = 0;
      my @temp = ();

      my $ucf_name = ucfirst($name);
      push @temp, <<"END_OF_TEXT";
<h4>Recent $ucf_name Updates</h4>
END_OF_TEXT

      #-----------------------------------------------------------------
      # Begin a table
      #
      push @temp, <<"END_OF_TEXT";
<table width="100%" border="0" cellpadding="4">
END_OF_TEXT

    ITEM:
      foreach my $item (@{ $items_by_category{$name} }) {

	my $days_old = $days_old{$item}{'num'};
	next ITEM if $days_old > $RECENT;

	my $file          = $days_old{$item}{'file'};
	my $last_changed  = $days_old{$item}{'date'};
	my $change_author = $days_old{$item}{'author'};

	++ $count{'update'}{'total'};

	$updates_exist = 1;

	my $outfile     = html_outfile_for_label($item);
	my $indexfile   = "$output_file.$name.html";
	my $anchor      = "$item";
	my $link        = "<a href=\"$outfile#$anchor\">$item</a>";
	my $title       = escape_html($lookup{$item}{'title'});
	my $description = escape_html($lookup{$item}{'description'});

	my $info = '';
	if ($name eq 'other')
	  {
	    $info = <<"END_OF_TEXT"
<b>$title</b> - $description<br/>$link - <span class="info">$file</span>
END_OF_TEXT
	  }
	else
	  {
	    $info = <<"END_OF_TEXT"
<b>$title</b> - $description<br/>$link - <a href=\"$indexfile#$anchor\">traceability matrix</a> - <span class="info">$file</span>
END_OF_TEXT
	  }

	my $html = <<"END_OF_TEXT";
<tr>
<td width="10%" align="center" class="$toggle">$last_changed</td>
<td width="15%" align="center" class="$toggle">$change_author</td>
<td width="63%" class="$toggle">$info</td>
</tr>
END_OF_TEXT

	push @temp, wrap($html), "\n\n";

	#-------------------------------------------------------------
	# Toggle table row background
	#
	if ( $toggle eq 'even' ) {
	  $toggle = 'odd';
	} else {
	  $toggle = 'even';
	}
      }

      #---------------------------------------------------------------
      # End the table
      #
      push @temp, <<"END_OF_TEXT";
</table>
END_OF_TEXT

      push @{ $aref }, @temp if $updates_exist;

    }
  }
}

######################################################################

sub render_changelog {

  # Render the changelog

  # Gather SVN log for the directory containing the published file.

  printdebug("creating changelog content") if $DEBUGGING;

  printstatus("rendering changelog...");

  my $svn    = $option{'svn'};
  my $rawlog = `$svn --verbose log "$docdir"`;

  parse_changelog($rawlog);

  #-------------------------------------------------------------------
  # Render HTML
  #
  if ( $rendering{'html'} ) {

    my $aref   = $html{'changelog'};
    my $toggle = 'odd';

    #-----------------------------------------------------------------
    # begin table
    #
    push @{ $aref }, <<"END_OF_TEXT";
<table width="100%" border="0" cellpadding="4">
<tr>
<td class="header">rev</td>
<td class="header">author<br>date<br>time</td>
<td class="header">changes</td>
<td class="header">comment</td>
</tr>
END_OF_TEXT

    foreach my $revision ( sort { $b <=> $a } keys %changelog ) {

      my $user     = $changelog{$revision}{'user'};
      my $date     = $changelog{$revision}{'date'};
      my $time     = $changelog{$revision}{'time'};
      my $comment  = $changelog{$revision}{'comment'};
      my $added    = $changelog{$revision}{'added'};
      my $modified = $changelog{$revision}{'modified'};
      my $deleted  = $changelog{$revision}{'deleted'};
      my $html     = <<"END_OF_TEXT";
<tr>
<td class="$toggle"><a name="$revision">$revision</td>
<td class="$toggle">$user<br>$date<br>$time</td>
<td class="$toggle">
  <nobr>$added added</nobr><br>
  <nobr>$modified modified</nobr><br>
  <nobr>$deleted deleted</nobr></td>
<td class="$toggle">$comment</td>
</tr>
END_OF_TEXT

      push @{ $aref }, wrap($html), "\n";

      if ( $toggle eq 'even' ) {
	$toggle = 'odd';
      } else {
	$toggle = 'even';
      }
    }

    #-----------------------------------------------------------------
    # end table
    #
    push @{ $aref }, <<"END_OF_TEXT";
</table>
END_OF_TEXT

  }

  #-------------------------------------------------------------------
  # Render PDF
  #
  if ( $rendering{'pdf'} ) {
  }

}

######################################################################

sub parse_changelog {

  # Parse a raw SVN changelog to populate the %changelog
  # datastructure.  Raw changelogs look like this:
  #
  #

  my $log      = shift;
  my $revision = '';
  my $user     = '';
  my $date     = '';
  my $time     = '';
  my $lines    = '';
  my $comment  = '';
  my $added    = 0;
  my $modified = 0;
  my $deleted  = 0;

  #-------------------------------------------------------------------
  # Process the log line-by-line
  #
  foreach ( split(/\n/, $log) ) {

    #-----------------------------------------------------------------
    # Look for revision lines
    #
    #     revision   user       date       lines
    if (/r(\d+)\s\|\s(.*?)\s\|\s(.*?)\s\|\s(.*?)/) {

      #---------------------------------------------------------------
      # remember previous revision, if any
      #
      if ($revision) {

	$comment = remove_newlines($comment);
	$comment = compress_whitespace($comment);

	if ( $date =~ /(\d\d:\d\d:\d\d)/ ) {
	  $time = $1;
	}

	if ( $date =~ /(\d\d\d\d-\d\d-\d\d)/ ) {
	  $date = $1;
	}

	$changelog{$revision}{'user'}     = $user;
	$changelog{$revision}{'date'}     = $date;
	$changelog{$revision}{'time'}     = $time;
	$changelog{$revision}{'lines'}    = $lines;
	$changelog{$revision}{'comment'}  = $comment;
	$changelog{$revision}{'added'}    = $added;
	$changelog{$revision}{'modified'} = $modified;
	$changelog{$revision}{'deleted'}  = $deleted;
      }

      #---------------------------------------------------------------
      # remember values just matched
      #
      $revision = $1;
      $user     = $2;
      $date     = $3;
      $lines    = $4;
      $comment  = '';
      $added    = 0;
      $modified = 0;
      $deleted  = 0;

    }

    #-----------------------------------------------------------------
    # skip lines containing all dashes
    #
    elsif (/^\s*\-+\s*$/) {
      next;
    }

    #-----------------------------------------------------------------
    # skip lines containing "Changed paths:"
    #
    elsif (/^Changed paths:/) {
      next;
    }

    #-----------------------------------------------------------------
    # count number of paths added
    #
    elsif (/^   A /) {
      ++ $added;
    }

    #-----------------------------------------------------------------
    # count number of paths modified
    #
    elsif (/^   M /) {
      ++ $modified;
    }

    #-----------------------------------------------------------------
    # count number of paths deleted
    #
    elsif (/^   D /) {
      ++ $deleted;
    }

    #-----------------------------------------------------------------
    # remember this as part of the comment
    #
    else {
      $comment .= $_;
    }
  }

  # remember the last revision
  #
  $comment = remove_newlines($comment);
  $comment = compress_whitespace($comment);

  $changelog{$revision}{'user'}     = $user;
  $changelog{$revision}{'date'}     = $date;
  $changelog{$revision}{'time'}     = $time;
  $changelog{$revision}{'lines'}    = $lines;
  $changelog{$revision}{'comment'}  = $comment;
  $changelog{$revision}{'added'}    = $added;
  $changelog{$revision}{'modified'} = $modified;
  $changelog{$revision}{'deleted'}  = $deleted;

}

######################################################################

sub render_priorities {

  my $name   = shift;
  my $ucname = ucfirst($name);
  my $aref   = $html{$name}{'priorities'};

  printstatus("rendering $name priorities");

  # This subroutine takes items and builds a prioritized list based on
  # the priority and status of each one.
  #
  # Each item can have a priority (critical, high, routine, or low)
  # and a status (green, yellow, or red) from which we can create an
  # overall ranking:
  #
  #       priority      status      rank     urgency
  #       --------      ------      ----     -------
  #       critical      red         1        urgent
  #       critical      yellow      2        urgent
  #       high          red         3        urgent
  #       high          yellow      4        urgent
  #       routine       red         5        routine
  #       routine       yellow      6        routine
  #       low           red         7        routine
  #       low           yellow      8        routine
  #       critical      green       9        low
  #       high          green       10       low
  #       routine       green       11       low
  #       low           green       12       low
  #
  # Here's another way to look at it:
  #
  #                  green      yellow      red
  #               +----------+----------+----------+
  #     critical  | rank: 9  | rank: 2  | rank: 1  |
  #               | low      | urgent   | urgent   |
  #               +----------+----------+----------+
  #         high  | rank: 10 | rank: 4  | rank: 3  |
  #               | low      | urgent   | urgent   |
  #               +----------+----------+----------+
  #      routine  | rank: 11 | rank: 6  | rank: 5  |
  #               | low      | routine  | routine  |
  #               +----------+----------+----------+
  #          low  | rank: 12 | rank: 8  | rank: 7  |
  #               | low      | routine  | routine  |
  #               +----------+----------+----------+
  #
  # The ranking represents which items should recieve the most
  # attention.  In general, items with a "green" status should not
  # require any attention, but I've added them to the ranking scheme
  # for completeness.

  #-------------------------------------------------------------------
  # Initialize datastructures to index items by rank.  The data
  # structures will look like:
  #
  #     $items{'1'} = ['req-1','req-2','req-3']
  #     $items{'2'} = ['req-4','req-5','req-6']
  #     $items{'3'} = ['req-7','req-8','req-9']
  #
  my %items = ();

  #-------------------------------------------------------------------
  # Assign ranking number to each item in the item's domain.
  #
  foreach my $item ( list_by_name($name) ) {
    my $priority = $lookup{$item}{'priority'};
    my $status   = status_of($item) if label_exists($item);
    my $rank     = rank_for($priority,$status);
    push @{$items{$rank}}, $item;
    ++ $count{'priority'}{'total'} if $rank >= 1 and $rank <= 8;
  }

  #-------------------------------------------------------------------
  # Render HTML.
  #
  if ($rendering{'html'}) {

    #-----------------------------------------------------------------
    # Begin the item priorities table
    #
    push @{ $aref }, <<"END_OF_TEXT";
<table width="100%" border="0" cellpadding="4" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # Output a row for each item priority
    #
    foreach my $rank (1..8) {
      foreach my $item (@{$items{$rank}}) {

        my $title        = escape_html($lookup{$item}{'title'});
        my $description  = escape_html($lookup{$item}{'description'});
        my $priority     = $lookup{$item}{'priority'};
        my $status       = status_of($item) if label_exists($item);
        my @stakeholders = @{$lookup{$item}{'stakeholder'}};
        my $stakeholders = join(', ', @stakeholders);
        my @requests     = @{$lookup{$item}{'request'}};
        my $requests     = join(', ', @requests);
        my $importance   = 'routine';
        my $number       = $label{$item}{'number'};
	my $outfile      = html_outfile_for_label($item);
	my $anchor       = "$item";
        $importance      = 'urgent' if $rank <= 4;

        my $info = $EMPTY_STRING;
        $info .= $item;
        $info .= ", $stakeholders"  if $stakeholders;
        $info .= ", $requests"      if $requests;

        push @{ $aref }, <<"END_OF_TEXT";
<tr>
<td width="58%">
  <b><a href="$outfile#$anchor">$title</a></b> - $description
  <span class="req_info">$info</span>
</td>
<td width="14%" align="center"><b>$importance</b><br/>rank: $rank</td>
<td width="14%" align="center" class="req_${priority}"><i>priority:</i> $priority</td>
<td width="14%" align="center" class="req_${status}"><i>status:</i> $status</td>
</tr>

END_OF_TEXT
      }
    }

    #-----------------------------------------------------------------
    # End the table
    #
    push @{ $aref }, <<"END_OF_TEXT";
<tr>
<td colspan="4">&nbsp;</td>
</tr>
</table>

END_OF_TEXT

  }
}

######################################################################

sub rank_for {

  # This subroutine takes two arguments: priority and a status, and
  # computes a rank.  If either argument is missing, return 0 (meaning
  # the item is unranked).

  my $priority = shift;
  my $status   = shift;

  return 0  if not $priority or not $status;

  return 1  if $priority eq 'critical' and $status eq 'red';
  return 2  if $priority eq 'critical' and $status eq 'yellow';
  return 3  if $priority eq 'high'     and $status eq 'red';
  return 4  if $priority eq 'high'     and $status eq 'yellow';
  return 5  if $priority eq 'routine'  and $status eq 'red';
  return 6  if $priority eq 'routine'  and $status eq 'yellow';
  return 7  if $priority eq 'low'      and $status eq 'red';
  return 8  if $priority eq 'low'      and $status eq 'yellow';
  return 9  if $priority eq 'critical' and $status eq 'green';
  return 10 if $priority eq 'high'     and $status eq 'green';
  return 11 if $priority eq 'routine'  and $status eq 'green';
  return 12 if $priority eq 'low'      and $status eq 'green';

  return 0;

}

######################################################################

sub end_any_data_element {

  # printdebug("end_any_data_element") if $DEBUGGING;

  # We're no longer in any environment or region data element
  #
  #     !!! Bug Here !!!
  #
  #     There is a potential here for a serious problem if the name of
  #     an element is the same as the name of a type since these two
  #     constructs are both used:
  #
  #       $in{$name}{$type}
  #
  #     and:
  #
  #       $in{$name}{$element}
  #
  #     Types are: text, environment, and region.
  #
  #     To avoid potential problems, I should convert all:
  #
  #       $in{$name}{$element}
  #
  #     to:
  #
  #       $in{$name}{$type}{$element}
  #
  foreach my $name (keys %structure) {
    my $type = $structure{$name}{'type'};
    foreach my $element (keys %{$structure{$name}{'elements'}}) {
      if ($in{$name}{$element}) {
        printdebug("no longer in $name $type $element") if $DEBUGGING;
        $in{$name}{$element} = 0;
      }
    }
  }

  # We're also no longer in any universal text block data elements
  # (index, footnote, glossary, step).  NOTE: steps are special
  # because we don't track that we're in one, we just put some special
  # text at the beginning of steps.

  $in{'file'}      = 0;
  $in{'generate'}  = 0;
  $in{'script'}    = 0;
  $in{'image'}     = 0;
  $in{'footnote'}  = 0;
  $in{'glossary'}  = 0;
  $in{'acronym'}   = 0;
  $in{'index'}     = 0;
  $in{'outcome'}   = 0;
  $in{'review'}    = 0;
  $in{'step'}      = 0;
  $in{'label'}     = 0;
  $in{'title'}     = 0;
  $in{'date'}      = 0;
  $in{'revision'}  = 0;
  $in{'author'}    = 0;
  $in{'type'}      = 0;
  $in{'column'}    = 0;

  foreach my $element (@header_footer_elements) {
    $in{$element} = 0;
  }

}

######################################################################

sub write_popimage_js {

  open JAVASCRIPT, ">$output_dir/popimage.js";
  print JAVASCRIPT <<"END_OF_TEXT";
//
// popImage JavaScript to display images in their own windows
//

// Set the horizontal and vertical position for the popup

PositionX = 0;
PositionY = 0;

// Set these value approximately 20 pixels greater than the
// size of the largest image to be used (needed for Netscape)

defaultWidth  = 1000;
defaultHeight = 500;

// Set autoclose true to have the window close automatically
// Set autoclose false to allow multiple popup windows

var AutoClose = true;

if (parseInt(navigator.appVersion.charAt(0))>=4) {
  var isNN=(navigator.appName=="Netscape")?1:0;
  var isIE=(navigator.appName.indexOf("Microsoft")!=-1)?1:0;
}

var optNN='scrollbars=no,width='+defaultWidth+',height='+defaultHeight+',left='+PositionX+',top='+PositionY;
var optIE='scrollbars=no,width=150,height=100,left='+PositionX+',top='+PositionY;

function popImage(imageURL,imageTitle) {
  if (isNN){imgWin=window.open('about:blank','',optNN);}
  if (isIE){imgWin=window.open('about:blank','',optIE);}
  with (imgWin.document) {
    writeln('<html><head><title>Loading...</title><style>body{margin:0px;}</style>');writeln('<sc'+'ript>');
    writeln('var isNN,isIE;');writeln('if (parseInt(navigator.appVersion.charAt(0))>=4){');
    writeln('isNN=(navigator.appName=="Netscape")?1:0;');writeln('isIE=(navigator.appName.indexOf("Microsoft")!=-1)?1:0;}');
    writeln('function reSizeToImage(){');writeln('if (isIE){');writeln('window.resizeTo(100,100);');
    writeln('width=100-(document.body.clientWidth-document.images[0].width);');
    writeln('height=100-(document.body.clientHeight-document.images[0].height);');
    writeln('window.resizeTo(width,height);}');writeln('if (isNN){');
    writeln('window.innerWidth=document.images["George"].width;');writeln('window.innerHeight=document.images["George"].height;}}');
    writeln('function doTitle(){document.title="'+imageTitle+'";}');writeln('</sc'+'ript>');
    if (!AutoClose) writeln('</head><body bgcolor=000000 scroll="no" onload="reSizeToImage();doTitle();self.focus()">')
    else writeln('</head><body bgcolor=000000 scroll="no" onload="reSizeToImage();doTitle();self.focus()" onblur="self.close()">');
    writeln('<img name="George" src='+imageURL+' style="display:block"></body></html>');
    close();
  }
}

END_OF_TEXT
  close JAVASCRIPT;

}

######################################################################

sub write_treetable_js {

  open JAVASCRIPT, ">$output_dir/treetable.js";
  print JAVASCRIPT <<'END_OF_TEXT';
/*
author: Bojan Mihelac <bojan@mihelac.org>
http://source.mihelac.org
*/

var treetable_rowstate = new Array();
var treetable_callbacks = new Array();

function treetable_hideRow(rowId) {
  el = document.getElementById(rowId);
  el.style.display = "none";
}

function treetable_showRow(rowId) {
  el = document.getElementById(rowId);
  el.style.display = "";
}

function treetable_hideField(fieldId) {
  el = document.getElementByClass(fieldId);
  el.style.display = "none";
}

function treetable_showField(fieldId) {
  el = document.getElementByClass(fieldId);
  el.style.display = "";
}

function treetable_hasChildren(rowId) {
  res = document.getElementById(rowId + '_0');
  return (res != null);
}

function treetable_getRowChildren(rowId) {
  el = document.getElementById(rowId);
  var arr = new Array();
  i = 0;
  while (true) {
    childRowId = rowId + '_' + i;
    childEl = document.getElementById(childRowId);
    if (childEl) {
      arr[i] = childRowId;
    } else {
      break;
    }
    i++;
  }
  return (arr);
}

function treetable_toggleRow(rowId, state, force) {
  var rowChildren;
  var i;
  // open or close all children rows depend on current state
  force = (force == null) ? 1 : force; 
  if (state == null) {
    row_state = ((treetable_rowstate[rowId]) ? (treetable_rowstate[rowId]) : 1) * -1;
  } else {
    row_state = state;
  }
  rowChildren = treetable_getRowChildren(rowId);
  if (rowChildren.length == 0) return (false);
  for (i = 0; i < rowChildren.length; i++) {
    if (row_state == -1) {
      treetable_hideRow(rowChildren[i]);
      treetable_toggleRow(rowChildren[i], row_state, -1);
    } else {
      if (force == 1 || treetable_rowstate[rowId] != -1) {
        treetable_showRow(rowChildren[i]);
        treetable_toggleRow(rowChildren[i], row_state, -1);
      }
    }
  }
  if (force == 1) {
    treetable_rowstate[rowId] = row_state;
    treetable_fireEventRowStateChanged(rowId, row_state);
  }
  return (true);
}

function treetable_fireEventRowStateChanged(rowId, state) {
  if (treetable_callbacks['eventRowStateChanged']) {
    callback = treetable_callbacks['eventRowStateChanged'] + "('" + rowId + "', " + state + ");";
    eval(callback);
  }
}

function treetable_collapseAll(tableId) {
  table = document.getElementById(tableId);
  rowChildren = table.getElementsByTagName('tr');
  for (i = 0; i < rowChildren.length; i++) {
    if (index = rowChildren[i].id.indexOf('_')) {
      // do not hide root elements
      if(index != rowChildren[i].id.lastIndexOf('_')) {
        rowChildren[i].style.display = 'none';
      }
      if (treetable_hasChildren(rowChildren[i].id)) {
        treetable_rowstate[rowChildren[i].id] = -1;
        treetable_fireEventRowStateChanged(rowChildren[i].id, -1);
      }
    }
  }
  return (true);
}

function treetable_expandAll(tableId) {
  table = document.getElementById(tableId);
  rowChildren = table.getElementsByTagName('tr');
  for (i = 0; i < rowChildren.length; i++) {
    if (index = rowChildren[i].id.indexOf('_')) {
      rowChildren[i].style.display = '';
      if (treetable_hasChildren(rowChildren[i].id)) {
        treetable_rowstate[rowChildren[i].id] = 1;
        treetable_fireEventRowStateChanged(rowChildren[i].id, 1);
      }
    }
  }
  return (true);
}

treetable_callbacks['eventRowStateChanged'] = 'treetable_eventRowChanged';

function treetable_eventRowChanged(rowId, state) {
  img = document.getElementById(rowId).getElementsByTagName('td')[0].getElementsByTagName('img')[0];
  if (state == 1) {
    img.src = 'folder_green_open.png';
  } else {
    img.src = 'folder_green.png';
  }
  return (true);
}

END_OF_TEXT

  close JAVASCRIPT;

}

######################################################################

sub cleanup_tempfiles {

  # Unless the user has specifically requested NO deletion of
  # temporary files ($option{'cleanup_files'}) remove all temporary
  # files.

  #-------------------------------------------------------------------
  # Cleanup?
  #
  #     Only delete the temporary files if the user indicated they
  #     should be removed (which is the default).
  #
  if ($option{'cleanup_files'}) {

    printstatus("Cleaning up temp files");

    #-----------------------------------------------------------------
    # Remove (most) Temporary LaTeX files
    #
    #     The PDF rendering process (via LaTeX) leaves a lot of files
    #     laying around.  Delete them all (even the .tex file).
    #
    #     The statements that delete the LaTeX glossary files (.glo
    #     and .gls) are commented out because it often takes several
    #     publishing runs to resolve glossary entries that contain
    #     other glossary entries.  If these files are deleted between
    #     runs certain glossary terms will *never* show up in the
    #     glossary.
    #
    if ($rendering{'pdf'}) {
      unlink "$output_dir/$output_file.att" if -f "$output_dir/$output_file.att";
      unlink "$output_dir/$output_file.aux" if -f "$output_dir/$output_file.aux";
      unlink "$output_dir/$output_file.bbl" if -f "$output_dir/$output_file.bbl";
      unlink "$output_dir/$output_file.bib" if -f "$output_dir/$output_file.bib";
      unlink "$output_dir/$output_file.blg" if -f "$output_dir/$output_file.blg";
      unlink "$output_dir/$output_file.brf" if -f "$output_dir/$output_file.brf";
      unlink "$output_dir/$output_file.dem" if -f "$output_dir/$output_file.dem";
      unlink "$output_dir/$output_file.exr" if -f "$output_dir/$output_file.exr";
      unlink "$output_dir/$output_file.glg" if -f "$output_dir/$output_file.glg";
      # unlink "$output_dir/$output_file.glo" if -f "$output_dir/$output_file.glo";
      # unlink "$output_dir/$output_file.gls" if -f "$output_dir/$output_file.gls";
      unlink "$output_dir/$output_file.idx" if -f "$output_dir/$output_file.idx";
      unlink "$output_dir/$output_file.ilg" if -f "$output_dir/$output_file.ilg";
      unlink "$output_dir/$output_file.ind" if -f "$output_dir/$output_file.ind";
      unlink "$output_dir/$output_file.ist" if -f "$output_dir/$output_file.ist";
      unlink "$output_dir/$output_file.lis" if -f "$output_dir/$output_file.lis";
      unlink "$output_dir/$output_file.lof" if -f "$output_dir/$output_file.lof";
      unlink "$output_dir/$output_file.log" if -f "$output_dir/$output_file.log";
      unlink "$output_dir/$output_file.lot" if -f "$output_dir/$output_file.lot";
      unlink "$output_dir/$output_file.out" if -f "$output_dir/$output_file.out";
      unlink "$output_dir/$output_file.req" if -f "$output_dir/$output_file.req";
      unlink "$output_dir/$output_file.rol" if -f "$output_dir/$output_file.rol";
      unlink "$output_dir/$output_file.sol" if -f "$output_dir/$output_file.sol";
      unlink "$output_dir/$output_file.tex" if -f "$output_dir/$output_file.tex";
      unlink "$output_dir/$output_file.toc" if -f "$output_dir/$output_file.toc";
      unlink "$output_dir/$output_file.tsk" if -f "$output_dir/$output_file.tsk";
      unlink "$output_dir/$output_file.tst" if -f "$output_dir/$output_file.tst";
      unlink "$output_dir/$output_file.res" if -f "$output_dir/$output_file.res";
    }

    #-----------------------------------------------------------------
    # Remove text output file
    #
    #     The publisher creates a text-only version of the assembled
    #     document for debugging.  Remove it.
    #
    unlink "$output_dir/$output_file.txt" if -f "$output_dir/$output_file.txt";

    #-----------------------------------------------------------------
    # Remove script files
    #
    #     The publisher creates script files that enable the user to
    #     re-render documents by hand for debugging purposes.  Remove
    #     them.
    #
    unlink "$output_dir/makepdf.bat"      if -f "$output_dir/makepdf.bat";
    unlink "$output_dir/makepdf.sh"       if -f "$output_dir/makepdf.sh";

    #-----------------------------------------------------------------
    # Remove Backup files
    #
    #     Some applications leave behind backup files.  For instance,
    #     Emacs leaves behind files with names that end with a tilde
    #     (~).  These files should be deleted.
    #
    opendir(OUTPUT,"$output_dir") or die "can't opendir $output_dir: $!";
    while (defined(my $file = readdir(OUTPUT))) {
      unlink "$output_dir/$file" if $file =~ /~$/;
    }

  }

  #---------------------------------------------------------------
  # Notification
  #
  #     The user requested the --nocleanup option.  Let them know we
  #     are NOT cleaning up the temp files (gives the user the
  #     illusion of being in control... users seem to like that.
  #
  else {
    printstatus("NOT cleaning up temp files");
  }

}

######################################################################

sub list_current_contexts {

  # At any given time, we should only be in 1 context.

  foreach my $name (sort keys %structure) {
    my $type = $structure{$name}{'type'};
    if ( $in{$name}{$type} ) {
      printdebug("in $name $type") if $DEBUGGING;
    }
  }
}

######################################################################

sub strip_revision_control_keyword_chars {

  # Strip off any revision control keyword characters.  For instance,
  # if the sub-routine is passed "$Author: don.johnson $" return "Don"

  my $string = shift;
  if ( $string =~ /\$\w+\:\s+(.*?)\s+\$/ ) {
    $string = $1;
  }
  return $string;
}

######################################################################

sub by_resource_tier {

  my $a_tier = $files{$a}{'tier'};
  my $b_tier = $files{$b}{'tier'};

  $a_tier <=> $b_tier;

}

######################################################################

sub by_env_number {

  # This is a sort subroutine designed to sort environments by number.
  # Environments are blocks of text with semantic significance such as
  # problems, solutions, allocations, assignments, tests, tasks,
  # results, and roles.
  #
  # $a and $b, passed to the subroutine, are the LABELS of the
  # environments.  You must look up the numbers based on the labels.
  #
  # This number ALWAYS is 2 integers separated by a dash
  # (i.e. '2-12').

  my @a_fields = split(/-/,$label{$a}{'number'});
  my @b_fields = split(/-/,$label{$b}{'number'});

  $a_fields[0] <=> $b_fields[0] || $a_fields[1] <=> $b_fields[1];

}

######################################################################

sub by_days_old {

  # Sort by days old.

  $days_old{$a}{'num'} <=> $days_old{$b}{'num'}

}

######################################################################

sub by_doc_order {

  # Sort by document order

  $lookup{$a}{'order'} <=> $lookup{$b}{'order'}

}

######################################################################

sub section_contains {

  # Use the %specials data structure to test whether a section
  # contains any special environments or regions.

  my $special = shift;
  my $section = shift;

  if ( $specials{$special}{$section} > 0 ) {
    return 1;
  } else {
    return 0;
  }

}

######################################################################

sub insert_frontmatter_list_headings {

  # Insert sections headings into frontmatter lists of 'specials.'
  # There are 8 such lists.  Here are the lists and the 3-letter
  # acronym (TLA) i.e. file extensions, used by LaTeX for the files
  # used to typeset each one:
  #
  #     List of Listings         lis
  #     List of Slides           sld
  #     List of Exercises        exr
  #     List of Demonstrations   dem
  #     List of Problems         req
  #     List of Solutions        sol
  #     List of Allocations      alo
  #     List of Assignments      asn
  #     List of Tests            tst
  #     List of Tasks            tsk
  #     List of Results          res
  #     List of Roles            rol
  #
  # This subroutine takes 2 arguments:
  #
  #     1) the latex variable for the section counter:
  #
  #        - thechapter
  #        - thesection
  #        - thesubsection
  #        - thesubsubsection
  #
  #     2) the latex text of the section heading
  #

  my $counter    = shift;
  my $latex_text = shift;

  foreach my $special (@specials) {

    my $tla    = $tla_for{$special};  # tla = three-letter-acronym
    my $secnum = $current{'secnum'};

    if (
	section_contains($special,$secnum)
	and
	$option{'front_list_heads'}
       ) {

      my $latex = <<"END_OF_TEXT";
\\addtocontents{$tla}{\\protect\\addvspace{.5\\baselineskip}}
\\addcontentsline{$tla}{section}{\\protect\\numberline{\\textbf{\\$counter}} \\hspace{0.1in} \\textbf{$latex_text}}
\\addtocontents{$tla}{\\protect\\addvspace{.5\\baselineskip}}

END_OF_TEXT

      push @latex, "$latex";
    }

    elsif ( section_contains($special,$secnum) ) {
      my $latex = <<"END_OF_TEXT";
\\addtocontents{$tla}{\\protect\\addvspace{.5\\baselineskip}}

END_OF_TEXT
      push @latex, "$latex";
    }

  }
}

######################################################################

sub html_cell_bgcolor_for {

  my $text = shift;

  return '#ff6666' if $text =~ /^critical$/;  # red
  return '#ff9933' if $text =~ /^high$/;      # orange
  return '#ffff66' if $text =~ /^routine$/;   # yellow
  return '#cccccc' if $text =~ /^low$/;       # grey

  return '#66ff66' if $text =~ /^green$/;     # green
  return '#ffff66' if $text =~ /^yellow$/;    # yellow
  return '#ff6666' if $text =~ /^red$/;       # red
  return '#cccccc' if $text =~ /^grey$/;      # grey
  return '#cccccc' if $text =~ /^gray$/;      # grey
  return '';

}

######################################################################

sub html_cell_class_for {

  my $text = shift;

  return 'critical' if $text =~ /^critical$/;  # red
  return 'high'     if $text =~ /^high$/;      # orange
  return 'routine'  if $text =~ /^routine$/;   # yellow
  return 'low'      if $text =~ /^low$/;       # grey
  return 'green'    if $text =~ /^green$/;     # green
  return 'yellow'   if $text =~ /^yellow$/;    # yellow
  return 'orange'   if $text =~ /^orange$/;    # orange
  return 'red'      if $text =~ /^red$/;       # red
  return 'grey'     if $text =~ /^grey$/;      # grey
  return 'gray'     if $text =~ /^gray$/;      # grey
  return '';

}

######################################################################

sub update_files {

  # This subroutine makes necessary changes to file contents then
  # writes the updated files back out to permanant storage.
  #
  # At this time, the only automatically updateable content elements
  # are meta-data comments like the following:
  #
  #     [#v:Solutions/ci-000001.txt:19]
  #
  #     [#d:Solutions/ci-000001.txt:2008-05-20]
  #
  #     [#a:Solutions/ci-000001.txt:Don.Johnson]
  #
  #     include:solution:$r19$: Solutions/ci-000001.txt
  #
  # These in-line comments enable a document author to refer to SVN
  # meta-data of one file inside another.
  #
  # This feature enables authors to build version controlled, modular
  # documents in which a change to a child document triggers a change
  # to the containing parent.  Such is the case with requirements
  # documents for instance.

  # return if not $option{'use_svn'};

  printstatus("updating files...");

  #-------------------------------------------------------------------
  # Update files
  #
  #     Look through each file in the %files data structure looking
  #     for updateable content elements that need to be updated.
  #
  foreach my $file (reverse sort by_resource_tier keys %files) {

    my $tier = $files{$file}{'tier'};

    # Create new resources division
    #
    my $new_resources_div = '';
    if ( scalar keys %{ $files{$file}{'resources'} } ) {
      $new_resources_div = ">>>RESOURCES\n";
      foreach my $resource (sort keys %{ $files{$file}{'resources'} }) {
	if ( -f $resource )
	  {
	    my $sha = Digest::SHA->new;
	    $sha->addfile($resource);
	    my $digest = $sha->hexdigest;
	    $new_resources_div .= "$digest $resource\n";
	  }

	else
	  {
	    printwarning("CAN'T FIND RESOURCE FILE: \'$resource\'");
	  }
      }
      $new_resources_div .= "<<<RESOURCES\n";
      $files{$file}{'new_resources_div'} = $new_resources_div;
    }

    # Parse old resources division
    #
    my $old_resources_div = '';
    my $in_resources_div  = 0;
    foreach ( @{ $files{$file}{'content'} } ) {
      if (/^>>>RESOURCES$/) {
	$in_resources_div = 1;
	$old_resources_div .= $_;
      } elsif (/^<<<RESOURCES$/) {
	$old_resources_div .= $_;
	$in_resources_div = 0;
      } elsif ($in_resources_div) {
	$old_resources_div .= $_;
      }
    }

    # Compare new and old resources divisions
    #
    if ( $new_resources_div ne $old_resources_div ) {
      $files{$file}{'modified'} = 1;
    } else {
      $files{$file}{'modified'} = 0;
    }

    #-----------------------------------------------------------------
    # Modify SVN update trigger tags
    #
    if ( $option{'use_svn'} ) {

      foreach ( @{ $files{$file}{'content'} } ) {

	#---------------------------------------------------------------
	# update revision comments
	#
	if (/\[#v:(.*?):(.*?)\]/) {
	  my $ref_file     = $1;
	  my $orig_version = $2;
	  my $new_version  = $svninfo{$ref_file}{'revision'};
	  if ( $new_version ne $orig_version ) {
	    $files{$file}{'modified'} = 1;
	    s/\[#v:(.*?):(.*?)\]/\[#v:$ref_file:$new_version\]/;
	    printstatus("Updated $ref_file version $orig_version to $new_version in $file");
	  }
	}

	#---------------------------------------------------------------
	# update date comments
	#
	if (/\[#d:(.*?):(.*?)\]/) {
	  my $ref_file  = $1;
	  my $orig_date = $2;
	  my $new_date  = $svninfo{$ref_file}{'date'};
	  if ( $new_date ne $orig_date ) {
	    $files{$file}{'modified'} = 1;
	    s/\[#d:(.*?):(.*?)\]/\[#d:$ref_file:$new_date\]/;
	    printstatus("Updated $ref_file date $orig_date to $new_date in $file");
	  }
	}

	#---------------------------------------------------------------
	# update author comments
	#
	if (/\[#a:(.*?):(.*?)\]/) {
	  my $ref_file    = $1;
	  my $orig_author = $2;
	  my $new_author  = $svninfo{$ref_file}{'author'};
	  if ( $new_author ne $orig_author ) {
	    $files{$file}{'modified'} = 1;
	    s/\[#a:(.*?):(.*?)\]/\[#a:$ref_file:$new_author\]/;
	    printstatus("Updated $ref_file author $orig_author to $new_author in $file");
	  }
	}
      }
    }

    # Remove revision argument fields
    #
    foreach ( @{ $files{$file}{'content'} } ) {

      #---------------------------------------------------------------
      # update include revision argument fields
      #
      if (/^(\*+\s+)?include::(.*?:)?(\$r(\w*?)\$:)?(.*?:)?\s+(.*?)\s*(#(.*))?$/) {
	# my $orig_version = $4;
	# my $ref_file     = $6;
	# my $new_version  = $svninfo{$ref_file}{'revision'};
	# if ( $new_version ne $orig_version ) {
	$files{$file}{'modified'} = 1;
	s/\$r(\w*)\$://;
	# printstatus("Updated $ref_file version $orig_version to $new_version in $file");
      # }
      }
    }

    #-------------------------------------------------------------------
    # Write changed files
    #
    foreach my $file (keys %files) {

      #-----------------------------------------------------------------
      # file modified?
      #
      if ( $files{$file}{'modified'} ) {

	#---------------------------------------------------------------
	# file writeable?
	#
	#    If this file is not writable, print an error and skip to
	#    the next file.
	#
	if ( not -w $file ) {
	  printerror("file not writable: $file");
	  next;
	} else {

	  my $in_resources_div = 0;
	  open FILE, ">$file";

	LINE:
	  foreach ( @{ $files{$file}{'content'} } ) {

	    if (/^>>>RESOURCES$/) {
	      $in_resources_div = 1;
	      next LINE;
	    } elsif (/^<<<RESOURCES$/) {
	      $in_resources_div = 0;
	      next LINE;
	    } elsif ($in_resources_div) {
	      next LINE;
	    } else {
	      print FILE;
	    }

	  }

	  print FILE $files{$file}{'new_resources_div'};

	  close FILE;
	}
      }
    }
  }
}

######################################################################

sub render_html_trace {

  # Render an HTML fragment that traces to one of the following
  # entities: problem, solution, allocation, assignment, test, task,
  # result, role, directed_by, derived_from.

  # The 'item' passed may be (1) a label that identifies an item in
  # the document, (2) arbitrary text that describes a solution, or (3)
  # a label *and* arbitrary text separated by a comma:
  #
  #    (1) ci-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) do-000234, section 3.2, para 4 on pg 158

  my $type    = shift; # directed_by, derived_from, problem, solution,
                       # test, task, result, role, effort, etc...
  my $item    = shift; # i.e. rq-001512
  my $string  = '';

  #-------------------------------------------------------------------
  # split labels from notes
  #
  my $note = '';
  if ( $item =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
    $item = $1;
    $note = $2;
  }

  #-------------------------------------------------------------------
  # outfile and anchor
  #
  #     These will be used to build a hyperlink to the item.
  #
  my $outfile = '';
  my $anchor  = '';
  if ( label_exists($item) ) {
    $outfile = html_outfile_for_label($item);
    $anchor  = "$item";
  }

  #-------------------------------------------------------------------
  # type_name
  #
  #     This name will be used in the string.
  #
  my $type_name = '';
  for ($type) {
    if    (/problem/)      { $type_name = 'problem'      }
    elsif (/solution/)     { $type_name = 'solution'     }
    elsif (/allocation/)   { $type_name = 'allocation'   }
    elsif (/assignment/)   { $type_name = 'assignment'   }
    elsif (/test/)         { $type_name = 'test'         }
    elsif (/task/)         { $type_name = 'task'         }
    elsif (/result/)       { $type_name = 'result'       }
    elsif (/role/)         { $type_name = 'role'         }
    elsif (/directs/)      { $type_name = 'directs'      }
    elsif (/directed_by/)  { $type_name = 'directed by'  }
    elsif (/uses/)         { $type_name = 'uses'         }
    elsif (/used_by/)      { $type_name = 'used by'      }
    elsif (/extends/)      { $type_name = 'extends'      }
    elsif (/extended_by/)  { $type_name = 'extended by'  }
    elsif (/realizes/)     { $type_name = 'realizes'     }
    elsif (/realized_by/)  { $type_name = 'realized by'  }
    elsif (/derived_from/) { $type_name = 'derived from' }
    elsif (/derived/)      { $type_name = 'derived'      }
    elsif (/owner/)        { $type_name = 'owner'        }
    elsif (/stakeholder/)  { $type_name = 'stakeholder'  }
    elsif (/assignee/)     { $type_name = 'assignee'     }
    elsif (/next/)         { $type_name = 'next'         }
    elsif (/previous/)     { $type_name = 'previous'     }
    elsif (/effort/)       { $type_name = 'effort'       }
    elsif (/required_by/)  { $type_name = 'required by'  }
    elsif (/depends_on/)   { $type_name = 'depends on'   }
    elsif (/class_of/)     { $type_name = 'class of'     }
    elsif (/instance_of/)  { $type_name = 'instance of'  }
    elsif (/generalizes/)  { $type_name = 'generalizes'  }
    elsif (/specializes/)  { $type_name = 'specializes'  }
    else {
      printerror("unknown trace type: $type");
    }
  }

  #-------------------------------------------------------------------
  # item is an existing label
  #
  if ( label_exists($item) ) {

    #-----------------------------------------------------------------
    # assemble title
    #
    my $title       = trim_whitespace($lookup{$item}{'title'});
    my $html_title  = escape_html($title);
    $html_title     = "<a href=\"$outfile#$anchor\">$html_title</a>";
    if ($note) {
      my $html_note = escape_html($note);
      $html_title .= ", $html_note";
    }
    my $title_block = wrap($html_title);

    #-----------------------------------------------------------------
    # get priority
    #
    my $priority = $lookup{$item}{'priority'} || 'low';
    my $priority_icon = html_priority_icon_for($priority);

    #-----------------------------------------------------------------
    # get status
    #
    my $status_color = status_of($item);
    my $status_icon  = html_status_icon_for($status_color);

    #-----------------------------------------------------------------
    # assemble type and tier
    #
    my @type        = @{ $lookup{$item}{'type'} };
    my $type        = escape_html(join(', ', @type));
    my $tier        = escape_html($lookup{$item}{'tier'});

    my $type_block  = '';
    $type_block .= "<span class=\"req_info\">(";
    if ($type) {
      $type_block .= "$type, ";
    }
    $type_block .= "tier $tier";
    $type_block .= ")</span>";

    #-----------------------------------------------------------------
    # get hyperlink info
    #
    my $name        = name_for($item);
    my $indexfile   = "$output_file.$name.html";

    $string = <<"END_OF_STRING";
<div class="trace">
$status_icon
$priority_icon
$type_name: <a href="$indexfile#$anchor">$item</a> -
$title_block
$type_block
</div>

END_OF_STRING
  }

  #-------------------------------------------------------------------
  # item is NOT an existing label
  #
  else {
    my $title = escape_html($item);

    $string = <<"END_OF_STRING";
<div class="trace">$type_name: $title</div>

END_OF_STRING
  }
  return $string;
}

######################################################################

sub status_of {

  ####################################################################
  #
  # Determine the current status (green, yellow, red, or grey) of an
  # item (problem, solution, allocation, assignment, test, task,
  # result, or role).  This is not a trivial task for the following
  # reasons:
  #
  # 1. The status of an item may be informally declared as a 'status'
  #    data element in the item itself *OR* may be formally documented
  #    as an 'outcome' data element.
  #
  # 2. If formally documented as an 'outcome' data element there may
  #    be multiple 'outcome' declarations and you need to determine
  #    the most recent one.
  #
  # 3. If the item is a container for other items, the status must be
  #    derived by recursively evaluating child items.
  #
  # Informally declared status is stored in the %lookup datastructure.
  #
  # Formally declared status is stored in the %results datastructure.
  #
  ####################################################################
  #
  # !!! BUG HERE !!!
  #
  # This subroutine is called recursively.  Protect against infinite
  # loops by checking hierarchies for redundant items (items that are
  # their own children or their own parents).
  #
  ####################################################################

  my $label  = shift;   # item label

  #-------------------------------------------------------------------
  # Validate label
  #
  if ( not label_exists($label) ) {
    my $status = 'grey';  # default to grey
    printwarning("label doesn't exist: \"$label\" returning $status");
    return $status;
  }

  #-------------------------------------------------------------------
  # Informally declared status
  #
  #    The 'use_formal_status' option defines whether the document
  #    being published requires "formal" or "informal" status
  #    determinations.  If $option{'use_formal_status'} is set to 1,
  #    use formal status from outcomes.  If
  #    $option{'use_formal_status'} is set to 0, use the 'status' data
  #    elements within regions.
  #
  if ( not $option{'use_formal_status'} ) {
    my $status = $lookup{$label}{'status'} || 'grey';
    return $status;
  }

  #-------------------------------------------------------------------
  # Formally declared status outcome
  #
  #     Items exist in whole/part hierarchies and the status of
  #     'container' items is derived from the status of their
  #     'contained' items according to the following rules:
  #
  #     1. The status of a 'container' is GREEN only if *all* of its
  #        items are GREEN.
  #
  #     2. The status of a 'container' is RED only if *all* of its
  #        items are RED or GREY.
  #
  #     3. The status of a 'container' is GREY only if *all* of its
  #        items are GREY.
  #
  #     4. In all other cases, the status of the container is YELLOW.
  #
  else {

    # If we've already computed this status and memoized it in the
    # %status datastructure, return the memoized value.
    #
    if ( exists $status{$label}{'status'} ) {
      my $status = $status{$label}{'status'};
      return $status;
    }

    # Elsif Item HAS children...
    #
    elsif ( has_children($label) ) {

      my $status = 'grey';

      # Otherwise, compute the status of this item by looking at the
      # the status of its children.
      #
      my $green  = 1;
      my $yellow = 1;
      my $red    = 1;
      my $grey   = 1;

      foreach my $child ( @{ $lookup{$label}{'children'} } ) {
	my $child_status = status_of($child) || 'grey';
	if ( $child_status eq 'green' ) {
	  $red   = 0; # parent status can't be red
	  $grey  = 0; # parent status can't be grey
	} elsif ( $child_status eq 'yellow' ) {
	  $green = 0; # parent status can't be green
	  $red   = 0; # parent status can't be red
	  $grey  = 0; # parent status can't be grey
	} elsif ( $child_status eq 'red' ) {
	  $green = 0; # parent status can't be green
	  $grey  = 0; # parent status can't be grey
	} elsif ( $child_status eq 'grey' ) {
	  $green = 0; # parent status can't be green
	}
      }

      # Determine, memoize, and return most recent status.
      #
      if ($green) {
	$status{$label}{'status'} = 'green';
	$status{$label}{'source'} = '(computed)';
	$status{$label}{'date'}   = '';
	$status = 'green';
      }

      elsif ($grey) {
	$status{$label}{'status'} = 'grey';
	$status{$label}{'source'} = '(computed)';
	$status{$label}{'date'}   = '';
	$status = 'grey';
      }

      elsif ($red) {
	$status{$label}{'status'} = 'red';
	$status{$label}{'source'} = '(computed)';
	$status{$label}{'date'}   = '';
	$status = 'red';
      }

      else {
	$status{$label}{'status'} = 'yellow';
	$status{$label}{'source'} = '(computed)';
	$status{$label}{'date'}   = '';
	$status = 'yellow';
      }

      return $status;

    }

    # Else, item DOESN'T have children...
    #
    else {

      # Determine, memoize, and return most recent status.
      #
      my @dates  = sort keys %{ $outcomes{$label} };
      my $date   = $dates[-1]; # most recent date
      my $status = $outcomes{$label}{$date}{'status'} || 'grey';
      my $source = $outcomes{$label}{$date}{'source'};

      $status{$label}{'status'} = $status;
      $status{$label}{'source'} = $source;
      $status{$label}{'date'}   = $date;

      return $status;
    }
  }

  return $status;

}

######################################################################

sub effort_for {

  # Compute the effort required for an item.
  #
  # Typically the "item" is a business requirement (a.k.a. an
  # operational requirement) that describes something an organization
  # must do.
  #
  # Effort can be expressed in different ways.  It can be a number
  # representing required FTE.  One FTE is 2040 hours (one work-year).
  # For instance, an effort of "o.025" represents about 52 hours, or
  # one hour per week.  It can also be expressed as a number
  # representing hours per week.  The subroutine doesn't care what
  # units are used.  It only requires that the number be anchored to
  # the beginning of the string.
  #
  # This subroutine is called recursively to "roll up" the level of
  # effort required for a hierarchy of items.

  my $label = shift;   # item label
  my $units = $document{'effort_units'};

  #-------------------------------------------------------------------
  # Validate label
  #
  if ( not label_exists($label) ) {
    printwarning("label doesn't exist: $label");
    return $status;
  }

  #-------------------------------------------------------------------
  # If this item has children...
  #
  if ( has_children($label) ) {

    my $effort = 0;

    # Compute the effort for this item by looking at the effort for
    # each child.
    #
    foreach my $child ( @{ $lookup{$label}{'children'} } ) {
      my $child_effort = effort_for($child);
      if ( $child_effort =~ /^\s*(\d+\.\d+|\d+\.|\.\d+|\d+)/ and $1 != 0 ) {
	$effort = $effort + $1;
      }
    }

    return "$effort $units (computed)";

  }

  #-------------------------------------------------------------------
  # Else this item doesn't have children.
  #
  else {

    my $effort = 0;

    my @item_efforts = @{ $lookup{$label}{'effort'} };
    foreach my $item_effort (@item_efforts) {
      if ( $item_effort =~ /^\s*(\d+\.\d+|\d+\.|\.\d+|\d+)/ and $1 != 0 ) {
	$effort = $effort + $1;
      }
    }

    return "$effort $units";

  }

}

######################################################################

sub latex_header_for {

  my $label         = shift;
  my $name          = name_for($label);
  my $ucname        = ucfirst $name;
  my $title         = escape_latex($lookup{$label}{'title'});
  my $description   = escape_latex($lookup{$label}{'description'});
  my @lines         = ();
#  my $text          = wrap("\\textbf{$ucname \\the${name}\\ -- $title} -- $description");
  my $text          = wrap("\\textbf{$label -- $title} -- $description");
  my $title_block   = wrap("\\begin{$name}{$title}");
  my $status        = status_of($label) if label_exists($label);
  my $status_icon   = latex_status_icon_for($status);
  my $priority      = $lookup{$label}{'priority'} || 'low';
  my $priority_icon = latex_priority_icon_for($priority);
  my @type          = @{ $lookup{$label}{'type'} };
  my $type          = join(', ',@type);
  my $date          = trim_whitespace($lookup{$label}{'date'});
  my $author        = $lookup{$label}{'author'};
  $author           = strip_revision_control_keyword_chars($author);
  $author           = trim_whitespace($author);
  $author           = escape_latex($author);
  my $revision      = trim_whitespace($lookup{$label}{'revision'});

  # normalize date
  #
  if ($date =~ /\((.*?)\)/) {
    $date = $1;
  }

  # The following LaTeX code is carefully crafted to control page
  # breaks.  Only modify it with caution.
  #
  # Published items start with (1) a name (i.e. Problem, Solution,
  # Allocation, Assignment, Test, Task...), (2) a number (i.e. 2.13),
  # (3) a title, (4) a description, and (5) a metadata table.  The
  # metadata table can be followed by any amount of narrative content.
  #
  # I don't want to allow page breaks anywhere between the name and
  # the metadata table.
  #
  push @lines, <<"END_OF_TEXT";

\\vspace{\\baselineskip}

%% begin $name
%%

$title_block

\\begin{samepage}

\\label{$label}

$text

\\nopagebreak

%%-----------------------------------
%% meta data table
%%
\\begin{tabularx}{\\linewidth}{
G
>{\\footnotesize}l
>{\\footnotesize}l
>{\\footnotesize}l
>{\\footnotesize}X
>{\\footnotesize}X
>{\\footnotesize}X
>{\\footnotesize}l
G
}
\\ghline
\\textit{ID:}
&
\\textit{Priority:}
&
\\textit{Status:}
&
\\textit{Type:}
&
\\textit{Last Modified:}
&
\\textit{By:}
&
\\textit{Changeset:}
\\\\
$label
&
$priority_icon $priority
&
$status_icon $status
&
$type
&
$date
&
$author
&
$revision
\\\\
\\ghline
\\end{tabularx}

\\end{samepage}

%% \\vspace{-\\baselineskip}

%% begin table
%%

\\begin{longtable}{%
\@{}
>{\\small\\raggedright\\arraybackslash}p{60pt}
>{\\small\\raggedright\\arraybackslash}p{300pt}
>{\\small\\raggedright\\arraybackslash}p{40pt}
\@{}
}
\\tabularnewline
\\endfirsthead
\\tabularnewline
\\endhead
\\tabularnewline
\\endfoot
\\endlastfoot

END_OF_TEXT

  return @lines;
}

######################################################################

sub latex_status_for {

  my $label  = shift;
  my @lines  = ();

  #-------------------------------------------------------------------
  # Formal Status
  #
  #     Formal status outcomes are declared in 'outcome' data
  #     elements.  The 'use_formal_status' option determines whether
  #     to use formal status (1) or informal status (0).
  #
  if ($option{'use_formal_status'} == 1) {

    #-----------------------------------------------------------------
    # Look for status in the results datastructure
    #
    my @dates = keys %{ $outcomes{$label} };
    my $found_status = 0;
    foreach my $date (@dates) {
      my $status      = $outcomes{$label}{$date}{'status'};
      my $description = $outcomes{$label}{$date}{'description'};
      my $source      = $outcomes{$label}{$date}{'source'};
      if ($status) {
	$found_status = 1;
	my $icon   = latex_status_icon_for($status);
	my $string = escape_latex("[id:$source] - $status on $date - $description");

	my $cell_1 = "\\textit{Result:}";
	my $cell_2 = wrap("$icon $string");
	my $cell_3 = "p. \\pageref{$source}";

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }
    }

    #-----------------------------------------------------------------
    # Default Status is grey
    #
#     if (not $found_status) {
#       my $status = 'grey';
#       my $icon   = latex_status_icon_for($status);

#       my $cell_1 = "\\textit{Status:}";
#       my $cell_2 = wrap("$icon $status");

#       push @lines, <<"END_OF_TEXT";
# $cell_1
# &
# $cell_2
# &

# \\\\

# END_OF_TEXT
#     }
  }

  #-------------------------------------------------------------------
  # Informal Status
  #
#   else {
#     my $status = $lookup{$label}{'status'} || '';
#     my $icon   = latex_status_icon_for($status);
#     if ($status) {

#       my $cell_1 = "\\textit{Status:}";
#       my $cell_2 = wrap("$icon $status");

#       push @lines, <<"END_OF_TEXT";
# $cell_1
# &
# $cell_2
# &

# \\\\

# END_OF_TEXT
#     }
#   }

  return @lines;
}

######################################################################

sub latex_reviews_for {

  my $label  = shift;
  my @lines  = ();
  my @dates  = keys %{ $reviews{$label} };

  my $is_first_row = 1;
  foreach my $date (@dates) {

    my $status        = $reviews{$label}{$date}{'status'};
    my $icon          = latex_status_icon_for($status);
    my $description   = $reviews{$label}{$date}{'description'};
    my $source        = $reviews{$label}{$date}{'source'};
    my $review_header = $EMPTY_STRING;
    $review_header    = '\\textit{Reviews:}' if $is_first_row;
    $is_first_row     = 0;
    my $string        = escape_latex("$status: ($date, [id:$source]) $description");

    my $cell_1 = wrap("$review_header");
    my $cell_2 = wrap("$icon $string");

    push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
  }

  return @lines;
}

######################################################################

sub latex_label_for {

  my $label  = shift;
  my @lines  = ();

  if ($label and not $option{'hide_ids'}) {

    my $cell_1 = "\\textit{ID:}";
    my $cell_2 = wrap("$label");

    push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub latex_revision_for {

  my $label    = shift;
  my $revision = escape_latex($lookup{$label}{'revision'});
  my @lines    = ();

  if ($revision) {

    # Change "$Revision: 16454 $" to just "2"
    #
    if ( $revision =~ /\$Revision:\s*(.*?)\s*\$/ ) {
      $revision = $1;
    }

    my $cell_1 = "\\textit{Revision:}";
    my $cell_2 = wrap("$revision");

    push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub latex_date_for {

  my $label = shift;
  my $date  = $lookup{$label}{'date'};
  my @lines = ();

  if ($date) {

    my $cell_1 = "\\textit{Date:}";
    my $cell_2 = wrap("$date");

    push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub latex_author_for {

  my $label  = shift;
  my $author = $lookup{$label}{'author'};
  $author    = strip_revision_control_keyword_chars($author);
  $author    = escape_latex($author);
  my @lines  = ();

  if ($author) {

    my $cell_1 = "\\textit{Author:}";
    my $cell_2 = wrap("$author");

    push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub latex_types_for {

  my $label = shift;
  my @types = @{$lookup{$label}{'type'}};
  my @lines = ();

  if (@types) {
    my $types = join(', ', @types);

    my $cell_1 = "\\textit{Type:}";
    my $cell_2 = wrap("$types");

    push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub latex_pros_for {

  my $label = shift;
  my @pros = @{$lookup{$label}{'pro'}};
  my @lines = ();

  if (@pros) {
    my $pros = join(', ', @pros);

    my $cell_1 = "\\textit{Pro:}";
    my $cell_2 = wrap("$pros");

    push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub latex_cons_for {

  my $label = shift;
  my @cons = @{$lookup{$label}{'con'}};
  my @lines = ();

  if (@cons) {
    my $cons = join(', ', @cons);

    my $cell_1 = "\\textit{Con:}";
    my $cell_2 = wrap("$cons");

    push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub latex_priority_for {

  my $label    = shift;
  my $priority = escape_latex($lookup{$label}{'priority'});
  my $icon     = latex_priority_icon_for($priority);
  my $string   = escape_latex($priority);
  my @lines    = ();

  if ($priority) {

    my $cell_1 = "\\textit{Priority:}";
    my $cell_2 = wrap("$icon $string");

    push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub latex_owner_for {

  my $label  = shift;
  my $owner  = $lookup{$label}{'owner'} || '';
  my $string = '';
  my @lines  = ();

  if ( label_exists($owner) ) {

    my $link  = "\\hyperref[$owner]{$owner}";
    my $title = escape_latex($lookup{$owner}{'title'});
    $string = "$link - $title";

    my $cell_1 = "\\textit{Owner:}";
    my $cell_2 = wrap("$string");
    my $cell_3 = wrap("p. \\pageref{$owner}");

    push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
  }

  elsif ($owner) {

    $string = escape_latex($owner);

    my $cell_1 = "\\textit{Owner:}";
    my $cell_2 = wrap("$string");

    push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
  }

  return @lines;
}

######################################################################

sub latex_assignees_for {

  my $label        = shift;
  my @assignees   = @{$lookup{$label}{'assignee'}};
  my @lines        = ();

  my $is_first_row = 1;
  foreach my $assignee (@assignees) {

    my $header    = $EMPTY_STRING;
    $header       = '\\textit{Assignees:}' if $is_first_row;
    $is_first_row = 0;

    if ( label_exists($assignee) ) {
      my $link  = "\\hyperref[$assignee]{$assignee}";
      my $title = escape_latex($lookup{$assignee}{'title'});
      $string = "$link - $title";

      my $cell_1 = wrap("$header");
      my $cell_2 = wrap("$string");
      my $cell_3 = wrap("p. \\pageref{$assignee}");

      push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
    }

    else {
      $string = escape_latex($assignee);

      my $cell_1 = wrap("$header");
      my $cell_2 = wrap("$string");

      push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
    }

  }

  return @lines;
}

######################################################################

sub latex_roles_for {

  my $label        = shift;
  my @roles = ();
  if ( ref $lookup{$label}{'role'} eq 'ARRAY' ) {
    @roles = @{$lookup{$label}{'role'}};
  } elsif ($lookup{$label}{'role'}) {
    push @roles, $lookup{$label}{'role'};
  }

  my @lines        = ();

  my $is_first_row = 1;
  foreach my $role (@roles) {

    my $header    = $EMPTY_STRING;
    $header       = '\\textit{Roles:}' if $is_first_row;
    $is_first_row = 0;

    if ( label_exists($role) ) {
      my $link  = "\\hyperref[$role]{$role}";
      my $title = escape_latex($lookup{$role}{'title'});
      $string = "$link - $title";

      my $cell_1 = wrap("$header");
      my $cell_2 = wrap("$string");
      my $cell_3 = wrap("p. \\pageref{$role}");

      push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
    }

    else {
      $string = escape_latex($role);

      my $cell_1 = wrap("$header");
      my $cell_2 = wrap("$string");

      push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
    }

  }

  return @lines;
}

######################################################################

sub latex_stakeholders_for {

  my $label        = shift;
  my @stakeholders = @{$lookup{$label}{'stakeholder'}};
  my @lines        = ();

  my $is_first_row = 1;
  foreach my $stakeholder (@stakeholders) {

    my $header    = $EMPTY_STRING;
    $header       = '\\textit{Stakeholders:}' if $is_first_row;
    $is_first_row = 0;

    if ( label_exists($stakeholder) ) {
      my $link  = "\\hyperref[$stakeholder]{$stakeholder}";
      my $title = escape_latex($lookup{$stakeholder}{'title'});
      $string = "$link - $title";

      my $cell_1 = wrap("$header");
      my $cell_2 = wrap("$string");
      my $cell_3 = wrap("p. \\pageref{$stakeholder}");

      push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
    }

    else {
      $string = escape_latex($stakeholder);

      my $cell_1 = wrap("$header");
      my $cell_2 = wrap("$string");

      push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
    }

  }

  return @lines;
}

######################################################################

sub latex_previous_for {

  my $label    = shift;
  my @previous = @{$lookup{$label}{'previous'}};
  my @lines    = ();

  if (@previous) {

    my $first_line = 1;
    foreach my $previous (@previous) {

      my $title  = $lookup{$previous}{'title'};
      my $string = "[id:$previous] - $title";
      my $latex  = escape_latex($string);
      my $status = status_of($previous) if label_exists($previous);
      my $icon   = latex_status_icon_for($status);

      my $cell_1 = '';
      if ($first_line) {
	$cell_1 = "\\textit{Previous:}";
	$first_line = 0;
      }

      my $cell_2 = wrap("$icon $latex");
      my $cell_3 = wrap("p. \\pageref{$previous}");

      push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
    }
  }

  return @lines;
}

######################################################################

sub latex_next_for {

  my $label  = shift;
  my @next   = @{$lookup{$label}{'next'}};
  my @lines  = ();

  if (@next) {

    my $first_line = 1;
    foreach my $next (@next) {

      my $title  = $lookup{$next}{'title'};
      my $string = "[id:$next] - $title";
      my $latex  = escape_latex($string);
      my $status = status_of($next) if label_exists($next);
      my $icon   = latex_status_icon_for($status);

      my $cell_1 = '';
      if ($first_line) {
	$cell_1 = wrap("\\textit{Next:}");
	$first_line = 0;
      }

      my $cell_2 = wrap("$icon $latex");
      my $cell_3 = wrap("p. \\pageref{$next}");

      push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
    }
  }

  return @lines;
}

######################################################################

sub latex_license_for {

  my $label   = shift;
  my $license = escape_latex($lookup{$label}{'license'});
  my @lines   = ();

  if ($license) {

    my $cell_1 = "\\textit{License:}";
    my $cell_2 = wrap("$license");

    push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub latex_cost_of {

  my $label = shift;
  my $cost  = escape_latex($lookup{$label}{'cost'});
  my @lines = ();

  if ($cost) {

    my $cell_1 = "\\textit{Cost:}";
    my $cell_2 = wrap("$cost");

    push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub latex_copyright_of {

  my $label     = shift;
  my $copyright = escape_latex($lookup{$label}{'copyright'});
  my @lines = ();

  if ($copyright) {

    my $cell_1 = "\\textit{Copyright:}";
    my $cell_2 = wrap("$copyright");

    push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub latex_version_of {

  my $label   = shift;
  my $version = escape_latex($lookup{$label}{'version'});
  my @lines   = ();

  if ($version) {

    my $cell_1 = "\\textit{Version:}";
    my $cell_2 = wrap("$version");

    push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub latex_release_for {

  my $label   = shift;
  my $release = escape_latex($lookup{$label}{'release'});
  my @lines   = ();

  if ($release) {

    my $cell_1 = "\\textit{Release:}";
    my $cell_2 = wrap("$release");

    push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub latex_validator_for {

  my $label     = shift;
  my $validator = escape_latex($lookup{$label}{'validator'});
  my @lines     = ();

  if ($validator) {

    my $cell_1 = "\\textit{Validator:}";
    my $cell_2 = wrap("$validator");

    push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub latex_effort_for {

  my @lines  = ();
  my $label  = shift;
  my $units  = $document{'effort_units'} || '';

  if ( has_children($label) ) {
    my $effort = escape_latex(effort_for($label));
    if ($effort =~ /\s*(\d+\.\d+|\d+\.|\.\d+|\d+)/ and $1 != 0) {

      my $cell_1 = "\\textit{Effort:}";
      my $Cell_2 = wrap("$effort");

      push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
    }
    return @lines;
  }

  else {

    my @lines  = ();
    my $amount = 0;
    my $units  = $document{'effort_units'} || '';

    my @item_efforts = @{ $lookup{$label}{'effort'} };
    my @items        = ();

    foreach my $item_effort (@item_efforts) {
      if ( $item_effort =~ /^\s*(\d+\.\d+|\d+\.|\.\d+|\d+)/  and $1 != 0 ) {
	$amount = $amount + $1;
      }
      push @items, $item_effort;
    }

    if ( scalar(@item_efforts) > 1 ) {
      push @items, "$amount $units total";
    }

    my $block = join(', ',@items);
    if ( $amount != 0 ) {

      my $cell_1 = "\\textit{Effort:}";
      my $cell_2 = wrap("$block");

      push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
    }

    return @lines;
  }


}

######################################################################

sub latex_directs {

  # Each 'directs' may be (1) a label that identifies an item in
  # the document, (2) arbitrary text that describes a directs, or
  # (3) a label *and* arbitrary text separated by a comma:
  #
  #    (1) ci-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) do-000234, section 3.2, para 4 on pg 158

  my $label       = shift;
  my @directs = @{$lookup{$label}{'directs'}};
  my @lines       = ();

  if (@directs) {

    #-----------------------------------------------------------------
    # List directives
    #
    my $is_first_row = 1;
    foreach my $directs (@directs) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $directs =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$directs = $1;
	$note        = $2;
      }

      #---------------------------------------------------------------
      # Determine this directs's title
      #
      my $directs_title = '';
      if ( label_exists($directs) ) {
	my $directs_string = "\\hyperref[$directs]{$directs}";
	my $title_string   = escape_latex( $lookup{$directs}{'title'} );
	$directs_title     = $directs_string . " - " . $title_string;
      } else {
	$directs_title = escape_latex($directs);
      }

      my $directs_status = status_of($directs) if label_exists($directs);
      my $directs_icon   = latex_status_icon_for($directs_status);

      #---------------------------------------------------------------
      # assemble header
      #
      my $directs_header   = $EMPTY_STRING;
      $directs_header      = '\\textit{Directs:}' if $is_first_row;
      $is_first_row = 0;
      $directs_priority    = '\\textit{priority:} ' . $directs_priority if $directs_priority;
      $directs_status      = '\\textit{status:} ' . $directs_status if $directs_status;

      #---------------------------------------------------------------
      # if there was a note, add it after the title
      #
      if ($note) {
	$note = escape_latex($note);
	$directs_title = $directs_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate text
      #
      if ( label_exists($directs) ) {

	my $cell_1 = wrap("$directs_header");
	my $cell_2 = wrap("$directs_icon $directs_title");
	my $cell_3 = wrap("p. \\pageref{$directs}");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }

      else {

	my $cell_1 = wrap("$directs_header");
	my $cell_2 = wrap("$directs_title");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
      }


    }
  }
  return @lines;
}

######################################################################

sub latex_directed_by {

  # Each 'directed_by' may be (1) a label that identifies an item in
  # the document, (2) arbitrary text that describes a directed_by, or
  # (3) a label *and* arbitrary text separated by a comma:
  #
  #    (1) ci-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) do-000234, section 3.2, para 4 on pg 158

  my $label       = shift;
  my @directed_by = @{$lookup{$label}{'directed_by'}};
  my @lines       = ();

  if (@directed_by) {

    #-----------------------------------------------------------------
    # List directives
    #
    my $is_first_row = 1;
    foreach my $directed_by (@directed_by) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $directed_by =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$directed_by = $1;
	$note        = $2;
      }

      #---------------------------------------------------------------
      # Determine this directed_by's title
      #
      my $directed_by_title = '';
      if ( label_exists($directed_by) ) {
	my $directed_by_string = "\\hyperref[$directed_by]{$directed_by}";
	my $title_string       = escape_latex( $lookup{$directed_by}{'title'} );
	$directed_by_title     = $directed_by_string . " - " . $title_string;
      } else {
	$directed_by_title = escape_latex($directed_by);
      }

      my $status             = status_of($directed_by) if label_exists($directed_by);
      my $directed_by_icon   = latex_status_icon_for($status);

      #---------------------------------------------------------------
      # assemble header
      #
      my $directed_by_header   = $EMPTY_STRING;
      $directed_by_header      = '\\textit{Directed By:}' if $is_first_row;
      $is_first_row = 0;
      $directed_by_priority    = '\\textit{priority:} ' . $directed_by_priority if $directed_by_priority;
      $directed_by_status      = '\\textit{status:} ' . $directed_by_status if $directed_by_status;

      #---------------------------------------------------------------
      # if there was a note, add after the title
      #
      if ($note) {
	$note = escape_latex($note);
	$directed_by_title = $directed_by_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate text
      #
      if ( label_exists($directed_by) ) {

	my $cell_1 = wrap("$directed_by_header");
	my $cell_2 = wrap("$directed_by_icon $directed_by_title");
	my $cell_3 = wrap("p. \\pageref{$directed_by}");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }

      else {

	my $cell_1 = wrap("$directed_by_header");
	my $cell_2 = wrap("$directed_by_title");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
      }


    }
  }
  return @lines;
}

######################################################################

sub latex_uses {

  # Each 'uses' may be (1) a label that identifies an item in
  # the document, (2) arbitrary text that describes a uses, or
  # (3) a label *and* arbitrary text separated by a comma:
  #
  #    (1) ci-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) do-000234, section 3.2, para 4 on pg 158

  my $label       = shift;
  my @uses = @{$lookup{$label}{'uses'}};
  my @lines       = ();

  if (@uses) {

    #-----------------------------------------------------------------
    # List useives
    #
    my $is_first_row = 1;
    foreach my $uses (@uses) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $uses =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$uses = $1;
	$note        = $2;
      }

      #---------------------------------------------------------------
      # Determine this uses's title
      #
      my $uses_title = '';
      if ( label_exists($uses) ) {
	my $uses_string = "\\hyperref[$uses]{$uses}";
	my $title_string   = escape_latex( $lookup{$uses}{'title'} );
	$uses_title     = $uses_string . " - " . $title_string;
      } else {
	$uses_title = escape_latex($uses);
      }

      my $uses_status = status_of($uses) if label_exists($uses);
      my $uses_icon   = latex_status_icon_for($uses_status);

      #---------------------------------------------------------------
      # assemble header
      #
      my $uses_header   = $EMPTY_STRING;
      $uses_header      = '\\textit{Uses:}' if $is_first_row;
      $is_first_row = 0;
      $uses_priority    = '\\textit{priority:} ' . $uses_priority if $uses_priority;
      $uses_status      = '\\textit{status:} ' . $uses_status if $uses_status;

      #---------------------------------------------------------------
      # if there was a note, add it after the title
      #
      if ($note) {
	$note = escape_latex($note);
	$uses_title = $uses_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate text
      #
      if ( label_exists($uses) ) {

	my $cell_1 = wrap("$uses_header");
	my $cell_2 = wrap("$uses_icon $uses_title");
	my $cell_3 = wrap("p. \\pageref{$uses}");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }

      else {

	my $cell_1 = wrap("$uses_header");
	my $cell_2 = wrap("$uses_title");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
      }


    }
  }
  return @lines;
}

######################################################################

sub latex_used_by {

  # Each 'used_by' may be (1) a label that identifies an item in
  # the document, (2) arbitrary text that describes a used_by, or
  # (3) a label *and* arbitrary text separated by a comma:
  #
  #    (1) ci-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) do-000234, section 3.2, para 4 on pg 158

  my $label       = shift;
  my @used_by = @{$lookup{$label}{'used_by'}};
  my @lines       = ();

  if (@used_by) {

    #-----------------------------------------------------------------
    # List useives
    #
    my $is_first_row = 1;
    foreach my $used_by (@used_by) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $used_by =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$used_by = $1;
	$note        = $2;
      }

      #---------------------------------------------------------------
      # Determine this used_by's title
      #
      my $used_by_title = '';
      if ( label_exists($used_by) ) {
	my $used_by_string = "\\hyperref[$used_by]{$used_by}";
	my $title_string       = escape_latex( $lookup{$used_by}{'title'} );
	$used_by_title     = $used_by_string . " - " . $title_string;
      } else {
	$used_by_title = escape_latex($used_by);
      }

      my $status             = status_of($used_by) if label_exists($used_by);
      my $used_by_icon   = latex_status_icon_for($status);

      #---------------------------------------------------------------
      # assemble header
      #
      my $used_by_header   = $EMPTY_STRING;
      $used_by_header      = '\\textit{Used By:}' if $is_first_row;
      $is_first_row = 0;
      $used_by_priority    = '\\textit{priority:} ' . $used_by_priority if $used_by_priority;
      $used_by_status      = '\\textit{status:} ' . $used_by_status if $used_by_status;

      #---------------------------------------------------------------
      # if there was a note, add after the title
      #
      if ($note) {
	$note = escape_latex($note);
	$used_by_title = $used_by_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate text
      #
      if ( label_exists($used_by) ) {

	my $cell_1 = wrap("$used_by_header");
	my $cell_2 = wrap("$used_by_icon $used_by_title");
	my $cell_3 = wrap("p. \\pageref{$used_by}");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }

      else {

	my $cell_1 = wrap("$used_by_header");
	my $cell_2 = wrap("$used_by_title");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
      }


    }
  }
  return @lines;
}

######################################################################

sub latex_extends {

  # Each 'extends' may be (1) a label that identifies an item in
  # the document, (2) arbitrary text that describes a extends, or
  # (3) a label *and* arbitrary text separated by a comma:
  #
  #    (1) ci-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) do-000234, section 3.2, para 4 on pg 158

  my $label       = shift;
  my @extends = @{$lookup{$label}{'extends'}};
  my @lines       = ();

  if (@extends) {

    #-----------------------------------------------------------------
    # List directives
    #
    my $is_first_row = 1;
    foreach my $extends (@extends) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $extends =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$extends = $1;
	$note        = $2;
      }

      #---------------------------------------------------------------
      # Determine this extends's title
      #
      my $extends_title = '';
      if ( label_exists($extends) ) {
	my $extends_string = "\\hyperref[$extends]{$extends}";
	my $title_string   = escape_latex( $lookup{$extends}{'title'} );
	$extends_title     = $extends_string . " - " . $title_string;
      } else {
	$extends_title = escape_latex($extends);
      }

      my $extends_status = status_of($extends) if label_exists($extends);
      my $extends_icon   = latex_status_icon_for($extends_status);

      #---------------------------------------------------------------
      # assemble header
      #
      my $extends_header   = $EMPTY_STRING;
      $extends_header      = '\\textit{Extends:}' if $is_first_row;
      $is_first_row = 0;
      $extends_priority    = '\\textit{priority:} ' . $extends_priority if $extends_priority;
      $extends_status      = '\\textit{status:} ' . $extends_status if $extends_status;

      #---------------------------------------------------------------
      # if there was a note, add it after the title
      #
      if ($note) {
	$note = escape_latex($note);
	$extends_title = $extends_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate text
      #
      if ( label_exists($extends) ) {

	my $cell_1 = wrap("$extends_header");
	my $cell_2 = wrap("$extends_icon $extends_title");
	my $cell_3 = wrap("p. \\pageref{$extends}");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }

      else {

	my $cell_1 = wrap("$extends_header");
	my $cell_2 = wrap("$extends_title");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
      }


    }
  }
  return @lines;
}

######################################################################

sub latex_extended_by {

  # Each 'extended_by' may be (1) a label that identifies an item in
  # the document, (2) arbitrary text that describes a extended_by, or
  # (3) a label *and* arbitrary text separated by a comma:
  #
  #    (1) ci-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) do-000234, section 3.2, para 4 on pg 158

  my $label       = shift;
  my @extended_by = @{$lookup{$label}{'extended_by'}};
  my @lines       = ();

  if (@extended_by) {

    #-----------------------------------------------------------------
    # List extendives
    #
    my $is_first_row = 1;
    foreach my $extended_by (@extended_by) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $extended_by =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$extended_by = $1;
	$note        = $2;
      }

      #---------------------------------------------------------------
      # Determine this extended_by's title
      #
      my $extended_by_title = '';
      if ( label_exists($extended_by) ) {
	my $extended_by_string = "\\hyperref[$extended_by]{$extended_by}";
	my $title_string       = escape_latex( $lookup{$extended_by}{'title'} );
	$extended_by_title     = $extended_by_string . " - " . $title_string;
      } else {
	$extended_by_title = escape_latex($extended_by);
      }

      my $status             = status_of($extended_by) if label_exists($extended_by);
      my $extended_by_icon   = latex_status_icon_for($status);

      #---------------------------------------------------------------
      # assemble header
      #
      my $extended_by_header   = $EMPTY_STRING;
      $extended_by_header      = '\\textit{Extended By:}' if $is_first_row;
      $is_first_row = 0;
      $extended_by_priority    = '\\textit{priority:} ' . $extended_by_priority if $extended_by_priority;
      $extended_by_status      = '\\textit{status:} ' . $extended_by_status if $extended_by_status;

      #---------------------------------------------------------------
      # if there was a note, add after the title
      #
      if ($note) {
	$note = escape_latex($note);
	$extended_by_title = $extended_by_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate text
      #
      if ( label_exists($extended_by) ) {

	my $cell_1 = wrap("$extended_by_header");
	my $cell_2 = wrap("$extended_by_icon $extended_by_title");
	my $cell_3 = wrap("p. \\pageref{$extended_by}");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }

      else {

	my $cell_1 = wrap("$extended_by_header");
	my $cell_2 = wrap("$extended_by_title");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
      }


    }
  }
  return @lines;
}

######################################################################

sub latex_realizes {

  # Each 'realizes' may be (1) a label that identifies an item in
  # the document, (2) arbitrary text that describes a realizes, or
  # (3) a label *and* arbitrary text separated by a comma:
  #
  #    (1) ci-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) do-000234, section 3.2, para 4 on pg 158

  my $label       = shift;
  my @realizes = @{$lookup{$label}{'realizes'}};
  my @lines       = ();

  if (@realizes) {

    #-----------------------------------------------------------------
    # List directives
    #
    my $is_first_row = 1;
    foreach my $realizes (@realizes) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $realizes =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$realizes = $1;
	$note        = $2;
      }

      #---------------------------------------------------------------
      # Determine this realizes's title
      #
      my $realizes_title = '';
      if ( label_exists($realizes) ) {
	my $realizes_string = "\\hyperref[$realizes]{$realizes}";
	my $title_string   = escape_latex( $lookup{$realizes}{'title'} );
	$realizes_title     = $realizes_string . " - " . $title_string;
      } else {
	$realizes_title = escape_latex($realizes);
      }

      my $realizes_status = status_of($realizes) if label_exists($realizes);
      my $realizes_icon   = latex_status_icon_for($realizes_status);

      #---------------------------------------------------------------
      # assemble header
      #
      my $realizes_header   = $EMPTY_STRING;
      $realizes_header      = '\\textit{Realizes:}' if $is_first_row;
      $is_first_row = 0;
      $realizes_priority    = '\\textit{priority:} ' . $realizes_priority if $realizes_priority;
      $realizes_status      = '\\textit{status:} ' . $realizes_status if $realizes_status;

      #---------------------------------------------------------------
      # if there was a note, add it after the title
      #
      if ($note) {
	$note = escape_latex($note);
	$realizes_title = $realizes_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate text
      #
      if ( label_exists($realizes) ) {

	my $cell_1 = wrap("$realizes_header");
	my $cell_2 = wrap("$realizes_icon $realizes_title");
	my $cell_3 = wrap("p. \\pageref{$realizes}");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }

      else {

	my $cell_1 = wrap("$realizes_header");
	my $cell_2 = wrap("$realizes_title");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
      }


    }
  }
  return @lines;
}

######################################################################

sub latex_realized_by {

  # Each 'realized_by' may be (1) a label that identifies an item in
  # the document, (2) arbitrary text that describes a realized_by, or
  # (3) a label *and* arbitrary text separated by a comma:
  #
  #    (1) ci-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) do-000234, section 3.2, para 4 on pg 158

  my $label       = shift;
  my @realized_by = @{$lookup{$label}{'realized_by'}};
  my @lines       = ();

  if (@realized_by) {

    #-----------------------------------------------------------------
    # List extendives
    #
    my $is_first_row = 1;
    foreach my $realized_by (@realized_by) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $realized_by =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$realized_by = $1;
	$note        = $2;
      }

      #---------------------------------------------------------------
      # Determine this realized_by's title
      #
      my $realized_by_title = '';
      if ( label_exists($realized_by) ) {
	my $realized_by_string = "\\hyperref[$realized_by]{$realized_by}";
	my $title_string       = escape_latex( $lookup{$realized_by}{'title'} );
	$realized_by_title     = $realized_by_string . " - " . $title_string;
      } else {
	$realized_by_title = escape_latex($realized_by);
      }

      my $status             = status_of($realized_by) if label_exists($realized_by);
      my $realized_by_icon   = latex_status_icon_for($status);

      #---------------------------------------------------------------
      # assemble header
      #
      my $realized_by_header   = $EMPTY_STRING;
      $realized_by_header      = '\\textit{Extended By:}' if $is_first_row;
      $is_first_row = 0;
      $realized_by_priority    = '\\textit{priority:} ' . $realized_by_priority if $realized_by_priority;
      $realized_by_status      = '\\textit{status:} ' . $realized_by_status if $realized_by_status;

      #---------------------------------------------------------------
      # if there was a note, add after the title
      #
      if ($note) {
	$note = escape_latex($note);
	$realized_by_title = $realized_by_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate text
      #
      if ( label_exists($realized_by) ) {

	my $cell_1 = wrap("$realized_by_header");
	my $cell_2 = wrap("$realized_by_icon $realized_by_title");
	my $cell_3 = wrap("p. \\pageref{$realized_by}");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }

      else {

	my $cell_1 = wrap("$realized_by_header");
	my $cell_2 = wrap("$realized_by_title");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
      }


    }
  }
  return @lines;
}

######################################################################

sub latex_parents_of {

  my $label  = shift;
  my $parent = $lookup{$label}{'parent'};
  my $name   = name_for($label);
  my @lines  = ();

  if ($parent) {

    #-----------------------------------------------------------------
    # Walk up the parent tree to make a list of parents.
    #
    my @parents = ();
    my $current_item = $label;
    my $current_name = $name;
    while ($lookup{$current_item}{'parent'}) {
      my $parent = $lookup{$current_item}{'parent'};
      push @parents, $parent;
      $current_item = $parent;
    }

    #---------------------------------------------------------------
    # Now render a link to each ancestor
    #
    my $is_first_row = 1;
    foreach my $parent (reverse @parents) {
      my $parent_string   = "\\hyperref[$parent]{$parent}";
      my $title_string    = escape_latex($lookup{$parent}{'title'});
      my $parent_title    = $parent_string . " - " . $title_string;
      my $parent_priority = $lookup{$parent}{'priority'};
      my $parent_status   = status_of($parent) if label_exists($parent);
      my $parent_icon     = latex_status_icon_for($parent_status);
      my $parent_type     = $lookup{$parent}{'type'};

      my $parent_header   = $EMPTY_STRING;
      $parent_header      = '\\textit{Parents:}' if $is_first_row;
      $is_first_row = 0;

      $parent_priority    = '\\textit{priority:} ' . $parent_priority if $parent_priority;
      $parent_status      = '\\textit{status:} ' . $parent_status if $parent_status;

      #-------------------------------------------------------------
      # If this parent exists (has a title)...
      #
      if ($parent_title) {

	my $cell_1 = wrap("$parent_header");
	my $cell_2 = wrap("$parent_icon $parent_title");
	my $cell_3 = wrap("p. \\pageref{$parent}");

	#-----------------------------------------------------------
	# add the parent's title, priority, and status
	#
	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }
    }
  }
  return @lines;
}

######################################################################

sub latex_children_of {

  my $label    = shift;
  my @children = @{$lookup{$label}{'children'}};
  my @lines    = ();

  if (@children) {

    #-----------------------------------------------------------------
    # List children of this item
    #
    my $is_first_row = 1;
    foreach my $child (@children) {
      my $child_string   = "\\hyperref[$child]{$child}";
      my $title_string   = escape_latex($lookup{$child}{'title'});
      my $child_title    = $child_string . " - " . $title_string;
      my $child_priority = $lookup{$child}{'priority'};
      my $child_status   = status_of($child) if label_exists($child);
      my $child_icon     = latex_status_icon_for($child_status);
      my $child_type     = $lookup{$child}{'type'};

      my $child_header   = $EMPTY_STRING;
      $child_header      = '\\textit{Parts:}' if $is_first_row;
      $is_first_row      = 0;

      $child_priority    = '\\textit{priority:} ' . $child_priority if $child_priority;
      $child_status      = '\\textit{status:} ' . $child_status if $child_status;

      #-------------------------------------------------------------
      # If this child exists (has a title)...
      #
      if ($child_title) {

	my $cell_1 = wrap("$child_header");
	my $cell_2 = wrap("$child_icon $child_title");
	my $cell_3 = wrap("p. \\pageref{$child}");

	#-----------------------------------------------------------
	# add the child title, priority, and status
	#
	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }
    }
  }
  return @lines;
}

######################################################################

sub latex_depends_on {

  my $label      = shift;
  my @depends_on = @{$lookup{$label}{'depends_on'}};
  my @lines      = ();

  if (@depends_on) {

    #-----------------------------------------------------------------
    # List the 'depends_on' of this problem.
    #
    my $is_first_row = 1;
    foreach my $depends_on (@depends_on) {

      my $depends_on_string   = "\\hyperref[$depends_on]{$depends_on}";
      my $title_string        = escape_latex($lookup{$depends_on}{'title'});
      my $depends_on_title    = $depends_on_string . " - " . $title_string;
      my $depends_on_priority = $lookup{$depends_on}{'priority'};
      my $depends_on_type     = $lookup{$depends_on}{'type'};
      my $depends_on_status   = status_of($depends_on) if label_exists($depends_on);
      my $depends_on_icon     = latex_status_icon_for($depends_on_status);

      my $depends_on_header   = $EMPTY_STRING;
      $depends_on_header      = '\\textit{Depends On:}' if $is_first_row;
      $is_first_row = 0;

      $depends_on_priority    = '\\textit{priority:} ' . $depends_on_priority if $depends_on_priority;
      $depends_on_status      = '\\textit{status:} ' . $depends_on_status if $depends_on_status;

      #-------------------------------------------------------------
      # If this depends_on exists (has a title)...
      #
      if ($depends_on_title) {

	my $cell_1 = wrap("$depends_on_header");
	my $cell_2 = wrap("$depends_on_icon $depends_on_title");
	my $cell_3 = wrap("p. \\pageref{$depends_on}");

	#-----------------------------------------------------------
	# add the depends_on title, priority, and status
	#
	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }
    }
  }
  return @lines;
}

######################################################################

sub latex_required_by {

  my $label       = shift;
  my @required_by = @{$lookup{$label}{'required_by'}};
  my @lines       = ();

  if (@required_by) {

    #-----------------------------------------------------------------
    # List items that require this one.
    #
    my $is_first_row = 1;
    foreach my $required_by (@required_by) {

      my $required_by_string   = "\\hyperref[$required_by]{$required_by}";
      my $title_string         = escape_latex($lookup{$required_by}{'title'});
      my $required_by_title    = $required_by_string . " - " . $title_string;
      my $required_by_priority = $lookup{$required_by}{'priority'};
      my $required_by_type     = $lookup{$required_by}{'type'};
      my $required_by_status   = status_of($required_by) if label_exists($required_by);
      my $required_by_icon     = latex_status_icon_for($required_by_status);

      my $required_by_header   = $EMPTY_STRING;
      $required_by_header      = '\\textit{Required By:}' if $is_first_row;
      $is_first_row = 0;

      $required_by_priority    = '\\textit{priority:} ' . $required_by_priority if $required_by_priority;
      $required_by_status      = '\\textit{status:} ' . $required_by_status if $required_by_status;

      #-------------------------------------------------------------
      # If this required_by exists (has a title)...
      #
      if ($required_by_title) {

	my $cell_1 = wrap("$required_by_header");
	my $cell_2 = wrap("$required_by_icon $required_by_title");
	my $cell_3 = wrap("p. \\pageref{$required_by}");

	#-----------------------------------------------------------
	# add the required_by title, priority, and status
	#
	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }
    }
  }
  return @lines;
}

######################################################################

sub latex_derived_from {

  # Generate latex lines listing items from which this one is derived.

  my $label        = shift;
  my @derived_from = @{$lookup{$label}{'derived_from'}};
  my @lines        = ();

  foreach my $derived_from (@derived_from) {

    #---------------------------------------------------------------
    # Now render a link to each ancestor
    #
    my $is_first_row = 1;

    my $derived_from_string   = "\\hyperref[$derived_from]{$derived_from}";
    my $title_string          = escape_latex($lookup{$derived_from}{'title'});
    my $derived_from_title    = $derived_from_string . " - " . $title_string;
    my $derived_from_priority = $lookup{$derived_from}{'priority'};
    my $derived_from_status   = status_of($derived_from) if label_exists($derived_from);
    my $derived_from_icon     = latex_status_icon_for($derived_from_status);
    my $derived_from_type     = $lookup{$derived_from}{'type'};

    my $derived_from_header   = $EMPTY_STRING;
    $derived_from_header      = '\\textit{Derived From:}' if $is_first_row;
    $is_first_row = 0;

    $derived_from_priority    = '\\textit{priority:} ' . $derived_from_priority if $derived_from_priority;
    $derived_from_status      = '\\textit{status:} ' . $derived_from_status if $derived_from_status;

    #-------------------------------------------------------------
    # If this derived_from exists (has a title)...
    #
    if ($derived_from_title) {

      my $cell_1 = wrap("$derived_from_header");
      my $cell_2 = wrap("$derived_from_icon $derived_from_title");
      my $cell_3 = wrap("p. \\pageref{$derived_from}");

      #-----------------------------------------------------------
      # add the derived_from's title, priority, and status
      #
      push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
    }
  }
  return @lines;
}

######################################################################

sub latex_derived {

  # Generate latex lines listing items derived from this one.

  my $label   = shift;
  my @derived = @{$lookup{$label}{'derived'}};
  my @lines   = ();

  if (@derived) {

    #-----------------------------------------------------------------
    # List items derived from this one.
    #
    my $is_first_row = 1;
    foreach my $derived (@derived) {
      my $derived_string   = "\\hyperref[$derived]{$derived}";
      my $title_string     = escape_latex($lookup{$derived}{'title'});
      my $derived_title    = $derived_string . " - " . $title_string;
      my $derived_priority = $lookup{$derived}{'priority'};
      my $derived_status   = status_of($derived) if label_exists($derived);
      my $derived_icon     = latex_status_icon_for($derived_status);
      my $derived_type     = $lookup{$derived}{'type'};

      my $derived_header   = $EMPTY_STRING;
      $derived_header      = '\\textit{Derived:}' if $is_first_row;
      $is_first_row = 0;

      $derived_priority    = '\\textit{priority:} ' . $derived_priority if $derived_priority;
      $derived_status      = '\\textit{status:} ' . $derived_status if $derived_status;

      #-------------------------------------------------------------
      # If this derived exists (has a title)...
      #
      if ($derived_title) {

	my $cell_1 = wrap("$derived_header");
	my $cell_2 = wrap("$derived_icon $derived_title");
	my $cell_3 = wrap("p. \\pageref{$derived}");

	#-----------------------------------------------------------
	# add the derived title, priority, and status
	#
	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }
    }
  }
  return @lines;
}

######################################################################

sub latex_instance_of {

  my $label       = shift;
  my @instance_of = @{$lookup{$label}{'instance_of'}};
  my @lines       = ();

  if (@instance_of) {

    #-----------------------------------------------------------------
    # List items for which this is an instance
    #
    my $is_first_row = 1;
    foreach my $instance_of (@instance_of) {
      my $instance_of_string   = "\\hyperref[$instance_of]{$instance_of}";
      my $title_string         = escape_latex($lookup{$instance_of}{'title'});
      my $instance_of_title    = $instance_of_string . " - " . $title_string;
      my $instance_of_priority = $lookup{$instance_of}{'priority'};
      my $instance_of_status   = status_of($instance_of) if label_exists($instance_of);
      my $instance_of_icon     = latex_status_icon_for($instance_of_status);
      my $instance_of_type     = $lookup{$instance_of}{'type'};

      my $instance_of_header   = $EMPTY_STRING;
      $instance_of_header      = '\\textit{Instance Of:}' if $is_first_row;
      $is_first_row = 0;

      $instance_of_priority    = '\\textit{priority:} ' . $instance_of_priority if $instance_of_priority;
      $instance_of_status      = '\\textit{status:} ' . $instance_of_status if $instance_of_status;

      #-------------------------------------------------------------
      # If this instance_of exists (has a title)...
      #
      if ($instance_of_title) {

	my $cell_1 = wrap("$instance_of_header");
	my $cell_2 = wrap("$instance_of_icon $instance_of_title");
	my $cell_3 = wrap("p. \\pageref{$instance_of}");

	#-----------------------------------------------------------
	# add the instance_of title, priority, and status
	#
	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }
    }
  }
  return @lines;
}

######################################################################

sub latex_class_of {

  my $label    = shift;
  my @class_of = @{$lookup{$label}{'class_of'}};
  my @lines    = ();

  if (@class_of) {

    #-----------------------------------------------------------------
    # List items for which this is a class of (super-class)
    #
    my $is_first_row = 1;
    foreach my $class_of (@class_of) {
      my $class_of_string   = "\\hyperref[$class_of]{$class_of}";
      my $title_string      = escape_latex($lookup{$class_of}{'title'});
      my $class_of_title    = $class_of_string . " - " . $title_string;
      my $class_of_priority = $lookup{$class_of}{'priority'};
      my $class_of_status   = status_of($class_of) if label_exists($class_of);
      my $class_of_icon     = latex_status_icon_for($class_of_status);
      my $class_of_type     = $lookup{$class_of}{'type'};

      my $class_of_header   = $EMPTY_STRING;
      $class_of_header      = '\\textit{Class Of:}' if $is_first_row;
      $is_first_row = 0;

      $class_of_priority    = '\\textit{priority:} ' . $class_of_priority if $class_of_priority;
      $class_of_status      = '\\textit{status:} ' . $class_of_status if $class_of_status;

      #-------------------------------------------------------------
      # If this class_of exists (has a title)...
      #
      if ($class_of_title) {

	my $cell_1 = wrap("$class_of_header");
	my $cell_2 = wrap("$class_of_icon $class_of_title");
	my $cell_3 = wrap("p. \\pageref{$class_of}");

	#-----------------------------------------------------------
	# add the class_of title, priority, and status
	#
	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }
    }
  }
  return @lines;
}

######################################################################

sub latex_generalizes {

  my $label    = shift;
  my @generalizes = @{$lookup{$label}{'generalizes'}};
  my @lines    = ();

  if (@generalizes) {

    #-----------------------------------------------------------------
    # List items for which this is a class of (super-class)
    #
    my $is_first_row = 1;
    foreach my $generalizes (@generalizes) {
      my $generalizes_string   = "\\hyperref[$generalizes]{$generalizes}";
      my $title_string      = escape_latex($lookup{$generalizes}{'title'});
      my $generalizes_title    = $generalizes_string . " - " . $title_string;
      my $generalizes_priority = $lookup{$generalizes}{'priority'};
      my $generalizes_status   = status_of($generalizes) if label_exists($generalizes);
      my $generalizes_icon     = latex_status_icon_for($generalizes_status);
      my $generalizes_type     = $lookup{$generalizes}{'type'};

      my $generalizes_header   = $EMPTY_STRING;
      $generalizes_header      = '\\textit{Generalizes:}' if $is_first_row;
      $is_first_row = 0;

      $generalizes_priority    = '\\textit{priority:} ' . $generalizes_priority if $generalizes_priority;
      $generalizes_status      = '\\textit{status:} ' . $generalizes_status if $generalizes_status;

      #-------------------------------------------------------------
      # If this generalizes exists (has a title)...
      #
      if ($generalizes_title) {

	my $cell_1 = wrap("$generalizes_header");
	my $cell_2 = wrap("$generalizes_icon $generalizes_title");
	my $cell_3 = wrap("p. \\pageref{$generalizes}");

	#-----------------------------------------------------------
	# add the generalizes title, priority, and status
	#
	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }
    }
  }
  return @lines;
}

######################################################################

sub latex_specializes {

  my $label    = shift;
  my @specializes = @{$lookup{$label}{'specializes'}};
  my @lines    = ();

  if (@specializes) {

    #-----------------------------------------------------------------
    # List items for which this is a class of (super-class)
    #
    my $is_first_row = 1;
    foreach my $specializes (@specializes) {
      my $specializes_string   = "\\hyperref[$specializes]{$specializes}";
      my $title_string      = escape_latex($lookup{$specializes}{'title'});
      my $specializes_title    = $specializes_string . " - " . $title_string;
      my $specializes_priority = $lookup{$specializes}{'priority'};
      my $specializes_status   = status_of($specializes) if label_exists($specializes);
      my $specializes_icon     = latex_status_icon_for($specializes_status);
      my $specializes_type     = $lookup{$specializes}{'type'};

      my $specializes_header   = $EMPTY_STRING;
      $specializes_header      = '\\textit{Specializes:}' if $is_first_row;
      $is_first_row = 0;

      $specializes_priority    = '\\textit{priority:} ' . $specializes_priority if $specializes_priority;
      $specializes_status      = '\\textit{status:} ' . $specializes_status if $specializes_status;

      #-------------------------------------------------------------
      # If this specializes exists (has a title)...
      #
      if ($specializes_title) {

	my $cell_1 = wrap("$specializes_header");
	my $cell_2 = wrap("$specializes_icon $specializes_title");
	my $cell_3 = wrap("p. \\pageref{$specializes}");

	#-----------------------------------------------------------
	# add the specializes title, priority, and status
	#
	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }
    }
  }
  return @lines;
}

######################################################################

sub latex_problems_for {

  my $label    = shift;
  my @problems = ();
  if ( ref $lookup{$label}{'problem'} eq 'ARRAY' ) {
    @problems = @{$lookup{$label}{'problem'}};
  } elsif ($lookup{$label}{'problem'}) {
    push @problems, $lookup{$label}{'problem'};
  }

  my @lines    = ();

  if (@problems) {

    #-----------------------------------------------------------------
    # list of problems
    #
    my $is_first_row = 1;
    foreach my $problem (sort by_doc_order @problems) {

      my $problem_string   = "\\hyperref[$problem]{$problem}";
      my $title_string     = escape_latex($lookup{$problem}{'title'});
      my $problem_title    = $problem_string . " - " . $title_string;
      my $problem_priority = $lookup{$problem}{'priority'};
      my $problem_status   = status_of($problem) if label_exists($problem);
      my $problem_icon     = latex_status_icon_for($problem_status);
      my $problem_type     = $lookup{$problem}{'type'};

      my $problem_header   = $EMPTY_STRING;
      $problem_header      = '\\textit{Problems:}' if $is_first_row;
      $is_first_row = 0;

      $problem_priority    = '\\textit{priority:} ' . $problem_priority if $problem_priority;
      $problem_status      = '\\textit{status:} ' . $problem_status if $problem_status;

      #-------------------------------------------------------------
      # If this problem exists (has a title)...
      #
      if ($problem_title) {

	my $cell_1 = wrap("$problem_header");
	my $cell_2 = wrap("$problem_icon $problem_title");
	my $cell_3 = wrap("p. \\pageref{$problem}");

	#-----------------------------------------------------------
	# add the problem title, priority, and status
	#
	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }
    }
  }
  return @lines;
}

######################################################################

sub latex_solutions_for {

  # Each 'solution' may be (1) a label that identifies an item in the
  # document, (2) arbitrary text that describes a solution, or (3) a
  # label *and* arbitrary text separated by a comma:
  #
  #    (1) ci-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) do-000234, section 3.2, para 4 on pg 158

  my $label     = shift;
  my @solutions = ();
  if ( ref $lookup{$label}{'solution'} eq 'ARRAY' ) {
    @solutions = @{$lookup{$label}{'solution'}};
  } elsif ($lookup{$label}{'solution'}) {
    push @solutions, $lookup{$label}{'solution'};
  }

  my @lines     = ();

  if (@solutions) {

    #-----------------------------------------------------------------
    # List solutions
    #
    my $is_first_row = 1;
    foreach my $solution (sort by_doc_order @solutions) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $solution =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$solution = $1;
	$note     = $2;
      }

      #---------------------------------------------------------------
      # Determine this solution's title
      #
      my $solution_title = '';
      if ( label_exists($solution) ) {
	my $solution_string = "\\hyperref[$solution]{$solution}";
	my $title_string    = escape_latex( $lookup{$solution}{'title'} );
	$solution_title     = $solution_string . " - " . $title_string;
      } else {
	$solution_title = escape_latex($solution);
      }

      #---------------------------------------------------------------
      # Determine this solution's priority
      #
      my $solution_priority = '';
      if ( label_exists($solution) ) {
	$solution_priority = $lookup{$solution}{'priority'};
      }

      #---------------------------------------------------------------
      # Determine this solution's status
      #
      my $solution_status = '';
      if ( label_exists($solution) ) {
	$solution_status = status_of($solution) if label_exists($solution);
      } else {
	$solution_status = 'grey';
      }
      my $solution_icon = latex_status_icon_for($solution_status);

      #---------------------------------------------------------------
      # assemble header
      #
      my $solution_header   = $EMPTY_STRING;
      $solution_header      = '\\textit{Solutions:}' if $is_first_row;
      $is_first_row = 0;

      $solution_priority    = '\\textit{priority:} ' . $solution_priority if $solution_priority;
      $solution_status      = '\\textit{status:} ' . $solution_status if $solution_status;

      #---------------------------------------------------------------
      # if there was a note, add after the title
      #
      if ($note) {
	$note = escape_latex($note);
	$solution_title = $solution_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate text
      #
      if ( label_exists($solution) ) {

	my $cell_1 = wrap("$solution_header");
	my $cell_2 = wrap("$solution_icon $solution_title");
	my $cell_3 = wrap("p. \\pageref{$solution}");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }

      else {

	my $cell_1 = wrap("$solution_header");
	my $cell_2 = wrap("$solution_icon $solution_title");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
      }
    }
  }
  return @lines;
}

######################################################################

sub latex_allocations_for {

  # Each 'allocation' may be (1) a label that identifies an item in the
  # document, (2) arbitrary text that describes a allocation, or (3) a
  # label *and* arbitrary text separated by a comma:
  #
  #    (1) ci-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) do-000234, section 3.2, para 4 on pg 158

  my $label       = shift;
  my @allocations = @{$lookup{$label}{'allocation'}};
  my @lines       = ();

  if (@allocations) {

    #-----------------------------------------------------------------
    # List allocations
    #
    my $is_first_row = 1;
    foreach my $allocation (@allocations) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $allocation =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$allocation = $1;
	$note     = $2;
      }

      #---------------------------------------------------------------
      # Determine this allocation's title
      #
      my $allocation_title = '';
      if ( label_exists($allocation) ) {
	my $allocation_string = "\\hyperref[$allocation]{$allocation}";
	my $title_string    = escape_latex( $lookup{$allocation}{'title'} );
	$allocation_title     = $allocation_string . " - " . $title_string;
      } else {
	$allocation_title = escape_latex($allocation);
      }

      #---------------------------------------------------------------
      # Determine this allocation's priority
      #
      my $allocation_priority = '';
      if ( label_exists($allocation) ) {
	$allocation_priority = $lookup{$allocation}{'priority'};
      }

      #---------------------------------------------------------------
      # Determine this allocation's status
      #
      my $allocation_status = '';
      if ( label_exists($allocation) ) {
	$allocation_status = status_of($allocation) if label_exists($allocation);
      } else {
	$allocation_status = 'grey';
      }
      my $allocation_icon = latex_status_icon_for($allocation_status);

      #---------------------------------------------------------------
      # assemble header
      #
      my $allocation_header   = $EMPTY_STRING;
      $allocation_header      = '\\textit{Allocations:}' if $is_first_row;
      $is_first_row = 0;

      $allocation_priority    = '\\textit{priority:} ' . $allocation_priority if $allocation_priority;
      $allocation_status      = '\\textit{status:} ' . $allocation_status if $allocation_status;

      #---------------------------------------------------------------
      # if there was a note, add after the title
      #
      if ($note) {
	$note = escape_latex($note);
	$allocation_title = $allocation_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate text
      #
      if ( label_exists($allocation) ) {

	my $cell_1 = wrap("$allocation_header");
	my $cell_2 = wrap("$allocation_icon $allocation_title");
	my $cell_3 = wrap("p. \\pageref{$allocation}");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }

      else {

	my $cell_1 = wrap("$allocation_header");
	my $cell_2 = wrap("$allocation_icon $allocation_title");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
      }
    }
  }
  return @lines;
}

######################################################################

sub latex_assignments_for {

  # Each 'assignment' may be (1) a label that identifies an item in the
  # document, (2) arbitrary text that describes a assignment, or (3) a
  # label *and* arbitrary text separated by a comma:
  #
  #    (1) ci-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) do-000234, section 3.2, para 4 on pg 158

  my $label       = shift;
  my @assignments = @{$lookup{$label}{'assignment'}};
  my @lines       = ();

  if (@assignments) {

    #-----------------------------------------------------------------
    # List assignments
    #
    my $is_first_row = 1;
    foreach my $assignment (@assignments) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $assignment =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$assignment = $1;
	$note     = $2;
      }

      #---------------------------------------------------------------
      # Determine this assignment's title
      #
      my $assignment_title = '';
      if ( label_exists($assignment) ) {
	my $assignment_string = "\\hyperref[$assignment]{$assignment}";
	my $title_string    = escape_latex( $lookup{$assignment}{'title'} );
	$assignment_title     = $assignment_string . " - " . $title_string;
      } else {
	$assignment_title = escape_latex($assignment);
      }

      #---------------------------------------------------------------
      # Determine this assignment's priority
      #
      my $assignment_priority = '';
      if ( label_exists($assignment) ) {
	$assignment_priority = $lookup{$assignment}{'priority'};
      }

      #---------------------------------------------------------------
      # Determine this assignment's status
      #
      my $assignment_status = '';
      if ( label_exists($assignment) ) {
	$assignment_status = status_of($assignment) if label_exists($assignment);
      } else {
	$assignment_status = 'grey';
      }
      my $assignment_icon = latex_status_icon_for($assignment_status);

      #---------------------------------------------------------------
      # assemble header
      #
      my $assignment_header   = $EMPTY_STRING;
      $assignment_header      = '\\textit{Assignments:}' if $is_first_row;
      $is_first_row = 0;

      $assignment_priority    = '\\textit{priority:} ' . $assignment_priority if $assignment_priority;
      $assignment_status      = '\\textit{status:} ' . $assignment_status if $assignment_status;

      #---------------------------------------------------------------
      # if there was a note, add after the title
      #
      if ($note) {
	$note = escape_latex($note);
	$assignment_title = $assignment_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate text
      #
      if ( label_exists($assignment) ) {

	my $cell_1 = wrap("$assignment_header");
	my $cell_2 = wrap("$assignment_icon $assignment_title");
	my $cell_3 = wrap("p. \\pageref{$assignment}");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }

      else {

	my $cell_1 = wrap("$assignment_header");
	my $cell_2 = wrap("$assignment_icon $assignment_title");

	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&

\\\\

END_OF_TEXT
      }
    }
  }
  return @lines;
}

######################################################################

sub latex_tests_for {

  my $label = shift;
  my @tests = @{$lookup{$label}{'test'}};
  my @lines = ();

  if (@tests) {

    #-----------------------------------------------------------------
    # List tests associated with this problem
    #
    my $is_first_row = 1;
    foreach my $test (@tests) {
      my $test_string   = "\\hyperref[$test]{$test}";
      my $title_string  = escape_latex( $lookup{$test}{'title'} );
      my $test_title    = $test_string . " - " . $title_string;
      my $test_priority = $lookup{$test}{'priority'};
      my $test_status   = status_of($test) if label_exists($test);
      my $test_icon     = latex_status_icon_for($test_status);
      my $test_type     = $lookup{$test}{'type'};
      my $test_header   = $EMPTY_STRING;
      $test_header      = '\\textit{Tests:}' if $is_first_row;
      $is_first_row     = 0;

      $test_priority    = '\\textit{priority:} ' . $test_priority if $test_priority;
      $test_status      = '\\textit{status:} ' . $test_status if $test_status;

      #-------------------------------------------------------------
      # If this test exists (has a title)...
      #
      if ($test_title) {

	my $cell_1 = wrap("$test_header");
	my $cell_2 = wrap("$test_icon $test_title");
	my $cell_3 = wrap("p. \\pageref{$test}");

	#-----------------------------------------------------------
	# add the test title, priority, and status
	#
	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }
    }
  }
  return @lines;
}

######################################################################

sub latex_tasks_for {

  my $label = shift;
  my @tasks = @{$lookup{$label}{'task'}};
  my @lines = ();

  if (@tasks) {

    #-----------------------------------------------------------------
    # List tasks associated with this problem
    #
    my $is_first_row = 1;
    foreach my $task (@tasks) {
      my $task_string   = "\\hyperref[$task]{$task}";
      my $title_string  = escape_latex( $lookup{$task}{'title'} );
      my $task_title    = $task_string . " - " . $title_string;
      my $task_priority = $lookup{$task}{'priority'};
      my $task_status   = status_of($task) if label_exists($task);
      my $task_icon     = latex_status_icon_for($task_status);
      my $task_type     = $lookup{$task}{'type'};
      my $task_header   = $EMPTY_STRING;
      $task_header      = '\\textit{Tasks:}' if $is_first_row;
      $is_first_row     = 0;

      #-------------------------------------------------------------
      # If this task exists (has a title)...
      #
      if ($task_title) {

	my $cell_1 = wrap("$task_header");
	my $cell_2 = wrap("$task_icon $task_title");
	my $cell_3 = wrap("p. \\pageref{$task}");

	#-----------------------------------------------------------
	# add the task title, priority, and status
	#
	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }
    }
  }
  return @lines;
}

######################################################################
#
# !!! BUG HERE !!!
#
# This subroutine confuses results and outcomes.
#

# sub latex_results_for {

#   my $label = shift;
#   my @lines = ();
#   my @dates = keys %{ $outcomes{$label} };

#   foreach my $date (@dates) {

#     my $status        = $outcomes{$label}{$date}{'status'};
#     my $source        = $outcomes{$label}{$date}{'source'};
#     my $icon          = latex_status_icon_for($status);
#     my $method        = $status{$label}{'source'};
#     my $description   = $outcomes{$label}{$date}{'description'};

#     if ($status and $source) {

#       my $string  = escape_latex("$status: ($date, [id:$source]) $description");

#       my $cell_1 = "\\textit{Result:}";
#       my $cell_2 = wrap("$icon $string");

#       push @lines, <<"END_OF_TEXT";
# $cell_1
# &
# $cell_2
# &

# \\\\

# END_OF_TEXT
#     }
#   }

#   return @lines;
# }

######################################################################

sub latex_results_for {

  my $label   = shift;
  my @results = @{$lookup{$label}{'result'}};
  my @lines   = ();

  if (@results) {

    #-----------------------------------------------------------------
    # list of results
    #
    my $is_first_row = 1;
    foreach my $result (@results) {

      my $result_string   = "\\hyperref[$result]{$result}";
      my $title_string    = escape_latex($lookup{$result}{'title'});
      my $result_title    = $result_string . " - " . $title_string;
      my $result_priority = $lookup{$result}{'priority'};
      my $result_status   = status_of($result) if label_exists($result);
      my $result_icon     = latex_status_icon_for($result_status);
      my $result_type     = $lookup{$result}{'type'};

      my $result_header   = $EMPTY_STRING;
      $result_header      = '\\textit{Results:}' if $is_first_row;
      $is_first_row = 0;

      $result_priority    = '\\textit{priority:} ' . $result_priority if $result_priority;
      $result_status      = '\\textit{status:} ' . $result_status if $result_status;

      #-------------------------------------------------------------
      # If this result exists (has a title)...
      #
      if ($result_title) {

	my $cell_1 = wrap("$result_header");
	my $cell_2 = wrap("$result_icon $result_title");
	my $cell_3 = wrap("p. \\pageref{$result}");

	#-----------------------------------------------------------
	# add the result title, priority, and status
	#
	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }
    }
  }
  return @lines;
}

# ######################################################################

# sub latex_roles_for {

#   my $label   = shift;
#   my @roles = @{$lookup{$label}{'role'}};
#   my @lines   = ();

#   if (@roles) {

#     #-----------------------------------------------------------------
#     # List roles associated with this problem
#     #
#     my $is_first_row = 1;
#     foreach my $role (@roles) {
#       my $role_string   = "\\hyperref[$role]{$role}";
#       my $title_string  = escape_latex( $lookup{$role}{'title'} );
#       my $role_title    = $role_string . " - " . $title_string;
#       my $role_priority = $lookup{$role}{'priority'};
#       my $role_status   = status_of($role) if label_exists($role);
#       my $role_type     = $lookup{$role}{'type'};
#       my $role_header   = $EMPTY_STRING;
#       $role_header      = '\\textit{Roles:}' if $is_first_row;
#       $is_first_row     = 0;

#       #-------------------------------------------------------------
#       # If this role exists (has a title)...
#       #
#       if ($role_title) {

# 	#-----------------------------------------------------------
# 	# add the role title, priority, and status
# 	#
# 	push @lines, <<"END_OF_TEXT";
# $role_header
# &
# $role_title
# &
# p. \\pageref{$role}
# \\\\

# END_OF_TEXT
#       }
#     }
#   }
#   return @lines;
# }

######################################################################

sub latex_associates_of {

  my $label      = shift;
  my @associates = @{$lookup{$label}{'associated'}};
  my @lines      = ();

  if (@associates) {

    #-----------------------------------------------------------------
    # List other things associated with this problem
    #
    my $is_first_row = 1;
    foreach my $associate (@associates) {
      my $associate_string = "\\hyperref[$associate]{$associate}";
      my $associate_status = status_of($associate) if label_exists($associate);
      my $associate_icon   = latex_status_icon_for($associate_status);
      my $title_string     = escape_latex( $lookup{$associate}{'title'} );
      my $associate_title  = $associate_string . " - " . $title_string;
      my $associate_header = $EMPTY_STRING;
      $associate_header    = '\\textit{Associated:}' if $is_first_row;
      $is_first_row        = 0;

      #-------------------------------------------------------------
      # If this associate exists (has a title)...
      #
      if ($associate_title) {

	my $cell_1 = wrap("$associate_header");
	my $cell_2 = wrap("$associate_icon $associate_title");
	my $cell_3 = wrap("p. \\pageref{$associate}");

	#-----------------------------------------------------------
	# add the associate title, priority, and status
	#
	push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
      }
    }
  }
  return @lines;
}

######################################################################

sub latex_rel_component_for {

  my $label         = shift;
  my $rel_component = $lookup{$label}{'rel_component'};
  my @lines      = ();

  if ($rel_component) {

    my $string = "\\hyperref[$rel_component]{$rel_component}";
    my $status = status_of($rel_component) if label_exists($rel_component);
    my $icon   = latex_status_icon_for($status);
    my $title_string     = escape_latex( $lookup{$rel_component}{'title'} );
    my $title  = $string . " - " . $title_string;
    my $header = '\\textit{Releaseable Component:}';

    #-------------------------------------------------------------
    # If this releasable component exists (has a title)...
    #
    if ($title) {

      my $cell_1 = wrap("$header");
      my $cell_2 = wrap("$icon $title");
      my $cell_3 = wrap("p. \\pageref{$rel_component}");

      #-----------------------------------------------------------
      # add the releaseable component title, priority, and status
      #
      push @lines, <<"END_OF_TEXT";
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
    }
  }
  return @lines;
}

######################################################################

sub latex_requests_for {

  my $label    = shift;
  my @requests = @{$lookup{$label}{'request'}};
  my @lines    = ();

  if (@requests) {
    my $requests = escape_latex( join(', ', @requests) );

    my $cell_2 = wrap("$requests");

    push @lines, <<"END_OF_TEXT";
\\textit{Requests:}
&
$cell_2
&

\\\\

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub latex_attributes_of {

  my $label = shift;
  my %attrs = %{$attribute{$label}};
  my @lines = ();

  if (%attrs) {
    foreach my $key (sort keys %attrs) {
      my @value = @{ $attribute{$label}{$key} };
      foreach my $value (@value) {
	my $key_string   = escape_latex($key);
	my $value_string = escape_latex($value);

	my $cell_2 = wrap("$value_string");

	push @lines, <<"END_OF_TEXT";
\\textit{$key_string:}
&
$cell_2
&

\\\\

END_OF_TEXT
      }
    }
  }
  return @lines;
}

######################################################################

sub latex_outcomes_for {

  my $label = shift;
  my @lines = ();

  # make a list of outcomes from the %results datastructure
  #
  my @outcomes = ();
  foreach my $item (sort keys %results ) {
    foreach my $date (sort keys %{ $outcomes{$item} }) {
      my $source = $outcomes{$item}{$date}{'source'};
      if ($source eq $label) {
	my $status      = $outcomes{$item}{$date}{'status'};
	my $description = $outcomes{$item}{$date}{'description'};
	push @outcomes, ["$item","$date","$status","$description"];
      }
    }
  }

  if (@outcomes) {

    #-----------------------------------------------------------------
    # Begin a table for outcomes
    #
    push @lines, <<"END_OF_TEXT";
%% begin longtable
%%
\\setlength{\\tablewidth}{\\textwidth}
\\setlength{\\extrarowheight}{4pt}
\\setlength{\\LTcapwidth}{\\hsize}
\\begin{longtable}[c]{%
\@{}
>{\\small\\raggedright\\arraybackslash}p{0.28\\tablewidth}
>{\\small\\raggedright\\arraybackslash}p{0.48\\tablewidth}
>{\\small\\raggedright\\arraybackslash}p{0.08\\tablewidth}
\@{}
}
\\caption[]{}
\\tabularnewline
\\endfirsthead
\\caption[]{}
\\tabularnewline
\\endhead
\\tabularnewline
\\endfoot
\\endlastfoot

%% begin table row
%%
\\textbf{Item}
&
\\textbf{Description}
&
\\textbf{Outcome}
\\\\

END_OF_TEXT

    #-----------------------------------------------------------------
    # Render a table row for each individual outcome
    #
    foreach my $outcome (@outcomes) {

      my $item        = $outcome->[0];
      my $date        = $outcome->[1];
      my $status      = $outcome->[2];
      my $description = escape_latex( $outcome->[3] );
      my $key         = name_for($item);
      my $title       = escape_latex($lookup{$item}{'title'});
      $item           = "[id:" . $item . "]";
      $item           = escape_latex($item);

      my $cell_1 = wrap("\\small $key $item: $title");
      my $cell_2 = wrap("\\small $description");
      my $cell_3 = wrap("\\multicolumn{1}{>{\\small\\raggedright\\columncolor{bg-${status}}}p{0.1000\\tablewidth}}{\\small $status $date}");

      push @lines, <<"END_OF_TEXT";
%% begin table row
%%
$cell_1
&
$cell_2
&
$cell_3
\\\\

END_OF_TEXT
    }

    #-----------------------------------------------------------------
    # End the table for outcomes
    #
    push @lines, <<"END_OF_TEXT";
\\end{longtable}
%%
%% end table (end_table sub)

END_OF_TEXT

  }

  return @lines;
}

######################################################################

sub latex_product_of {

  my $label   = shift;
  my $product = escape_latex($lookup{$label}{'product'});
  my @lines   = ();

  if ($product) {

    my $cell_2 = wrap("$product");

    push @lines, <<"END_OF_TEXT";
\\textit{Product:}
&
$cell_2
&

\\\\

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub latex_footer_for {

  # End the meta-data table.

  my $label = shift;
  my @lines = ();

  push @lines, <<"END_OF_TEXT";
\\end{longtable}

END_OF_TEXT

  return @lines;
}

######################################################################

sub html_header_for {

  my $label         = shift;
  my $name          = name_for($label);
  my $ucname        = uc $name;
  my $ucfname       = ucfirst $name;
  my $number        = $label{$label}{'number'};
  my $outfile       = html_outfile_for_label($label);
  my $anchor        = "$label";
  my $title         = escape_html($lookup{$label}{'title'});
  my $description   = escape_html($lookup{$label}{'description'});
  my @lines         = ();
#  my $text          = wrap("<p><span class=\"req_title\">$label - $title</span> - $description</p>");
  my $text          = "<p><span class=\"req_title\">$label - $title</span> - $description</p>";
  my $status        = status_of($label) if label_exists($label);
  my $status_icon   = html_status_icon_for($status);
  my $priority      = $lookup{$label}{'priority'} || 'low';
  my $priority_icon = html_priority_icon_for($priority);
  my @type          = @{ $lookup{$label}{'type'} };
  my $type          = join(', ',@type);
  my $date          = $lookup{$label}{'date'};
  my $author        = $lookup{$label}{'author'};
  $author           = strip_revision_control_keyword_chars($author);
  $author           = escape_html($author);
  my $revision      = $lookup{$label}{'revision'};

  # normalize date
  #
  if ($date =~ /\((.*?)\)/) {
    $date = $1;
  }

  push @lines, <<"END_OF_TEXT";
<a name="$ucfname.$number">
<a name="$label">

<!-- ==================== BEGIN $ucname  ====================== -->
<div class="$name">

$text

<table width="95%" border="0" cellspacing="2" cellpadding="2" class="metadata">
<tr>
<td><i>ID:</i></td>
<td><i>Priority:</i></td>
<td><i>Status:</i></td>
<td><i>Type:</i></td>
<td><i>Last Modified:</i></td>
<td><i>By:</i></td>
<td><i>Changeset:</i></td>
</tr>
<tr>
<td>$label</td>
<td>$priority_icon &nbsp; $priority</td>
<td>$status_icon &nbsp; $status</td>
<td>$type</td>
<td>$date</td>
<td>$author</td>
<td>$revision</td>
</tr>
</table>

<table width="90%" border="0" cellspacing="4" cellpadding="2">

END_OF_TEXT

  return @lines;
}

######################################################################

sub html_label_for {

  my $label = shift;
  my @lines = ();

  if ($label and not $option{'hide_ids'}) {
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">ID:</td>
<td width="85%" class="req_individual">$label</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_revision_for {

  my $label    = shift;
  my $revision = $lookup{$label}{'revision'};
  my @lines    = ();

  if ($revision =~ /\$Revision:\s*(\d+)\s*\$/) {
    $revision = $1;
  }

  if ($revision) {

    $revision = trim_whitespace($revision);

    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Revision:</td>
<td width="85%" class="req_individual"><a href="$html_changelog_file#$revision">$revision</a></td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_date_for {

  my $label = shift;
  my $date  = $lookup{$label}{'date'};
  my @lines = ();

  if ($date) {
    my $block = wrap("<td width=\"85%\" class=\"req_individual\">$date</td>");
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Date:</td>
$block
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_author_for {

  my $label  = shift;
  my $author = $lookup{$label}{'author'};
  $author    = strip_revision_control_keyword_chars($author);
  $author    = escape_html($author);
  my @lines  = ();

  if ($author) {
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Author:</td>
<td width="85%" class="req_individual">$author</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_types_for {

  my $label = shift;
  my @types = @{$lookup{$label}{'type'}};
  my @lines = ();

  if (@types) {
    my @text = ();
    foreach my $type (@types) {
      my $text = escape_html($type);
      push @text, $type;
    }
    my $string = join(', ', @text);
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Type:</td>
<td width="85%" class="req_individual">$string</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_pros_for {

  my $label = shift;
  my @pros  = @{$lookup{$label}{'pro'}};
  my @lines = ();

  if (@pros) {
    my @text = ();
    foreach my $pro (@pros) {
      my $text = escape_html($pro);
      push @text, $pro;
    }
    my $string = join(', ', @text);
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Pros:</td>
<td width="85%" class="req_individual">$string</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_cons_for {

  my $label = shift;
  my @cons  = @{$lookup{$label}{'con'}};
  my @lines = ();

  if (@cons) {
    my @text = ();
    foreach my $con (@cons) {
      my $text = escape_html($con);
      push @text, $con;
    }
    my $string = join(', ', @text);
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Cons:</td>
<td width="85%" class="req_individual">$string</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_priority_for {

  my $label    = shift;
  my $priority = $lookup{$label}{'priority'};
  my @lines    = ();

  if ($priority) {
    my $bgcolor = html_cell_bgcolor_for($priority);
    my $icon    = html_priority_icon_for($priority);
    my $string  = escape_html($priority);
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Priority:</td>
<td width="85%" class="req_individual">$icon &nbsp; $string</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_status_for {

  my $label        = shift;
  my @lines        = ();
  my $found_status = 0;

  if ($option{'use_formal_status'} == 1) {

    my @dates = sort keys %{ $outcomes{$label} };

    # Look for status of in the outcomes datastructure
    #
    foreach my $date (@dates) {

      my $status      = $outcomes{$label}{$date}{'status'};
      my $icon        = html_status_icon_for($status);
      my $method      = $status{$label}{'source'};
      my $description = $outcomes{$label}{$date}{'description'};
      my $source      = $outcomes{$label}{$date}{'source'};

      if ($status and $source) {

	$found_status = 1;
	my $bgcolor = html_cell_bgcolor_for($status);
	my $string  = escape_html("[id:$source] - $status on $date - $description");
	my $block   = wrap("<td width=\"85%\" class=\"req_individual\">$icon &nbsp; $string</td>");
	push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Result:</td>
$block
</tr>

END_OF_TEXT
      }

      elsif ($status) {

	$found_status = 1;
	my $icon    = html_status_icon_for($status);
	my $bgcolor = html_cell_bgcolor_for($status);
	my $string  = escape_html("$status");
	my $block   = wrap("<td width=\"85%\" class=\"req_individual\">$icon &nbsp; $string</td>");
	push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Status:</td>
$block
</tr>

END_OF_TEXT
      }
    }

    # Status is grey if no status was found in the results
    # datastructure
    #
    if (not $found_status) {
      my $status  = 'grey';
      my $icon    = html_status_icon_for($status);
      my $bgcolor = html_cell_bgcolor_for($status);
      my $string  = escape_html("$status");
      my $block   = wrap("<td width=\"85%\" class=\"req_individual\">$icon &nbsp; $string</td>");
      push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Status:</td>
$block
</tr>

END_OF_TEXT
    }
  }

  else {
    my $status = status_of($label) if label_exists($label);
    if ($status) {
      my $icon    = html_status_icon_for($status);
      my $bgcolor = html_cell_bgcolor_for($status);
      my $string  = escape_html($status);
      my $block   = wrap("<td width=\"85%\" class=\"req_individual\">$icon &nbsp; $string</td>");
      push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Status:</td>
$block
</tr>

END_OF_TEXT
    }
  }
  return @lines;
}

######################################################################

sub html_reviews_for {

  my $label = shift;
  my @lines = ();
  my @dates = keys %{ $reviews{$label} };

  my $is_first_row = 1;
  foreach my $date (@dates) {

    my $status      = $reviews{$label}{$date}{'status'};
    my $icon        = html_status_icon_for($status);
    my $description = $reviews{$label}{$date}{'description'};
    my $source      = $reviews{$label}{$date}{'source'};
    my $review_header = $EMPTY_STRING;
    $review_header    = 'Reviews:' if $is_first_row;
    $is_first_row     = 0;

    my $bgcolor     = html_cell_bgcolor_for($status);
    my $string      = escape_html("$status: ($date, [id:$source]) $description");
    my $block       = wrap("<td width=\"85%\" class=\"req_individual\">$icon &nbsp; $string</td>");

    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">$review_header</td>
$block
</tr>

END_OF_TEXT
  }

  return @lines;
}

######################################################################

sub html_owner_for {

  my $label  = shift;
  my $owner  = $lookup{$label}{'owner'} || '';
  my $string = '';
  my @lines  = ();

  if ( label_exists($owner) ) {
    my $title = escape_html($lookup{$owner}{'title'});
    my $link  = escape_html('[id:' . $owner . ']');
    $string = "$link - $title";
  } else {
    $string = escape_html($owner);
  }

  if ($owner) {
    my $block = wrap("<td width=\"85%\" class=\"req_individual\">$string</td>");
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Owner:</td>
$block
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_assignees_for {

  my $label       = shift;
  my @assignees   = @{$lookup{$label}{'assignee'}};
  my @lines       = ();

  if (@assignees) {

      push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Assignees:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    foreach my $assignee (@assignees) {
      my $string = '';
      if ( label_exists($assignee) ) {
	my $title = escape_html($lookup{$assignee}{'title'});
	my $link  = escape_html('[id:' . $assignee . ']');
	$string = "$link - $title";
      } else {
	$string = escape_html($assignee);
      }

      push @lines, <<"END_OF_TEXT";
<tr>
<td width="50%"><span class="req_solution">$string</td>
</tr>

END_OF_TEXT
    }
      push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT
  }

  return @lines;
}

######################################################################

sub html_roles_for {

  my $label = shift;
  my @roles = ();
  if ( ref $lookup{$label}{'role'} eq 'ARRAY' ) {
    @roles = @{$lookup{$label}{'role'}};
  } elsif ($lookup{$label}{'role'}) {
    push @roles, $lookup{$label}{'role'};
  }

  my @lines   = ();

  if (@roles) {

      push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Roles:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    foreach my $role (sort by_doc_order @roles) {

      my $role_title    = escape_html($lookup{$role}{'title'});
      my $role_priority = $lookup{$role}{'priority'};
      my $role_status   = status_of($role) if label_exists($role);
      my $role_icon     = html_status_icon_for($role_status);
      my $outfile          = html_outfile_for_label($role);

      if ( $role_title ) {
	my $block = wrap("<td width=\"70%\">$role_icon &nbsp; <span class=\"sol_role\"><a href=\"$outfile#${role}\">$role</a> - $role_title</span></td>");
	push @lines, "<tr>$block</tr>\n";
      }

    }
      push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT
  }

  return @lines;
}

######################################################################

sub html_stakeholders_for {

  my $label        = shift;
  my @stakeholders = @{$lookup{$label}{'stakeholder'}};
  my @lines        = ();

  if (@stakeholders) {

      push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Stakeholders:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    foreach my $stakeholder (@stakeholders) {
      my $string = '';
      if ( label_exists($stakeholder) ) {
	my $title = escape_html($lookup{$stakeholder}{'title'});
	my $link  = escape_html('[id:' . $stakeholder . ']');
	$string = "$link - $title";
      } else {
	$string = escape_html($stakeholder);
      }

      push @lines, <<"END_OF_TEXT";
<tr>
<td width="50%"><span class="req_solution">$string</td>
</tr>

END_OF_TEXT
    }
      push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT
  }

  return @lines;
}

######################################################################

sub html_previous_for {

  # Render the html to present the "previous" item.

  my $label    = shift;
  my @previous = @{ $lookup{$label}{'previous'} };
  my @lines    = ();

  if (@previous) {

    my $first_line = 1;

    foreach my $previous (@previous) {

      my $title   = $lookup{$previous}{'title'};
      my $status  = status_of($previous) if label_exists($previous);
      my $icon    = html_status_icon_for($status);
      my $string  = "[id:$previous] - $title";
      my $html    = escape_html($string);
      my $block   = wrap("$icon &nbsp; $html");
      my $element = '';

      if ($first_line) {
	$element = 'Previous:';
	$first_line = 0;
      }

      push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">$element</td>
<td width="85%" class="req_individual">
$block
</td>
</tr>

END_OF_TEXT

    }
  }

  return @lines;
}

######################################################################

sub html_next_for {

  # Render the html to present the "next" item.

  my $label  = shift;
  my @next   = @{ $lookup{$label}{'next'} };
  my @lines  = ();

  if (@next) {

    my $first_line = 1;

    foreach my $next (@next) {

      my $title   = $lookup{$next}{'title'};
      my $status  = status_of($next) if label_exists($next);
      my $icon    = html_status_icon_for($status);
      my $string  = "[id:$next] - $title";
      my $html    = escape_html($string);
      my $block   = wrap("$icon &nbsp; $html<br/>");
      my $element = '';

      if ($first_line) {
	$element = 'Next:';
	$first_line = 0;
      }

      push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">$element</td>
<td width="85%" class="req_individual">
$block
</td>
</tr>

END_OF_TEXT

    }

  }

  return @lines;
}

######################################################################

sub html_validator_for {

  my $label     = shift;
  my $validator = escape_html($lookup{$label}{'validator'});
  my @lines     = ();

  if ($validator) {
    my $block = wrap("<td width=\"85%\" class=\"req_individual\">$validator</td>");
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Validator:</td>
$block
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_effort_for {

  my $label  = shift;

  if ( has_children($label) ) {

    my $effort = escape_html(effort_for($label));
    my @lines  = ();

    if ($effort =~ /\s*(\d+\.\d+|\d+\.|\.\d+|\d+)/ and $1 != 0) {
      my $block = wrap("<td width=\"85%\" class=\"req_individual\">$effort</td>");
      push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Effort:</td>
$block
</tr>

END_OF_TEXT
    }

    return @lines;
  }

  else {

    my @lines  = ();
    my $amount = 0;
    my $units  = $document{'effort_units'} || '';
    my $block  = '<td width="85%" class="req_individual">';

    my @item_efforts = @{ $lookup{$label}{'effort'} };

    foreach my $item_effort (@item_efforts) {
      if ( $item_effort =~ /^\s*(\d+\.\d+|\d+\.|\.\d+|\d+)/  and $1 != 0 ) {
	$amount = $amount + $1;
      }
      $block .= $item_effort . "<br/>";
    }

    if ( scalar(@item_efforts) > 1 ) {
      $block .= "$amount $units total";
    }

    $block .= '</td>';
    $block = wrap($block);

    if ( $amount != 0 ) {
      push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Effort:</td>
$block
</tr>

END_OF_TEXT
    }

    return @lines;
  }

}

######################################################################

sub html_directs {

  # Each 'directs' may be (1) a label that identifies an item in the
  # document, (2) arbitrary text that describes a directive, or (3) a
  # label *and* arbitrary text separated by a comma:
  #
  #    (1) rq-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) rq-000234, section 3.2, para 4 on pg 158

  my $label   = shift;
  my @directs = @{$lookup{$label}{'directs'}};
  my @lines   = ();

  if (@directs) {

    #-----------------------------------------------------------------
    # begin table row
    #
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%"class="req_label">Directs:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # list directives
    #
    foreach my $directs (@directs) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $directs =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$directs = $1;
	$note    = $2;
      }

      my $status = status_of($directs) if label_exists($directs);
      my $icon   = html_status_icon_for($status);

      #---------------------------------------------------------------
      # Determine this directs's title
      #
      my $directs_title = '';
      if ( label_exists($directs) ) {
	$directs_title = escape_html($lookup{$directs}{'title'});
      } else {
	$directs_title = escape_html($directs);
      }

      #---------------------------------------------------------------
      # if there was a note, add it after the title
      #
      if ($note) {
	$note              = escape_html($note);
	$directs_title = $directs_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate the directs title
      #
      my $block = '';
      if ( label_exists($directs) ) {
	my $outfile = html_outfile_for_label($directs);
	$block = wrap("<td width=\"70%\">$icon &nbsp; <span class=\"req_directs\"><a href=\"$outfile#${directs}\">$directs</a> - $directs_title</span><br/></td>");
      } else {
	$block = wrap("<td width=\"70%\"><span class=\"req_solution\">$directs_title</span><br/></td>");
      }

      #---------------------------------------------------------------
      # add the directs title
      #
      push @lines, <<"END_OF_TEXT";
<tr>
$block
END_OF_TEXT

      #-----------------------------------------------------------
      # end the directs row
      #
      push @lines, <<"END_OF_TEXT";
</tr>
END_OF_TEXT

    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT

  }

  return @lines;
}

######################################################################

sub html_directed_by {

  # Each 'directed_by' may be (1) a label that identifies an item in
  # the document, (2) arbitrary text that describes a directive, or
  # (3) a label *and* arbitrary text separated by a comma:
  #
  #    (1) rq-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) rq-000234, section 3.2, para 4 on pg 158

  my $label       = shift;
  my @directed_by = @{$lookup{$label}{'directed_by'}};
  my @lines       = ();

  if (@directed_by) {

    #-----------------------------------------------------------------
    # begin table row
    #
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%"class="req_label">Directed By:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # list directives
    #
    foreach my $directed_by (@directed_by) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $directed_by =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$directed_by = $1;
	$note        = $2;
      }

      my $status = status_of($directed_by) if label_exists($directed_by);
      my $icon   = html_status_icon_for($status);

      #---------------------------------------------------------------
      # Determine this directed_by's title
      #
      my $directed_by_title = '';
      if ( label_exists($directed_by) ) {
	$directed_by_title = escape_html($lookup{$directed_by}{'title'});
      } else {
	$directed_by_title = escape_html($directed_by);
      }

      #---------------------------------------------------------------
      # if there was a note, add it in parenthesis to the end of the
      # title
      #
      if ($note) {
	$note              = escape_html($note);
	$directed_by_title = $directed_by_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate the directed_by title
      #
      my $block = '';
      if ( label_exists($directed_by) ) {
	my $outfile = html_outfile_for_label($directed_by);
	$block = wrap("<td width=\"70%\">$icon &nbsp; <span class=\"req_directed_by\"><a href=\"$outfile#${directed_by}\">$directed_by</a> - $directed_by_title</span><br/></td>");
      } else {
	$block = wrap("<td width=\"70%\"><span class=\"req_solution\">$directed_by_title</span><br/></td>");
      }

      #---------------------------------------------------------------
      # add the directed_by title
      #
      push @lines, <<"END_OF_TEXT";
<tr>
$block
END_OF_TEXT

      #-----------------------------------------------------------
      # end the directed_by row
      #
      push @lines, <<"END_OF_TEXT";
</tr>
END_OF_TEXT

    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT

  }

  return @lines;
}

######################################################################

sub html_uses {

  # Each 'uses' may be (1) a label that identifies an item in the
  # document, (2) arbitrary text that describes a useive, or (3) a
  # label *and* arbitrary text separated by a comma:
  #
  #    (1) rq-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) rq-000234, section 3.2, para 4 on pg 158

  my $label   = shift;
  my @uses = @{$lookup{$label}{'uses'}};
  my @lines   = ();

  if (@uses) {

    #-----------------------------------------------------------------
    # begin table row
    #
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%"class="req_label">Uses:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # list useives
    #
    foreach my $uses (@uses) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $uses =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$uses = $1;
	$note    = $2;
      }

      my $status = status_of($uses) if label_exists($uses);
      my $icon   = html_status_icon_for($status);

      #---------------------------------------------------------------
      # Determine this uses's title
      #
      my $uses_title = '';
      if ( label_exists($uses) ) {
	$uses_title = escape_html($lookup{$uses}{'title'});
      } else {
	$uses_title = escape_html($uses);
      }

      #---------------------------------------------------------------
      # if there was a note, add it after the title
      #
      if ($note) {
	$note              = escape_html($note);
	$uses_title = $uses_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate the uses title
      #
      my $block = '';
      if ( label_exists($uses) ) {
	my $outfile = html_outfile_for_label($uses);
	$block = wrap("<td width=\"70%\">$icon &nbsp; <span class=\"req_uses\"><a href=\"$outfile#${uses}\">$uses</a> - $uses_title</span><br/></td>");
      } else {
	$block = wrap("<td width=\"70%\"><span class=\"req_solution\">$uses_title</span><br/></td>");
      }

      #---------------------------------------------------------------
      # add the uses title
      #
      push @lines, <<"END_OF_TEXT";
<tr>
$block
END_OF_TEXT

      #-----------------------------------------------------------
      # end the uses row
      #
      push @lines, <<"END_OF_TEXT";
</tr>
END_OF_TEXT

    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT

  }

  return @lines;
}

######################################################################

sub html_used_by {

  # Each 'used_by' may be (1) a label that identifies an item in
  # the document, (2) arbitrary text that describes a useive, or
  # (3) a label *and* arbitrary text separated by a comma:
  #
  #    (1) rq-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) rq-000234, section 3.2, para 4 on pg 158

  my $label       = shift;
  my @used_by = @{$lookup{$label}{'used_by'}};
  my @lines       = ();

  if (@used_by) {

    #-----------------------------------------------------------------
    # begin table row
    #
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%"class="req_label">Used By:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # list useives
    #
    foreach my $used_by (@used_by) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $used_by =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$used_by = $1;
	$note        = $2;
      }

      my $status = status_of($used_by) if label_exists($used_by);
      my $icon   = html_status_icon_for($status);

      #---------------------------------------------------------------
      # Determine this used_by's title
      #
      my $used_by_title = '';
      if ( label_exists($used_by) ) {
	$used_by_title = escape_html($lookup{$used_by}{'title'});
      } else {
	$used_by_title = escape_html($used_by);
      }

      #---------------------------------------------------------------
      # if there was a note, add it in parenthesis to the end of the
      # title
      #
      if ($note) {
	$note              = escape_html($note);
	$used_by_title = $used_by_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate the used_by title
      #
      my $block = '';
      if ( label_exists($used_by) ) {
	my $outfile = html_outfile_for_label($used_by);
	$block = wrap("<td width=\"70%\">$icon &nbsp; <span class=\"req_used_by\"><a href=\"$outfile#${used_by}\">$used_by</a> - $used_by_title</span><br/></td>");
      } else {
	$block = wrap("<td width=\"70%\"><span class=\"req_solution\">$used_by_title</span><br/></td>");
      }

      #---------------------------------------------------------------
      # add the used_by title
      #
      push @lines, <<"END_OF_TEXT";
<tr>
$block
END_OF_TEXT

      #-----------------------------------------------------------
      # end the used_by row
      #
      push @lines, <<"END_OF_TEXT";
</tr>
END_OF_TEXT

    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT

  }

  return @lines;
}

######################################################################

sub html_extends {

  # Each 'extends' may be (1) a label that identifies an item in the
  # document, (2) arbitrary text that describes a directive, or (3) a
  # label *and* arbitrary text separated by a comma:
  #
  #    (1) rq-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) rq-000234, section 3.2, para 4 on pg 158

  my $label   = shift;
  my @extends = @{$lookup{$label}{'extends'}};
  my @lines   = ();

  if (@extends) {

    #-----------------------------------------------------------------
    # begin table row
    #
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%"class="req_label">Extends:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # list directives
    #
    foreach my $extends (@extends) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $extends =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$extends = $1;
	$note    = $2;
      }

      my $status = status_of($extends) if label_exists($extends);
      my $icon   = html_status_icon_for($status);

      #---------------------------------------------------------------
      # Determine this extends's title
      #
      my $extends_title = '';
      if ( label_exists($extends) ) {
	$extends_title = escape_html($lookup{$extends}{'title'});
      } else {
	$extends_title = escape_html($extends);
      }

      #---------------------------------------------------------------
      # if there was a note, add it after the title
      #
      if ($note) {
	$note              = escape_html($note);
	$extends_title = $extends_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate the extends title
      #
      my $block = '';
      if ( label_exists($extends) ) {
	my $outfile = html_outfile_for_label($extends);
	$block = wrap("<td width=\"70%\">$icon &nbsp; <span class=\"req_extends\"><a href=\"$outfile#${extends}\">$extends</a> - $extends_title</span><br/></td>");
      } else {
	$block = wrap("<td width=\"70%\"><span class=\"req_solution\">$extends_title</span><br/></td>");
      }

      #---------------------------------------------------------------
      # add the extends title
      #
      push @lines, <<"END_OF_TEXT";
<tr>
$block
END_OF_TEXT

      #-----------------------------------------------------------
      # end the extends row
      #
      push @lines, <<"END_OF_TEXT";
</tr>
END_OF_TEXT

    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT

  }

  return @lines;
}

######################################################################

sub html_extended_by {

  # Each 'extended_by' may be (1) a label that identifies an item in
  # the document, (2) arbitrary text that describes a directive, or
  # (3) a label *and* arbitrary text separated by a comma:
  #
  #    (1) rq-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) rq-000234, section 3.2, para 4 on pg 158

  my $label       = shift;
  my @extended_by = @{$lookup{$label}{'extended_by'}};
  my @lines       = ();

  if (@extended_by) {

    #-----------------------------------------------------------------
    # begin table row
    #
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%"class="req_label">Directed By:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # list directives
    #
    foreach my $extended_by (@extended_by) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $extended_by =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$extended_by = $1;
	$note        = $2;
      }

      my $status = status_of($extended_by) if label_exists($extended_by);
      my $icon   = html_status_icon_for($status);

      #---------------------------------------------------------------
      # Determine this extended_by's title
      #
      my $extended_by_title = '';
      if ( label_exists($extended_by) ) {
	$extended_by_title = escape_html($lookup{$extended_by}{'title'});
      } else {
	$extended_by_title = escape_html($extended_by);
      }

      #---------------------------------------------------------------
      # if there was a note, add it in parenthesis to the end of the
      # title
      #
      if ($note) {
	$note              = escape_html($note);
	$extended_by_title = $extended_by_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate the extended_by title
      #
      my $block = '';
      if ( label_exists($extended_by) ) {
	my $outfile = html_outfile_for_label($extended_by);
	$block = wrap("<td width=\"70%\">$icon &nbsp; <span class=\"req_extended_by\"><a href=\"$outfile#${extended_by}\">$extended_by</a> - $extended_by_title</span><br/></td>");
      } else {
	$block = wrap("<td width=\"70%\"><span class=\"req_solution\">$extended_by_title</span><br/></td>");
      }

      #---------------------------------------------------------------
      # add the extended_by title
      #
      push @lines, <<"END_OF_TEXT";
<tr>
$block
END_OF_TEXT

      #-----------------------------------------------------------
      # end the extended_by row
      #
      push @lines, <<"END_OF_TEXT";
</tr>
END_OF_TEXT

    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT

  }

  return @lines;
}

######################################################################

sub html_realizes {

  # Each 'realizes' may be (1) a label that identifies an item in the
  # document, (2) arbitrary text that describes a directive, or (3) a
  # label *and* arbitrary text separated by a comma:
  #
  #    (1) rq-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) rq-000234, section 3.2, para 4 on pg 158

  my $label    = shift;
  my @realizes = @{$lookup{$label}{'realizes'}};
  my @lines    = ();

  if (@realizes) {

    #-----------------------------------------------------------------
    # begin table row
    #
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%"class="req_label">Realizes:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # list directives
    #
    foreach my $realizes (@realizes) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $realizes =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$realizes = $1;
	$note     = $2;
      }

      my $status = status_of($realizes) if label_exists($realizes);
      my $icon   = html_status_icon_for($status);

      #---------------------------------------------------------------
      # Determine this realizes's title
      #
      my $realizes_title = '';
      if ( label_exists($realizes) ) {
	$realizes_title = escape_html($lookup{$realizes}{'title'});
      } else {
	$realizes_title = escape_html($realizes);
      }

      #---------------------------------------------------------------
      # if there was a note, add it after the title
      #
      if ($note) {
	$note              = escape_html($note);
	$realizes_title = $realizes_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate the realizes title
      #
      my $block = '';
      if ( label_exists($realizes) ) {
	my $outfile = html_outfile_for_label($realizes);
	$block = wrap("<td width=\"70%\">$icon &nbsp; <span class=\"req_realizes\"><a href=\"$outfile#${realizes}\">$realizes</a> - $realizes_title</span><br/></td>");
      } else {
	$block = wrap("<td width=\"70%\"><span class=\"req_solution\">$realizes_title</span><br/></td>");
      }

      #---------------------------------------------------------------
      # add the realizes title
      #
      push @lines, <<"END_OF_TEXT";
<tr>
$block
END_OF_TEXT

      #-----------------------------------------------------------
      # end the realizes row
      #
      push @lines, <<"END_OF_TEXT";
</tr>
END_OF_TEXT

    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT

  }

  return @lines;
}

######################################################################

sub html_realized_by {

  # Each 'realized_by' may be (1) a label that identifies an item in
  # the document, (2) arbitrary text that describes a directive, or
  # (3) a label *and* arbitrary text separated by a comma:
  #
  #    (1) rq-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) rq-000234, section 3.2, para 4 on pg 158

  my $label       = shift;
  my @realized_by = @{$lookup{$label}{'realized_by'}};
  my @lines       = ();

  if (@realized_by) {

    #-----------------------------------------------------------------
    # begin table row
    #
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%"class="req_label">Realized By:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # list directives
    #
    foreach my $realized_by (@realized_by) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $realized_by =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$realized_by = $1;
	$note        = $2;
      }

      my $status = status_of($realized_by) if label_exists($realized_by);
      my $icon   = html_status_icon_for($status);

      #---------------------------------------------------------------
      # Determine this realized_by's title
      #
      my $realized_by_title = '';
      if ( label_exists($realized_by) ) {
	$realized_by_title = escape_html($lookup{$realized_by}{'title'});
      } else {
	$realized_by_title = escape_html($realized_by);
      }

      #---------------------------------------------------------------
      # if there was a note, add it in parenthesis to the end of the
      # title
      #
      if ($note) {
	$note              = escape_html($note);
	$realized_by_title = $realized_by_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate the realized_by title
      #
      my $block = '';
      if ( label_exists($realized_by) ) {
	my $outfile = html_outfile_for_label($realized_by);
	$block = wrap("<td width=\"70%\">$icon &nbsp; <span class=\"req_realized_by\"><a href=\"$outfile#${realized_by}\">$realized_by</a> - $realized_by_title</span><br/></td>");
      } else {
	$block = wrap("<td width=\"70%\"><span class=\"req_solution\">$realized_by_title</span><br/></td>");
      }

      #---------------------------------------------------------------
      # add the realized_by title
      #
      push @lines, <<"END_OF_TEXT";
<tr>
$block
END_OF_TEXT

      #-----------------------------------------------------------
      # end the realized_by row
      #
      push @lines, <<"END_OF_TEXT";
</tr>
END_OF_TEXT

    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT

  }

  return @lines;
}

######################################################################

sub html_parents_of {

  my $label  = shift;
  my $parent = $lookup{$label}{'parent'};
  my @lines  = ();

  if ($parent) {

    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Parents:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # Walk up the parent tree to make a list of parents.
    #
    my @parents = ();
    my $current_item = $label;
    while ($lookup{$current_item}{'parent'}) {
      my $parent = $lookup{$current_item}{'parent'};
      push @parents, $parent;
      $current_item = $parent;
    }

    #---------------------------------------------------------------
    # Now render a link to each ancestor
    #
    foreach my $parent (reverse @parents) {

      my $parent_title    = escape_html($lookup{$parent}{'title'});
      my $parent_priority = $lookup{$parent}{'priority'};
      my $parent_status   = status_of($parent) if label_exists($parent);
      my $parent_icon     = html_status_icon_for($parent_status);
      my $outfile         = html_outfile_for_label($parent);

      #-------------------------------------------------------------
      # If this parent exists (has a title)...
      #
      if ($parent_title) {

	#-----------------------------------------------------------
	# add the parent's title
	#
	my $block = wrap("<td width=\"70%\">$parent_icon &nbsp; <span class=\"req_parent\"><a href=\"$outfile#${parent}\">$parent</a> - $parent_title</span></td>");

	push @lines, "<tr>$block</tr>\n";

      }
    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_children_of {

  my $label    = shift;
  my @children = @{$lookup{$label}{'children'}};
  my @lines    = ();

  if (@children) {

    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Parts:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # List children of this problem.
    #
    foreach my $child (@children) {
      my $child_title    = escape_html($lookup{$child}{'title'});
      my $child_priority = $lookup{$child}{'priority'};
      my $child_status   = status_of($child) if label_exists($child);
      my $child_icon     = html_status_icon_for($child_status);
      my $outfile        = html_outfile_for_label($child);

      #-------------------------------------------------------------
      # If this child exists (has a title)...
      #
      if ($child_title) {

	#-----------------------------------------------------------
	# add the child title
	#
	my $block = wrap("<td width=\"70%\">$child_icon &nbsp; <span class=\"req_child\"><a href=\"$outfile#${child}\">$child</a> - $child_title</span></td>");

	push @lines, "<tr>$block</tr>\n";

      }
    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_derived_from {

  my $label        = shift;
  my @derived_from = @{$lookup{$label}{'derived_from'}};
  my @lines        = ();

  if (@derived_from) {

    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Derived From:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    foreach my $derived_from (@derived_from) {

      my $derived_from_title    = escape_html($lookup{$derived_from}{'title'});
      my $derived_from_priority = $lookup{$derived_from}{'priority'};
      my $derived_from_status   = status_of($derived_from) if label_exists($derived_from);
      my $derived_from_icon     = html_status_icon_for($derived_from_status);
      my $outfile               = html_outfile_for_label($derived_from);

      #-------------------------------------------------------------
      # If this derived_from exists (has a title)...
      #
      if ($derived_from_title) {

	#-----------------------------------------------------------
	# add the derived_from's title
	#
	my $block = wrap("<td width=\"70%\">$derived_from_icon &nbsp; <span class=\"req_parent\"><a href=\"$outfile#${derived_from}\">$derived_from</a> - $derived_from_title</span></td>");

	push @lines, "<tr>$block</tr>\n";

      }

    }
    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT

  }
  return @lines;
}

######################################################################

sub html_derived {

  my $label   = shift;
  my @derived = @{$lookup{$label}{'derived'}};
  my @lines   = ();

  if (@derived) {

    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Derived:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # List items derived from this one.
    #
    foreach my $derived (@derived) {

      my $derived_title    = escape_html($lookup{$derived}{'title'});
      my $derived_priority = $lookup{$derived}{'priority'};
      my $derived_status   = status_of($derived) if label_exists($derived);
      my $derived_icon     = html_status_icon_for($derived_status);
      my $outfile          = html_outfile_for_label($derived);

      #-------------------------------------------------------------
      # If this derived exists (has a title)...
      #
      if ($derived_title) {

	#-----------------------------------------------------------
	# add the derived title
	#
	my $block = wrap("<td width=\"70%\">$derived_icon &nbsp; <span class=\"req_child\"><a href=\"$outfile#${derived}\">$derived</a> - $derived_title</span></td>");

	push @lines, "<tr>$block</tr>\n";

      }
    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_instance_of {

  my $label       = shift;
  my @instance_of = @{$lookup{$label}{'instance_of'}};
  my @lines       = ();

  if (@instance_of) {

    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Instance Of:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # List
    #
    foreach my $instance_of (@instance_of) {

      my $instance_of_title    = escape_html($lookup{$instance_of}{'title'});
      my $instance_of_priority = $lookup{$instance_of}{'priority'};
      my $instance_of_status   = status_of($instance_of) if label_exists($instance_of);
      my $instance_of_icon     = html_status_icon_for($instance_of_status);
      my $outfile              = html_outfile_for_label($instance_of);

      #-------------------------------------------------------------
      # If this instance_of exists (has a title)...
      #
      if ($instance_of_title) {

	#-----------------------------------------------------------
	# add the instance_of title
	#
	my $block = wrap("<td width=\"70%\">$instance_of_icon &nbsp; <span class=\"req_child\"><a href=\"$outfile#${instance_of}\">$instance_of</a> - $instance_of_title</a></span></td>");

	push @lines, "<tr>$block</tr>\n";

      }
    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_class_of {

  my $label    = shift;
  my $name     = ();
  my @class_of = @{$lookup{$label}{'class_of'}};
  my @lines    = ();

  if (@class_of) {

    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Class Of:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # List problems that require this one.
    #
    foreach my $class_of (@class_of) {

      my $class_of_title    = escape_html($lookup{$class_of}{'title'});
      my $class_of_priority = $lookup{$class_of}{'priority'};
      my $class_of_status   = status_of($class_of) if label_exists($class_of);
      my $class_of_icon     = html_status_icon_for($class_of_status);
      my $outfile           = html_outfile_for_label($class_of);

      #-------------------------------------------------------------
      # If this class_of exists (has a title)...
      #
      if ($class_of_title) {

	#-----------------------------------------------------------
	# add the class_of title
	#
	my $block = wrap("<td width=\"70%\">$class_of_icon &nbsp; <span class=\"req_child\"><a href=\"$outfile#${class_of}\">$class_of</a> - $class_of_title</span></td>");

	push @lines, "<tr>$block</tr>\n";

      }
    }

    #---------------------------------------------------------------
    # end the "required by" table
    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_generalizes {

  my $label       = shift;
  my $name        = ();
  my @generalizes = @{$lookup{$label}{'generalizes'}};
  my @lines       = ();

  if (@generalizes) {

    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Generalizes:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # List problems that require this one.
    #
    foreach my $generalizes (@generalizes) {

      my $generalizes_title    = escape_html($lookup{$generalizes}{'title'});
      my $generalizes_priority = $lookup{$generalizes}{'priority'};
      my $generalizes_status   = status_of($generalizes) if label_exists($generalizes);
      my $generalizes_icon     = html_status_icon_for($generalizes_status);
      my $outfile              = html_outfile_for_label($generalizes);

      #-------------------------------------------------------------
      # If this generalizes exists (has a title)...
      #
      if ($generalizes_title) {

	#-----------------------------------------------------------
	# add the generalizes title
	#
	my $block = wrap("<td width=\"70%\">$generalizes_icon &nbsp; <span class=\"req_child\"><a href=\"$outfile#${generalizes}\">$generalizes</a> - $generalizes_title</span></td>");

	push @lines, "<tr>$block</tr>\n";

      }
    }

    #---------------------------------------------------------------
    # end the "required by" table
    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_specializes {

  my $label       = shift;
  my $name        = ();
  my @specializes = @{$lookup{$label}{'specializes'}};
  my @lines       = ();

  if (@specializes) {

    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Specializes:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # List problems that require this one.
    #
    foreach my $specializes (@specializes) {

      my $specializes_title    = escape_html($lookup{$specializes}{'title'});
      my $specializes_priority = $lookup{$specializes}{'priority'};
      my $specializes_status   = status_of($specializes) if label_exists($specializes);
      my $specializes_icon     = html_status_icon_for($specializes_status);
      my $outfile              = html_outfile_for_label($specializes);

      #-------------------------------------------------------------
      # If this specializes exists (has a title)...
      #
      if ($specializes_title) {

	#-----------------------------------------------------------
	# add the specializes title
	#
	my $block = wrap("<td width=\"70%\">$specializes_icon &nbsp; <span class=\"req_child\"><a href=\"$outfile#${specializes}\">$specializes</a> - $specializes_title</span></td>");

	push @lines, "<tr>$block</tr>\n";

      }
    }

    #---------------------------------------------------------------
    # end the "required by" table
    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_solutions_for {

  # Each 'solution' may be (1) a label that identifies an item in the
  # document, (2) arbitrary text that describes a solution, or (3) a
  # label *and* arbitrary text separated by a comma:
  #
  #    (1) ci-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) do-000234, section 3.2, para 4 on pg 158

  my $label     = shift;
  my @solutions = ();
  if ( ref $lookup{$label}{'solution'} eq 'ARRAY' ) {
    @solutions = @{$lookup{$label}{'solution'}};
  } elsif ($lookup{$label}{'solution'}) {
    push @solutions, $lookup{$label}{'solution'};
  }

  my @lines     = ();

  if (@solutions) {

    #-----------------------------------------------------------------
    # Begin table row
    #
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%"class="req_label">Solutions:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # List solutions to this problem.
    #
    foreach my $solution (sort by_doc_order @solutions) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $solution =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$solution = $1;
	$note     = $2;
      }

      #---------------------------------------------------------------
      # Determine this solution's title
      #
      my $solution_title = '';
      if ( label_exists($solution) ) {
	$solution_title = escape_html($lookup{$solution}{'title'});
      } else {
	$solution_title = escape_html($solution);
      }

      #---------------------------------------------------------------
      # Determine this solution's status
      #
      my $solution_status = '';
      if ( label_exists($solution) ) {
	$solution_status = status_of($solution) if label_exists($solution);
      } else {
	$solution_status = 'grey';
      }
      my $solution_icon = html_status_icon_for($solution_status);

      #---------------------------------------------------------------
      # if there was a note, add after the title
      #
      if ($note) {
	$note = escape_html($note);
	$solution_title = $solution_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate the solution title
      #
      my $block = '';
      if ( label_exists($solution) ) {
	my $outfile = html_outfile_for_label($solution);
	$block = wrap("<td width=\"70%\">$solution_icon &nbsp; <span class=\"req_solution\"><a href=\"$outfile#${solution}\">$solution</a> - $solution_title</span><br/></td>");
      } else {
	$block = wrap("<td width=\"70%\"><span class=\"req_solution\">$solution_title</span><br/></td>");
      }

      #---------------------------------------------------------------
      # add the solution title
      #
      push @lines, "<tr>$block</tr>\n";

    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_allocations_for {

  # Each 'allocation' may be (1) a label that identifies an item in the
  # document, (2) arbitrary text that describes a allocation, or (3) a
  # label *and* arbitrary text separated by a comma:
  #
  #    (1) ci-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) do-000234, section 3.2, para 4 on pg 158

  my $label     = shift;
  my @allocations = @{$lookup{$label}{'allocation'}};
  my @lines     = ();

  if (@allocations) {

    #-----------------------------------------------------------------
    # Begin table row
    #
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%"class="req_label">Allocations:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # List allocations to this problem.
    #
    foreach my $allocation (@allocations) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $allocation =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$allocation = $1;
	$note     = $2;
      }

      #---------------------------------------------------------------
      # Determine this allocation's title
      #
      my $allocation_title = '';
      if ( label_exists($allocation) ) {
	$allocation_title = escape_html($lookup{$allocation}{'title'});
      } else {
	$allocation_title = escape_html($allocation);
      }

      #---------------------------------------------------------------
      # Determine this allocation's status
      #
      my $allocation_status = '';
      if ( label_exists($allocation) ) {
	$allocation_status = status_of($allocation) if label_exists($allocation);
      } else {
	$allocation_status = 'grey';
      }
      my $allocation_icon = html_status_icon_for($allocation_status);

      #---------------------------------------------------------------
      # if there was a note, add after the title
      #
      if ($note) {
	$note = escape_html($note);
	$allocation_title = $allocation_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate the allocation title
      #
      my $block = '';
      if ( label_exists($allocation) ) {
	my $outfile = html_outfile_for_label($allocation);
	$block = wrap("<td width=\"70%\">$allocation_icon &nbsp; <span class=\"req_allocation\"><a href=\"$outfile#${allocation}\">$allocation</a> - $allocation_title</span><br/></td>");
      } else {
	$block = wrap("<td width=\"70%\"><span class=\"req_allocation\">$allocation_title</span><br/></td>");
      }

      #---------------------------------------------------------------
      # add the allocation title
      #
      push @lines, "<tr>$block</tr>\n";

    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_assignments_for {

  # Each 'assignment' may be (1) a label that identifies an item in the
  # document, (2) arbitrary text that describes a assignment, or (3) a
  # label *and* arbitrary text separated by a comma:
  #
  #    (1) ci-123456
  #
  #    (2) Ralph's special data transformation script
  #
  #    (3) do-000234, section 3.2, para 4 on pg 158

  my $label     = shift;
  my @assignments = @{$lookup{$label}{'assignment'}};
  my @lines     = ();

  if (@assignments) {

    #-----------------------------------------------------------------
    # Begin table row
    #
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%"class="req_label">Assignments:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # List assignments to this problem.
    #
    foreach my $assignment (@assignments) {

      #---------------------------------------------------------------
      # Split labels from notes
      #
      my $note = '';
      if ( $assignment =~ /^(\S+)\s*,\s*(.*)/ and label_exists($1) ) {
	$assignment = $1;
	$note     = $2;
      }

      #---------------------------------------------------------------
      # Determine this assignment's title
      #
      my $assignment_title = '';
      if ( label_exists($assignment) ) {
	$assignment_title = escape_html($lookup{$assignment}{'title'});
      } else {
	$assignment_title = escape_html($assignment);
      }

      #---------------------------------------------------------------
      # Determine this assignment's status
      #
      my $assignment_status = '';
      if ( label_exists($assignment) ) {
	$assignment_status = status_of($assignment) if label_exists($assignment);
      } else {
	$assignment_status = 'grey';
      }
      my $assignment_icon = html_status_icon_for($assignment_status);

      #---------------------------------------------------------------
      # if there was a note, add after the title
      #
      if ($note) {
	$note = escape_html($note);
	$assignment_title = $assignment_title . ", $note";
      }

      #---------------------------------------------------------------
      # formulate the assignment title
      #
      my $block = '';
      if ( label_exists($assignment) ) {
	my $outfile = html_outfile_for_label($assignment);
	$block = wrap("<td width=\"70%\">$assignment_icon &nbsp; <span class=\"req_assignment\"><a href=\"$outfile#${assignment}\">$assignment</a> - $assignment_title</span><br/></td>");
      } else {
	$block = wrap("<td width=\"70%\"><span class=\"req_assignment\">$assignment_title</span><br/></td>");
      }

      #---------------------------------------------------------------
      # add the assignment title
      #
      push @lines, "<tr>$block</tr>\n";

    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_tests_for {

  my $label = shift;
  my @tests = @{$lookup{$label}{'test'}};
  my @lines = ();

  if (@tests) {

    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%"class="req_label">Tests:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # List tests associated with this problem.
    #
    foreach my $test (@tests) {

      my $test_title    = escape_html($lookup{$test}{'title'});
      my $test_priority = $lookup{$test}{'priority'};
      my $test_status   = status_of($test) if label_exists($test);
      my $test_icon     = html_status_icon_for($test_status);
      my $outfile       = html_outfile_for_label($test);

      #-------------------------------------------------------------
      # If this test exists (has a title)...
      #
      if ($test_title) {

	my $block = wrap("<td width=\"70%\">$test_icon &nbsp; <span class=\"req_solution\"><a href=\"$outfile#${test}\">$test</a> - $test_title</span><br/></td>");

	push @lines, "<tr>$block</tr>\n";

      }
    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_tasks_for {

  my $label = shift;
  my @tasks = @{$lookup{$label}{'task'}};
  my @lines = ();

  if (@tasks) {

    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%"class="req_label">Tasks:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # List tasks associated with this problem.
    #
    foreach my $task (@tasks) {

      my $task_title    = escape_html($lookup{$task}{'title'});
      my $task_priority = $lookup{$task}{'priority'};
      my $task_status   = status_of($task) if label_exists($task);
      my $task_icon     = html_status_icon_for($task_status);
      my $outfile       = html_outfile_for_label($task);

      #-------------------------------------------------------------
      # If this task exists (has a title)...
      #
      if ($task_title) {

	#-----------------------------------------------------------
	# add the task title
	#
	my $block = wrap("<td width=\"70%\">$task_icon &nbsp; <span class=\"req_solution\"><a href=\"$outfile#${task}\">$task</a> - $task_title</span><br/></td>");

	push @lines, "<tr>$block</tr>\n";

      }
    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################
#
# !!! BUG HERE !!!
#
# This subroutine confuses results and outcomes.
#

# sub html_results_for {

#   my $label = shift;
#   my @lines = ();
#   my @dates = keys %{ $outcomes{$label} };

#   # Look for results in the outcomes datastructure
#   #
#   my $is_first_row = 1;
#   foreach my $date (@dates) {

#     my $status        = $outcomes{$label}{$date}{'status'};
#     my $icon          = html_status_icon_for($status);
#     my $method        = $status{$label}{'source'};
#     my $description   = $outcomes{$label}{$date}{'description'};
#     my $source        = $outcomes{$label}{$date}{'source'};
#     my $result_header = $EMPTY_STRING;
#     $result_header    = 'Results:' if $is_first_row;
#     $is_first_row     = 0;

#     if ($status and $source) {

#       my $bgcolor = html_cell_bgcolor_for($status);
#       my $string  = escape_html("$status: ($date, [id:$source]) $description");
#       my $block   = wrap("<td width=\"85%\" class=\"req_individual\">$icon &nbsp; $string</td>");
#       push @lines, <<"END_OF_TEXT";
# <tr>
# <td width="15%" class="req_label">$result_header</td>
# $block
# </tr>

# END_OF_TEXT
#     }

#     elsif ($status) {

#       my $icon    = html_status_icon_for($status);
#       my $bgcolor = html_cell_bgcolor_for($status);
#       my $string  = escape_html("$status");
#       my $block   = wrap("<td width=\"85%\" class=\"req_individual\">$icon &nbsp; $string</td>");
#       push @lines, <<"END_OF_TEXT";
# <tr>
# <td width="15%" class="req_label">$result_header</td>
# $block
# </tr>

# END_OF_TEXT
#     }
#   }

#   return @lines;
# }

######################################################################

sub html_results_for {

  my $label   = shift;
  my @results = @{ $lookup{$label}{'result'} };
  my @lines   = ();

  if (@results) {

    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="sol_label">Results:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # list of results
    #
    foreach my $result (@results) {

      my $result_title    = escape_html($lookup{$result}{'title'});
      my $result_priority = $lookup{$result}{'priority'};
      my $result_status   = status_of($result) if label_exists($result);
      my $result_icon     = html_status_icon_for($result_status);
      my $outfile          = html_outfile_for_label($result);

      #-------------------------------------------------------------
      # If this result exists (has a title)...
      #
      if ($result_title) {

	#-----------------------------------------------------------
	# add the result title
	#
	my $block = wrap("<td width=\"70%\">$result_icon &nbsp; <span class=\"sol_result\"><a href=\"$outfile#${result}\">$result</a> - $result_title</span></td>");

	push @lines, "<tr>$block</tr>\n";

      }
    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_associates_of {

  my $label      = shift;
  my @associates = @{$lookup{$label}{'associated'}};
  my @lines      = ();

  if (@associates) {

    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%"class="req_label">Associated:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # List other things associated with this problem.
    #
    foreach my $associate (@associates) {

      my $associate_title  = escape_html($lookup{$associate}{'title'});
      my $outfile          = html_outfile_for_label($associate);
      my $associate_status = status_of($associate) if label_exists($associate);
      my $associate_icon   = html_status_icon_for($associate_status);

      #-------------------------------------------------------------
      # If this associate exists (has a title)...
      #
      if ($associate_title) {

	#-----------------------------------------------------------
	# add the associate title
	#
	my $block = wrap("<td width=\"50%\">$associate_icon &nbsp; <span class=\"req_solution\"><a href=\"$outfile#${associate}\">$associate</a> - $associate_title</span><br/></td>");
	push @lines, "<tr>$block</tr>\n";

      }
    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_rel_component_for {

  my $label         = shift;
  my $rel_component = $lookup{$label}{'rel_component'};
  my @lines         = ();

  if ($rel_component) {

    my $title   = escape_html($lookup{$rel_component}{'title'});
    my $outfile = html_outfile_for_label($rel_component);
    my $status  = status_of($rel_component) if label_exists($rel_component);
    my $icon    = html_status_icon_for($status);

    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%"class="req_label">Releaseable Component:</td>
<td width="85%">$icon &nbsp; <span class=\"req_solution\"><a href=\"$outfile#${rel_component}\">$rel_component</a> - $title</span></td>
<tr>

END_OF_TEXT

  }
  return @lines;
}

######################################################################

sub html_requests_for {

  my $label    = shift;
  my @requests = @{$lookup{$label}{'request'}};
  my @lines    = ();

  if (@requests) {
    my @text = ();
    foreach my $request (@requests) {
      my $text = escape_html($request);
      push @text, $text;
    }
    my $string = join(', ', @text);
    my $block  = wrap("<td width=\"85%\" class=\"req_individual\">$string</td>");
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Requests:</td>
$block
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_attributes_of {

  my $label = shift;
  my %attrs = %{$attribute{$label}};
  my @lines = ();

  if (%attrs) {
    foreach my $key (sort keys %attrs) {
      my $key_string = escape_html($key);
      my @value = @{ $attribute{$label}{$key} };
      foreach my $value (@value) {
	my $value_string = escape_html($value);
	my $block = wrap("<td width=\"85%\" class=\"sol_solution\">$value_string</td>");
	push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="sol_label">$key_string:</td>
$block
</tr>

END_OF_TEXT
      }
    }
  }
  return @lines;
}

######################################################################

sub html_outcomes_for {

  my $label = shift;
  my @lines = ();

  # make a list of outcomes from the %results datastructure
  #
  my @outcomes = ();
  foreach my $item (sort keys %results ) {
    foreach my $date (sort keys %{ $outcomes{$item} }) {
      my $source = $outcomes{$item}{$date}{'source'};
      if ($source eq $label) {
	my $status      = $outcomes{$item}{$date}{'status'};
	my $description = $outcomes{$item}{$date}{'description'};
	push @outcomes, ["$item","$date","$status","$description"];
      }
    }
  }

  if (@outcomes) {
    foreach my $outcome (@outcomes) {

      my $item        = $outcome->[0];
      my $date        = $outcome->[1];
      my $status      = $outcome->[2];
      my $icon        = html_status_icon_for($status);
      my $description = escape_html( $outcome->[3] );
      my $key         = name_for($item);
      my $bgcolor     = html_cell_bgcolor_for($status);
      my $title       = escape_html($lookup{$item}{'title'});
      $item           = "[id:" . $item . "]";
      $item           = escape_html($item);

      my $block1      = wrap("<td width=\"35%\">$key $item: $title</td>");
      my $block2      = wrap("<td width=\"50%\">$description</td>");

      push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="sol_label">Outcome:</td>
<td width="85%" class="sol_solution" border="0">
<table width="100%" cellpadding="2" cellspacing="2">
<tr>
$block1
$block2
<td width="15%">$icon &nbsp; $status<br/>$date</td>
</tr>
</table>
</td>
</tr>

END_OF_TEXT
    }
  }

  return @lines;
}

######################################################################

sub html_footer_for {

  my $label = shift;
  my @lines = ();

  push @lines, <<"END_OF_TEXT";
</table>

END_OF_TEXT

  return @lines;

}

######################################################################

sub html_version_of {

  my $label   = shift;
  my $version = escape_html($lookup{$label}{'version'});
  my @lines   = ();

  if ($version) {
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="sol_label">Version:</td>
<td width="85%" class="sol_version">$version</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_release_for {

  my $label   = shift;
  my $release = escape_html($lookup{$label}{'release'});
  my @lines   = ();

  if ($release) {
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="sol_label">Release:</td>
<td width="85%" class="sol_version">$release</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_license_for {

  my $label  = shift;
  my $string = escape_html($lookup{$label}{'license'});
  my @lines  = ();

  if ($string) {
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="sol_label">License:</td>
<td width="85%" class="sol_version">$string</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_cost_of {

  my $label  = shift;
  my $string = escape_html($lookup{$label}{'cost'});
  my @lines  = ();

  if ($string) {
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="sol_label">Cost:</td>
<td width="85%" class="sol_version">$string</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_copyright_of {

  my $label  = shift;
  my $string = escape_html($lookup{$label}{'copyright'});
  my @lines  = ();

  if ($string) {
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="sol_label">Copyright:</td>
<td width="85%" class="sol_version">$string</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_depends_on {

  my $label      = shift;
  my @depends_on = @{$lookup{$label}{'depends_on'}};
  my @lines      = ();

  if (@depends_on) {

    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="sol_label">Depends On:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # List the items this one depends on
    #
    foreach my $depends_on (@depends_on) {

      my $depends_on_title    = escape_html($lookup{$depends_on}{'title'});
      my $depends_on_priority = $lookup{$depends_on}{'priority'};
      my $depends_on_status   = status_of($depends_on) if label_exists($depends_on);
      my $depends_on_icon     = html_status_icon_for($depends_on_status);
      my $outfile             = html_outfile_for_label($depends_on);

      #-------------------------------------------------------------
      # If this depends_on exists (has a title)...
      #
      if ($depends_on_title) {

	#-----------------------------------------------------------
	# add the depends_on title
	#
	my $block = wrap("<td width=\"70%\">$depends_on_icon &nbsp; <span class=\"sol_child\"><a href=\"$outfile#${depends_on}\">$depends_on</a> - $depends_on_title</a></span></td>");
	push @lines, <<"END_OF_TEXT";
<tr>
$block
</tr>

END_OF_TEXT

      }
    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_required_by {

  my $label       = shift;
  my @required_by = @{$lookup{$label}{'required_by'}};
  my @lines       = ();

  if (@required_by) {

    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="sol_label">Required By:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # List solutions that require this one.
    #
    foreach my $required_by (@required_by) {

      my $required_by_title    = escape_html($lookup{$required_by}{'title'});
      my $required_by_priority = $lookup{$required_by}{'priority'};
      my $required_by_status   = status_of($required_by) if label_exists($required_by);
      my $required_by_icon     = html_status_icon_for($required_by_status);
      my $outfile              = html_outfile_for_label($required_by);

      #-------------------------------------------------------------
      # If this required_by exists (has a title)...
      #
      if ($required_by_title) {

	#-----------------------------------------------------------
	# add the required_by title
	#
	my $block = wrap("<td width=\"70%\">$required_by_icon &nbsp; <span class=\"sol_child\"><a href=\"$outfile#${required_by}\">$required_by</a> - $required_by_title</span></td>");
	push @lines, <<"END_OF_TEXT";
<tr>
$block
</tr>

END_OF_TEXT

      }
    }

    #---------------------------------------------------------------
    # end the "required by" table
    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_problems_for {

  my $label    = shift;
  my @problems = ();
  if ( ref $lookup{$label}{'problem'} eq 'ARRAY' ) {
    @problems = @{$lookup{$label}{'problem'}};
  } elsif ($lookup{$label}{'problem'}) {
    push @problems, $lookup{$label}{'problem'};
  }

  my @lines    = ();

  if (@problems) {

    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="sol_label">Problems:</td>
<td width="85%">
<table width="100%" border="0" cellpadding="2" cellspacing="0">

END_OF_TEXT

    #-----------------------------------------------------------------
    # list of problems
    #
    foreach my $problem (sort by_doc_order @problems) {

      # print "DEBUG: html_problems_for $label problem => \"$problem\"\n";

      my $problem_title    = escape_html($lookup{$problem}{'title'});
      my $problem_priority = $lookup{$problem}{'priority'};
      my $problem_status   = status_of($problem) if label_exists($problem);
      my $problem_icon     = html_status_icon_for($problem_status);
      my $outfile          = html_outfile_for_label($problem);

      #-------------------------------------------------------------
      # If this problem exists (has a title)...
      #
      if ($problem_title) {

	#-----------------------------------------------------------
	# add the problem title
	#
	my $block = wrap("<td width=\"70%\">$problem_icon &nbsp; <span class=\"sol_problem\"><a href=\"$outfile#${problem}\">$problem</a> - $problem_title</span></td>");

	push @lines, "<tr>$block</tr>\n";

      }
    }

    push @lines, <<"END_OF_TEXT";
</table>
</td>
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub html_product_of {

  my $label   = shift;
  my $product = escape_html($lookup{$label}{'product'});
  my @lines   = ();

  if ($product) {
    my $block = wrap("<td width=\"85%\" class=\"req_individual\">$product</td>");
    push @lines, <<"END_OF_TEXT";
<tr>
<td width="15%" class="req_label">Product:</td>
$block
</tr>

END_OF_TEXT
  }
  return @lines;
}

######################################################################

sub has_children {

  my $label    = shift;
  my @children = @{$lookup{$label}{'children'}};

  if (@children) {
    return 1;
  } else {
    return 0;
  }
}

######################################################################

sub list_by_name {

  # List all items by name.  For instance, if the calling code sends
  # the string 'problem' return a list of all 'problem' labels.

  my $name = shift;
  my @list = ();

  foreach my $label (sort by_doc_order keys %lookup) {
    if ( name_for($label) eq $name ) {
      push @list, $label;
    }
  }

  return @list;

}

######################################################################

sub lookup {

  # !!! BUG HERE !!!
  #
  # This subroutine is not currently used.  I wrote it in anticipation
  # of modifying the %lookup datastructure and potentially replacing
  # all %lookup datastructure queries with this subroutine.  Now I'm
  # not sure this subroutine is necessary.  I think the code might
  # perform better without the additional call to this subroutine.

  # Lookup a data element value.  For instance, if the calling code
  # sends the two arguments 'rq-000001' and 'title', lookup and return
  # the title of the item with label 'rq-000001'.

  my $label   = shift;
  my $element = shift;

  my $text    = $lookup{$label}{$element} || '';

  return $text;

}

######################################################################

sub is_special {

  # Check to see if the name passed as an argument is "special"
  # (i.e. is in the @specials list)

  my $name = shift;

  foreach my $special ( @specials ) {
    if ( $name eq $special ) {
      return 1;
    }
  }

  return 0;

}

######################################################################

sub hyphenate {

  # Change the periods to hyphens in the provided string.  The
  # intended use of this subroutine is to take a section number like
  # "2.6.1" and return the string "2-6-1" to be used in a file name.

  my $string = shift;
  $string =~ s/\./-/g;
  return $string;

}

######################################################################

sub html_outfile_for_label {

  # Return the HTML output file for a given label.  Each document
  # section is contained within it's own HTML output file.  The output
  # file name contains the section number.  For example:
  #
  #     my-document-2-14.html
  #
  # If the label is a 'source' return the name of the html 'sources'
  # file.

  my $label   = shift;
  my $name    = name_for($label);

  return $html_source_index_file if $name eq 'source';

  my $secnum  = hyphenate( $label{$label}{'secnum'} );
  my $outfile = "$output_file-$secnum.html";

  return $outfile;
}

######################################################################

sub html_outfile_for_secnum {

  # Return the HTML output filename for a give section number.

  my $secnum  = shift;
  $secnum     = hyphenate($secnum);
  my $outfile = "$output_file-$secnum.html";
  return $outfile;

}

######################################################################

sub tree_outfile_aref_for {

  # Return the array reference (aref) for the tree outfile data for
  # $name and $size.

  my $name = shift;
  my $size = shift;

  if ( $size eq 'small' ) {
    return $html{'problem'}{'tree_small'}  if $name eq 'problem';
    return $html{'solution'}{'tree_small'} if $name eq 'solution';
    return $html{'allocation'}{'tree_small'} if $name eq 'allocation';
    return $html{'assignment'}{'tree_small'} if $name eq 'assignment';
    return $html{'task'}{'tree_small'}     if $name eq 'task';
    return $html{'test'}{'tree_small'}     if $name eq 'test';
    return $html{'result'}{'tree_small'}   if $name eq 'result';
    return $html{'role'}{'tree_small'}     if $name eq 'role';
  }

  elsif ( $size eq 'big' ) {
    return $html{'problem'}{'tree_big'}    if $name eq 'problem';
    return $html{'solution'}{'tree_big'}   if $name eq 'solution';
    return $html{'allocation'}{'tree_big'}   if $name eq 'allocation';
    return $html{'assignment'}{'tree_big'}   if $name eq 'assignment';
    return $html{'task'}{'tree_big'}       if $name eq 'task';
    return $html{'test'}{'tree_big'}       if $name eq 'test';
    return $html{'result'}{'tree_big'}     if $name eq 'result';
    return $html{'role'}{'tree_big'}       if $name eq 'role';
  }
}

######################################################################

sub remove_newlines {

  my $text = shift;
  $text =~ s/\r?\n/ /g;
  return $text;

}

######################################################################

sub wrap {

  # Wrap text to 70 columns.

  local($Text::Wrap::columns) = 70;
  local($Text::Wrap::huge)    = 'overflow';

  my $string = shift;

  my $result = Text::Wrap::wrap(
        $EMPTY_STRING,
        $EMPTY_STRING,
        "$string"
  );

  return $result;
}

######################################################################

sub count_children {

  # Count the total number of child nodes in a hierarchy.  This
  # subroutine is called recursively.

  my $label = shift;
  my $count = 0;
  my @parts = ();

  my @children = @{$lookup{$label}{'children'}};
  $count = scalar(@children);

  foreach my $child (@children) {
    $count = $count + count_children($child);
  }

  return $count;

}

######################################################################

sub column_heads_present {

  # Determine whether column heads have been defined for a table.  In
  # SML, column heads are defined like this:
  #
  #     column:1:head: column 1 head
  #     column:2:head: column 2 head
  #     column:3:head: column 3 head

  my $num = shift;

  foreach my $column ( keys %{ $data{'table'}{$num} } ) {
    if ( defined $data{'table'}{$num}{$column}{'head'} ) {
      return 1;
    }
  }

  return 0;

}

######################################################################

sub contains_label {

  # Determine whether a string contains a stand-alone label.  A
  # stand-alone label is one flanked by whitespace.  If so, return the
  # label.
  #
  #     !!! BUG HERE !!!
  #
  #     What if the string contains *multiple* labels?

  my $string = shift;
  my $label  = '';

  foreach my $label (keys %label) {
    $regexp = escape_regexp($label);
    if ($string =~ /\s$regexp\s/) {
      return 1;
    }
  }

  return 0;
}

######################################################################

sub extract_label {

  # Extract a stand-alone label from a string.  Stand-alone means the
  # label is flanked by whitespace.

  my $string = shift;
  my $label  = '';

  foreach my $label (keys %label) {
    $regexp = escape_regexp($label);
    if ($string =~ /\s$regexp\s/) {
      return $label;
    }
  }

  return 0;
}

######################################################################

sub html_status_icon_for {

  my $status = shift;

  # default to grey
  #
  my $icon = "<image src=\"$status_grey_icon\" border=\"0\"/>";

  # green?
  #
  if ( $status =~ /green/ ) {
    $icon = "<image src=\"$status_green_icon\" border=\"0\"/>";
  }

  # yellow?
  #
  elsif ( $status =~ /yellow/) {
    $icon = "<image src=\"$status_yellow_icon\" border=\"0\"/>";
  }

  # red?
  #
  elsif ( $status =~ /red/) {
    $icon = "<image src=\"$status_red_icon\" border=\"0\"/>";
  }

  return $icon;

}

######################################################################

sub latex_status_icon_for {

  my $status = shift;

  # default to grey
  #
  my $icon = '\textcolor{fg-grey}{$\blacksquare$}';

  # green?
  #
  if ( $status =~ /green/ ) {
    $icon = '\textcolor{fg-green}{$\blacksquare$}';
  }

  # yellow?
  #
  elsif ( $status =~ /yellow/) {
    $icon = '\textcolor{fg-yellow}{$\blacksquare$}';
  }

  # red?
  #
  elsif ( $status =~ /red/) {
    $icon = '\textcolor{fg-red}{$\blacksquare$}';
  }

  return $icon;

}

######################################################################

sub html_priority_icon_for {

  my $priority = shift;

  # default to grey
  #
  my $icon = "<image src=\"$priority_grey_icon\" border=\"0\"/>";

  # low?
  #
  if ( $priority =~ /(grey|low)/ ) {
    $icon = "<image src=\"$priority_grey_icon\" border=\"0\"/>";
  }

  # routine?
  #
  elsif ( $priority =~ /(yellow|routine)/) {
    $icon = "<image src=\"$priority_yellow_icon\" border=\"0\"/>";
  }

  # high?
  #
  elsif ( $priority =~ /(orange|high)/) {
    $icon = "<image src=\"$priority_orange_icon\" border=\"0\"/>";
  }

  # critical?
  #
  elsif ( $priority =~ /(red|critical)/) {
    $icon = "<image src=\"$priority_red_icon\" border=\"0\"/>";
  }

  return $icon;

}

######################################################################

sub latex_priority_icon_for {

  my $priority = shift;

  # default to grey
  #
  my $icon = '\textcolor{fg-grey}{$\newmoon$}';

  # low?
  #
  if ( $priority =~ /(grey|low)/ ) {
    $icon = '\textcolor{fg-grey}{$\newmoon$}';
  }

  # routine?
  #
  elsif ( $priority =~ /(yellow|routine)/) {
    $icon = '\textcolor{fg-yellow}{$\newmoon$}';
  }

  # high?
  #
  elsif ( $priority =~ /(orange|high)/) {
    $icon = '\textcolor{fg-orange}{$\newmoon$}';
  }

  # critical?
  #
  elsif ( $priority =~ /(red|critical)/) {
    $icon = '\textcolor{fg-red}{$\newmoon$}';
  }

  return $icon;

}

######################################################################

sub plain_text {

  # Convert a string of characters to plain text.  This conversion
  # includes:
  #
  #   - title reference substitutions
  #   - description reference substitutions
  #   - lookup substitutions
  #   - strip special characters
  #
  # This is useful when you need to count the number of characters in
  # the content of text without any markup like when determining how
  # wide to make table cells.
  #

  my $text = shift;

  return "" if $text =~ /^\s*$/;

  $text = remove_newlines($text);

  $text = compress_whitespace($text);

  #---------------------------------------------------------------
  # Lookup Substitution
  #
  #     If the content of the table cell is one of:
  #
  #       [lookup:ci-000741:Serial Number]
  #       [l:ci-000741:Serial Number]
  #
  #     ...and the referenced lookup value is actually 70 characters
  #     long?  We must resolve this lookup reference to get an
  #     accurate sense of how wide this column should be.
  #
  while ( $text =~ /\[(lookup|l):([^:]+):(.*?)\]/ ) {

    my $element = $2;
    my $label   = $3;
    my $name    = name_for($label);

    # Element may be a simple pre-defined data element
    #
    if ( defined $lookup{$label}{$element} ) {

      # Determine whether this data element is multi-valued
      #
      my $is_multivalued = 0;
      if ( $structure{$name}{'elements'}{$element}{'multivalued'} ) {
	$is_multivalued = 1;
      }

      # If the data element is NOT multivalued...
      #
      if (not $is_multivalued) {
	my $value = $lookup{$label}{$element};
	$text     =~ s/\[(lookup|l):([^:]+):(.*?)\]/$value/;
      }

      # If the data element IS multivalued...
      #
      else {
	my @value = @{ $lookup{$label}{$element} };
	my $value = join(', ',@value);
	$text     =~ s/\[(lookup|l):([^:]+):(.*?)\]/$value/;
      }
    }

    # Element may be a user-defined attribute
    #
    elsif ( defined $attribute{$label}{$element} ) {

      my @value = @{ $attribute{$label}{$element} };
      my $value = join(', ',@value);
      $text     =~ s/\[(lookup|l):([^:]+):(.*?)\]/$value/;

    }

    # Element not defined
    #
    else {
      my $value = '?';
      $text =~ s/\[(lookup|l):([^:]+):(.*?)\]/$value/;
    }

  }

  #---------------------------------------------------------------
  # Title Substitution
  #
  #     If the content of the table cell is one of:
  #
  #       [title:my-title-reference]
  #       [t:my-title-reference]
  #
  #     ...and the referenced title is actually 70 characters
  #     long?  We must resolve this title reference to get an
  #     accurate sense of how wide this column should be.
  #
  while ( $text =~ /\[(title|t):(.+?)\]/ ) {
    my $label = $2;
    my $title = $lookup{$label}{'title'} || '?';
    $text =~ s/\[(title|t):(.+?)\]/$title/;
  }

  #---------------------------------------------------------------
  # Description Substitution
  #
  #     If the content of the table cell is one of:
  #
  #       [description:my-description-reference]
  #       [d:my-description-reference]
  #
  #     ...and the referenced description is actually 70 characters
  #     long?  We must resolve this description reference to get an
  #     accurate sense of how wide this column should be.
  #
  while ( $text =~ /\[(description|d):(.+?)\]/ ) {
    my $label = $2;
    my $description = $lookup{$label}{'description'} || '?';
    $text =~ s/\[(description|d):(.+?)\]/$description/;
  }

  #-------------------------------------------------------------------
  # Glossary References
  #
  while ( $text =~ /\[(glossary|gloss|g):(.+?)\]/ ) {
    my $term = $2;
    $text =~ s/\[(glossary|gloss|g):(.+?)\]/$term/;
  }

  #-------------------------------------------------------------------
  # Command References
  #
  while ( $text =~ /\[cmd:(.+?)\]/ ) {
    my $command = $1;
    $text =~ s/\[cmd:(.+?)\]/$command/;
  }

  #-------------------------------------------------------------------
  # File References
  #
  while ( $text =~ /\[file:(.+?)\]/ ) {
    my $file = $1;
    $text =~ s/\[file:(.+?)\]/$file/;
  }

  #-------------------------------------------------------------------
  # Status References
  #
  while ( $text =~ /\[status:(.+?)\]/ ) {
    my $status = $1;
    $text =~ s/\[status:(.+?)\]/$status/;
  }

  #-------------------------------------------------------------------
  # Citations
  #
  while ( $text =~ /\[cite:(.+?)\]/ ) {
    my $cite = $1;
    $text =~ s/\[cite:(.+?)\]/$cite/;
  }

  #-------------------------------------------------------------------
  # URL References
  #
  while ( $text =~ /\[url:(.+?)\]/ ) {
    my $url = $1;
    $text =~ s/\[url:(.+?)\]/$url/;
  }

  #-------------------------------------------------------------------
  # Cross References
  #
  while ( $text =~ /\[(ref|r|id):(.+?)\]/ ) {
    my $ref = $2;
    $text =~ s/\[(ref|r|id):(.+?)\]/$ref/;
  }

  #-------------------------------------------------------------------
  # Special Characters
  #
  #     Strip all text sequences that represent format markup:
  #
  #       **content** - bold
  #       !!content!! - bold (deprecated)
  #       ~~content~~ - italics
  #       __content__ - underline
  #       ||content|| - typewriter type
  #       [[content]] - keystroke indicator
  #
  #     Also strip leading and trailing whitespace
  #
  $text =~ s/([^~])~~([^~])/$1$2/g;     # ignore italics markup
  $text =~ s/([^_])__([^_])/$1$2/g;     # ignore underline markup
  $text =~ s/([^\*])\*\*([^\*])/$1$2/g; # ignore bold markup
  $text =~ s/([^\!])\!\!([^\!])/$1$2/g; # ignore bold markup
  $text =~ s/([^|])||([^|])/$1$2/g;     # ignore tt markup
  $text =~ s/\[\[([^\]]+)\]\]/$1/g;     # ignore keystroke indicators
  $text =~ s/\[linebreak\]//g;          # ignore linebreaks

  $text = trim_whitespace($text);

  return $text;

}

######################################################################

sub already_in_array {

  # Determine whether a value is already in an array.

  my $value = shift;
  my $aref  = shift;

  foreach my $item ( @{ $aref } ) {
    if ($item eq $value) {
      return 1;
    }
  }

  return 0;

}

######################################################################

sub count_markup_in_line {

  # Count the number of certain markup strings in a line of text.

  #-------------------------------------------------------------------
  # SUBROUTINE OUTLINE
  #
  # 2 1.  Get line
  # 2 2.  WHILE line contains [ref:...] markup
  # 4     1. Replace [ref:...] with 'reference'
  # 4     2. Increment count ref total
  # 2 3.  WHILE line contains [r:...] markup
  # 4     1. Replace [r:...] with 'reference'
  # 4     2. Increment count ref total
  # 2 4.  WHILE line contains [id:...] markup
  # 4     1. Replace [id:...] with 'reference'
  # 4     2. Increment count ref total
  # 2 5.  WHILE line contains [[take_note]] markup
  # 4     1. Replace [[take_note]] with 'take_note'
  # 4     2. Increment count take_note total
  # 2 6.  WHILE line contains :-) markup
  # 4     1. Replace :-) with 'smiley'
  # 4     2. Increment count smiley total
  # 2 7.  WHILE line contains :-( markup
  # 4     1. Replace :-( with 'frowny'
  # 4     2. Increment count frowny total
  # 2 8.  WHILE line contains 'http:' URL markup
  # 4     1. Replace the URL with 'url'
  # 4     2. Increment count url total
  #
  #-------------------------------------------------------------------

  my $line = shift;

  ##################################################################
  ##################################################################
  ##
  ## Look for inline elements: references, smileys, frownys, take
  ## note indicators, urls, etc.
  ##
  ##################################################################
  ##################################################################

  #-----------------------------------------------------------------
  # Count [ref:...] markup
  #
  while ($line =~ /\[ref:.*?\]/) {
    $line =~ s/\[ref:.*?\]/reference/;
    ++ $count{'ref'}{'total'};
  }

  #-----------------------------------------------------------------
  # Count [r:...] markup
  #
  while ($line =~ /\[r:.*?\]/) {
    $line =~ s/\[r:.*?\]/reference/;
    ++ $count{'ref'}{'total'};
  }

  #-----------------------------------------------------------------
  # Count [id:...] markup
  #
  while ($line =~ /\[id:.*?\]/) {
    $line =~ s/\[id:.*?\]/reference/;
    ++ $count{'ref'}{'total'};
  }

  #-----------------------------------------------------------------
  # Count [[take_note]] markup
  #
  while ($line =~ /\[\[take_note\]\]/) {
    $line =~ s/\[\[take_note\]\]/take_note/;
    ++ $count{'take_note'}{'total'};
  }

  #-----------------------------------------------------------------
  # Count :-) markup
  #
  while ($line =~ /:-\)/) {
    $line =~ s/:-\)/smiley/;
    ++ $count{'smiley'}{'total'};
  }

  #-----------------------------------------------------------------
  # Count :-( markup
  #
  while ($line =~ /:-\(/) {
    $line =~ s/:-\(/frowny/;
    ++ $count{'frowny'}{'total'};
  }

  #-----------------------------------------------------------------
  # Count http:... URLs
  #
  while ($line =~ /http:\/\/\S+[\s\}\)]?/i) {
    $line =~ s/http:\/\/\S+[\s\}\)]?/url/i;
    ++ $count{'url'}{'total'};
  }

  #-----------------------------------------------------------------
  #
  #     !!! Bug Here !!!
  #
  #     There are more inline elements than these, aren't there?
  #
  #-----------------------------------------------------------------

}

######################################################################

sub no_longer_in_any_environment {
  foreach my $environment (list_of_environment_names()) {
    $in{$environment}{'environment'} = 0;
  }
}

######################################################################

sub list_of_region_names {

  # Return a list of region names.

  my @regions = ();

  foreach my $name (keys %structure) {
    if ( $structure{$name}{'type'} eq 'region' ) {
      push(@regions,$name);
    }
  }

  return @regions;

}

######################################################################

sub list_of_environment_names {

  # Return a list of environment names.

  my @environments = ();

  foreach my $name (keys %structure) {
    if ( $structure{$name}{'type'} eq 'environment' ) {
      push(@environments,$name);
    }
  }

  return @environments;

}

######################################################################

sub normalize_glossary_definitions {

  # Remove newlines and compress whitespaces in each glossary
  # definition.

  printstatus("normalizing glossary definitions...");

  foreach my $term ( keys %{ $data{'glossary'} } ) {

    foreach my $alt ( keys %{ $data{'glossary'}{$term} } ) {

      my $definition = $data{'glossary'}{$term}{$alt};

      $definition = remove_newlines($definition);
      $definition = compress_whitespace($definition);

      $glossary{$term}{$alt}         = $definition;
      $data{'glossary'}{$term}{$alt} = $definition;

    }

  }

}

######################################################################

sub normalize_variable_values {

  # Remove newlines and compress whitespaces in each variable value.

  printstatus("normalizing variable values...");

  foreach my $name ( keys %{ $data{'var'} } ) {

    my $value = $data{'var'}{$name};

    $value = remove_newlines($value);
    $value = compress_whitespace($value);

    $variable{$name}    = $value;
    $data{'var'}{$name} = $value;

  }

}

######################################################################

sub normalize_acronym_definitions {

  # Remove newlines and compress whitespaces in each acronym
  # definition.

  printstatus("normalizing acronym definitions...");

  foreach my $acronym ( keys %{ $data{'acronym'} } ) {

    my $definition = $data{'acronym'}{$acronym};

    $definition = remove_newlines($definition);
    $definition = compress_whitespace($definition);

    $acronym{$acronym}         = $definition;
    $data{'acronym'}{$acronym} = $definition;

  }

}

######################################################################

sub in_any_region {

  # Return 1 if we're currently in any region, otherwise 0.

  foreach my $region (list_of_region_names()) {
    if ($in{$region}{'region'}) {
      return 1;
    }
  }

  return 0;

}

######################################################################

sub in_any_environment {

  # Return 1 if we're currently in any environment, otherwise 0.

  foreach my $environment (list_of_environment_names()) {
    if ($in{$environment}{'environment'}) {
      return 1;
    }
  }

  return 0;

}

######################################################################

sub in_section {

  # Return 1 if we're currently in a section.
  #
  return 1 if $current{'name'} eq 'section';
  return 1 if $current{'name'} eq 'chapter';
  return 1 if $current{'name'} eq 'appendix';
  return 1 if $current{'name'} eq 'part';
  return 0;

}

######################################################################

sub resolve_references {

  # Resolve certain SML references

  my $text = shift;

  #---------------------------------------------------------------
  # Title Substitution
  #
  #     If the content of the table cell is one of:
  #
  #       [title:my-title-reference]
  #       [t:my-title-reference]
  #
  #     ...and the referenced title is actually 70 characters
  #     long?  We must resolve this title reference to get an
  #     accurate sense of how wide this column should be.
  #
  while ( $text =~ /\[(title|t):(.+?)\]/ ) {
    my $label = $2;
    my $title = $label{$label}{'title'} || '?';
    $text =~ s/\[(title|t):(.+?)\]/$title/;
  }

  #---------------------------------------------------------------
  # Description Substitution
  #
  #     If the content of the table cell is one of:
  #
  #       [description:my-description-reference]
  #       [d:my-description-reference]
  #
  #     ...and the referenced description is actually 70 characters
  #     long?  We must resolve this description reference to get an
  #     accurate sense of how wide this column should be.
  #
  while ( $text =~ /\[(description|d):(.+?)\]/ ) {
    my $label = $2;
    my $description = $label{$label}{'description'} || '?';
    $text =~ s/\[(description|d):(.+?)\]/$description/;
  }

  #---------------------------------------------------------------
  # Lookup Substitution
  #
  #     If the content of the table cell is one of:
  #
  #       [lookup:ci-000741:Serial Number]
  #       [l:ci-000741:Serial Number]
  #
  #     ...and the referenced lookup value is actually 70 characters
  #     long?  We must resolve this lookup reference to get an
  #     accurate sense of how wide this column should be.
  #
  while ( $text =~ /\[(lookup|l):([^:]+):(.*?)\]/ ) {

    my $element = $2;
    my $label   = $3;
    my $name    = name_for($label);

    # Element may be a simple pre-defined data element
    #
    if ( defined $lookup{$label}{$element} ) {

      # Determine whether this data element is multi-valued
      #
      my $is_multivalued = 0;
      if ( $structure{$name}{'elements'}{$element}{'multivalued'} ) {
	$is_multivalued = 1;
      }

      # If the data element is NOT multivalued...
      #
      if (not $is_multivalued) {
	my $value = $lookup{$label}{$element};
	$text     =~ s/\[(lookup|l):([^:]+):(.*?)\]/$value/;
      }

      # If the data element IS multivalued...
      #
      else {
	my @value = @{ $lookup{$label}{$element} };
	my $value = join(', ',@value);
	$text     =~ s/\[(lookup|l):([^:]+):(.*?)\]/$value/;
      }
    }

    # Element is 'status'
    #
    elsif ($element eq 'status') {
      my $value = status_of($label);
      $text     =~ s/\[(lookup|l):([^:]+):(.*?)\]/$value/;
    }

    # Element may be a user-defined attribute
    #
    elsif ( defined $attribute{$label}{$element} ) {

      my @value = @{ $attribute{$label}{$element} };
      my $value = join(', ',@value);
      $text     =~ s/\[(lookup|l):([^:]+):(.*?)\]/$value/;

    }

    # Element not defined
    #
    else {
      my $value = '?';
      $text =~ s/\[(lookup|l):([^:]+):(.*?)\]/$value/;
    }
  }

  #-------------------------------------------------------------------
  # Glossary References
  #
  while ( $text =~ /\[(glossary|gloss|g):(.+?)\]/ ) {
    my $term = $2;
    $text =~ s/\[(glossary|gloss|g):(.+?)\]/$term/;
  }

  #-------------------------------------------------------------------
  # Command References
  #
  while ( $text =~ /\[cmd:(.+?)\]/ ) {
    my $command = $1;
    $text =~ s/\[cmd:(.+?)\]/$command/;
  }

  #-------------------------------------------------------------------
  # File References
  #
  while ( $text =~ /\[file:(.+?)\]/ ) {
    my $file = $1;
    $text =~ s/\[file:(.+?)\]/$file/;
  }

  #-------------------------------------------------------------------
  # URL References
  #
  while ( $text =~ /\[url:(.+?)\]/ ) {
    my $url = $1;
    $text =~ s/\[url:(.+?)\]/$url/;
  }

  #-------------------------------------------------------------------
  # Cross References
  #
  while ( $text =~ /\[(ref|r|id):(.+?)\]/ ) {
    my $ref = $2;
    $text =~ s/\[(ref|r|id):(.+?)\]/$ref/;
  }

  return $text;

}

######################################################################

sub insert_hide_marker {

  my $nest          = shift;
  my $nesting_level = shift;

  push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},"\n"];
  push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},"\n"];
  push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},"###hide"];
  push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},"\n"];
  push @outtext, [$nest,$nesting_level,$current_line{$nesting_level},"\n"];

}

######################################################################

sub remove_bogus_labels {

  # Take a list of entities (that is, entity labels) and return a list
  # of only valid labels.

  my $oldlist = shift;
  my $newlist = [];

  foreach my $entity (@{ $oldlist }) {
    if (label_exists($entity)) {
      push @{$newlist}, $entity;
    }
  }

  return $newlist;
}

######################################################################

sub read_csvfile {

  use Text::CSV;

  my $csvfile = shift;
  my $names   = [];
  my $csv     = Text::CSV->new;

  if ( not -e $csvfile ) {
    warn "CSV file $csvfile not found!";
    return;
  }

  open CSVFILE, "<$csvfile" || die "couldn't open $csvfile";

  my $first_row = 1;

  while (<CSVFILE>) {

    my $status = $csv->parse($_);
    my $record = [ $csv->fields ];
    my $i      = 0;

    if ($first_row) {
      foreach my $name (@{ $record }) {
	$names->[$i] = $name;
	++ $i;
      }
      $first_row = 0;
      next;
    }

    else {
      foreach my $field (@{ $record }) {
	my $key  = $record->[0];
	my $name = $names->[$i];
	push @{ $csvdata->{$key}{$name} }, $field;
	++ $i;
      }
    }
  }


  close CSVFILE;
}

######################################################################
